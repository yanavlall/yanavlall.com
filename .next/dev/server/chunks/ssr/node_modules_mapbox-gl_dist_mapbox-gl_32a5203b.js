module.exports = [
"[project]/node_modules/mapbox-gl/dist/mapbox-gl.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) {
            shared = chunk;
        } else if (!worker) {
            worker = chunk;
        } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
        }
    }
    define([
        "exports"
    ], function(t1) {
        var e = 1e-6, r = "undefined" != typeof Float32Array ? Float32Array : Array;
        function n(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r * s - i * n;
            return a ? (t1[0] = s * (a = 1 / a), t1[1] = -n * a, t1[2] = -i * a, t1[3] = r * a, t1) : null;
        }
        function i() {
            var t1 = new r(9);
            return r != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
        }
        function s(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8];
            return t1[0] = a * c - o * u, t1[1] = i * u - n * c, t1[2] = n * o - i * a, t1[3] = o * l - s * c, t1[4] = r * c - i * l, t1[5] = i * s - r * o, t1[6] = s * u - a * l, t1[7] = n * l - r * u, t1[8] = r * a - n * s, t1;
        }
        function a(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = r[0], d = r[1], f = r[2], m = r[3], y = r[4], g = r[5], x = r[6], v = r[7], b = r[8];
            return t1[0] = p * n + d * a + f * u, t1[1] = p * i + d * o + f * c, t1[2] = p * s + d * l + f * h, t1[3] = m * n + y * a + g * u, t1[4] = m * i + y * o + g * c, t1[5] = m * s + y * l + g * h, t1[6] = x * n + v * a + b * u, t1[7] = x * i + v * o + b * c, t1[8] = x * s + v * l + b * h, t1;
        }
        function o() {
            var t1 = new r(16);
            return r != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
        }
        function l(t1) {
            var e = new r(16);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e[4] = t1[4], e[5] = t1[5], e[6] = t1[6], e[7] = t1[7], e[8] = t1[8], e[9] = t1[9], e[10] = t1[10], e[11] = t1[11], e[12] = t1[12], e[13] = t1[13], e[14] = t1[14], e[15] = t1[15], e;
        }
        function u(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function c(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], d = e[11], f = e[12], m = e[13], y = e[14], g = e[15], x = r * o - n * a, v = r * l - i * a, b = r * u - s * a, w = n * l - i * o, _ = n * u - s * o, A = i * u - s * l, I = c * m - h * f, M = c * y - p * f, S = c * g - d * f, P = h * y - p * m, z = h * g - d * m, B = p * g - d * y, k = x * B - v * z + b * P + w * S - _ * M + A * I;
            return k ? (t1[0] = (o * B - l * z + u * P) * (k = 1 / k), t1[1] = (i * z - n * B - s * P) * k, t1[2] = (m * A - y * _ + g * w) * k, t1[3] = (p * _ - h * A - d * w) * k, t1[4] = (l * S - a * B - u * M) * k, t1[5] = (r * B - i * S + s * M) * k, t1[6] = (y * b - f * A - g * v) * k, t1[7] = (c * A - p * b + d * v) * k, t1[8] = (a * z - o * S + u * I) * k, t1[9] = (n * S - r * z - s * I) * k, t1[10] = (f * _ - m * b + g * x) * k, t1[11] = (h * b - c * _ - d * x) * k, t1[12] = (o * M - a * P - l * I) * k, t1[13] = (r * P - n * M + i * I) * k, t1[14] = (m * v - f * w - y * x) * k, t1[15] = (c * w - h * v + p * x) * k, t1) : null;
        }
        function h(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], d = e[10], f = e[11], m = e[12], y = e[13], g = e[14], x = e[15], v = r[0], b = r[1], w = r[2], _ = r[3];
            return t1[0] = v * n + b * o + w * h + _ * m, t1[1] = v * i + b * l + w * p + _ * y, t1[2] = v * s + b * u + w * d + _ * g, t1[3] = v * a + b * c + w * f + _ * x, t1[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * m, t1[5] = v * i + b * l + w * p + _ * y, t1[6] = v * s + b * u + w * d + _ * g, t1[7] = v * a + b * c + w * f + _ * x, t1[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * m, t1[9] = v * i + b * l + w * p + _ * y, t1[10] = v * s + b * u + w * d + _ * g, t1[11] = v * a + b * c + w * f + _ * x, t1[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * m, t1[13] = v * i + b * l + w * p + _ * y, t1[14] = v * s + b * u + w * d + _ * g, t1[15] = v * a + b * c + w * f + _ * x, t1;
        }
        function p(t1, e, r) {
            var n, i, s, a, o, l, u, c, h, p, d, f, m = r[0], y = r[1], g = r[2];
            return e === t1 ? (t1[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t1[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t1[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t1[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], d = e[10], f = e[11], t1[0] = n = e[0], t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = o, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = d, t1[11] = f, t1[12] = n * m + o * y + h * g + e[12], t1[13] = i * m + l * y + p * g + e[13], t1[14] = s * m + u * y + d * g + e[14], t1[15] = a * m + c * y + f * g + e[15]), t1;
        }
        function d(t1, e, r) {
            var n = r[0], i = r[1], s = r[2];
            return t1[0] = e[0] * n, t1[1] = e[1] * n, t1[2] = e[2] * n, t1[3] = e[3] * n, t1[4] = e[4] * i, t1[5] = e[5] * i, t1[6] = e[6] * i, t1[7] = e[7] * i, t1[8] = e[8] * s, t1[9] = e[9] * s, t1[10] = e[10] * s, t1[11] = e[11] * s, t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15], t1;
        }
        function f(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[4], a = e[5], o = e[6], l = e[7], u = e[8], c = e[9], h = e[10], p = e[11];
            return e !== t1 && (t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[4] = s * i + u * n, t1[5] = a * i + c * n, t1[6] = o * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - s * n, t1[9] = c * i - a * n, t1[10] = h * i - o * n, t1[11] = p * i - l * n, t1;
        }
        function m(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[0], a = e[1], o = e[2], l = e[3], u = e[8], c = e[9], h = e[10], p = e[11];
            return e !== t1 && (t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = s * i - u * n, t1[1] = a * i - c * n, t1[2] = o * i - h * n, t1[3] = l * i - p * n, t1[8] = s * n + u * i, t1[9] = a * n + c * i, t1[10] = o * n + h * i, t1[11] = l * n + p * i, t1;
        }
        function y(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[0], a = e[1], o = e[2], l = e[3], u = e[4], c = e[5], h = e[6], p = e[7];
            return e !== t1 && (t1[8] = e[8], t1[9] = e[9], t1[10] = e[10], t1[11] = e[11], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = s * i + u * n, t1[1] = a * i + c * n, t1[2] = o * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - s * n, t1[5] = c * i - a * n, t1[6] = h * i - o * n, t1[7] = p * i - l * n, t1;
        }
        function g(t1, e) {
            return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function x(t1, r, n) {
            var i, s, a, o = n[0], l = n[1], u = n[2], c = Math.sqrt(o * o + l * l + u * u);
            return c < e ? null : (o *= c = 1 / c, l *= c, u *= c, i = Math.sin(r), s = Math.cos(r), t1[0] = o * o * (a = 1 - s) + s, t1[1] = l * o * a + u * i, t1[2] = u * o * a - l * i, t1[3] = 0, t1[4] = o * l * a - u * i, t1[5] = l * l * a + s, t1[6] = u * l * a + o * i, t1[7] = 0, t1[8] = o * u * a + l * i, t1[9] = l * u * a - o * i, t1[10] = u * u * a + s, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1);
        }
        function v(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[4], a = e[5], o = e[6], l = e[8], u = e[9], c = e[10];
            return t1[0] = Math.sqrt(r * r + n * n + i * i), t1[1] = Math.sqrt(s * s + a * a + o * o), t1[2] = Math.sqrt(l * l + u * u + c * c), t1;
        }
        function b(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r + r, o = n + n, l = i + i, u = r * a, c = n * a, h = n * o, p = i * a, d = i * o, f = i * l, m = s * a, y = s * o, g = s * l;
            return t1[0] = 1 - h - f, t1[1] = c + g, t1[2] = p - y, t1[3] = 0, t1[4] = c - g, t1[5] = 1 - u - f, t1[6] = d + m, t1[7] = 0, t1[8] = p + y, t1[9] = d - m, t1[10] = 1 - u - h, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        var w = h;
        function _() {
            var t1 = new r(3);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
        }
        function A(t1) {
            var e = new r(3);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e;
        }
        function I(t1) {
            var e = t1[0], r = t1[1], n = t1[2];
            return Math.sqrt(e * e + r * r + n * n);
        }
        function M(t1, e, n) {
            var i = new r(3);
            return i[0] = t1, i[1] = e, i[2] = n, i;
        }
        function S(t1, e, r, n) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1;
        }
        function P(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1;
        }
        function z(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1;
        }
        function B(t1, e, r) {
            return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1[2] = e[2] * r[2], t1;
        }
        function k(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1;
        }
        function T(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1;
        }
        function V(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1;
        }
        function E(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1;
        }
        function F(t1, e) {
            var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2];
            return Math.sqrt(r * r + n * n + i * i);
        }
        function D(t1, e) {
            var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2];
            return r * r + n * n + i * i;
        }
        function C(t1) {
            var e = t1[0], r = t1[1], n = t1[2];
            return e * e + r * r + n * n;
        }
        function R(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1;
        }
        function L(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = r * r + n * n + i * i;
            return s > 0 && (s = 1 / Math.sqrt(s)), t1[0] = e[0] * s, t1[1] = e[1] * s, t1[2] = e[2] * s, t1;
        }
        function O(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2];
        }
        function U(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = r[0], o = r[1], l = r[2];
            return t1[0] = i * l - s * o, t1[1] = s * a - n * l, t1[2] = n * o - i * a, t1;
        }
        function N(t1, e, r, n) {
            var i = e[0], s = e[1], a = e[2];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1[2] = a + n * (r[2] - a), t1;
        }
        function j(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = r[3] * n + r[7] * i + r[11] * s + r[15];
            return t1[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t1[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t1[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t1;
        }
        function G(t1, e, r) {
            var n = e[0], i = e[1], s = e[2];
            return t1[0] = n * r[0] + i * r[3] + s * r[6], t1[1] = n * r[1] + i * r[4] + s * r[7], t1[2] = n * r[2] + i * r[5] + s * r[8], t1;
        }
        function $(t1, e, r) {
            var n = r[0], i = r[1], s = r[2], a = r[3], o = e[0], l = e[1], u = e[2], c = i * u - s * l, h = s * o - n * u, p = n * l - i * o;
            return t1[0] = o + a * (c += c) + i * (p += p) - s * (h += h), t1[1] = l + a * h + s * c - n * p, t1[2] = u + a * p + n * h - i * c, t1;
        }
        function q(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1;
        }
        function X(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2];
        }
        var H = z, Z = B, W = I;
        function Y() {
            var t1 = new r(4);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 0), t1;
        }
        function J(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1;
        }
        function K(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r * r + n * n + i * i + s * s;
            return a > 0 && (a = 1 / Math.sqrt(a)), t1[0] = r * a, t1[1] = n * a, t1[2] = i * a, t1[3] = s * a, t1;
        }
        function Q(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2] + t1[3] * e[3];
        }
        function tt(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3];
            return t1[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t1[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t1[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t1[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t1;
        }
        function et() {
            var t1 = new r(4);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
        }
        function rt(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
        }
        function nt(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + a * o, t1[1] = i * l + s * o, t1[2] = s * l - i * o, t1[3] = a * l - n * o, t1;
        }
        function it(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l - s * o, t1[1] = i * l + a * o, t1[2] = s * l + n * o, t1[3] = a * l - i * o, t1;
        }
        _(), Y();
        var st, at, ot, lt = K, ut = (st = _(), at = M(1, 0, 0), ot = M(0, 1, 0), function(t1, e, r) {
            var n = O(e, r);
            return n < -.999999 ? (U(st, at, e), W(st) < 1e-6 && U(st, ot, e), L(st, st), function(t1, e, r) {
                r *= .5;
                var n = Math.sin(r);
                t1[0] = n * e[0], t1[1] = n * e[1], t1[2] = n * e[2], t1[3] = Math.cos(r);
            }(t1, st, Math.PI), t1) : n > .999999 ? (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1) : (U(st, e, r), t1[0] = st[0], t1[1] = st[1], t1[2] = st[2], t1[3] = 1 + n, lt(t1, t1));
        });
        function ct() {
            var t1 = new r(2);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0), t1;
        }
        function ht(t1, e) {
            var n = new r(2);
            return n[0] = t1, n[1] = e, n;
        }
        function pt(t1, e, r) {
            return t1[0] = e, t1[1] = r, t1;
        }
        function dt(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1;
        }
        function ft(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1;
        }
        function mt(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1;
        }
        function yt(t1) {
            var e = t1[0], r = t1[1];
            return Math.sqrt(e * e + r * r);
        }
        function gt(t1, e) {
            var r = e[0], n = e[1], i = r * r + n * n;
            return i > 0 && (i = 1 / Math.sqrt(i)), t1[0] = e[0] * i, t1[1] = e[1] * i, t1;
        }
        function xt(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1];
        }
        et(), et(), i();
        var vt, bt, wt = ft;
        function _t(t1) {
            return t1 && t1.__esModule && Object.prototype.hasOwnProperty.call(t1, "default") ? t1.default : t1;
        }
        ct();
        var At = function() {
            if (bt) return vt;
            function t1(t1, e, r, n) {
                this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e, this.p2x = r, this.p2y = n;
            }
            return bt = 1, vt = t1, t1.prototype = {
                sampleCurveX: function(t1) {
                    return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
                },
                sampleCurveY: function(t1) {
                    return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
                },
                sampleCurveDerivativeX: function(t1) {
                    return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
                },
                solveCurveX: function(t1, e) {
                    if (void 0 === e && (e = 1e-6), t1 < 0) return 0;
                    if (t1 > 1) return 1;
                    for(var r = t1, n = 0; n < 8; n++){
                        var i = this.sampleCurveX(r) - t1;
                        if (Math.abs(i) < e) return r;
                        var s = this.sampleCurveDerivativeX(r);
                        if (Math.abs(s) < 1e-6) break;
                        r -= i / s;
                    }
                    var a = 0, o = 1;
                    for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e)); n++)t1 > i ? a = r : o = r, r = .5 * (o - a) + a;
                    return r;
                },
                solve: function(t1, e) {
                    return this.sampleCurveY(this.solveCurveX(t1, e));
                }
            }, vt;
        }(), It = _t(At);
        function Mt(t1, e) {
            this.x = t1, this.y = e;
        }
        function St(t1, e) {
            if (Array.isArray(t1)) {
                if (!Array.isArray(e) || t1.length !== e.length) return !1;
                for(let r = 0; r < t1.length; r++)if (!St(t1[r], e[r])) return !1;
                return !0;
            }
            if ("object" == typeof t1 && null !== t1 && null !== e) {
                if ("object" != typeof e) return !1;
                if (Object.keys(t1).length !== Object.keys(e).length) return !1;
                for(const r in t1)if (!St(t1[r], e[r])) return !1;
                return !0;
            }
            return t1 === e;
        }
        Mt.prototype = {
            clone () {
                return new Mt(this.x, this.y);
            },
            add (t1) {
                return this.clone()._add(t1);
            },
            sub (t1) {
                return this.clone()._sub(t1);
            },
            multByPoint (t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint (t1) {
                return this.clone()._divByPoint(t1);
            },
            mult (t1) {
                return this.clone()._mult(t1);
            },
            div (t1) {
                return this.clone()._div(t1);
            },
            rotate (t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround (t1, e) {
                return this.clone()._rotateAround(t1, e);
            },
            matMult (t1) {
                return this.clone()._matMult(t1);
            },
            unit () {
                return this.clone()._unit();
            },
            perp () {
                return this.clone()._perp();
            },
            round () {
                return this.clone()._round();
            },
            mag () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals (t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist (t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr (t1) {
                const e = t1.x - this.x, r = t1.y - this.y;
                return e * e + r * r;
            },
            angle () {
                return Math.atan2(this.y, this.x);
            },
            angleTo (t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith (t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep (t1, e) {
                return Math.atan2(this.x * e - this.y * t1, this.x * t1 + this.y * e);
            },
            _matMult (t1) {
                const e = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e, this;
            },
            _add (t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub (t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult (t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div (t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint (t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint (t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit () {
                return this._div(this.mag()), this;
            },
            _perp () {
                const t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate (t1) {
                const e = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e * this.y;
                return this.x = e * this.x - r * this.y, this.y = n, this;
            },
            _rotateAround (t1, e) {
                const r = Math.cos(t1), n = Math.sin(t1), i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
                return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
            },
            _round () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            },
            constructor: Mt
        }, Mt.convert = function(t1) {
            if (t1 instanceof Mt) return t1;
            if (Array.isArray(t1)) return new Mt(+t1[0], +t1[1]);
            if (void 0 !== t1.x && void 0 !== t1.y) return new Mt(+t1.x, +t1.y);
            throw new Error("Expected [x, y] or {x, y} point format");
        };
        const Pt = Math.PI / 180, zt = 180 / Math.PI;
        function Bt(t1) {
            return t1 * Pt;
        }
        function kt(t1) {
            return t1 * zt;
        }
        const Tt = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function Vt(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e = t1 * t1, r = e * t1;
            return 4 * (t1 < .5 ? r : 3 * (t1 - e) + r - .75);
        }
        function Et(t1, e, r, n) {
            const i = new It(t1, e, r, n);
            return function(t1) {
                return i.solve(t1);
            };
        }
        const Ft = Et(.25, .1, .25, 1);
        function Dt(t1, e, r) {
            return Math.min(r, Math.max(e, t1));
        }
        function Ct(t1, e, r) {
            return (r = Dt((r - t1) / (e - t1), 0, 1)) * r * (3 - 2 * r);
        }
        function Rt(t1, e, r) {
            const n = r - e, i = ((t1 - e) % n + n) % n + e;
            return i === e ? r : i;
        }
        function Lt(t1, e, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let s = null;
            t1.forEach((t1, a)=>{
                e(t1, (t1, e)=>{
                    t1 && (s = t1), i[a] = e, 0 === --n && r(s, i);
                });
            });
        }
        let Ot = 1;
        function Ut() {
            return Ot++;
        }
        function Nt(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log2(t1)));
        }
        function jt(t1, e) {
            t1.forEach((t1)=>{
                e[t1] && (e[t1] = e[t1].bind(e));
            });
        }
        function Gt(t1, e, r) {
            const n = {};
            for(const r in t1)n[r] = e.call(this, t1[r], r, t1);
            return n;
        }
        function $t(t1, e, r) {
            const n = {};
            for(const r in t1)e.call(this, t1[r], r, t1) && (n[r] = t1[r]);
            return n;
        }
        function qt(t1) {
            return Array.isArray(t1) ? t1.map(qt) : "object" == typeof t1 && t1 ? Gt(t1, qt) : t1;
        }
        function Xt(t1, e) {
            for(let r = 0; r < t1.length; r++)if (e.indexOf(t1[r]) >= 0) return !0;
            return !1;
        }
        const Ht = {};
        function Zt(t1) {
            Ht[t1] || ("undefined" != typeof console && console.warn(t1), Ht[t1] = !0);
        }
        function Wt(t1, e, r) {
            return (r.y - t1.y) * (e.x - t1.x) > (e.y - t1.y) * (r.x - t1.x);
        }
        function Yt(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function Jt([t1, e, r]) {
            const n = Bt(e + 90), i = Bt(r);
            return {
                x: t1 * Math.cos(n) * Math.sin(i),
                y: t1 * Math.sin(n) * Math.sin(i),
                z: t1 * Math.cos(i),
                azimuthal: e,
                polar: r
            };
        }
        function Kt(t1) {
            return ("undefined" != typeof self || void 0 !== t1) && "undefined" != typeof WorkerGlobalScope && (void 0 !== t1 ? t1 : self) instanceof WorkerGlobalScope;
        }
        function Qt(t1) {
            const e = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const s = n || i;
                return e[r] = !s || s.toLowerCase(), "";
            }), e["max-age"]) {
                const t1 = parseInt(e["max-age"], 10);
                isNaN(t1) ? delete e["max-age"] : e["max-age"] = t1;
            }
            return e;
        }
        let te = null;
        function ee(t1, e) {
            return [
                t1[4 * e],
                t1[4 * e + 1],
                t1[4 * e + 2],
                t1[4 * e + 3]
            ];
        }
        function re(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] < n ? e = i + 1 : r = i;
            }
            return e;
        }
        function ne(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] <= n ? e = i + 1 : r = i;
            }
            return e;
        }
        function ie(t1) {
            return t1 > 0 ? 1 / (1.001 - t1) : 1 + t1;
        }
        function se(t1) {
            return t1 > 0 ? 1 - 1 / (1.001 - t1) : -t1;
        }
        function ae(t1, e, r) {
            return (t1 - e.min) * (r.max - r.min) / (e.max - e.min) + r.min;
        }
        const oe = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                if (!oe.API_URL) return null;
                try {
                    const t1 = new URL(oe.API_URL);
                    return "api.mapbox.cn" === t1.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t1.hostname ? "https://events.mapbox.com/events/v2" : null;
                } catch (t1) {
                    return null;
                }
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
            MAX_PARALLEL_IMAGE_REQUESTS: 16,
            DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
            MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
            MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
            BUILDING_GEN_URL: "https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v1.2.4.wasm",
            GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
            TILES3D_URL_PREFIX: "3dtiles/v1"
        };
        function le(t1) {
            return oe.API_URL_REGEX.test(t1);
        }
        function ue(t1) {
            return oe.API_SPRITE_REGEX.test(t1);
        }
        let ce, he, pe, de, fe, me;
        function ye() {
            return null == ce && (ce = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), ce;
        }
        const ge = {
            now: ()=>void 0 !== de ? de : performance.now(),
            setNow (t1) {
                de = t1;
            },
            restoreNow () {
                de = void 0;
            },
            frame (t1) {
                const e = requestAnimationFrame(t1);
                return {
                    cancel: ()=>cancelAnimationFrame(e)
                };
            },
            getImageData (t1, e = 0) {
                const { width: r, height: n } = t1;
                fe || (fe = document.createElement("canvas"));
                const i = fe.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!i) throw new Error("failed to create canvas 2d context");
                return (r > fe.width || n > fe.height) && (fe.width = r, fe.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t1, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);
            },
            resolveURL: (t1)=>(he || (he = document.createElement("a")), he.href = t1, he.href),
            get devicePixelRatio () {
                return window.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!window.matchMedia && (null == pe && (pe = window.matchMedia("(prefers-reduced-motion: reduce)")), pe.matches);
            },
            hasCanvasFingerprintNoise () {
                if (void 0 !== me) return me;
                if (!ye()) return me = !1, !1;
                const t1 = new OffscreenCanvas(85, 1), e = t1.getContext("2d", {
                    willReadFrequently: !0
                });
                let r = 0;
                for(let n = 0; n < t1.width; ++n)e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(n, 0, 1, 1);
                const n = e.getImageData(0, 0, t1.width, t1.height);
                r = 0;
                for(let t1 = 0; t1 < n.data.length; ++t1)if (t1 % 4 != 3 && r++ !== n.data[t1]) return me = !0, !0;
                return me = !1, !1;
            }
        };
        function xe(t1, e) {
            const r = t1.indexOf("?");
            if (r < 0) return `${t1}?${new URLSearchParams(e).toString()}`;
            const n = new URLSearchParams(t1.slice(r));
            for(const t1 in e)n.set(t1, e[t1]);
            return `${t1.slice(0, r)}?${n.toString()}`;
        }
        function ve(t1, e = {
            persistentParams: []
        }) {
            const r = t1.indexOf("?");
            if (r < 0) return t1;
            const n = new URLSearchParams, i = new URLSearchParams(t1.slice(r));
            for (const t1 of e.persistentParams){
                const e = i.get(t1);
                e && n.set(t1, e);
            }
            const s = n.toString();
            return `${t1.slice(0, r)}${s.length > 0 ? `?${s}` : ""}`;
        }
        const be = "mapbox-tiles";
        let we = 500, _e = 50;
        const Ae = [
            "language",
            "worldview",
            "jobid"
        ];
        let Ie, Me;
        function Se() {
            try {
                return caches;
            } catch (t1) {}
        }
        function Pe() {
            const t1 = Se();
            t1 && null == Ie && (Ie = t1.open(be));
        }
        let ze = 1 / 0;
        const Be = {
            supported: !1,
            testSupport: function(t1) {
                !Ve && Te && (Ee ? De(t1) : ke = t1);
            }
        };
        let ke, Te, Ve = !1, Ee = !1;
        const Fe = "undefined" != typeof self ? self : {};
        function De(t1) {
            const e = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, Te), t1.isContextLost()) return;
                Be.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e), Ve = !0;
        }
        Fe.document && (Te = Fe.document.createElement("img"), Te.onload = function() {
            ke && De(ke), ke = null, Ee = !0;
        }, Te.onerror = function() {
            Ve = !0, ke = null;
        }, Te.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Ce = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Iconset: "Iconset",
            Image: "Image",
            Model: "Model"
        };
        "function" == typeof Object.freeze && Object.freeze(Ce);
        class Re extends Error {
            constructor(t1, e, r){
                401 === e && le(r) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e, this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const Le = Kt() ? ()=>self.worker.referrer : ()=>("blob:" === location.protocol ? parent : self).location.href;
        const Oe = function(t1, e) {
            if (!(/^file:/.test(r = t1.url) || /^file:/.test(Le()) && !/^\w+:/.test(r))) {
                if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t1, e) {
                    const r = new AbortController, n = new Request(t1.url, {
                        method: t1.method || "GET",
                        body: t1.body,
                        credentials: t1.credentials,
                        headers: t1.headers,
                        referrer: Le(),
                        referrerPolicy: t1.referrerPolicy,
                        signal: r.signal
                    });
                    let i = !1, s = !1;
                    const a = (o = n.url).indexOf("sku=") > 0 && le(o);
                    var o;
                    "json" === t1.type && n.headers.set("Accept", "application/json");
                    const l = (r, i, o)=>{
                        if (s) return;
                        if (r && "SecurityError" !== r.message && Zt(r.toString()), i && o) return u(i);
                        const l = Date.now();
                        fetch(n).then((r)=>{
                            if (r.ok) {
                                const t1 = a ? r.clone() : null;
                                return u(r, t1, l);
                            }
                            return e(new Re(r.statusText, r.status, t1.url));
                        }).catch((r)=>{
                            "AbortError" !== r.name && e(new Error(`${r.message} ${t1.url}`));
                        });
                    }, u = (r, a, o)=>{
                        ("arrayBuffer" === t1.type ? r.arrayBuffer() : "json" === t1.type ? r.json() : r.text()).then((t1)=>{
                            s || (a && o && function(t1, e, r) {
                                if (Pe(), null == Ie) return;
                                const n = Qt(e.headers.get("Cache-Control") || "");
                                if (n["no-store"]) return;
                                const i = {
                                    status: e.status,
                                    statusText: e.statusText,
                                    headers: new Headers
                                };
                                e.headers.forEach((t1, e)=>i.headers.set(e, t1)), n["max-age"] && i.headers.set("Expires", new Date(r + 1e3 * n["max-age"]).toUTCString());
                                const s = i.headers.get("Expires");
                                if (!s) return;
                                if (new Date(s).getTime() - r < 42e4) return;
                                let a = ve(t1.url, {
                                    persistentParams: Ae
                                });
                                if (206 === e.status) {
                                    const e = t1.headers.get("Range");
                                    if (!e) return;
                                    i.status = 200, a = xe(a, {
                                        range: e
                                    });
                                }
                                !function(t1, e) {
                                    if (void 0 === Me) try {
                                        new Response(new ReadableStream), Me = !0;
                                    } catch (t1) {
                                        Me = !1;
                                    }
                                    Me ? e(t1.body) : t1.blob().then(e).catch((t1)=>Zt(t1.message));
                                }(e, (t1)=>{
                                    const r = new Response(200 !== (n = e.status) && 404 !== n && [
                                        101,
                                        103,
                                        204,
                                        205,
                                        304
                                    ].includes(n) ? null : t1, i);
                                    var n;
                                    Pe(), null != Ie && Ie.then((t1)=>t1.put(a, r)).catch((t1)=>Zt(t1.message));
                                });
                            }(n, a, o), i = !0, e(null, t1, r.headers));
                        }).catch((t1)=>{
                            s || e(new Error(t1.message));
                        });
                    };
                    return a ? function(t1, e) {
                        if (Pe(), null == Ie) return e(null);
                        Ie.then((r)=>{
                            let n = ve(t1.url, {
                                persistentParams: Ae
                            });
                            const i = t1.headers.get("Range");
                            i && (n = xe(n, {
                                range: i
                            })), r.match(n).then((t1)=>{
                                const i = function(t1) {
                                    if (!t1) return !1;
                                    const e = new Date(t1.headers.get("Expires") || 0), r = Qt(t1.headers.get("Cache-Control") || "");
                                    return Number(e) > Date.now() && !r["no-cache"];
                                }(t1);
                                r.delete(n).catch(e), i && r.put(n, t1.clone()).catch(e), e(null, t1, i);
                            }).catch(e);
                        }).catch(e);
                    }(n, l) : l(null, null), {
                        cancel: ()=>{
                            s = !0, i || r.abort();
                        }
                    };
                }(t1, e);
                if (Kt(self) && self.worker.actor) return self.worker.actor.send("getResource", t1, e, void 0, !0);
            }
            var r;
            return function(t1, e) {
                const r = new XMLHttpRequest;
                r.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (r.responseType = "arraybuffer");
                for(const e in t1.headers)r.setRequestHeader(e, t1.headers[e]);
                return "json" === t1.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t1.credentials, r.onerror = ()=>{
                    e(new Error(r.statusText));
                }, r.onload = ()=>{
                    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
                        let n = r.response;
                        if ("json" === t1.type) try {
                            n = JSON.parse(r.response);
                        } catch (t1) {
                            return e(t1);
                        }
                        const i = new Headers;
                        r.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((t1)=>{
                            const e = t1.split(": "), r = e.shift(), n = e.join(": ");
                            i.append(r, n);
                        }), e(null, n, i);
                    } else e(new Re(r.statusText, r.status, t1.url));
                }, r.send(t1.body), {
                    cancel: ()=>r.abort()
                };
            }(t1, e);
        }, Ue = function(t1, e) {
            return Oe(Object.assign(t1, {
                type: "arrayBuffer"
            }), e);
        };
        function Ne(t1) {
            const e = document.createElement("a");
            return e.href = t1, e.protocol === location.protocol && e.host === location.host;
        }
        const je = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let Ge, $e;
        Ge = [], $e = 0;
        const qe = function(t1, e) {
            if (Be.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), $e >= oe.MAX_PARALLEL_IMAGE_REQUESTS) {
                const r = {
                    requestParameters: t1,
                    callback: e,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return Ge.push(r), r;
            }
            $e++;
            let r = !1;
            const n = ()=>{
                if (!r) for(r = !0, $e--; Ge.length && $e < oe.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = Ge.shift(), { requestParameters: e, callback: r, cancelled: n } = t1;
                    n || (t1.cancel = qe(e, r).cancel);
                }
            }, i = Ue(t1, (t1, r, i)=>{
                n(), t1 ? e(t1) : r && (self.createImageBitmap ? function(t1, e) {
                    const r = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    createImageBitmap(r).then((t1)=>{
                        e(null, t1);
                    }).catch((t1)=>{
                        e(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(r, (t1, r)=>e(t1, r, i)) : function(t1, e) {
                    const r = new Image;
                    r.onload = ()=>{
                        e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(()=>{
                            r.src = je;
                        });
                    }, r.onerror = ()=>e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const n = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    r.src = t1.byteLength ? URL.createObjectURL(n) : je;
                }(r, (t1, r)=>e(t1, r, i)));
            });
            return {
                cancel: ()=>{
                    i.cancel(), n();
                }
            };
        };
        var Xe, He, Ze, We = {
            exports: {}
        }, Ye = {
            exports: {}
        }, Je = {
            exports: {}
        }, Ke = function() {
            if (Ze) return We.exports;
            Ze = 1;
            var t1 = (Xe || (Xe = 1, Ye.exports = function(t1, e) {
                var r, n, i, s, a, o, l, u;
                for(n = t1.length - (r = 3 & t1.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + (((s >>> 16) + 58964 & 65535) << 16);
                switch(l = 0, r){
                    case 3:
                        l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                    case 2:
                        l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                    case 1:
                        i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
                }
                return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
            }), Ye.exports), e = (He || (He = 1, Je.exports = function(t1, e) {
                for(var r, n = t1.length, i = e ^ n, s = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(s) | (255 & t1.charCodeAt(++s)) << 8 | (255 & t1.charCodeAt(++s)) << 16 | (255 & t1.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;
                switch(n){
                    case 3:
                        i ^= (255 & t1.charCodeAt(s + 2)) << 16;
                    case 2:
                        i ^= (255 & t1.charCodeAt(s + 1)) << 8;
                    case 1:
                        i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
                }
                return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
            }), Je.exports);
            return We.exports = t1, We.exports.murmur3 = t1, We.exports.murmur2 = e, We.exports;
        }(), Qe = _t(Ke);
        class tr {
            constructor(t1, ...e){
                Object.assign(this, e[0] || {}), this.type = t1;
            }
        }
        class er extends tr {
            constructor(t1, e = {}){
                super("error", Object.assign({
                    error: t1
                }, e));
            }
        }
        function rr(t1, e, r) {
            r[t1] && -1 !== r[t1].indexOf(e) || (r[t1] = r[t1] || [], r[t1].push(e));
        }
        function nr(t1, e, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class ir {
            on(t1, e) {
                return this._listeners = this._listeners || {}, rr(t1, e, this._listeners), this;
            }
            off(t1, e) {
                return nr(t1, e, this._listeners), nr(t1, e, this._oneTimeListeners), this;
            }
            once(t1, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, rr(t1, e, this._oneTimeListeners), this) : new Promise((e)=>{
                    this.once(t1, e);
                });
            }
            fire(t1, e) {
                const r = "string" == typeof t1 ? new tr(t1, e) : t1, n = r.type;
                if (this.listens(n)) {
                    r.target = this;
                    const t1 = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
                    for (const e of t1)e.call(this, r);
                    const e = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
                    for (const t1 of e)nr(n, t1, this._oneTimeListeners), t1.call(this, r);
                    const i = this._eventedParent;
                    if (i) {
                        const t1 = "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData;
                        Object.assign(r, t1), i.fire(r);
                    }
                } else r instanceof er && console.error(r.error);
                return this;
            }
            listens(t1) {
                return !!(this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1));
            }
            setEventedParent(t1, e) {
                return this._eventedParent = t1, this._eventedParentData = e, this;
            }
        }
        class sr {
            constructor(t1){
                "string" == typeof t1 ? this.name = t1 : (this.name = t1.name, this.iconsetId = t1.iconsetId);
            }
            static from(t1) {
                return new sr(t1);
            }
            static toString(t1) {
                return t1.iconsetId ? `${t1.name}${t1.iconsetId}` : t1.name;
            }
            static parse(t1) {
                const [e, r] = t1.split("");
                return new sr({
                    name: e,
                    iconsetId: r
                });
            }
            static isEqual(t1, e) {
                return t1.name === e.name && t1.iconsetId === e.iconsetId;
            }
            toString() {
                return sr.toString(this);
            }
            serialize() {
                return {
                    name: this.name,
                    iconsetId: this.iconsetId
                };
            }
        }
        var ar, or = {}, lr = function() {
            if (ar) return or;
            ar = 1;
            var t1 = {
                transparent: [
                    0,
                    0,
                    0,
                    0
                ],
                aliceblue: [
                    240,
                    248,
                    255,
                    1
                ],
                antiquewhite: [
                    250,
                    235,
                    215,
                    1
                ],
                aqua: [
                    0,
                    255,
                    255,
                    1
                ],
                aquamarine: [
                    127,
                    255,
                    212,
                    1
                ],
                azure: [
                    240,
                    255,
                    255,
                    1
                ],
                beige: [
                    245,
                    245,
                    220,
                    1
                ],
                bisque: [
                    255,
                    228,
                    196,
                    1
                ],
                black: [
                    0,
                    0,
                    0,
                    1
                ],
                blanchedalmond: [
                    255,
                    235,
                    205,
                    1
                ],
                blue: [
                    0,
                    0,
                    255,
                    1
                ],
                blueviolet: [
                    138,
                    43,
                    226,
                    1
                ],
                brown: [
                    165,
                    42,
                    42,
                    1
                ],
                burlywood: [
                    222,
                    184,
                    135,
                    1
                ],
                cadetblue: [
                    95,
                    158,
                    160,
                    1
                ],
                chartreuse: [
                    127,
                    255,
                    0,
                    1
                ],
                chocolate: [
                    210,
                    105,
                    30,
                    1
                ],
                coral: [
                    255,
                    127,
                    80,
                    1
                ],
                cornflowerblue: [
                    100,
                    149,
                    237,
                    1
                ],
                cornsilk: [
                    255,
                    248,
                    220,
                    1
                ],
                crimson: [
                    220,
                    20,
                    60,
                    1
                ],
                cyan: [
                    0,
                    255,
                    255,
                    1
                ],
                darkblue: [
                    0,
                    0,
                    139,
                    1
                ],
                darkcyan: [
                    0,
                    139,
                    139,
                    1
                ],
                darkgoldenrod: [
                    184,
                    134,
                    11,
                    1
                ],
                darkgray: [
                    169,
                    169,
                    169,
                    1
                ],
                darkgreen: [
                    0,
                    100,
                    0,
                    1
                ],
                darkgrey: [
                    169,
                    169,
                    169,
                    1
                ],
                darkkhaki: [
                    189,
                    183,
                    107,
                    1
                ],
                darkmagenta: [
                    139,
                    0,
                    139,
                    1
                ],
                darkolivegreen: [
                    85,
                    107,
                    47,
                    1
                ],
                darkorange: [
                    255,
                    140,
                    0,
                    1
                ],
                darkorchid: [
                    153,
                    50,
                    204,
                    1
                ],
                darkred: [
                    139,
                    0,
                    0,
                    1
                ],
                darksalmon: [
                    233,
                    150,
                    122,
                    1
                ],
                darkseagreen: [
                    143,
                    188,
                    143,
                    1
                ],
                darkslateblue: [
                    72,
                    61,
                    139,
                    1
                ],
                darkslategray: [
                    47,
                    79,
                    79,
                    1
                ],
                darkslategrey: [
                    47,
                    79,
                    79,
                    1
                ],
                darkturquoise: [
                    0,
                    206,
                    209,
                    1
                ],
                darkviolet: [
                    148,
                    0,
                    211,
                    1
                ],
                deeppink: [
                    255,
                    20,
                    147,
                    1
                ],
                deepskyblue: [
                    0,
                    191,
                    255,
                    1
                ],
                dimgray: [
                    105,
                    105,
                    105,
                    1
                ],
                dimgrey: [
                    105,
                    105,
                    105,
                    1
                ],
                dodgerblue: [
                    30,
                    144,
                    255,
                    1
                ],
                firebrick: [
                    178,
                    34,
                    34,
                    1
                ],
                floralwhite: [
                    255,
                    250,
                    240,
                    1
                ],
                forestgreen: [
                    34,
                    139,
                    34,
                    1
                ],
                fuchsia: [
                    255,
                    0,
                    255,
                    1
                ],
                gainsboro: [
                    220,
                    220,
                    220,
                    1
                ],
                ghostwhite: [
                    248,
                    248,
                    255,
                    1
                ],
                gold: [
                    255,
                    215,
                    0,
                    1
                ],
                goldenrod: [
                    218,
                    165,
                    32,
                    1
                ],
                gray: [
                    128,
                    128,
                    128,
                    1
                ],
                green: [
                    0,
                    128,
                    0,
                    1
                ],
                greenyellow: [
                    173,
                    255,
                    47,
                    1
                ],
                grey: [
                    128,
                    128,
                    128,
                    1
                ],
                honeydew: [
                    240,
                    255,
                    240,
                    1
                ],
                hotpink: [
                    255,
                    105,
                    180,
                    1
                ],
                indianred: [
                    205,
                    92,
                    92,
                    1
                ],
                indigo: [
                    75,
                    0,
                    130,
                    1
                ],
                ivory: [
                    255,
                    255,
                    240,
                    1
                ],
                khaki: [
                    240,
                    230,
                    140,
                    1
                ],
                lavender: [
                    230,
                    230,
                    250,
                    1
                ],
                lavenderblush: [
                    255,
                    240,
                    245,
                    1
                ],
                lawngreen: [
                    124,
                    252,
                    0,
                    1
                ],
                lemonchiffon: [
                    255,
                    250,
                    205,
                    1
                ],
                lightblue: [
                    173,
                    216,
                    230,
                    1
                ],
                lightcoral: [
                    240,
                    128,
                    128,
                    1
                ],
                lightcyan: [
                    224,
                    255,
                    255,
                    1
                ],
                lightgoldenrodyellow: [
                    250,
                    250,
                    210,
                    1
                ],
                lightgray: [
                    211,
                    211,
                    211,
                    1
                ],
                lightgreen: [
                    144,
                    238,
                    144,
                    1
                ],
                lightgrey: [
                    211,
                    211,
                    211,
                    1
                ],
                lightpink: [
                    255,
                    182,
                    193,
                    1
                ],
                lightsalmon: [
                    255,
                    160,
                    122,
                    1
                ],
                lightseagreen: [
                    32,
                    178,
                    170,
                    1
                ],
                lightskyblue: [
                    135,
                    206,
                    250,
                    1
                ],
                lightslategray: [
                    119,
                    136,
                    153,
                    1
                ],
                lightslategrey: [
                    119,
                    136,
                    153,
                    1
                ],
                lightsteelblue: [
                    176,
                    196,
                    222,
                    1
                ],
                lightyellow: [
                    255,
                    255,
                    224,
                    1
                ],
                lime: [
                    0,
                    255,
                    0,
                    1
                ],
                limegreen: [
                    50,
                    205,
                    50,
                    1
                ],
                linen: [
                    250,
                    240,
                    230,
                    1
                ],
                magenta: [
                    255,
                    0,
                    255,
                    1
                ],
                maroon: [
                    128,
                    0,
                    0,
                    1
                ],
                mediumaquamarine: [
                    102,
                    205,
                    170,
                    1
                ],
                mediumblue: [
                    0,
                    0,
                    205,
                    1
                ],
                mediumorchid: [
                    186,
                    85,
                    211,
                    1
                ],
                mediumpurple: [
                    147,
                    112,
                    219,
                    1
                ],
                mediumseagreen: [
                    60,
                    179,
                    113,
                    1
                ],
                mediumslateblue: [
                    123,
                    104,
                    238,
                    1
                ],
                mediumspringgreen: [
                    0,
                    250,
                    154,
                    1
                ],
                mediumturquoise: [
                    72,
                    209,
                    204,
                    1
                ],
                mediumvioletred: [
                    199,
                    21,
                    133,
                    1
                ],
                midnightblue: [
                    25,
                    25,
                    112,
                    1
                ],
                mintcream: [
                    245,
                    255,
                    250,
                    1
                ],
                mistyrose: [
                    255,
                    228,
                    225,
                    1
                ],
                moccasin: [
                    255,
                    228,
                    181,
                    1
                ],
                navajowhite: [
                    255,
                    222,
                    173,
                    1
                ],
                navy: [
                    0,
                    0,
                    128,
                    1
                ],
                oldlace: [
                    253,
                    245,
                    230,
                    1
                ],
                olive: [
                    128,
                    128,
                    0,
                    1
                ],
                olivedrab: [
                    107,
                    142,
                    35,
                    1
                ],
                orange: [
                    255,
                    165,
                    0,
                    1
                ],
                orangered: [
                    255,
                    69,
                    0,
                    1
                ],
                orchid: [
                    218,
                    112,
                    214,
                    1
                ],
                palegoldenrod: [
                    238,
                    232,
                    170,
                    1
                ],
                palegreen: [
                    152,
                    251,
                    152,
                    1
                ],
                paleturquoise: [
                    175,
                    238,
                    238,
                    1
                ],
                palevioletred: [
                    219,
                    112,
                    147,
                    1
                ],
                papayawhip: [
                    255,
                    239,
                    213,
                    1
                ],
                peachpuff: [
                    255,
                    218,
                    185,
                    1
                ],
                peru: [
                    205,
                    133,
                    63,
                    1
                ],
                pink: [
                    255,
                    192,
                    203,
                    1
                ],
                plum: [
                    221,
                    160,
                    221,
                    1
                ],
                powderblue: [
                    176,
                    224,
                    230,
                    1
                ],
                purple: [
                    128,
                    0,
                    128,
                    1
                ],
                rebeccapurple: [
                    102,
                    51,
                    153,
                    1
                ],
                red: [
                    255,
                    0,
                    0,
                    1
                ],
                rosybrown: [
                    188,
                    143,
                    143,
                    1
                ],
                royalblue: [
                    65,
                    105,
                    225,
                    1
                ],
                saddlebrown: [
                    139,
                    69,
                    19,
                    1
                ],
                salmon: [
                    250,
                    128,
                    114,
                    1
                ],
                sandybrown: [
                    244,
                    164,
                    96,
                    1
                ],
                seagreen: [
                    46,
                    139,
                    87,
                    1
                ],
                seashell: [
                    255,
                    245,
                    238,
                    1
                ],
                sienna: [
                    160,
                    82,
                    45,
                    1
                ],
                silver: [
                    192,
                    192,
                    192,
                    1
                ],
                skyblue: [
                    135,
                    206,
                    235,
                    1
                ],
                slateblue: [
                    106,
                    90,
                    205,
                    1
                ],
                slategray: [
                    112,
                    128,
                    144,
                    1
                ],
                slategrey: [
                    112,
                    128,
                    144,
                    1
                ],
                snow: [
                    255,
                    250,
                    250,
                    1
                ],
                springgreen: [
                    0,
                    255,
                    127,
                    1
                ],
                steelblue: [
                    70,
                    130,
                    180,
                    1
                ],
                tan: [
                    210,
                    180,
                    140,
                    1
                ],
                teal: [
                    0,
                    128,
                    128,
                    1
                ],
                thistle: [
                    216,
                    191,
                    216,
                    1
                ],
                tomato: [
                    255,
                    99,
                    71,
                    1
                ],
                turquoise: [
                    64,
                    224,
                    208,
                    1
                ],
                violet: [
                    238,
                    130,
                    238,
                    1
                ],
                wheat: [
                    245,
                    222,
                    179,
                    1
                ],
                white: [
                    255,
                    255,
                    255,
                    1
                ],
                whitesmoke: [
                    245,
                    245,
                    245,
                    1
                ],
                yellow: [
                    255,
                    255,
                    0,
                    1
                ],
                yellowgreen: [
                    154,
                    205,
                    50,
                    1
                ]
            };
            function e(t1) {
                return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
            }
            function r(t1) {
                return e("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
            }
            function n(t1) {
                return (e = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e > 1 ? 1 : e;
                //TURBOPACK unreachable
                ;
                var e;
            }
            function i(t1, e, r) {
                return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e - t1) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t1 + (e - t1) * (2 / 3 - r) * 6 : t1;
            }
            try {
                or.parseCSSColor = function(s) {
                    var a, o = s.replace(/ /g, "").toLowerCase();
                    if (o in t1) return t1[o].slice();
                    if ("#" === o[0]) return 4 === o.length ? (a = parseInt(o.substr(1), 16)) >= 0 && a <= 4095 ? [
                        (3840 & a) >> 4 | (3840 & a) >> 8,
                        240 & a | (240 & a) >> 4,
                        15 & a | (15 & a) << 4,
                        1
                    ] : null : 7 === o.length && (a = parseInt(o.substr(1), 16)) >= 0 && a <= 16777215 ? [
                        (16711680 & a) >> 16,
                        (65280 & a) >> 8,
                        255 & a,
                        1
                    ] : null;
                    var l = o.indexOf("("), u = o.indexOf(")");
                    if (-1 !== l && u + 1 === o.length) {
                        var c = o.substr(0, l), h = o.substr(l + 1, u - (l + 1)).split(","), p = 1;
                        switch(c){
                            case "rgba":
                                if (4 !== h.length) return null;
                                p = n(h.pop());
                            case "rgb":
                                return 3 !== h.length ? null : [
                                    r(h[0]),
                                    r(h[1]),
                                    r(h[2]),
                                    p
                                ];
                            case "hsla":
                                if (4 !== h.length) return null;
                                p = n(h.pop());
                            case "hsl":
                                if (3 !== h.length) return null;
                                var d = (parseFloat(h[0]) % 360 + 360) % 360 / 360, f = n(h[1]), m = n(h[2]), y = m <= .5 ? m * (f + 1) : m + f - m * f, g = 2 * m - y;
                                return [
                                    e(255 * i(g, y, d + 1 / 3)),
                                    e(255 * i(g, y, d)),
                                    e(255 * i(g, y, d - 1 / 3)),
                                    p
                                ];
                            default:
                                return null;
                        }
                    }
                    return null;
                };
            } catch (t1) {}
            return or;
        }();
        class ur {
            constructor(t1, e, r, n = 1){
                this.r = t1, this.g = e, this.b = r, this.a = n;
            }
            static parse(t1) {
                if (!t1) return;
                if (t1 instanceof ur) return t1;
                if ("string" != typeof t1) return;
                const e = lr.parseCSSColor(t1);
                return e ? new ur(e[0] / 255, e[1] / 255, e[2] / 255, e[3]) : void 0;
            }
            toString() {
                const [t1, e, r, n] = [
                    this.r,
                    this.g,
                    this.b,
                    this.a
                ];
                return `rgba(${Math.round(255 * t1)},${Math.round(255 * e)},${Math.round(255 * r)},${n})`;
            }
            toNonPremultipliedRenderColor(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return new hr(t1, e, r, n, i);
            }
            toPremultipliedRenderColor(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return new pr(t1, e * i, r * i, n * i, i);
            }
            clone() {
                return new ur(this.r, this.g, this.b, this.a);
            }
        }
        class cr {
            constructor(t1, e, r, n, i, s = !1){
                if (this.premultiplied = !1, this.premultiplied = s, t1) {
                    const s = t1.image.height, a = s * s;
                    this.premultiplied ? (e = 0 === i ? 0 : e / i * (s - 1), r = 0 === i ? 0 : r / i * (s - 1), n = 0 === i ? 0 : n / i * (s - 1)) : (e *= s - 1, r *= s - 1, n *= s - 1);
                    const o = Math.floor(e), l = Math.floor(r), u = Math.floor(n), c = Math.ceil(e), h = Math.ceil(r), p = Math.ceil(n), d = e - o, f = r - l, m = n - u, y = t1.image.data, g = 4 * (o + l * a + u * s), x = 4 * (o + l * a + p * s), v = 4 * (o + h * a + u * s), b = 4 * (o + h * a + p * s), w = 4 * (c + l * a + u * s), _ = 4 * (c + l * a + p * s), A = 4 * (c + h * a + u * s), I = 4 * (c + h * a + p * s);
                    if (g < 0 || I >= y.length) throw new Error("out of range");
                    this.r = dr(dr(dr(y[g], y[x], m), dr(y[v], y[b], m), f), dr(dr(y[w], y[_], m), dr(y[A], y[I], m), f), d) / 255 * (this.premultiplied ? i : 1), this.g = dr(dr(dr(y[g + 1], y[x + 1], m), dr(y[v + 1], y[b + 1], m), f), dr(dr(y[w + 1], y[_ + 1], m), dr(y[A + 1], y[I + 1], m), f), d) / 255 * (this.premultiplied ? i : 1), this.b = dr(dr(dr(y[g + 2], y[x + 2], m), dr(y[v + 2], y[b + 2], m), f), dr(dr(y[w + 2], y[_ + 2], m), dr(y[A + 2], y[I + 2], m), f), d) / 255 * (this.premultiplied ? i : 1), this.a = i;
                } else this.r = e, this.g = r, this.b = n, this.a = i;
            }
            toArray() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    255 * t1,
                    255 * e,
                    255 * r,
                    n
                ];
            }
            toHslaArray() {
                let { r: t1, g: e, b: r, a: n } = this;
                if (this.premultiplied) {
                    if (0 === n) return [
                        0,
                        0,
                        0,
                        0
                    ];
                    const i = 1 / n;
                    t1 *= i, e *= i, r *= i;
                }
                const i = Math.min(Math.max(t1, 0), 1), s = Math.min(Math.max(e, 0), 1), a = Math.min(Math.max(r, 0), 1), o = Math.min(i, s, a), l = Math.max(i, s, a), u = l - o, c = .5 * (o + l);
                if (0 === u) return [
                    0,
                    0,
                    100 * c,
                    n
                ];
                const h = c > .5 ? u / (2 - l - o) : u / (l + o);
                let p;
                switch(l){
                    case i:
                        p = 60 * ((s - a) / u + (s < a ? 6 : 0));
                        break;
                    case s:
                        p = 60 * ((a - i) / u + 2);
                        break;
                    default:
                        p = 60 * ((i - s) / u + 4);
                }
                return [
                    p,
                    100 * h,
                    100 * c,
                    n
                ];
            }
            toArray01() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    t1,
                    e,
                    r,
                    n
                ];
            }
            toArray01Scaled(t1) {
                const { r: e, g: r, b: n } = this;
                return [
                    e * t1,
                    r * t1,
                    n * t1
                ];
            }
            toArray01Linear() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    Math.pow(t1, 2.2),
                    Math.pow(e, 2.2),
                    Math.pow(r, 2.2),
                    n
                ];
            }
        }
        class hr extends cr {
            constructor(t1, e, r, n, i){
                super(t1, e, r, n, i, !1);
            }
        }
        class pr extends cr {
            constructor(t1, e, r, n, i){
                super(t1, e, r, n, i, !0);
            }
        }
        function dr(t1, e, r) {
            return t1 * (1 - r) + e * r;
        }
        function fr(t1, e, r) {
            return t1.map((t1, n)=>dr(t1, e[n], r));
        }
        ur.black = new ur(0, 0, 0, 1), ur.white = new ur(1, 1, 1, 1), ur.transparent = new ur(0, 0, 0, 0), ur.red = new ur(1, 0, 0, 1), ur.blue = new ur(0, 0, 1, 1);
        var mr = Object.freeze({
            __proto__: null,
            array: fr,
            color: function(t1, e, r) {
                return new ur(dr(t1.r, e.r, r), dr(t1.g, e.g, r), dr(t1.b, e.b, r), dr(t1.a, e.a, r));
            },
            number: dr
        });
        class yr extends Error {
            constructor(t1, e){
                super(e), this.message = e, this.key = t1;
            }
        }
        class gr {
            constructor(t1, e = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e)this.bindings[t1] = r;
            }
            concat(t1) {
                return new gr(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        const xr = {
            kind: "null"
        }, vr = {
            kind: "number"
        }, br = {
            kind: "string"
        }, wr = {
            kind: "boolean"
        }, _r = {
            kind: "color"
        }, Ar = {
            kind: "object"
        }, Ir = {
            kind: "value"
        }, Mr = {
            kind: "collator"
        }, Sr = {
            kind: "formatted"
        }, Pr = {
            kind: "resolvedImage"
        };
        function zr(t1, e) {
            return {
                kind: "array",
                itemType: t1,
                N: e
            };
        }
        function Br(t1) {
            if ("array" === t1.kind) {
                const e = Br(t1.itemType);
                return "number" == typeof t1.N ? `array<${e}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e}>`;
            }
            return t1.kind;
        }
        const kr = [
            xr,
            vr,
            br,
            wr,
            _r,
            Sr,
            Ar,
            zr(Ir),
            Pr
        ];
        function Tr(t1, e) {
            if ("error" === e.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Tr(t1.itemType, e.itemType)) && ("number" != typeof t1.N || t1.N === e.N)) return null;
            } else {
                if (t1.kind === e.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of kr)if (!Tr(t1, e)) return null;
                }
            }
            return `Expected ${Br(t1)} but found ${Br(e)} instead.`;
        }
        function Vr(t1, e) {
            return e.some((e)=>e.kind === t1.kind);
        }
        function Er(t1, e) {
            return e.some((e)=>"null" === e ? null === t1 : "array" === e ? Array.isArray(t1) : "object" === e ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e === typeof t1);
        }
        function Fr(t1, e) {
            return "array" === t1.kind && "array" === e.kind ? t1.N === e.N && Fr(t1.itemType, e.itemType) : t1.kind === e.kind;
        }
        class Dr {
            constructor(t1, e, r){
                this.sensitivity = t1 ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e) {
                return this.collator.compare(t1, e);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class Cr {
            constructor(t1, e, r, n, i){
                this.text = t1.normalize ? t1.normalize() : t1, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class Rr {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new Rr([
                    new Cr(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || !!t1.image && t1.image.hasPrimary());
            }
            static factory(t1) {
                return t1 instanceof Rr ? t1 : Rr.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    if (e.image) {
                        const r = e.image.getPrimary().id.toString();
                        t1.push([
                            "image",
                            r
                        ]);
                        continue;
                    }
                    t1.push(e.text);
                    const r = {};
                    e.fontStack && (r["text-font"] = [
                        "literal",
                        e.fontStack.split(",")
                    ]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = [
                        "rgba"
                    ].concat(e.textColor.toNonPremultipliedRenderColor(null).toArray())), t1.push(r);
                }
                return t1;
            }
        }
        class Lr {
            constructor(t1, e = {}){
                this.id = sr.from(t1), this.params = e.params, this.sx = e.sx || 1, this.sy = e.sy || 1;
            }
            toString() {
                return JSON.stringify(this);
            }
            static parse(t1) {
                let e, r, n, i;
                try {
                    ({ id: e, params: r, sx: n, sy: i } = JSON.parse(t1) || {});
                } catch (t1) {
                    return null;
                }
                return e ? new Lr(e, {
                    params: r,
                    sx: n,
                    sy: i
                }) : null;
            }
            scaleSelf(t1, e = t1) {
                return this.sx *= t1, this.sy *= e, this;
            }
        }
        class Or {
            constructor(t1, e, r, n, i = !1){
                this.primaryId = sr.from(t1), this.primaryOptions = e, r && (this.secondaryId = sr.from(r)), this.secondaryOptions = n, this.available = i;
            }
            toString() {
                return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;
            }
            hasPrimary() {
                return !!this.primaryId;
            }
            getPrimary() {
                return new Lr(this.primaryId, this.primaryOptions);
            }
            hasSecondary() {
                return !!this.secondaryId;
            }
            getSecondary() {
                return this.secondaryId ? new Lr(this.secondaryId, this.secondaryOptions) : null;
            }
            static from(t1) {
                return "string" == typeof t1 ? Or.build({
                    name: t1
                }) : t1;
            }
            static build(t1, e, r, n) {
                return !t1 || "object" == typeof t1 && !("name" in t1) ? null : new Or(t1, r, e, n);
            }
        }
        function Ur(t1, e, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e,
                r,
                n
            ] : [
                t1,
                e,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Nr(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof ur) return !0;
            if (t1 instanceof Dr) return !0;
            if (t1 instanceof Rr) return !0;
            if (t1 instanceof Or) return !0;
            if (Array.isArray(t1)) {
                for (const e of t1)if (!Nr(e)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e in t1)if (!Nr(t1[e])) return !1;
                return !0;
            }
            return !1;
        }
        function jr(t1) {
            if (null === t1) return xr;
            if ("string" == typeof t1) return br;
            if ("boolean" == typeof t1) return wr;
            if ("number" == typeof t1) return vr;
            if (t1 instanceof ur) return _r;
            if (t1 instanceof Dr) return Mr;
            if (t1 instanceof Rr) return Sr;
            if (t1 instanceof Or) return Pr;
            if (Array.isArray(t1)) {
                const e = t1.length;
                let r;
                for (const e of t1){
                    const t1 = jr(e);
                    if (r) {
                        if (r === t1) continue;
                        r = Ir;
                        break;
                    }
                    r = t1;
                }
                return zr(r || Ir, e);
            }
            return Ar;
        }
        function Gr(t1) {
            const e = typeof t1;
            return null === t1 ? "" : "string" === e || "number" === e || "boolean" === e ? String(t1) : t1 instanceof Rr || t1 instanceof Or || t1 instanceof ur ? t1.toString() : JSON.stringify(t1);
        }
        class $r {
            constructor(t1, e){
                this.type = t1, this.value = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!Nr(t1[1])) return e.error("invalid value");
                const r = t1[1];
                let n = jr(r);
                const i = e.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new $r(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof ur ? [
                    "rgba"
                ].concat(this.value.toNonPremultipliedRenderColor(null).toArray()) : this.value instanceof Rr ? this.value.serialize() : this.value;
            }
        }
        class qr {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        }
        const Xr = {
            string: br,
            number: vr,
            boolean: wr,
            object: Ar
        };
        class Hr {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, s;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in Xr) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = Xr[r], n++;
                    } else i = Ir;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
                        s = t1[2], n++;
                    }
                    r = zr(i, s);
                } else r = Xr[i];
                const s = [];
                for(; n < t1.length; n++){
                    const r = e.parse(t1[n], n, Ir);
                    if (!r) return null;
                    s.push(r);
                }
                return new Hr(r, s);
            }
            evaluate(t1) {
                for(let e = 0; e < this.args.length; e++){
                    const r = this.args[e].evaluate(t1);
                    if (!Tr(this.type, jr(r))) return r;
                    if (e === this.args.length - 1) throw new qr(`The expression ${JSON.stringify(this.args[e].serialize())} evaluated to ${Br(jr(r))} but was expected to be of type ${Br(this.type)}.`);
                }
                return null;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = this.type, e = [
                    t1.kind
                ];
                if ("array" === t1.kind) {
                    const r = t1.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e.push(r.kind);
                        const n = t1.N;
                        ("number" == typeof n || this.args.length > 1) && e.push(n);
                    }
                }
                return e.concat(this.args.map((t1)=>t1.serialize()));
            }
        }
        class Zr {
            constructor(t1){
                this.type = Sr, this.sections = t1;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const s = t1[r];
                    if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;
                        let t1 = null;
                        if (s["font-scale"] && (t1 = e.parseObjectValue(s["font-scale"], r, "font-scale", vr), !t1)) return null;
                        let a = null;
                        if (s["text-font"] && (a = e.parseObjectValue(s["text-font"], r, "text-font", zr(br)), !a)) return null;
                        let o = null;
                        if (s["text-color"] && (o = e.parseObjectValue(s["text-color"], r, "text-color", _r), !o)) return null;
                        const l = n[n.length - 1];
                        l.scale = t1, l.font = a, l.textColor = o;
                    } else {
                        const s = e.parse(t1[r], r, Ir);
                        if (!s) return null;
                        const a = s.type.kind;
                        if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: s,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Zr(n);
            }
            evaluate(t1) {
                return new Rr(this.sections.map((e)=>{
                    const r = e.content.evaluate(t1);
                    return Fr(jr(r), Pr) ? new Cr("", r, null, null, null) : new Cr(Gr(r), null, e.scale ? e.scale.evaluate(t1) : null, e.font ? e.font.evaluate(t1).join(",") : null, e.textColor ? e.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e of this.sections)t1(e.content), e.scale && t1(e.scale), e.font && t1(e.font), e.textColor && t1(e.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    t1.push(e.content.serialize());
                    const r = {};
                    e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t1.push(r);
                }
                return t1;
            }
        }
        class Wr {
            constructor(t1, e, r, n){
                this._imageWarnHistory = {}, this.type = Pr, this.namePrimary = t1, this.nameSecondary = e, r && (this.paramsPrimary = r.params, this.iconsetIdPrimary = r.iconset ? r.iconset.id : void 0), n && (this.paramsSecondary = n.params, this.iconsetIdSecondary = n.iconset ? n.iconset.id : void 0);
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected two or more arguments.");
                let r = 1;
                const n = [];
                function i() {
                    if (r < t1.length) {
                        const i = e.parse(t1[r], r++, br);
                        return i ? (n.push({
                            image: i,
                            options: {}
                        }), !0) : (e.error(n.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
                    }
                    return !0;
                }
                function s() {
                    if (r < t1.length) {
                        const s = t1[r];
                        if (null === (i = s) || "object" != typeof i || Array.isArray(i)) return !0;
                        const a = s.params, o = s.iconset, l = e.concat(r);
                        if (!a && !o) return r++, !0;
                        if (a) {
                            if ("object" != typeof a || a.constructor !== Object) return l.error('Image options "params" should be an object'), !1;
                            const t1 = {}, e = l.concat(void 0, "params");
                            for(const r in a){
                                if (!r) return e.error("Image parameter name should be non-empty"), !1;
                                const n = e.concat(void 0, r).parse(a[r], void 0, _r, void 0, {
                                    typeAnnotation: "coerce"
                                });
                                if (!n) return !1;
                                t1[r] = n;
                            }
                            n[n.length - 1].options.params = t1;
                        }
                        if (o) {
                            if ("object" != typeof o || o.constructor !== Object) return l.error('Image options "iconset" should be an object'), !1;
                            if (!o.id) return l.error('Image options "iconset" should have an "id" property'), !1;
                            n[n.length - 1].options.iconset = o;
                        }
                        return r++, !0;
                    }
                    var i;
                    return !0;
                }
                for(let t1 = 0; t1 < 2; t1++)if (!i() || !s()) return;
                return new Wr(n[0].image, n[1] ? n[1].image : void 0, n[0].options, n[1] ? n[1].options : void 0);
            }
            evaluateParams(t1, e) {
                const r = {};
                if (e) {
                    for(const n in e)if (e[n]) try {
                        r[n] = e[n].evaluate(t1);
                    } catch (t1) {
                        continue;
                    }
                    if (0 !== Object.keys(r).length) return {
                        params: r
                    };
                }
            }
            evaluate(t1) {
                const e = {
                    name: this.namePrimary.evaluate(t1),
                    iconsetId: this.iconsetIdPrimary
                }, r = this.nameSecondary ? {
                    name: this.nameSecondary.evaluate(t1),
                    iconsetId: this.iconsetIdSecondary
                } : void 0, n = Or.build(e, r, this.paramsPrimary ? this.evaluateParams(t1, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t1, this.paramsSecondary) : void 0);
                if (n && t1.availableImages) {
                    const e = n.getPrimary().id;
                    if (n.available = t1.availableImages.some((t1)=>sr.isEqual(t1, e)), n.available) {
                        const e = n.getSecondary() ? n.getSecondary().id : null;
                        e && (n.available = t1.availableImages.some((t1)=>sr.isEqual(t1, e)));
                    }
                }
                return n;
            }
            eachChild(t1) {
                if (t1(this.namePrimary), this.paramsPrimary) for(const e in this.paramsPrimary)this.paramsPrimary[e] && t1(this.paramsPrimary[e]);
                if (this.nameSecondary && (t1(this.nameSecondary), this.paramsSecondary)) for(const e in this.paramsSecondary)this.paramsSecondary[e] && t1(this.paramsSecondary[e]);
            }
            outputDefined() {
                return !1;
            }
            serializeOptions(t1, e) {
                const r = {};
                if (e && (r.iconset = {
                    id: e
                }), t1) {
                    r.params = {};
                    for(const e in t1)t1[e] && (r.params[e] = t1[e].serialize());
                }
                return Object.keys(r).length > 0 ? r : void 0;
            }
            serialize() {
                const t1 = [
                    "image",
                    this.namePrimary.serialize()
                ];
                if (this.paramsPrimary || this.iconsetIdPrimary) {
                    const e = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
                    e && t1.push(e);
                }
                if (this.nameSecondary && (t1.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
                    const e = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
                    e && t1.push(e);
                }
                return t1;
            }
        }
        function Yr(t1) {
            return Kr(t1) ? "string" : Qr(t1) ? "number" : tn(t1) ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : Jr(t1) ? "object" : typeof t1;
        }
        function Jr(t1) {
            return null != t1 && !Array.isArray(t1) && "function" != typeof t1 && !(t1 instanceof String || t1 instanceof Number || t1 instanceof Boolean) && "object" == typeof t1;
        }
        function Kr(t1) {
            return "string" == typeof t1 || t1 instanceof String;
        }
        function Qr(t1) {
            return "number" == typeof t1 || t1 instanceof Number;
        }
        function tn(t1) {
            return "boolean" == typeof t1 || t1 instanceof Boolean;
        }
        const en = {
            "to-boolean": wr,
            "to-color": _r,
            "to-number": vr,
            "to-string": br
        };
        class rn {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[0], n = [];
                let i = xr;
                if ("to-array" === r) {
                    if (!Array.isArray(t1[1])) return null;
                    const r = t1[1].length;
                    if (e.expectedType) {
                        if ("array" !== e.expectedType.kind) return e.error(`Expected ${e.expectedType.kind} but found array.`);
                        i = zr(e.expectedType.itemType, r);
                    } else {
                        if (!(r > 0 && Nr(t1[1][0]))) return null;
                        i = zr(jr(t1[1][0]), r);
                    }
                    for(let s = 0; s < r; s++){
                        const r = t1[1][s];
                        let a;
                        if (Array.isArray(r)) a = e.parse(r, void 0, i.itemType);
                        else {
                            const t1 = Yr(r);
                            if (t1 !== i.itemType.kind) return e.error(`Expected ${i.itemType.kind} but found ${t1}.`);
                            a = e.registry.literal.parse([
                                "literal",
                                void 0 === r ? null : r
                            ], e);
                        }
                        if (!a) return null;
                        n.push(a);
                    }
                } else {
                    if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e.error("Expected one argument.");
                    i = en[r];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], r, Ir);
                        if (!i) return null;
                        n.push(i);
                    }
                }
                return new rn(i, n);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e, r;
                    for (const n of this.args){
                        if (e = n.evaluate(t1), r = null, e instanceof ur) return e;
                        if ("string" == typeof e) {
                            const r = t1.parseColor(e);
                            if (r) return r;
                        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Ur(e[0], e[1], e[2], e[3]), !r)) return new ur(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                    }
                    throw new qr(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
                }
                if ("number" === this.type.kind) {
                    let e = null;
                    for (const r of this.args){
                        if (e = r.evaluate(t1), null === e) return 0;
                        const n = Number(e);
                        if (!isNaN(n)) return n;
                    }
                    throw new qr(`Could not convert ${JSON.stringify(e)} to number.`);
                }
                return "formatted" === this.type.kind ? Rr.fromString(Gr(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? Or.build(Gr(this.args[0].evaluate(t1))) : "array" === this.type.kind ? this.args.map((e)=>e.evaluate(t1)) : Gr(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                if ("formatted" === this.type.kind) return new Zr([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new Wr(this.args[0]).serialize();
                const t1 = "array" === this.type.kind ? [] : [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        const nn = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class sn {
            constructor(t1, e, r){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t1, this.options = e, this.iconImageUseTheme = r;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? nn[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            measureLight(t1) {
                return this.globals.brightness || 0;
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t1 = this.featureDistanceData.center, e = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e - t1[0]) + this.featureDistanceData.bearing[1] * (n * e - t1[1]);
                }
                return 0;
            }
            parseColor(t1) {
                let e = this._parseColorCache[t1];
                return e || (e = this._parseColorCache[t1] = ur.parse(t1)), e;
            }
            getConfig(t1) {
                return this.options ? this.options.get(t1) : null;
            }
        }
        class an {
            constructor(t1, e, r, n, i){
                this.name = t1, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;
            }
            evaluate(t1) {
                if (!this._evaluate) {
                    const t1 = an.definitions[this.name];
                    this._evaluate = Array.isArray(t1) ? t1[2] : t1.overloads[this._overloadIndex][1];
                }
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t1)=>t1.serialize()));
            }
            static parse(t1, e) {
                const r = t1[0], n = an.definitions[r];
                if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, s = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, a = [];
                let o = null, l = -1;
                for (const [n, u] of s){
                    if (Array.isArray(n) && n.length !== t1.length - 1) continue;
                    a.push(n), l++, o = new Mi(e.registry, e.path, null, e.scope, void 0, e._scope, e.options, e.iconImageUseTheme);
                    const s = [];
                    let c = !1;
                    for(let e = 1; e < t1.length; e++){
                        const r = t1[e], i = Array.isArray(n) ? n[e - 1] : n.type, a = o.parse(r, 1 + s.length, i);
                        if (!a) {
                            c = !0;
                            break;
                        }
                        s.push(a);
                    }
                    if (!c) if (Array.isArray(n) && n.length !== s.length) o.error(`Expected ${n.length} arguments, but found ${s.length} instead.`);
                    else {
                        for(let t1 = 0; t1 < s.length; t1++){
                            const e = Array.isArray(n) ? n[t1] : n.type, r = s[t1];
                            o.concat(t1 + 1).checkSubtype(e, r.type);
                        }
                        if (0 === o.errors.length) return new an(r, i, u, s, l);
                    }
                }
                if (1 === a.length) e.errors.push(...o.errors);
                else {
                    const r = (a.length ? a : s.map(([t1])=>t1)).map(on).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(Br(i.type));
                    }
                    e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e) {
                an.definitions = e;
                for(const r in e)t1[r] = an;
            }
        }
        function on(t1) {
            return Array.isArray(t1) ? `(${t1.map(Br).join(", ")})` : `(${Br(t1.type)}...)`;
        }
        class ln {
            constructor(t1, e, r){
                this.type = Mr, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");
                const n = void 0 === r["case-sensitive"] ? e.parse(!1, 1, wr) : e.parseObjectValue(r["case-sensitive"], 1, "case-sensitive", wr);
                if (!n) return null;
                const i = void 0 === r["diacritic-sensitive"] ? e.parse(!1, 1, wr) : e.parseObjectValue(r["diacritic-sensitive"], 1, "diacritic-sensitive", wr);
                if (!i) return null;
                let s = null;
                return r.locale && (s = e.parseObjectValue(r.locale, 1, "locale", br), !s) ? null : new ln(n, i, s);
            }
            evaluate(t1) {
                return new Dr(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return t1["case-sensitive"] = this.caseSensitive.serialize(), t1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t1.locale = this.locale.serialize()), [
                    "collator",
                    t1
                ];
            }
        }
        function un(t1, e, r = 0, n = t1.length - 1, i = hn) {
            for(; n > r;){
                if (n - r > 600) {
                    const s = n - r + 1, a = e - r + 1, o = Math.log(s), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
                    un(t1, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);
                }
                const s = t1[e];
                let a = r, o = n;
                for(cn(t1, r, e), i(t1[n], s) > 0 && cn(t1, r, n); a < o;){
                    for(cn(t1, a, o), a++, o--; i(t1[a], s) < 0;)a++;
                    for(; i(t1[o], s) > 0;)o--;
                }
                0 === i(t1[r], s) ? cn(t1, r, o) : (o++, cn(t1, o, n)), o <= e && (r = o + 1), e <= o && (n = o - 1);
            }
        }
        function cn(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function hn(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function pn(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function dn(t1, e) {
            t1[0] = Math.min(t1[0], e[0]), t1[1] = Math.min(t1[1], e[1]), t1[2] = Math.max(t1[2], e[0]), t1[3] = Math.max(t1[3], e[1]);
        }
        function fn(t1, e) {
            return !(t1[0] <= e[0] || t1[2] >= e[2] || t1[1] <= e[1] || t1[3] >= e[3]);
        }
        function mn(t1, e, r) {
            const n = t1[0] - e[0], i = t1[1] - e[1], s = t1[0] - r[0], a = t1[1] - r[1];
            return n * a - s * i === 0 && n * s <= 0 && i * a <= 0;
        }
        function yn(t1, e, r) {
            return e[1] > t1[1] != r[1] > t1[1] && t1[0] < (r[0] - e[0]) * (t1[1] - e[1]) / (r[1] - e[1]) + e[0];
        }
        function gn(t1, e, r = !1) {
            let n = !1;
            for(let i = 0, s = e.length; i < s; i++){
                const s = e[i];
                for(let e = 0, i = s.length, a = i - 1; e < i; a = e++){
                    const i = s[a], o = s[e];
                    if (mn(t1, i, o)) return r;
                    yn(t1, i, o) && (n = !n);
                }
            }
            return n;
        }
        function xn(t1, e, r, n) {
            const i = n[0] - r[0], s = n[1] - r[1], a = (t1[0] - r[0]) * s - i * (t1[1] - r[1]), o = (e[0] - r[0]) * s - i * (e[1] - r[1]);
            return a > 0 && o < 0 || a < 0 && o > 0;
        }
        function vn(t1, e, r, n) {
            return 0 !== (i = [
                n[0] - r[0],
                n[1] - r[1]
            ])[0] * (s = [
                e[0] - t1[0],
                e[1] - t1[1]
            ])[1] - i[1] * s[0] && !(!xn(t1, e, r, n) || !xn(r, n, t1, e));
            //TURBOPACK unreachable
            ;
            var i, s;
        }
        function bn(t1) {
            const e = new Mt(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r = new Mt(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            for (const n of t1[0])e.x > n.x && (e.x = n.x), e.y > n.y && (e.y = n.y), r.x < n.x && (r.x = n.x), r.y < n.y && (r.y = n.y);
            return {
                min: e,
                max: r
            };
        }
        const wn = 8192;
        function _n(t1, e) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e.z);
            return [
                Math.round(r * i * wn),
                Math.round(n * i * wn)
            ];
        }
        function An(t1, e) {
            for(let r = 0; r < e.length; r++)if (gn(t1, e[r])) return !0;
            return !1;
        }
        function In(t1, e, r) {
            for (const n of r)for(let r = 0, i = n.length, s = i - 1; r < i; s = r++)if (vn(t1, e, n[s], n[r])) return !0;
            return !1;
        }
        function Mn(t1, e) {
            for(let r = 0; r < t1.length; ++r)if (!gn(t1[r], e)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (In(t1[r], t1[r + 1], e)) return !1;
            return !0;
        }
        function Sn(t1, e) {
            for(let r = 0; r < e.length; r++)if (Mn(t1, e[r])) return !0;
            return !1;
        }
        function Pn(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = [];
                for(let n = 0; n < t1[i].length; n++){
                    const a = _n(t1[i][n], r);
                    dn(e, a), s.push(a);
                }
                n.push(s);
            }
            return n;
        }
        function zn(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = Pn(t1[i], e, r);
                n.push(s);
            }
            return n;
        }
        function Bn(t1, e, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e = .5 * n;
                let i = t1[0] - r[0] > e ? -n : r[0] - t1[0] > e ? n : 0;
                0 === i && (i = t1[0] - r[2] > e ? -n : r[2] - t1[0] > e ? n : 0), t1[0] += i;
            }
            dn(e, t1);
        }
        function kn(t1, e, r, n) {
            const i = Math.pow(2, n.z) * wn, s = [
                n.x * wn,
                n.y * wn
            ], a = [];
            if (!t1) return a;
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + s[0],
                    t1.y + s[1]
                ];
                Bn(n, e, r, i), a.push(n);
            }
            return a;
        }
        function Tn(t1, e, r, n) {
            const i = Math.pow(2, n.z) * wn, s = [
                n.x * wn,
                n.y * wn
            ], a = [];
            if (!t1) return a;
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + s[0],
                        n.y + s[1]
                    ];
                    dn(e, r), t1.push(r);
                }
                a.push(t1);
            }
            if (e[2] - e[0] <= i / 2) {
                (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
                for (const t1 of a)for (const n of t1)Bn(n, e, r, i);
            }
            var o;
            return a;
        }
        class Vn {
            constructor(t1, e){
                this.type = wr, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (Nr(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) for(let t1 = 0; t1 < e.features.length; ++t1){
                        const r = e.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new Vn(e, e.features[t1].geometry);
                    }
                    else if ("Feature" === e.type) {
                        const t1 = e.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new Vn(e, e.geometry);
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new Vn(e, e);
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const s = Pn(e.coordinates, n, i), a = kn(t1.geometry(), r, n, i);
                            if (!fn(r, n)) return !1;
                            for (const t1 of a)if (!gn(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const s = zn(e.coordinates, n, i), a = kn(t1.geometry(), r, n, i);
                            if (!fn(r, n)) return !1;
                            for (const t1 of a)if (!An(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const s = Pn(e.coordinates, n, i), a = Tn(t1.geometry(), r, n, i);
                            if (!fn(r, n)) return !1;
                            for (const t1 of a)if (!Mn(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const s = zn(e.coordinates, n, i), a = Tn(t1.geometry(), r, n, i);
                            if (!fn(r, n)) return !1;
                            for (const t1 of a)if (!Sn(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        const En = {
            kilometers: 1,
            miles: 1e3 / 1609.344,
            nauticalmiles: 1e3 / 1852,
            meters: 1e3,
            metres: 1e3,
            yards: 1e3 / .9144,
            feet: 1e3 / .3048,
            inches: 1e3 / .0254
        }, Fn = 1 / 298.257223563, Dn = Fn * (2 - Fn), Cn = Math.PI / 180;
        class Rn {
            static fromTile(t1, e, r) {
                const n = Math.PI * (1 - 2 * (t1 + .5) / Math.pow(2, e)), i = Math.atan(.5 * (Math.exp(n) - Math.exp(-n))) / Cn;
                return new Rn(i, r);
            }
            static get units() {
                return En;
            }
            constructor(t1, e){
                if (void 0 === t1) throw new Error("No latitude given.");
                if (e && !En[e]) throw new Error(`Unknown unit ${e}. Use one of: ${Object.keys(En).join(", ")}`);
                const r = 6378.137 * Cn * (e ? En[e] : 1), n = Math.cos(t1 * Cn), i = 1 / (1 - Dn * (1 - n * n)), s = Math.sqrt(i);
                this.kx = r * s * n, this.ky = r * s * i * (1 - Dn);
            }
            distance(t1, e) {
                const r = Un(t1[0] - e[0]) * this.kx, n = (t1[1] - e[1]) * this.ky;
                return Math.sqrt(r * r + n * n);
            }
            bearing(t1, e) {
                const r = Un(e[0] - t1[0]) * this.kx;
                return Math.atan2(r, (e[1] - t1[1]) * this.ky) / Cn;
            }
            destination(t1, e, r) {
                const n = r * Cn;
                return this.offset(t1, Math.sin(n) * e, Math.cos(n) * e);
            }
            offset(t1, e, r) {
                return [
                    t1[0] + e / this.kx,
                    t1[1] + r / this.ky
                ];
            }
            lineDistance(t1) {
                let e = 0;
                for(let r = 0; r < t1.length - 1; r++)e += this.distance(t1[r], t1[r + 1]);
                return e;
            }
            area(t1) {
                let e = 0;
                for(let r = 0; r < t1.length; r++){
                    const n = t1[r];
                    for(let t1 = 0, i = n.length, s = i - 1; t1 < i; s = t1++)e += Un(n[t1][0] - n[s][0]) * (n[t1][1] + n[s][1]) * (r ? -1 : 1);
                }
                return Math.abs(e) / 2 * this.kx * this.ky;
            }
            along(t1, e) {
                let r = 0;
                if (e <= 0) return t1[0];
                for(let n = 0; n < t1.length - 1; n++){
                    const i = t1[n], s = t1[n + 1], a = this.distance(i, s);
                    if (r += a, r > e) return On(i, s, (e - (r - a)) / a);
                }
                return t1[t1.length - 1];
            }
            pointToSegmentDistance(t1, e, r) {
                let [n, i] = e, s = Un(r[0] - n) * this.kx, a = (r[1] - i) * this.ky;
                if (0 !== s || 0 !== a) {
                    const e = (Un(t1[0] - n) * this.kx * s + (t1[1] - i) * this.ky * a) / (s * s + a * a);
                    e > 1 ? (n = r[0], i = r[1]) : e > 0 && (n += s / this.kx * e, i += a / this.ky * e);
                }
                return s = Un(t1[0] - n) * this.kx, a = (t1[1] - i) * this.ky, Math.sqrt(s * s + a * a);
            }
            pointOnLine(t1, e) {
                let r = 1 / 0, n = t1[0][0], i = t1[0][1], s = 0, a = 0;
                for(let o = 0; o < t1.length - 1; o++){
                    let l = t1[o][0], u = t1[o][1], c = Un(t1[o + 1][0] - l) * this.kx, h = (t1[o + 1][1] - u) * this.ky, p = 0;
                    0 === c && 0 === h || (p = (Un(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t1[o + 1][0], u = t1[o + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = Un(e[0] - l) * this.kx, h = (e[1] - u) * this.ky;
                    const d = c * c + h * h;
                    d < r && (r = d, n = l, i = u, s = o, a = p);
                }
                return {
                    point: [
                        n,
                        i
                    ],
                    index: s,
                    t: Math.max(0, Math.min(1, a))
                };
            }
            lineSlice(t1, e, r) {
                let n = this.pointOnLine(r, t1), i = this.pointOnLine(r, e);
                if (n.index > i.index || n.index === i.index && n.t > i.t) {
                    const t1 = n;
                    n = i, i = t1;
                }
                const s = [
                    n.point
                ], a = n.index + 1, o = i.index;
                !Ln(r[a], s[0]) && a <= o && s.push(r[a]);
                for(let t1 = a + 1; t1 <= o; t1++)s.push(r[t1]);
                return Ln(r[o], i.point) || s.push(i.point), s;
            }
            lineSliceAlong(t1, e, r) {
                let n = 0;
                const i = [];
                for(let s = 0; s < r.length - 1; s++){
                    const a = r[s], o = r[s + 1], l = this.distance(a, o);
                    if (n += l, n > t1 && 0 === i.length && i.push(On(a, o, (t1 - (n - l)) / l)), n >= e) return i.push(On(a, o, (e - (n - l)) / l)), i;
                    n > t1 && i.push(o);
                }
                return i;
            }
            bufferPoint(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[0] + n,
                    t1[1] + r
                ];
            }
            bufferBBox(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[2] + n,
                    t1[3] + r
                ];
            }
            insideBBox(t1, e) {
                return Un(t1[0] - e[0]) >= 0 && Un(t1[0] - e[2]) <= 0 && t1[1] >= e[1] && t1[1] <= e[3];
            }
        }
        function Ln(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1];
        }
        function On(t1, e, r) {
            const n = Un(e[0] - t1[0]);
            return [
                t1[0] + n * r,
                t1[1] + (e[1] - t1[1]) * r
            ];
        }
        function Un(t1) {
            for(; t1 < -180;)t1 += 360;
            for(; t1 > 180;)t1 -= 360;
            return t1;
        }
        class Nn {
            constructor(t1 = [], e = (t1, e)=>t1 < e ? -1 : t1 > e ? 1 : 0){
                if (this.data = t1, this.length = this.data.length, this.compare = e, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this._up(this.length++);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e = this.data.pop();
                return --this.length > 0 && (this.data[0] = e, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e, compare: r } = this, n = e[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, s = e[i];
                    if (r(n, s) >= 0) break;
                    e[t1] = s, t1 = i;
                }
                e[t1] = n;
            }
            _down(t1) {
                const { data: e, compare: r } = this, n = this.length >> 1, i = e[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1);
                    const s = n + 1;
                    if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break;
                    e[t1] = e[n], t1 = n;
                }
                e[t1] = i;
            }
        }
        var jn = 8192;
        function Gn(t1, e) {
            return e.dist - t1.dist;
        }
        function $n(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (e.length !== t1.length) return !1;
            for(let r = 0; r < e.length; r++)if (e[r] !== t1[r]) return !1;
            return !0;
        }
        function qn(t1) {
            return t1[1] - t1[0] + 1;
        }
        function Xn(t1, e) {
            const r = t1[1] >= t1[0] && t1[1] < e;
            return r || console.warn("Distance Expression: Index is out of range"), r;
        }
        function Hn(t1, e) {
            if (t1[0] > t1[1]) return [
                null,
                null
            ];
            const r = qn(t1);
            if (e) {
                if (2 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2);
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e,
                        t1[1]
                    ]
                ];
            }
            {
                if (1 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2) - 1;
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e + 1,
                        t1[1]
                    ]
                ];
            }
        }
        function Zn(t1, e) {
            const r = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (!Xn(e, t1.length)) return r;
            for(let n = e[0]; n <= e[1]; ++n)dn(r, t1[n]);
            return r;
        }
        function Wn(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let r = 0; r < t1.length; ++r)for(let n = 0; n < t1[r].length; ++n)dn(e, t1[r][n]);
            return e;
        }
        function Yn(t1, e, r) {
            if ($n(t1) || $n(e)) return NaN;
            let n = 0, i = 0;
            return t1[2] < e[0] && (n = e[0] - t1[2]), t1[0] > e[2] && (n = t1[0] - e[2]), t1[1] > e[3] && (i = t1[1] - e[3]), t1[3] < e[1] && (i = e[1] - t1[3]), r.distance([
                0,
                0
            ], [
                n,
                i
            ]);
        }
        function Jn(t1) {
            return 360 * t1 - 180;
        }
        function Kn(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function Qn(t1, e) {
            const r = Math.pow(2, e.z), n = (t1.y / jn + e.y) / r;
            return [
                Jn((t1.x / jn + e.x) / r),
                Kn(n)
            ];
        }
        function ti(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; ++n)r.push(Qn(t1[n], e));
            return r;
        }
        function ei(t1, e, r) {
            const n = r.pointOnLine(e, t1).point;
            return r.distance(t1, n);
        }
        function ri(t1, e, r, n, i) {
            const s = r.slice(n[0], n[1] + 1);
            let a = 1 / 0;
            for(let r = e[0]; r <= e[1]; ++r)if (0 === (a = Math.min(a, ei(t1[r], s, i)))) return 0;
            return a;
        }
        function ni(t1, e, r, n, i) {
            const s = Math.min(i.pointToSegmentDistance(t1, r, n), i.pointToSegmentDistance(e, r, n)), a = Math.min(i.pointToSegmentDistance(r, t1, e), i.pointToSegmentDistance(n, t1, e));
            return Math.min(s, a);
        }
        function ii(t1, e, r, n, i) {
            if (!Xn(e, t1.length) || !Xn(n, r.length)) return NaN;
            let s = 1 / 0;
            for(let a = e[0]; a < e[1]; ++a)for(let e = n[0]; e < n[1]; ++e){
                if (vn(t1[a], t1[a + 1], r[e], r[e + 1])) return 0;
                s = Math.min(s, ni(t1[a], t1[a + 1], r[e], r[e + 1], i));
            }
            return s;
        }
        function si(t1, e, r, n, i) {
            if (!Xn(e, t1.length) || !Xn(n, r.length)) return NaN;
            let s = 1 / 0;
            for(let a = e[0]; a <= e[1]; ++a)for(let e = n[0]; e <= n[1]; ++e)if (0 === (s = Math.min(s, i.distance(t1[a], r[e])))) return s;
            return s;
        }
        function ai(t1, e, r) {
            if (gn(t1, e, !0)) return 0;
            let n = 1 / 0;
            for (const i of e){
                const e = i.length;
                if (e < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
                if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t1, i[e - 1], i[0])))) return n;
                if (0 === (n = Math.min(n, ei(t1, i, r)))) return n;
            }
            return n;
        }
        function oi(t1, e, r, n) {
            if (!Xn(e, t1.length)) return NaN;
            for(let n = e[0]; n <= e[1]; ++n)if (gn(t1[n], r, !0)) return 0;
            let i = 1 / 0;
            for(let s = e[0]; s < e[1]; ++s)for (const e of r)for(let r = 0, a = e.length, o = a - 1; r < a; o = r++){
                if (vn(t1[s], t1[s + 1], e[o], e[r])) return 0;
                i = Math.min(i, ni(t1[s], t1[s + 1], e[o], e[r], n));
            }
            return i;
        }
        function li(t1, e) {
            for (const r of t1)for(let t1 = 0; t1 <= r.length - 1; ++t1)if (gn(r[t1], e, !0)) return !0;
            return !1;
        }
        function ui(t1, e, r, n = 1 / 0) {
            const i = Wn(t1), s = Wn(e);
            if (n !== 1 / 0 && Yn(i, s, r) >= n) return n;
            if (fn(i, s)) {
                if (li(t1, e)) return 0;
            } else if (li(e, t1)) return 0;
            let a = n;
            for (const n of t1)for(let t1 = 0, i = n.length, s = i - 1; t1 < i; s = t1++)for (const i of e)for(let e = 0, o = i.length, l = o - 1; e < o; l = e++){
                if (vn(n[s], n[t1], i[l], i[e])) return 0;
                a = Math.min(a, ni(n[s], n[t1], i[l], i[e], r));
            }
            return a;
        }
        function ci(t1, e, r, n, i, s, a) {
            if (null === s || null === a) return;
            const o = Yn(Zn(n, s), Zn(i, a), r);
            o < e && t1.push({
                dist: o,
                range1: s,
                range2: a
            });
        }
        function hi(t1, e, r, n, i = 1 / 0) {
            let s = Math.min(n.distance(t1[0], r[0][0]), i);
            if (0 === s) return s;
            const a = new Nn([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        0
                    ]
                }
            ], Gn), o = e ? 50 : 100, l = Wn(r);
            for(; a.length;){
                const i = a.pop();
                if (i.dist >= s) continue;
                const u = i.range1;
                if (qn(u) <= o) {
                    if (!Xn(u, t1.length)) return NaN;
                    if (e) {
                        const e = oi(t1, u, r, n);
                        if (0 === (s = Math.min(s, e))) return s;
                    } else for(let e = u[0]; e <= u[1]; ++e){
                        const i = ai(t1[e], r, n);
                        if (0 === (s = Math.min(s, i))) return s;
                    }
                } else {
                    const r = Hn(u, e);
                    if (null !== r[0]) {
                        const e = Yn(Zn(t1, r[0]), l, n);
                        e < s && a.push({
                            dist: e,
                            range1: r[0],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                    if (null !== r[1]) {
                        const e = Yn(Zn(t1, r[1]), l, n);
                        e < s && a.push({
                            dist: e,
                            range1: r[1],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                }
            }
            return s;
        }
        function pi(t1, e, r, n, i, s = 1 / 0) {
            let a = Math.min(s, i.distance(t1[0], r[0]));
            if (0 === a) return a;
            const o = new Nn([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        r.length - 1
                    ]
                }
            ], Gn), l = e ? 50 : 100, u = n ? 50 : 100;
            for(; o.length;){
                const s = o.pop();
                if (s.dist >= a) continue;
                const c = s.range1, h = s.range2;
                if (qn(c) <= l && qn(h) <= u) {
                    if (!Xn(c, t1.length) || !Xn(h, r.length)) return NaN;
                    if (e && n ? a = Math.min(a, ii(t1, c, r, h, i)) : e || n ? e && !n ? a = Math.min(a, ri(r, h, t1, c, i)) : !e && n && (a = Math.min(a, ri(t1, c, r, h, i))) : a = Math.min(a, si(t1, c, r, h, i)), 0 === a) return a;
                } else {
                    const s = Hn(c, e), l = Hn(h, n);
                    ci(o, a, i, t1, r, s[0], l[0]), ci(o, a, i, t1, r, s[0], l[1]), ci(o, a, i, t1, r, s[1], l[0]), ci(o, a, i, t1, r, s[1], l[1]);
                }
            }
            return a;
        }
        function di(t1, e, r, n, i = 1 / 0) {
            let s = i;
            const a = Zn(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r)if (!(s !== 1 / 0 && Yn(a, Zn(i, [
                0,
                i.length - 1
            ]), n) >= s) && (s = Math.min(s, pi(t1, e, i, !0, n, s)), 0 === s)) return s;
            return s;
        }
        function fi(t1, e, r, n, i = 1 / 0) {
            let s = i;
            const a = Zn(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r){
                if (s !== 1 / 0 && Yn(a, Wn(i), n) >= s) continue;
                const r = hi(t1, e, i, n, s);
                if (isNaN(r)) return r;
                if (0 === (s = Math.min(s, r))) return s;
            }
            return s;
        }
        function mi(t1) {
            return "Point" === t1 || "MultiPoint" === t1 || "LineString" === t1 || "MultiLineString" === t1 || "Polygon" === t1 || "MultiPolygon" === t1;
        }
        class yi {
            constructor(t1, e){
                this.type = vr, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'distance' expression requires either one argument, but found ' ${t1.length - 1} instead.`);
                if (Nr(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) {
                        for(let t1 = 0; t1 < e.features.length; ++t1)if (mi(e.features[t1].geometry.type)) return new yi(e, e.features[t1].geometry);
                    } else if ("Feature" === e.type) {
                        if (mi(e.geometry.type)) return new yi(e, e.geometry);
                    } else if (mi(e.type)) return new yi(e, e);
                }
                return e.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
            }
            evaluate(t1) {
                const e = t1.geometry(), r = t1.canonicalID();
                if (null != e && null != r) {
                    if ("Point" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1)for (const t1 of r)n.push(Qn(t1, e));
                        const i = new Rn(n[0][1], "meters");
                        return "Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type ? pi(n, !1, "Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, i) : "MultiLineString" === r.type ? di(n, !1, r.coordinates, i) : "Polygon" === r.type || "MultiPolygon" === r.type ? fi(n, !1, "Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, i) : null;
                    }(e, r, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1){
                            const t1 = [];
                            for (const n of r)t1.push(Qn(n, e));
                            n.push(t1);
                        }
                        const i = new Rn(n[0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return di("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const s = di(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        if ("Polygon" === r.type || "MultiPolygon" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < n.length; e++){
                                const s = fi(n[e], !0, "Polygon" === r.type ? [
                                    r.coordinates
                                ] : r.coordinates, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        return null;
                    }(e, r, this.geometries);
                    if ("Polygon" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of function(t1) {
                            const e = t1.length;
                            if (e <= 1) return [
                                t1
                            ];
                            const r = [];
                            let n, i;
                            for(let s = 0; s < e; s++){
                                const e = pn(t1[s]);
                                0 !== e && (t1[s].area = Math.abs(e), void 0 === i && (i = e < 0), i === e < 0 ? (n && r.push(n), n = [
                                    t1[s]
                                ]) : n.push(t1[s]));
                            }
                            return n && r.push(n), r;
                        }(t1)){
                            const t1 = [];
                            for(let n = 0; n < r.length; ++n)t1.push(ti(r[n], e));
                            n.push(t1);
                        }
                        const i = new Rn(n[0][0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return fi("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const s = fi(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        return "Polygon" === r.type || "MultiPolygon" === r.type ? function(t1, e, r) {
                            let n = 1 / 0;
                            for (const i of t1)for (const t1 of e){
                                const e = ui(i, t1, r, n);
                                if (isNaN(e)) return e;
                                if (0 === (n = Math.min(n, e))) return n;
                            }
                            return n;
                        }("Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, n, i) : null;
                    }(e, r, this.geometries);
                    console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
                } else console.warn("Distance Expression: requirs valid feature and canonical information.");
                return null;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "distance",
                    this.geojson
                ];
            }
        }
        function gi(t1) {
            if (t1 instanceof an) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof Vn) return !1;
            if (t1 instanceof yi) return !1;
            if (t1 instanceof Ai) return t1.featureConstant;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !gi(t1) && (e = !1);
            }), e;
        }
        function xi(t1) {
            if (t1 instanceof an && "feature-state" === t1.name) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !xi(t1) && (e = !1);
            }), e;
        }
        function vi(t1, e) {
            if (t1 instanceof an && e.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !vi(t1, e) && (r = !1);
            }), r;
        }
        function bi(t1, e, r) {
            return [
                t1,
                e,
                r
            ].filter(Boolean).join("");
        }
        function wi(t1, e) {
            switch(t1){
                case "string":
                    return Gr(e);
                case "number":
                    return +e;
                case "boolean":
                    return !!e;
                case "color":
                    return ur.parse(e);
                case "formatted":
                    return Rr.fromString(Gr(e));
                case "resolvedImage":
                    return Or.build(Gr(e));
            }
            return e;
        }
        function _i(t1, e, r, n) {
            return void 0 !== n && (t1 = n * Math.round(t1 / n)), void 0 !== e && t1 < e && (t1 = e), void 0 !== r && t1 > r && (t1 = r), t1;
        }
        class Ai {
            constructor(t1, e, r, n = !1){
                this.type = t1, this.key = e, this.scope = r, this.featureConstant = n;
            }
            static parse(t1, e) {
                let r = e.expectedType;
                if (null == r && (r = Ir), t1.length < 2 || t1.length > 3) return e.error("Invalid number of arguments for 'config' expression.");
                const n = e.parse(t1[1], 1);
                if (!(n instanceof $r)) return e.error("Key name of 'config' expression must be a string literal.");
                let i, s = !0;
                const a = Gr(n.value);
                if (t1.length >= 3) {
                    const r = e.parse(t1[2], 2);
                    if (!(r instanceof $r)) return e.error("Scope of 'config' expression must be a string literal.");
                    i = Gr(r.value);
                }
                if (e.options) {
                    const t1 = bi(a, i, e._scope), r = e.options.get(t1);
                    r && (s = gi(r.value || r.default));
                }
                return new Ai(r, a, i, s);
            }
            evaluate(t1) {
                const e = bi(this.key, this.scope, t1.scope), r = t1.getConfig(e);
                if (!r) return null;
                const { type: n, value: i, values: s, minValue: a, maxValue: o, stepValue: l } = r, u = r.default.evaluate(t1);
                let c = u;
                if (i) {
                    const e = t1.scope;
                    t1.scope = (e || "").split("").slice(1).join(""), c = i.evaluate(t1), t1.scope = e;
                }
                return n && (c = wi(n, c)), void 0 === c || void 0 === a && void 0 === o && void 0 === l || ("number" == typeof c ? c = _i(c, a, o, l) : Array.isArray(c) && (c = c.map((t1)=>"number" == typeof t1 ? _i(t1, a, o, l) : t1))), void 0 !== i && void 0 !== c && s && !s.includes(c) && (c = u, n && (c = wi(n, c))), (n && n !== this.type || void 0 !== c && !Fr(jr(c), this.type)) && (c = wi(this.type.kind, c)), c;
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "config",
                    this.key
                ];
                return this.scope && t1.concat(this.scope), t1;
            }
        }
        class Ii {
            constructor(t1, e){
                this.type = e.type, this.name = t1, this.boundExpression = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e.scope.has(r) ? new Ii(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        class Mi {
            constructor(t1, e = [], r, n = new gr, i = [], s, a, o){
                this.registry = t1, this.path = e, this.key = e.map((t1)=>"string" == typeof t1 ? `['${t1}']` : `[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r, this._scope = s, this.options = a, this.iconImageUseTheme = o;
            }
            parse(t1, e, r, n, i = {}) {
                return e || r ? this.concat(e, null, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            parseObjectValue(t1, e, r, n, i, s = {}) {
                return this.concat(e, r, n, i)._parse(t1, s);
            }
            _parse(t1, e) {
                function r(t1, e, r) {
                    return "assert" === r ? new Hr(e, [
                        t1
                    ]) : "coerce" === r ? new rn(e, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = "string" == typeof t1[0] ? this.registry[t1[0]] : void 0;
                    if (n) {
                        let i = n.parse(t1, this);
                        if (!i) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, n = i.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== n.kind) if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== n.kind && "string" !== n.kind) {
                                if (this.checkSubtype(t1, n)) return null;
                            } else i = r(i, t1, e.typeAnnotation || "coerce");
                            else i = r(i, t1, e.typeAnnotation || "assert");
                        }
                        if (!(i instanceof $r) && "resolvedImage" !== i.type.kind && Si(i)) {
                            const t1 = new sn(this._scope, this.options, this.iconImageUseTheme);
                            try {
                                i = new $r(i.type, i.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return i;
                    }
                    return rn.parse([
                        "to-array",
                        t1
                    ], this);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e, r, n) {
                let i = "number" == typeof t1 ? this.path.concat(t1) : this.path;
                i = "string" == typeof e ? i.concat(e) : i;
                const s = n ? this.scope.concat(n) : this.scope;
                return new Mi(this.registry, i, r || null, s, this.errors, this._scope, this.options, this.iconImageUseTheme);
            }
            error(t1, ...e) {
                const r = `${this.key}${e.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new yr(r, t1));
            }
            checkSubtype(t1, e) {
                const r = Tr(t1, e);
                return r && this.error(r), r;
            }
        }
        function Si(t1) {
            if (t1 instanceof Ii) return Si(t1.boundExpression);
            if (t1 instanceof an && "error" === t1.name) return !1;
            if (t1 instanceof ln) return !1;
            if (t1 instanceof Vn) return !1;
            if (t1 instanceof yi) return !1;
            if (t1 instanceof Ai) return !1;
            const e = t1 instanceof rn || t1 instanceof Hr;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e ? r && Si(t1) : r && t1 instanceof $r;
            }), !!r && gi(t1) && vi(t1, [
                "zoom",
                "heatmap-density",
                "worldview",
                "line-progress",
                "raster-value",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center",
                "measure-light",
                "raster-particle-speed"
            ]);
        }
        function Pi(t1, e) {
            const r = t1.length - 1;
            let n, i, s = 0, a = r, o = 0;
            for(; s <= a;)if (o = Math.floor((s + a) / 2), n = t1[o], i = t1[o + 1], n <= e) {
                if (o === r || e < i) return o;
                s = o + 1;
            } else {
                if (!(n > e)) throw new qr("Input is not a number.");
                a = o - 1;
            }
            return 0;
        }
        class zi {
            constructor(t1, e, r){
                this.type = t1, this.input = e, this.labels = [], this.outputs = [];
                for (const [t1, e] of r)this.labels.push(t1), this.outputs.push(e);
            }
            static parse(t1, e) {
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                const r = e.parse(t1[1], 1, vr);
                if (!r) return null;
                const n = [];
                let i = null;
                e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const s = 1 === r ? -1 / 0 : t1[r], a = t1[r + 1], o = r, l = r + 1;
                    if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e.parse(a, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        s,
                        u
                    ]);
                }
                return new zi(i, r, n);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                return n >= e[i - 1] ? r[i - 1].evaluate(t1) : r[Pi(e, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e = 0; e < this.labels.length; e++)e > 0 && t1.push(this.labels[e]), t1.push(this.outputs[e].serialize());
                return t1;
            }
        }
        const Bi = .95047, ki = 1.08883, Ti = 4 / 29, Vi = 6 / 29, Ei = 3 * Vi * Vi, Fi = Vi * Vi * Vi, Di = Math.PI / 180, Ci = 180 / Math.PI;
        function Ri(t1) {
            return t1 > Fi ? Math.pow(t1, 1 / 3) : t1 / Ei + Ti;
        }
        function Li(t1) {
            return t1 > Vi ? t1 * t1 * t1 : Ei * (t1 - Ti);
        }
        function Oi(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function Ui(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function Ni(t1) {
            const e = Ui(t1.r), r = Ui(t1.g), n = Ui(t1.b), i = Ri((.4124564 * e + .3575761 * r + .1804375 * n) / Bi), s = Ri((.2126729 * e + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * s - 16,
                a: 500 * (i - s),
                b: 200 * (s - Ri((.0193339 * e + .119192 * r + .9503041 * n) / ki)),
                alpha: t1.a
            };
        }
        function ji(t1) {
            let e = (t1.l + 16) / 116, r = isNaN(t1.a) ? e : e + t1.a / 500, n = isNaN(t1.b) ? e : e - t1.b / 200;
            return e = 1 * Li(e), r = Bi * Li(r), n = ki * Li(n), new ur(Oi(3.2404542 * r - 1.5371385 * e - .4985314 * n), Oi(-.969266 * r + 1.8760108 * e + .041556 * n), Oi(.0556434 * r - .2040259 * e + 1.0572252 * n), t1.alpha);
        }
        function Gi(t1, e, r) {
            const n = e - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const $i = {
            forward: Ni,
            reverse: ji,
            interpolate: function(t1, e, r) {
                return {
                    l: dr(t1.l, e.l, r),
                    a: dr(t1.a, e.a, r),
                    b: dr(t1.b, e.b, r),
                    alpha: dr(t1.alpha, e.alpha, r)
                };
            }
        }, qi = {
            forward: function(t1) {
                const { l: e, a: r, b: n } = Ni(t1), i = Math.atan2(n, r) * Ci;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e = t1.h * Di, r = t1.c;
                return ji({
                    l: t1.l,
                    a: Math.cos(e) * r,
                    b: Math.sin(e) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e, r) {
                return {
                    h: Gi(t1.h, e.h, r),
                    c: dr(t1.c, e.c, r),
                    l: dr(t1.l, e.l, r),
                    alpha: dr(t1.alpha, e.alpha, r)
                };
            }
        };
        var Xi = Object.freeze({
            __proto__: null,
            hcl: qi,
            lab: $i
        });
        class Hi {
            constructor(t1, e, r, n, i){
                this.type = t1, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
                for (const [t1, e] of i)this.labels.push(t1), this.outputs.push(e);
            }
            static interpolationFactor(t1, e, r, n) {
                let i = 0;
                if ("exponential" === t1.name) i = Zi(e, t1.base, r, n);
                else if ("linear" === t1.name) i = Zi(e, 1, r, n);
                else if ("cubic-bezier" === t1.name) {
                    const s = t1.controlPoints;
                    i = new It(s[0], s[1], s[2], s[3]).solve(Zi(e, 1, r, n));
                }
                return i;
            }
            static parse(t1, e) {
                let [r, n, i, ...s] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length - 1 > 3 && (t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                if (i = e.parse(i, 2, vr), !i) return null;
                const a = [];
                let o = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? o = _r : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType);
                for(let t1 = 0; t1 < s.length; t1 += 2){
                    const r = s[t1], n = s[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e.parse(n, l, o);
                    if (!u) return null;
                    o = o || u.type, a.push([
                        r,
                        u
                    ]);
                }
                return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Hi(o, r, n, i, a) : e.error(`Type ${Br(o)} is not interpolatable.`);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                if (n >= e[i - 1]) return r[i - 1].evaluate(t1);
                const s = Pi(e, n), a = Hi.interpolationFactor(this.interpolation, n, e[s], e[s + 1]), o = r[s].evaluate(t1), l = r[s + 1].evaluate(t1);
                return "interpolate" === this.operator ? mr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? qi.reverse(qi.interpolate(qi.forward(o), qi.forward(l), a)) : $i.reverse($i.interpolate($i.forward(o), $i.forward(l), a));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                let t1;
                t1 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier",
                    ...this.interpolation.controlPoints
                ];
                const e = [
                    this.operator,
                    t1,
                    this.input.serialize()
                ];
                for(let t1 = 0; t1 < this.labels.length; t1++)e.push(this.labels[t1], this.outputs[t1].serialize());
                return e;
            }
        }
        function Zi(t1, e, r, n) {
            const i = n - r, s = t1 - r;
            return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
        }
        class Wi {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expectected at least one argument.");
                let r = null;
                const n = e.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                const s = n && i.some((t1)=>Tr(n, t1.type));
                return new Wi(s ? Ir : r, i);
            }
            evaluate(t1) {
                let e, r = null, n = 0;
                for (const i of this.args){
                    if (n++, r = i.evaluate(t1), r && r instanceof Or && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
                    if (null !== r) break;
                }
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "coalesce"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class Yi {
            constructor(t1, e){
                this.type = e.type, this.bindings = [].concat(t1), this.result = e;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e of this.bindings)t1(e[1]);
                t1(this.result);
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const s = e.parse(t1[n + 1], n + 1);
                    if (!s) return null;
                    r.push([
                        i,
                        s
                    ]);
                }
                const n = e.parse(t1[t1.length - 1], t1.length - 1, e.expectedType, r);
                return n ? new Yi(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t1 = [
                    "let"
                ];
                for (const [e, r] of this.bindings)t1.push(e, r.serialize());
                return t1.push(this.result.serialize()), t1;
            }
        }
        class Ji {
            constructor(t1, e, r){
                this.type = t1, this.index = e, this.input = r;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, vr), n = e.parse(t1[2], 2, zr(e.expectedType || Ir));
                return r && n ? new Ji(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e < 0) throw new qr("Array index out of bounds: negative index");
                if (e >= r.length) throw new qr("Array index out of bounds: index exceeds array size");
                if (e !== Math.floor(e)) throw new qr("Array index must be an integer. Use at-interpolated for fractional indices");
                return r[e];
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        class Ki {
            constructor(t1, e, r){
                this.type = t1, this.index = e, this.input = r;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, vr), n = e.parse(t1[2], 2, zr(e.expectedType || Ir));
                return r && n ? new Ki(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e < 0) throw new qr(`Array index out of bounds: ${e} < 0.`);
                if (e > r.length - 1) throw new qr(`Array index out of bounds: ${e} > ${r.length - 1}.`);
                if (e === Math.floor(e)) return r[e];
                const n = Math.floor(e), i = Math.ceil(e), s = r[n], a = r[i];
                if ("number" != typeof s || "number" != typeof a) throw new qr(`Cannot interpolate between non-number values at index ${e}.`);
                const o = e - n;
                return s * (1 - o) + a * o;
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at-interpolated",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        class Qi {
            constructor(t1, e){
                this.type = wr, this.needle = t1, this.haystack = e;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Ir), n = e.parse(t1[2], 2, Ir);
                return r && n ? Vr(r.type, [
                    wr,
                    br,
                    vr,
                    xr,
                    Ir
                ]) ? new Qi(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Br(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (null == r) return !1;
                if (!Er(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new qr(`Expected first argument to be of type boolean, string, number or null, but found ${Br(jr(e))} instead.`);
                if (!Er(r, [
                    "string",
                    "array"
                ])) throw new qr(`Expected second argument to be of type array or string, but found ${Br(jr(r))} instead.`);
                return r.indexOf(e) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class ts {
            constructor(t1, e, r){
                this.type = vr, this.needle = t1, this.haystack = e, this.fromIndex = r;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Ir), n = e.parse(t1[2], 2, Ir);
                if (!r || !n) return null;
                if (!Vr(r.type, [
                    wr,
                    br,
                    vr,
                    xr,
                    Ir
                ])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Br(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, vr);
                    return i ? new ts(r, n, i) : null;
                }
                return new ts(r, n);
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!Er(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new qr(`Expected first argument to be of type boolean, string, number or null, but found ${Br(jr(e))} instead.`);
                if (!Er(r, [
                    "string",
                    "array"
                ])) throw new qr(`Expected second argument to be of type array or string, but found ${Br(jr(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e, n);
                }
                return r.indexOf(e);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t1 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t1
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class es {
            constructor(t1, e, r, n, i, s){
                this.inputType = t1, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
            }
            static parse(t1, e) {
                if (t1.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e.error("Expected an even number of arguments.");
                let r, n;
                e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                const i = {}, s = [];
                for(let a = 2; a < t1.length - 1; a += 2){
                    let o = t1[a];
                    const l = t1[a + 1];
                    Array.isArray(o) || (o = [
                        o
                    ]);
                    const u = e.concat(a);
                    if (0 === o.length) return u.error("Expected at least one branch label.");
                    for (const t1 of o){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, jr(t1))) return null;
                        } else r = jr(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = s.length;
                    }
                    const c = e.parse(l, a, n);
                    if (!c) return null;
                    n = n || c.type, s.push(c);
                }
                const a = e.parse(t1[1], 1, Ir);
                if (!a) return null;
                const o = e.parse(t1[t1.length - 1], t1.length - 1, n);
                return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new es(r, n, a, i, s, o) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                return (Fr(jr(e), this.inputType) && this.outputs[this.cases[e]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "match",
                    this.input.serialize()
                ], e = Object.keys(this.cases).sort(), r = [], n = {};
                for (const t1 of e){
                    const e = n[this.cases[t1]];
                    void 0 === e ? (n[this.cases[t1]] = r.length, r.push([
                        this.cases[t1],
                        [
                            t1
                        ]
                    ])) : r[e][1].push(t1);
                }
                const i = (t1)=>"number" === this.inputType.kind ? Number(t1) : t1;
                for (const [e, n] of r)t1.push(1 === n.length ? i(n[0]) : n.map(i)), t1.push(this.outputs[e].serialize());
                return t1.push(this.otherwise.serialize()), t1;
            }
        }
        class rs {
            constructor(t1, e, r){
                this.type = t1, this.branches = e, this.otherwise = r;
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e.error("Expected an odd number of arguments.");
                let r;
                e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const s = e.parse(t1[i], i, wr);
                    if (!s) return null;
                    const a = e.parse(t1[i + 1], i + 1, r);
                    if (!a) return null;
                    n.push([
                        s,
                        a
                    ]), r = r || a.type;
                }
                const i = e.parse(t1[t1.length - 1], t1.length - 1, r);
                return i ? new rs(r, n, i) : null;
            }
            evaluate(t1) {
                for (const [e, r] of this.branches)if (e.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e, r] of this.branches)t1(e), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e])=>e.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "case"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class ns {
            constructor(t1, e, r, n){
                this.type = t1, this.input = e, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Ir), n = e.parse(t1[2], 2, vr);
                if (!r || !n) return null;
                if (!Vr(r.type, [
                    zr(Ir),
                    br,
                    Ir
                ])) return e.error(`Expected first argument to be of type array or string, but found ${Br(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, vr);
                    return i ? new ns(r.type, r, n, i) : null;
                }
                return new ns(r.type, r, n);
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!Er(e, [
                    "string",
                    "array"
                ])) throw new qr(`Expected first argument to be of type array or string, but found ${Br(jr(e))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e.slice(r, n);
                }
                return e.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t1 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t1
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        class is {
            constructor(t1, e){
                this.type = zr(br), this.str = t1, this.delimiter = e;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, br), n = e.parse(t1[2], 2, br);
                return r && n ? new is(r, n) : void 0;
            }
            evaluate(t1) {
                const e = this.str.evaluate(t1), r = this.delimiter.evaluate(t1);
                return e.split(r);
            }
            eachChild(t1) {
                t1(this.str), t1(this.delimiter);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "split",
                    this.str.serialize(),
                    this.delimiter.serialize()
                ];
            }
        }
        function ss(t1, e) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
        }
        function as(t1, e, r, n) {
            return 0 === n.compare(e, r);
        }
        function os(t1, e, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e, r){
                    this.type = wr, this.lhs = t1, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e.type.kind;
                }
                static parse(t1, e) {
                    if (3 !== t1.length && 4 !== t1.length) return e.error("Expected two or three arguments.");
                    const r = t1[0];
                    let s = e.parse(t1[1], 1, Ir);
                    if (!s) return null;
                    if (!ss(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${Br(s.type)}'.`);
                    let a = e.parse(t1[2], 2, Ir);
                    if (!a) return null;
                    if (!ss(r, a.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${Br(a.type)}'.`);
                    if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error(`Cannot compare types '${Br(s.type)}' and '${Br(a.type)}'.`);
                    n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new Hr(a.type, [
                        s
                    ]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new Hr(s.type, [
                        a
                    ])));
                    let o = null;
                    if (4 === t1.length) {
                        if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types.");
                        if (o = e.parse(t1[3], 3, Mr), !o) return null;
                    }
                    return new i(s, a, o);
                }
                evaluate(i) {
                    const s = this.lhs.evaluate(i), a = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e = jr(s), r = jr(a);
                        if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new qr(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = jr(s), r = jr(a);
                        if ("string" !== t1.kind || "string" !== r.kind) return e(i, s, a);
                    }
                    return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e = [
                        t1
                    ];
                    return this.eachChild((t1)=>{
                        e.push(t1.serialize());
                    }), e;
                }
            };
        }
        const ls = os("==", function(t1, e, r) {
            return e === r;
        }, as), us = os("!=", function(t1, e, r) {
            return e !== r;
        }, function(t1, e, r, n) {
            return !as(0, e, r, n);
        }), cs = os("<", function(t1, e, r) {
            return e < r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) < 0;
        }), hs = os(">", function(t1, e, r) {
            return e > r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) > 0;
        }), ps = os("<=", function(t1, e, r) {
            return e <= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) <= 0;
        }), ds = os(">=", function(t1, e, r) {
            return e >= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) >= 0;
        });
        class fs {
            constructor(t1, e, r, n, i, s){
                this.type = br, this.number = t1, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error("Expected two arguments.");
                const r = e.parse(t1[1], 1, vr);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e.parseObjectValue(n.locale, 2, "locale", br), !i)) return null;
                let s = null;
                if (n.currency && (s = e.parseObjectValue(n.currency, 2, "currency", br), !s)) return null;
                let a = null;
                if (n.unit && (a = e.parseObjectValue(n.unit, 2, "unit", br), !a)) return null;
                let o = null;
                if (n["min-fraction-digits"] && (o = e.parseObjectValue(n["min-fraction-digits"], 2, "min-fraction-digits", vr), !o)) return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e.parseObjectValue(n["max-fraction-digits"], 2, "max-fraction-digits", vr), !l) ? null : new fs(r, i, s, a, o, l);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    unit: this.unit ? this.unit.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.unit && t1(this.unit), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return this.locale && (t1.locale = this.locale.serialize()), this.currency && (t1.currency = this.currency.serialize()), this.unit && (t1.unit = this.unit.serialize()), this.minFractionDigits && (t1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t1
                ];
            }
        }
        class ms {
            constructor(t1){
                this.type = vr, this.input = t1;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${Br(r.type)} instead.`) : new ms(r) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                if ("string" == typeof e) return e.length;
                if (Array.isArray(e)) return e.length;
                throw new qr(`Expected value to be of type string or array, but found ${Br(jr(e))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "length"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        function ys(t1) {
            return function() {
                t1 = 1831565813 + (t1 |= 0) | 0;
                let e = Math.imul(t1 ^ t1 >>> 15, 1 | t1);
                return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
            };
        }
        const gs = {
            "==": ls,
            "!=": us,
            ">": hs,
            "<": cs,
            ">=": ds,
            "<=": ps,
            array: Hr,
            at: Ji,
            "at-interpolated": Ki,
            boolean: Hr,
            case: rs,
            coalesce: Wi,
            collator: ln,
            format: Zr,
            image: Wr,
            in: Qi,
            "index-of": ts,
            interpolate: Hi,
            "interpolate-hcl": Hi,
            "interpolate-lab": Hi,
            length: ms,
            let: Yi,
            literal: $r,
            match: es,
            number: Hr,
            "number-format": fs,
            object: Hr,
            slice: ns,
            step: zi,
            string: Hr,
            "to-boolean": rn,
            "to-color": rn,
            "to-number": rn,
            "to-string": rn,
            var: Ii,
            within: Vn,
            distance: yi,
            config: Ai,
            split: is
        };
        function xs(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, a = Ur(e, r, n, s);
            if (a) throw new qr(a);
            return new ur(e / 255, r / 255, n / 255, s);
        }
        function vs(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, a = function(t1, e, r, n) {
                return "number" == typeof t1 && t1 >= 0 && t1 <= 360 ? "number" == typeof e && e >= 0 && e <= 100 && "number" == typeof r && r >= 0 && r <= 100 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid hsla value [${[
                    t1,
                    e,
                    r,
                    n
                ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 'h' must be between 0 and 360.`;
            }(e, r, n, s);
            if (a) throw new qr(a);
            const o = `hsla(${e}, ${r}%, ${n}%, ${s})`, l = ur.parse(o);
            if (!l) throw new qr(`Failed to parse HSLA color: ${o}`);
            return l;
        }
        function bs(t1, e) {
            return t1 in e;
        }
        function ws(t1, e) {
            const r = e[t1];
            return void 0 === r ? null : r;
        }
        function _s(t1) {
            return {
                type: t1
            };
        }
        function As(t1) {
            if (t1 instanceof Ai) return new Set([
                t1.key
            ]);
            let e = new Set;
            return t1.eachChild((t1)=>{
                e = new Set([
                    ...e,
                    ...As(t1)
                ]);
            }), e;
        }
        function Is(t1) {
            if (t1 instanceof an && "is-active-floor" === t1.name) return !0;
            let e = !1;
            return t1.eachChild((t1)=>{
                !e && Is(t1) && (e = !0);
            }), e;
        }
        function Ms(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function Ss(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function Ps(t1, e) {
            return !!t1 && !!t1.parameters && t1.parameters.indexOf(e) > -1;
        }
        function zs(t1) {
            return "data-driven" === t1["property-type"];
        }
        function Bs(t1) {
            return Ps(t1.expression, "measure-light");
        }
        function ks(t1) {
            return Ps(t1.expression, "zoom");
        }
        function Ts(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function Vs(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function Es(t1) {
            return t1;
        }
        function Fs(t1, e) {
            const r = "color" === e.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), s = t1.type || (Ts(e) ? "exponential" : "interval");
            if (r && ((t1 = Object.assign({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                    t1[0],
                    ur.parse(t1[1])
                ])), t1.default = ur.parse(t1.default ? t1.default : e.default)), t1.colorSpace && "rgb" !== t1.colorSpace && !Xi[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let a, o, l;
            if ("exponential" === s) a = Ls;
            else if ("interval" === s) a = Rs;
            else if ("categorical" === s) {
                a = Cs, o = Object.create(null);
                for (const e of t1.stops)o[e[0]] = e[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
                a = Os;
            }
            if (n) {
                const r = {}, n = [];
                for(let e = 0; e < t1.stops.length; e++){
                    const i = t1.stops[e], s = i[0].zoom;
                    void 0 === r[s] && (r[s] = {
                        zoom: s,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(s)), r[s].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    Fs(r[t1], e)
                ]);
                const s = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s,
                    interpolationFactor: Hi.interpolationFactor.bind(void 0, s),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r }, n)=>Ls({
                            stops: i,
                            base: t1.base
                        }, e, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === s ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: Hi.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r })=>a(t1, e, r, o, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? Ds(t1.default, e.default) : a(t1, e, i, o, l);
                }
            };
        }
        function Ds(t1, e, r) {
            return void 0 !== t1 ? t1 : void 0 !== e ? e : void 0 !== r ? r : void 0;
        }
        function Cs(t1, e, r, n, i) {
            return Ds(typeof r === i ? n[r] : void 0, t1.default, e.default);
        }
        function Rs(t1, e, r) {
            if (!Qr(r)) return Ds(t1.default, e.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = Pi(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function Ls(t1, e, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if (!Qr(r)) return Ds(t1.default, e.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const s = Pi(t1.stops.map((t1)=>t1[0]), r), a = function(t1, e, r, n) {
                const i = n - r, s = t1 - r;
                return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
            }(r, n, t1.stops[s][0], t1.stops[s + 1][0]), o = t1.stops[s][1], l = t1.stops[s + 1][1];
            let u = mr[e.type] || Es;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e = Xi[t1.colorSpace];
                u = (t1, r)=>e.reverse(e.interpolate(e.forward(t1), e.forward(r), a));
            }
            return "function" == typeof o.evaluate ? {
                evaluate (...t1) {
                    const e = o.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e && void 0 !== r) return u(e, r, a);
                }
            } : u(o, l, a);
        }
        function Os(t1, e, r) {
            return "color" === e.type ? r = ur.parse(r) : "formatted" === e.type ? r = Rr.fromString(r.toString()) : "resolvedImage" === e.type ? r = Or.build(r.toString()) : Yr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Ds(r, t1.default, e.default);
        }
        an.register(gs, {
            error: [
                {
                    kind: "error"
                },
                [
                    br
                ],
                (t1, [e])=>{
                    throw new qr(e.evaluate(t1));
                }
            ],
            typeof: [
                br,
                [
                    Ir
                ],
                (t1, [e])=>Br(jr(e.evaluate(t1)))
            ],
            "to-rgba": [
                zr(vr, 4),
                [
                    _r
                ],
                (t1, [e])=>e.evaluate(t1).toNonPremultipliedRenderColor(null).toArray()
            ],
            "to-hsla": [
                zr(vr, 4),
                [
                    _r
                ],
                (t1, [e])=>e.evaluate(t1).toNonPremultipliedRenderColor(null).toHslaArray()
            ],
            rgb: [
                _r,
                [
                    vr,
                    vr,
                    vr
                ],
                xs
            ],
            rgba: [
                _r,
                [
                    vr,
                    vr,
                    vr,
                    vr
                ],
                xs
            ],
            hsl: [
                _r,
                [
                    vr,
                    vr,
                    vr
                ],
                vs
            ],
            hsla: [
                _r,
                [
                    vr,
                    vr,
                    vr,
                    vr
                ],
                vs
            ],
            has: {
                type: wr,
                overloads: [
                    [
                        [
                            br
                        ],
                        (t1, [e])=>bs(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            br,
                            Ar
                        ],
                        (t1, [e, r])=>bs(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: Ir,
                overloads: [
                    [
                        [
                            br
                        ],
                        (t1, [e])=>ws(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            br,
                            Ar
                        ],
                        (t1, [e, r])=>ws(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                Ir,
                [
                    br
                ],
                (t1, [e])=>ws(e.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                Ar,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                br,
                [],
                (t1)=>t1.geometryType()
            ],
            worldview: [
                br,
                [],
                (t1)=>t1.globals.worldview || ""
            ],
            "is-active-floor": [
                wr,
                _s(br),
                (t1, e)=>{
                    if (!(t1.globals.activeFloors && t1.globals.activeFloors.size > 0)) return !1;
                    const r = t1.globals.activeFloors;
                    return e.some((e)=>{
                        const n = e.evaluate(t1);
                        return r.has(n);
                    });
                }
            ],
            id: [
                Ir,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                vr,
                [],
                (t1)=>t1.globals.zoom
            ],
            pitch: [
                vr,
                [],
                (t1)=>t1.globals.pitch || 0
            ],
            "distance-from-center": [
                vr,
                [],
                (t1)=>t1.distanceFromCenter()
            ],
            "measure-light": [
                vr,
                [
                    br
                ],
                (t1, [e])=>t1.measureLight(e.evaluate(t1))
            ],
            "heatmap-density": [
                vr,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                vr,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            "raster-value": [
                vr,
                [],
                (t1)=>t1.globals.rasterValue || 0
            ],
            "raster-particle-speed": [
                vr,
                [],
                (t1)=>t1.globals.rasterParticleSpeed || 0
            ],
            "sky-radial-progress": [
                vr,
                [],
                (t1)=>t1.globals.skyRadialProgress || 0
            ],
            accumulated: [
                Ir,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                vr,
                _s(vr),
                (t1, e)=>{
                    let r = 0;
                    for (const n of e)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                vr,
                _s(vr),
                (t1, e)=>{
                    let r = 1;
                    for (const n of e)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: vr,
                overloads: [
                    [
                        [
                            vr,
                            vr
                        ],
                        (t1, [e, r])=>e.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            vr
                        ],
                        (t1, [e])=>-e.evaluate(t1)
                    ]
                ]
            },
            "/": [
                vr,
                [
                    vr,
                    vr
                ],
                (t1, [e, r])=>e.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                vr,
                [
                    vr,
                    vr
                ],
                (t1, [e, r])=>e.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                vr,
                [],
                ()=>Math.LN2
            ],
            pi: [
                vr,
                [],
                ()=>Math.PI
            ],
            e: [
                vr,
                [],
                ()=>Math.E
            ],
            "^": [
                vr,
                [
                    vr,
                    vr
                ],
                (t1, [e, r])=>Math.pow(e.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.sqrt(e.evaluate(t1))
            ],
            log10: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN10
            ],
            ln: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.log(e.evaluate(t1))
            ],
            log2: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.log2(e.evaluate(t1))
            ],
            sin: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.sin(e.evaluate(t1))
            ],
            cos: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.cos(e.evaluate(t1))
            ],
            tan: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.tan(e.evaluate(t1))
            ],
            asin: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.asin(e.evaluate(t1))
            ],
            acos: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.acos(e.evaluate(t1))
            ],
            atan: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.atan(e.evaluate(t1))
            ],
            min: [
                vr,
                _s(vr),
                (t1, e)=>Math.min(...e.map((e)=>e.evaluate(t1)))
            ],
            max: [
                vr,
                _s(vr),
                (t1, e)=>Math.max(...e.map((e)=>e.evaluate(t1)))
            ],
            abs: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.abs(e.evaluate(t1))
            ],
            round: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>{
                    const r = e.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.floor(e.evaluate(t1))
            ],
            ceil: [
                vr,
                [
                    vr
                ],
                (t1, [e])=>Math.ceil(e.evaluate(t1))
            ],
            "filter-==": [
                wr,
                [
                    br,
                    Ir
                ],
                (t1, [e, r])=>t1.properties()[e.value] === r.value
            ],
            "filter-id-==": [
                wr,
                [
                    Ir
                ],
                (t1, [e])=>t1.id() === e.value
            ],
            "filter-type-==": [
                wr,
                [
                    br
                ],
                (t1, [e])=>t1.geometryType() === e.value
            ],
            "filter-<": [
                wr,
                [
                    br,
                    Ir
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                wr,
                [
                    Ir
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                wr,
                [
                    br,
                    Ir
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                wr,
                [
                    Ir
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                wr,
                [
                    br,
                    Ir
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                wr,
                [
                    Ir
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                wr,
                [
                    br,
                    Ir
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                wr,
                [
                    Ir
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                wr,
                [
                    Ir
                ],
                (t1, [e])=>e.value in t1.properties()
            ],
            "filter-has-id": [
                wr,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                wr,
                [
                    zr(br)
                ],
                (t1, [e])=>e.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                wr,
                [
                    zr(Ir)
                ],
                (t1, [e])=>e.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                wr,
                [
                    br,
                    zr(Ir)
                ],
                (t1, [e, r])=>r.value.indexOf(t1.properties()[e.value]) >= 0
            ],
            "filter-in-large": [
                wr,
                [
                    br,
                    zr(Ir)
                ],
                (t1, [e, r])=>(function(t1, e, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e[i] === t1) return !0;
                            e[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: wr,
                overloads: [
                    [
                        [
                            wr,
                            wr
                        ],
                        (t1, [e, r])=>e.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        _s(wr),
                        (t1, e)=>{
                            for (const r of e)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: wr,
                overloads: [
                    [
                        [
                            wr,
                            wr
                        ],
                        (t1, [e, r])=>e.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        _s(wr),
                        (t1, e)=>{
                            for (const r of e)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                wr,
                [
                    wr
                ],
                (t1, [e])=>!e.evaluate(t1)
            ],
            "is-supported-script": [
                wr,
                [
                    br
                ],
                (t1, [e])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e.evaluate(t1));
                }
            ],
            upcase: [
                br,
                [
                    br
                ],
                (t1, [e])=>e.evaluate(t1).toUpperCase()
            ],
            downcase: [
                br,
                [
                    br
                ],
                (t1, [e])=>e.evaluate(t1).toLowerCase()
            ],
            concat: [
                br,
                _s(Ir),
                (t1, e)=>e.map((e)=>Gr(e.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                br,
                [
                    Mr
                ],
                (t1, [e])=>e.evaluate(t1).resolvedLocale()
            ],
            random: [
                vr,
                [
                    vr,
                    vr,
                    Ir
                ],
                (t1, e)=>{
                    const [r, n, i] = e.map((e)=>e.evaluate(t1));
                    if (r > n) return r;
                    if (r === n) return r;
                    let s;
                    if ("string" == typeof i) s = function(t1) {
                        let e = 0;
                        if (0 === t1.length) return e;
                        for(let r = 0; r < t1.length; r++)e = (e << 5) - e + t1.charCodeAt(r), e &= e;
                        return e;
                    }(i);
                    else {
                        if ("number" != typeof i) throw new qr(`Invalid seed input: ${i}`);
                        s = i;
                    }
                    return r + ys(s)() * (n - r);
                }
            ]
        });
        class Us {
            constructor(t1, e, r, n, i){
                this.expression = t1, this._warningHistory = {}, this._scope = r, this._options = n, this._iconImageUseTheme = i, this._evaluator = new sn(r, n, i), this._defaultValue = e ? function(t1) {
                    return "color" === t1.type && (Vs(t1.default) || Array.isArray(t1.default)) ? new ur(0, 0, 0, 0) : "color" === t1.type ? ur.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null, this.configDependencies = As(t1), this.isIndoorDependent = Is(t1);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s, a, o) {
                return this._evaluator.globals = t1, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e, r, n, i, s, a, o, l) {
                this._evaluator || (this._evaluator = new sn(this._scope, this._options, this._iconImageUseTheme)), this._evaluator.globals = t1, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this._evaluator.iconImageUseTheme = l || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new qr(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    const e = t1;
                    return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${e.message}`)), this._defaultValue;
                }
            }
        }
        function Ns(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in gs;
        }
        function js(t1, e, r, n, i) {
            const s = new Mi(gs, [], e ? function(t1) {
                const e = {
                    color: _r,
                    string: br,
                    number: vr,
                    enum: br,
                    boolean: wr,
                    formatted: Sr,
                    resolvedImage: Pr
                };
                return "array" === t1.type ? zr(e[t1.value] || Ir, t1.length) : e[t1.type];
            }(e) : void 0, void 0, void 0, r, n, i), a = s.parse(t1, void 0, void 0, void 0, e && "string" === e.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return a ? Ms(new Us(a, e, r, n, i)) : Ss(s.errors);
        }
        class Gs {
            constructor(t1, e, r, n){
                this.kind = t1, this._styleExpression = e, this.isLightConstant = r, this.isLineProgressConstant = n, this.isStateDependent = "constant" !== t1 && !xi(e.expression), this.configDependencies = As(e.expression), this.isIndoorDependent = Is(e.expression);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, s);
            }
            evaluate(t1, e, r, n, i, s, a) {
                return this._styleExpression.evaluate(t1, e, r, n, i, s, void 0, void 0, a);
            }
        }
        class $s {
            constructor(t1, e, r, n, i, s){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t1 && !xi(e.expression), this.isIndoorDependent = Is(e.expression), this.isLightConstant = i, this.isLineProgressConstant = s, this.configDependencies = As(e.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, s);
            }
            evaluate(t1, e, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e, r, n, i, s);
            }
            interpolationFactor(t1, e, r) {
                return this.interpolationType ? Hi.interpolationFactor(this.interpolationType, t1, e, r) : 0;
            }
        }
        function qs(t1, e, r, n, i) {
            if ("error" === (t1 = js(t1, e, r, n, i)).result) return t1;
            const s = t1.value.expression, a = gi(s);
            if (!a && !zs(e)) return Ss([
                new yr("", "data expressions not supported")
            ]);
            const o = vi(s, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!o && !ks(e)) return Ss([
                new yr("", "zoom expressions not supported")
            ]);
            const l = vi(s, [
                "measure-light"
            ]);
            if (!l && !Bs(e)) return Ss([
                new yr("", "measure-light expression not supported")
            ]);
            const u = vi(s, [
                "line-progress"
            ]);
            if (!u && !function(t1) {
                return Ps(t1.expression, "line-progress");
            }(e)) return Ss([
                new yr("", "line-progress expression not supported")
            ]);
            const c = e.expression && e.expression.relaxZoomRestriction, h = Hs(s);
            return h || o || c ? h instanceof yr ? Ss([
                h
            ]) : h instanceof Hi && !Ts(e) ? Ss([
                new yr("", '"interpolate" expressions cannot be used with this property')
            ]) : Ms(h ? new $s(a && u ? "camera" : "composite", t1.value, h.labels, h instanceof Hi ? h.interpolation : void 0, l, u) : new Gs(a && u ? "constant" : "source", t1.value, l, u)) : Ss([
                new yr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')
            ]);
        }
        class Xs {
            constructor(t1, e){
                this._parameters = t1, this._specification = e, Object.assign(this, Fs(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new Xs(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function Hs(t1) {
            let e = null;
            if (t1 instanceof Yi) e = Hs(t1.result);
            else if (t1 instanceof Wi) {
                for (const r of t1.args)if (e = Hs(r), e) break;
            } else (t1 instanceof zi || t1 instanceof Hi) && t1.input instanceof an && "zoom" === t1.input.name && (e = t1);
            return e instanceof yr || t1.eachChild((t1)=>{
                const r = Hs(t1);
                r instanceof yr ? e = r : e && r && e !== r && (e = new yr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e;
        }
        var Zs, Ws, Ys = function() {
            if (Ws) return Zs;
            Ws = 1, Zs = e;
            var t1 = 3;
            function e(e, r, n) {
                var i = this.cells = [];
                if (e instanceof ArrayBuffer) {
                    this.arrayBuffer = e;
                    var s = new Int32Array(this.arrayBuffer);
                    e = s[0], this.d = (r = s[1]) + 2 * (n = s[2]);
                    for(var a = 0; a < this.d * this.d; a++){
                        var o = s[t1 + a], l = s[t1 + a + 1];
                        i.push(o === l ? null : s.subarray(o, l));
                    }
                    var u = s[t1 + i.length + 1];
                    this.keys = s.subarray(s[t1 + i.length], u), this.bboxes = s.subarray(u), this.insert = this._insertReadonly;
                } else {
                    this.d = r + 2 * n;
                    for(var c = 0; c < this.d * this.d; c++)i.push([]);
                    this.keys = [], this.bboxes = [];
                }
                this.n = r, this.extent = e, this.padding = n, this.scale = r / e, this.uid = 0;
                var h = n / r * e;
                this.min = -h, this.max = e + h;
            }
            return e.prototype.insert = function(t1, e, r, n, i) {
                this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t1), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
            }, e.prototype._insertReadonly = function() {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
            }, e.prototype._insertCell = function(t1, e, r, n, i, s) {
                this.cells[i].push(s);
            }, e.prototype.query = function(t1, e, r, n, i) {
                var s = this.min, a = this.max;
                if (t1 <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);
                var o = [];
                return this._forEachCell(t1, e, r, n, this._queryCell, o, {}, i), o;
            }, e.prototype._queryCell = function(t1, e, r, n, i, s, a, o) {
                var l = this.cells[i];
                if (null !== l) for(var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++){
                    var p = l[h];
                    if (void 0 === a[p]) {
                        var d = 4 * p;
                        (o ? o(c[d + 0], c[d + 1], c[d + 2], c[d + 3]) : t1 <= c[d + 2] && e <= c[d + 3] && r >= c[d + 0] && n >= c[d + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
                    }
                }
            }, e.prototype._forEachCell = function(t1, e, r, n, i, s, a, o) {
                for(var l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)for(var d = u; d <= h; d++){
                    var f = this.d * d + p;
                    if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(d), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(d + 1))) && i.call(this, t1, e, r, n, f, s, a, o)) return;
                }
            }, e.prototype._convertFromCellCoord = function(t1) {
                return (t1 - this.padding) / this.scale;
            }, e.prototype._convertToCellCoord = function(t1) {
                return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
            }, e.prototype.toArrayBuffer = function() {
                if (this.arrayBuffer) return this.arrayBuffer;
                for(var e = this.cells, r = t1 + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++)n += this.cells[i].length;
                var s = new Int32Array(r + n + this.keys.length + this.bboxes.length);
                s[0] = this.extent, s[1] = this.n, s[2] = this.padding;
                for(var a = r, o = 0; o < e.length; o++){
                    var l = e[o];
                    s[t1 + o] = a, s.set(l, a), a += l.length;
                }
                return s[t1 + e.length] = a, s.set(this.keys, a), s[t1 + e.length + 1] = a += this.keys.length, s.set(this.bboxes, a), a += this.bboxes.length, s.buffer;
            }, Zs;
        }(), Js = _t(Ys);
        const Ks = {};
        function Qs(t1, e, r = {}) {
            Object.defineProperty(t1, "_classRegistryKey", {
                value: e,
                writable: !1
            }), Ks[e] = {
                klass: t1,
                omit: r.omit || []
            };
        }
        Qs(Object, "Object"), Js.serialize = function(t1, e) {
            const r = t1.toArrayBuffer();
            return e && e.add(r), {
                buffer: r
            };
        }, Js.deserialize = function(t1) {
            return new Js(t1.buffer);
        }, Object.defineProperty(Js, "name", {
            value: "Grid"
        }), Qs(Js, "Grid"), delete Mt.prototype.constructor, Qs(ur, "Color"), Qs(Error, "Error"), Qs(Rr, "Formatted"), Qs(Cr, "FormattedSection"), Qs(Re, "AJAXError"), Qs(Or, "ResolvedImage"), Qs(Xs, "StylePropertyFunction"), Qs(Us, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), Qs(sr, "ImageId"), Qs(Lr, "ImageVariant"), Qs($s, "ZoomDependentExpression"), Qs(Gs, "ZoomConstantExpression"), Qs(an, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in gs)Ks[gs[t1]._classRegistryKey] || Qs(gs[t1], `Expression${t1}`);
        function ta(t1) {
            return t1 && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function ea(t1, e) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp) return t1;
            if (ta(t1) || t1 instanceof ImageBitmap) return e && e.add(t1), t1;
            if (ArrayBuffer.isView(t1)) return e && e.add(t1.buffer), t1;
            if (t1 instanceof ImageData) return e && e.add(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const r = [];
                for (const n of t1)r.push(ea(n, e));
                return r;
            }
            if (t1 instanceof Map) {
                const r = {
                    $name: "Map",
                    entries: []
                };
                for (const [n, i] of t1.entries())r.entries.push(ea(n), ea(i, e));
                return r;
            }
            if (t1 instanceof Set) {
                const e = {
                    $name: "Set"
                };
                let r = 0;
                for (const n of t1.values())e[++r] = ea(n);
                return e;
            }
            if ("bigint" == typeof t1) return {
                $name: "BigInt",
                value: t1.toString()
            };
            if ("object" == typeof t1) {
                const r = t1.constructor, n = r._classRegistryKey;
                if (!n) throw new Error(`Can't serialize object of unregistered class "${r.name}".`);
                const i = r.serialize ? r.serialize(t1, e) : {};
                if (!r.serialize) {
                    for(const r in t1)t1.hasOwnProperty(r) && (Ks[n].omit.indexOf(r) >= 0 || (i[r] = ea(t1[r], e)));
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function ra(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || ta(t1) || t1 instanceof ImageBitmap || ArrayBuffer.isView(t1) || t1 instanceof ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(ra);
            if ("object" == typeof t1) {
                const e = t1.$name || "Object";
                if ("Map" === e) {
                    const e = t1.entries || [], r = new Map;
                    for(let t1 = 0; t1 < e.length; t1 += 2)r.set(ra(e[t1]), ra(e[t1 + 1]));
                    return r;
                }
                if ("Set" === e) {
                    const e = new Set;
                    for (const r of Object.keys(t1))"$name" !== r && e.add(ra(t1[r]));
                    return e;
                }
                if ("BigInt" === e) return BigInt(t1.value);
                const { klass: r } = Ks[e];
                if (!r) throw new Error(`Can't deserialize unregistered class "${e}".`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const e of Object.keys(t1))"$name" !== e && (n[e] = ra(t1[e]));
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        const na = (t1)=>t1 >= 1536 && t1 <= 1791, ia = (t1)=>t1 >= 1872 && t1 <= 1919, sa = (t1)=>t1 >= 2208 && t1 <= 2303, aa = (t1)=>t1 >= 11904 && t1 <= 12031, oa = (t1)=>t1 >= 12032 && t1 <= 12255, la = (t1)=>t1 >= 12272 && t1 <= 12287, ua = (t1)=>t1 >= 12288 && t1 <= 12351, ca = (t1)=>t1 >= 12352 && t1 <= 12447, ha = (t1)=>t1 >= 12448 && t1 <= 12543, pa = (t1)=>t1 >= 12544 && t1 <= 12591, da = (t1)=>t1 >= 12704 && t1 <= 12735, fa = (t1)=>t1 >= 12736 && t1 <= 12783, ma = (t1)=>t1 >= 12784 && t1 <= 12799, ya = (t1)=>t1 >= 12800 && t1 <= 13055, ga = (t1)=>t1 >= 13056 && t1 <= 13311, xa = (t1)=>t1 >= 13312 && t1 <= 19903, va = (t1)=>t1 >= 19968 && t1 <= 40959, ba = (t1)=>t1 >= 40960 && t1 <= 42127, wa = (t1)=>t1 >= 42128 && t1 <= 42191, _a = (t1)=>t1 >= 44032 && t1 <= 55215, Aa = (t1)=>t1 >= 63744 && t1 <= 64255, Ia = (t1)=>t1 >= 64336 && t1 <= 65023, Ma = (t1)=>t1 >= 65040 && t1 <= 65055, Sa = (t1)=>t1 >= 65072 && t1 <= 65103, Pa = (t1)=>t1 >= 65104 && t1 <= 65135, za = (t1)=>t1 >= 65136 && t1 <= 65279, Ba = (t1)=>t1 >= 65280 && t1 <= 65519;
        function ka(t1) {
            for (const e of t1)if (Fa(e.charCodeAt(0))) return !0;
            return !1;
        }
        function Ta(t1) {
            for (const e of t1)if (!Va(e.charCodeAt(0))) return !1;
            return !0;
        }
        function Va(t1) {
            return !(na(t1) || ia(t1) || sa(t1) || Ia(t1) || za(t1));
        }
        function Ea(t1) {
            return !(t1 < 11904 || !(da(t1) || pa(t1) || Sa(t1) || Aa(t1) || ga(t1) || aa(t1) || fa(t1) || ua(t1) || xa(t1) || va(t1) || ya(t1) || Ba(t1) || ca(t1) || la(t1) || oa(t1) || ma(t1) || ha(t1) || Ma(t1) || wa(t1) || ba(t1)));
        }
        function Fa(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(da(t1) || pa(t1) || Sa(t1) && !(t1 >= 65097 && t1 <= 65103) || Aa(t1) || ga(t1) || aa(t1) || fa(t1) || !(!ua(t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || xa(t1) || va(t1) || ya(t1) || ((t1)=>t1 >= 12592 && t1 <= 12687)(t1) || ((t1)=>t1 >= 43360 && t1 <= 43391)(t1) || ((t1)=>t1 >= 55216 && t1 <= 55295)(t1) || ((t1)=>t1 >= 4352 && t1 <= 4607)(t1) || _a(t1) || ca(t1) || la(t1) || ((t1)=>t1 >= 12688 && t1 <= 12703)(t1) || oa(t1) || ma(t1) || ha(t1) && 12540 !== t1 || !(!Ba(t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!Pa(t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || ((t1)=>t1 >= 5120 && t1 <= 5759)(t1) || ((t1)=>t1 >= 6320 && t1 <= 6399)(t1) || Ma(t1) || ((t1)=>t1 >= 19904 && t1 <= 19967)(t1) || ba(t1) || wa(t1))));
        }
        function Da(t1) {
            return 12312 === t1 || 12313 === t1 || 12316 === t1 || 12540 === t1 || 12448 === t1;
        }
        function Ca(t1) {
            return !(Fa(t1) || function(t1) {
                return !!(((t1)=>t1 >= 128 && t1 <= 255)(t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || ((t1)=>t1 >= 8192 && t1 <= 8303)(t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || ((t1)=>t1 >= 8448 && t1 <= 8527)(t1) || ((t1)=>t1 >= 8528 && t1 <= 8591)(t1) || ((t1)=>t1 >= 8960 && t1 <= 9215)(t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || ((t1)=>t1 >= 9216 && t1 <= 9279)(t1) && 9251 !== t1 || ((t1)=>t1 >= 9280 && t1 <= 9311)(t1) || ((t1)=>t1 >= 9312 && t1 <= 9471)(t1) || ((t1)=>t1 >= 9632 && t1 <= 9727)(t1) || ((t1)=>t1 >= 9728 && t1 <= 9983)(t1) && !(t1 >= 9754 && t1 <= 9759) || ((t1)=>t1 >= 11008 && t1 <= 11263)(t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || ua(t1) || ha(t1) || ((t1)=>t1 >= 57344 && t1 <= 63743)(t1) || Sa(t1) || Pa(t1) || Ba(t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function Ra(t1) {
            return na(t1) || ia(t1) || sa(t1) || Ia(t1) || za(t1);
        }
        function La(t1) {
            return t1 >= 1424 && t1 <= 2303 || Ia(t1) || za(t1);
        }
        function Oa(t1, e) {
            return !(!e && La(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || ((t1)=>t1 >= 6016 && t1 <= 6143)(t1));
        }
        function Ua(t1) {
            for (const e of t1)if (La(e.charCodeAt(0))) return !0;
            return !1;
        }
        const Na = {
            unavailable: "unavailable",
            deferred: "deferred",
            loading: "loading",
            parsing: "parsing",
            parsed: "parsed",
            loaded: "loaded",
            error: "error"
        };
        let ja = null, Ga = Na.unavailable, $a = null;
        const qa = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (Ga = Na.error), ja && ja(t1);
        };
        function Xa() {
            Ha.fire(new tr("pluginStateChange", {
                pluginStatus: Ga,
                pluginURL: $a
            }));
        }
        const Ha = new ir, Za = function() {
            return Ga;
        }, Wa = function() {
            if (Ga !== Na.deferred || !$a) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Ga = Na.loading, Xa(), $a && Ue({
                url: $a
            }, (t1)=>{
                t1 ? qa(t1) : (Ga = Na.loaded, Xa());
            });
        }, Ya = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>Ga === Na.loaded || null != Ya.applyArabicShaping,
            isLoading: ()=>Ga === Na.loading,
            setState (t1) {
                Ga = t1.pluginStatus, $a = t1.pluginURL;
            },
            isParsing: ()=>Ga === Na.parsing,
            isParsed: ()=>Ga === Na.parsed,
            getPluginURL: ()=>$a
        };
        class Ja {
            constructor(t1, e){
                this.zoom = t1, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness, this.worldview = e.worldview, this.activeFloors = e.activeFloors) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
            }
            isSupportedScript(t1) {
                return function(t1, e) {
                    for (const r of t1)if (!Oa(r.charCodeAt(0), e)) return !1;
                    return !0;
                }(t1, Ya.isLoaded());
            }
        }
        class Ka {
            constructor(t1, e, r, n, i){
                this.property = t1, this.value = e, this.expression = function(t1, e, r, n, i) {
                    if (Vs(t1)) return new Xs(t1, e);
                    if (Ns(t1) || Array.isArray(t1) && t1.length > 0) {
                        const s = qs(t1, e, r, n, i);
                        if ("error" === s.result) throw new Error(s.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return s.value;
                    }
                    {
                        let r = t1;
                        return "string" == typeof t1 && "color" === e.type && (r = ur.parse(t1)), {
                            kind: "constant",
                            configDependencies: new Set,
                            isIndoorDependent: !1,
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e ? t1.specification.default : e, t1.specification, r, n, i);
            }
            isIndoorDependent() {
                return this.expression.isIndoorDependent;
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e, r, n) {
                return this.property.possiblyEvaluate(this, t1, e, r, n);
            }
        }
        class Qa {
            constructor(t1, e, r, n){
                this.property = t1, this.value = new Ka(t1, void 0, e, r, n);
            }
            transitioned(t1, e) {
                return new eo(this.property, this.value, e, Object.assign({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new eo(this.property, this.value, null, {}, 0);
            }
        }
        class to {
            constructor(t1, e, r, n){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this._iconImageUseTheme = n, this._isIndoorDependent = !1, this.configDependencies = new Set;
            }
            getValue(t1) {
                return qt(this._values[t1].value.value);
            }
            setValue(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Qa(this._values[t1].property, this._scope, this._options, this._iconImageUseTheme)), this._values[t1].value = new Ka(this._values[t1].property, null === e ? void 0 : qt(e), this._scope, this._options, this._iconImageUseTheme), this._values[t1].value.expression.configDependencies && (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...this._values[t1].value.expression.configDependencies
                ]), this._isIndoorDependent = this._isIndoorDependent || this._values[t1].value.isIndoorDependent());
            }
            setTransitionOrValue(t1, e) {
                e && (this._options = e);
                const r = this._properties.properties;
                if (t1) for(const e in t1){
                    const n = t1[e];
                    if (e.endsWith("-transition")) {
                        const t1 = e.slice(0, -11);
                        r[t1] && this.setTransition(t1, n);
                    } else r.hasOwnProperty(e) && this.setValue(e, n);
                }
            }
            getTransition(t1) {
                return qt(this._values[t1].transition);
            }
            setTransition(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Qa(this._values[t1].property)), this._values[t1].transition = qt(e) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                    const n = this.getTransition(e);
                    void 0 !== n && (t1[`${e}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e) {
                const r = new ro(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new ro(this._properties);
                for (const e of Object.keys(this._values))t1._values[e] = this._values[e].untransitioned();
                return t1;
            }
            isIndoorDependent() {
                return this._isIndoorDependent;
            }
        }
        class eo {
            constructor(t1, e, r, n, i){
                const s = n.delay || 0, a = n.duration || 0;
                i = i || 0, this.property = t1, this.value = e, this.begin = i + s, this.end = this.begin + a, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e, r), s = this.prior;
                if (s) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return s.possiblyEvaluate(t1, e, r);
                    {
                        const a = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s.possiblyEvaluate(t1, e, r), i, Vt(a));
                    }
                }
                return i;
            }
        }
        class ro {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e, r) {
                const n = new so(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class no {
            constructor(t1, e, r, n){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues), this._scope = e, this._options = r, this._iconImageUseTheme = n, this._isIndoorDependent = !1, this.configDependencies = new Set;
            }
            getValue(t1) {
                return qt(this._values[t1].value);
            }
            setValue(t1, e) {
                this._values[t1] = new Ka(this._values[t1].property, null === e ? void 0 : qt(e), this._scope, this._options, this._iconImageUseTheme), this._values[t1].expression.configDependencies && (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...this._values[t1].expression.configDependencies
                ]), this._isIndoorDependent = this._isIndoorDependent || this._values[t1].isIndoorDependent());
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e, r, n) {
                const i = new so(this._properties);
                for (const s of Object.keys(this._values))i._values[s] = this._values[s].possiblyEvaluate(t1, e, r, n);
                return i;
            }
            isIndoorDependent() {
                return this._isIndoorDependent;
            }
        }
        class io {
            constructor(t1, e, r, n){
                this.property = t1, this.value = e, this.parameters = r, this.iconImageUseTheme = n;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e, r, n, this.iconImageUseTheme);
            }
        }
        class so {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class ao {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return t1.expression.evaluate(e);
            }
            interpolate(t1, e, r) {
                const n = mr[this.specification.type];
                return n ? n(t1, e, r) : t1;
            }
        }
        class oo {
            constructor(t1, e){
                this.specification = t1, this.overrides = e;
            }
            possiblyEvaluate(t1, e, r, n, i) {
                return "constant" === t1.expression.kind || "camera" === t1.expression.kind ? new io(this, {
                    kind: "constant",
                    value: t1.expression.evaluate(e, null, {}, r, n, void 0, i)
                }, e) : new io(this, t1.expression, e, i);
            }
            interpolate(t1, e, r) {
                if ("constant" !== t1.value.kind || "constant" !== e.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e.value.value) return new io(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = mr[this.specification.type];
                return n ? new io(this, {
                    kind: "constant",
                    value: n(t1.value.value, e.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e, r, n, i, s, a) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e, r, n, i, s, void 0, a);
            }
        }
        class lo {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e, r, n) {
                return !!t1.expression.evaluate(e, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class uo {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                const e = new Ja(0, {});
                for(const r in t1){
                    const n = t1[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new Ka(n, void 0), s = this.defaultTransitionablePropertyValues[r] = new Qa(n);
                    this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
                }
            }
        }
        Qs(oo, "DataDrivenProperty"), Qs(ao, "DataConstantProperty"), Qs(lo, "ColorRampProperty");
        var co = JSON.parse('{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"shadow-draw-before-layer":{"type":"string"}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"modelNodeOverride":{"orientation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360}},"modelNodeOverrides":{"*":{"type":"modelNodeOverride"}},"modelMaterialOverride":{"model-color":{"type":"color"},"model-color-mix-intensity":{"type":"number"},"model-opacity":{"type":"number"},"model-emissive-strength":{"type":"number"}},"modelMaterialOverrides":{"*":{"type":"modelMaterialOverride"}},"modelSourceModel":{"uri":{"type":"string"},"position":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[-180,-90],"maximum":[180,90]},"orientation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360},"nodeOverrides":{"type":"modelNodeOverrides"},"materialOverrides":{"type":"modelMaterialOverrides"},"nodeOverrideNames":{"type":"array","value":"string"},"materialOverrideNames":{"type":"array","value":"string"},"featureProperties":{"type":"*"}},"modelSourceModels":{"*":{"type":"modelSourceModel"}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"url":{"type":"string"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"},"models":{"type":"modelSourceModels"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"appearances":{"type":"array","value":"appearance","supported-layer-types":["symbol"]}},"appearance":{"condition":{"type":"boolean","expression":{"interpolated":true,"parameters":["zoom","pitch","feature","feature-state","measure-light","distance-from-center"]},"property-type":"data-driven"},"name":{"type":"string"},"properties":{"type":"*"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"model-allow-density-reduction":{"type":"boolean","default":true}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-facade":{"type":"boolean","default":false,"expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-facade-floors":{"type":"number","minimum":1,"maximum":200,"default":3,"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-facade-unit-width":{"type":"number","minimum":1,"maximum":20,"default":3.1,"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-facade-window":{"type":"array","length":2,"value":"number","minimum":0.1,"maximum":1,"default":[0.9,0.9],"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"building-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"building-flip-roof-orientation":{"property-type":"data-driven","type":"boolean","default":false,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":[0.1,0.1],"maximum":[10,10],"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"appearance":true,"use-theme":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":[0.1,0.1],"maximum":[10,10],"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor_source":{"sourceId":{"type":"string"},"sourceLayers":{"type":"array","value":"string"}},"indoor":{"*":{"type":"indoor_source"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"parameters":[]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","use-theme":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-facade-emissive-chance":{"type":"number","default":0.35,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["measure-light","zoom"]}},"building-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"building-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"building-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"building-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-gradient":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"use-theme":true,"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"use-theme":true,"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white","use-theme":true},"sky-atmosphere-color":{"type":"color","default":"white","use-theme":true},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"use-theme":true,"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]},"model-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{}}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}');
        function ho(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function po(t1) {
            if (Array.isArray(t1)) return t1.map(po);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e = {};
                for(const r in t1)e[r] = po(t1[r]);
                return e;
            }
            return ho(t1);
        }
        function fo(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e of t1.slice(1))if (!fo(e) && "boolean" != typeof e) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function mo(t1, e = "", r = null, n = "fill") {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1,
                needFeature: !1
            };
            fo(t1) || (t1 = _o(t1));
            const i = t1;
            let s = !0;
            try {
                s = function(t1) {
                    if (!xo(t1)) return t1;
                    let e = po(t1);
                    return go(e), e = yo(e), e;
                }(i);
            } catch (t1) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(i, null, 2)}\n        `);
            }
            let a = null, o = null;
            if ("background" !== n && "sky" !== n && "slot" !== n) {
                o = co[`filter_${n}`];
                const t1 = js(s, o, e, r);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                a = (e, r, n)=>t1.value.evaluate(e, r, {}, n);
            }
            let l = null, u = null;
            if (s !== i) {
                const t1 = js(i, o, e, r);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                l = (e, r, n, i, s)=>t1.value.evaluate(e, r, {}, n, void 0, void 0, i, s), u = !gi(t1.value.expression);
            }
            return {
                filter: a,
                dynamicFilter: l || void 0,
                needGeometry: wo(s),
                needFeature: !!u
            };
        }
        function yo(t1) {
            if (!Array.isArray(t1)) return t1;
            const e = function(t1) {
                if (vo.has(t1[0])) {
                    for(let e = 1; e < t1.length; e++)if (xo(t1[e])) return !0;
                }
                return t1;
            }(t1);
            return !0 === e ? e : e.map((t1)=>yo(t1));
        }
        function go(t1) {
            let e = !1;
            const r = [];
            if ("case" === t1[0]) {
                for(let n = 1; n < t1.length - 1; n += 2)e = e || xo(t1[n]), r.push(t1[n + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("match" === t1[0]) {
                e = e || xo(t1[1]);
                for(let e = 2; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("step" === t1[0]) {
                e = e || xo(t1[1]);
                for(let e = 1; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
            }
            e && (t1.length = 0, t1.push("any", ...r));
            for(let e = 1; e < t1.length; e++)go(t1[e]);
        }
        function xo(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("pitch" === (e = t1[0]) || "distance-from-center" === e) return !0;
            var e;
            for(let e = 1; e < t1.length; e++)if (xo(t1[e])) return !0;
            return !1;
        }
        const vo = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function bo(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function wo(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0] || "distance" === t1[0]) return !0;
            for(let e = 1; e < t1.length; e++)if (wo(t1[e])) return !0;
            return !1;
        }
        function _o(t1) {
            if (!t1) return !0;
            const e = t1[0];
            return t1.length <= 1 ? "any" !== e : "==" === e ? Ao(t1[1], t1[2], "==") : "!=" === e ? So(Ao(t1[1], t1[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? Ao(t1[1], t1[2], e) : "any" === e ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(_o))) : "all" === e ? [
                "all"
            ].concat(t1.slice(1).map(_o)) : "none" === e ? [
                "all"
            ].concat(t1.slice(1).map(_o).map(So)) : "in" === e ? Io(t1[1], t1.slice(2)) : "!in" === e ? So(Io(t1[1], t1.slice(2))) : "has" === e ? Mo(t1[1]) : "!has" !== e || So(Mo(t1[1]));
            //TURBOPACK unreachable
            ;
            var r;
        }
        function Ao(t1, e, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e
                    ];
            }
        }
        function Io(t1, e) {
            if (0 === e.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                default:
                    return e.length > 200 && !e.some((t1)=>typeof t1 != typeof e[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e.sort(bo)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e
                        ]
                    ];
            }
        }
        function Mo(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function So(t1) {
            return [
                "!",
                t1
            ];
        }
        const Po = "";
        function zo(t1, e) {
            return e ? `${t1}${Po}${e}` : t1;
        }
        let Bo;
        const ko = ()=>Bo || (Bo = new uo({
                "icon-size": new oo(co.layout_symbol["icon-size"]),
                "icon-image": new oo(co.layout_symbol["icon-image"]),
                "icon-rotate": new oo(co.layout_symbol["icon-rotate"]),
                "icon-offset": new oo(co.layout_symbol["icon-offset"]),
                "text-size": new oo(co.layout_symbol["text-size"]),
                "text-rotate": new oo(co.layout_symbol["text-rotate"]),
                "text-offset": new oo(co.layout_symbol["text-offset"])
            }));
        class To {
            constructor(t1, e, r, n, i, s){
                const a = js(t1, co.appearance.condition);
                if ("success" === a.result && (this.condition = a.value), this.name = e, r) {
                    this.properties = new so(ko()), this.unevaluatedLayout = new no(ko(), n, i, s);
                    for(const t1 in r)this.unevaluatedLayout.setValue(t1, r[t1]);
                }
            }
            isActive(t1) {
                return !(this.condition || !t1.isHidden || "hidden" !== this.name) || this.condition.evaluate(t1.globals, t1.feature, t1.featureState, t1.canonical);
            }
            getCondition() {
                return this.condition;
            }
            getName() {
                return this.name;
            }
            getProperty(t1) {
                return this.properties.get(t1);
            }
            getUnevaluatedProperties() {
                return this.unevaluatedLayout;
            }
            getUnevaluatedProperty(t1) {
                return this.unevaluatedLayout._values[t1];
            }
            recalculate(t1, e, r) {
                this.unevaluatedLayout && (this.properties = this.unevaluatedLayout.possiblyEvaluate(t1, void 0, e, r));
            }
            serialize() {
                const t1 = {};
                return t1.condition = this.condition.expression.serialize(), this.name && (t1.name = this.name), this.unevaluatedLayout && (t1.properties = this.unevaluatedLayout.serialize()), t1;
            }
            hasIconProperties() {
                const t1 = this.hasProperty("icon-image"), e = this.hasProperty("icon-size"), r = this.hasProperty("icon-offset"), n = this.hasProperty("icon-rotate");
                return t1 || e || r || n;
            }
            hasTextProperties() {
                const t1 = this.hasProperty("text-size"), e = this.hasProperty("text-offset"), r = this.hasProperty("text-rotate");
                return t1 || e || r;
            }
            hasProperty(t1) {
                return void 0 !== this.getUnevaluatedProperty(t1).value;
            }
        }
        const Vo = "-transition", Eo = new Set([
            "fill",
            "line",
            "background",
            "hillshade",
            "raster"
        ]);
        class Fo extends ir {
            constructor(t1, e, r, n, i, s){
                if (super(), this.id = t1.id, this.fqid = zo(this.id, r), this.type = t1.type, this.scope = r, this.lut = n, this.options = i, this.iconImageUseTheme = s, this.appearances = new Array, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, this.expressionDependencies = {
                    isIndoorDependent: !1,
                    configDependencies: new Set
                }, "custom" !== t1.type) {
                    if (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, t1.type && "background" !== t1.type && "sky" !== t1.type && "slot" !== t1.type) {
                        this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter;
                        const e = js(this.filter, co[`filter_${t1.type}`]);
                        "error" !== e.result && (this.expressionDependencies.configDependencies = new Set([
                            ...this.expressionDependencies.configDependencies,
                            ...e.value.configDependencies
                        ]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || e.value.isIndoorDependent);
                    }
                    if (t1.slot && (this.slot = t1.slot), t1.appearances && this.setAppearances(t1.appearances), e.layout && (this._unevaluatedLayout = new no(e.layout, this.scope, i, this.iconImageUseTheme), this.expressionDependencies.configDependencies = new Set([
                        ...this.expressionDependencies.configDependencies,
                        ...this._unevaluatedLayout.configDependencies
                    ]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || this._unevaluatedLayout.isIndoorDependent()), e.paint) {
                        this._transitionablePaint = new to(e.paint, this.scope, i);
                        for(const e in t1.paint)this.setPaintProperty(e, t1.paint[e]);
                        for(const e in t1.layout)this.setLayoutProperty(e, t1.layout[e]);
                        this.expressionDependencies.configDependencies = new Set([
                            ...this.expressionDependencies.configDependencies,
                            ...this._transitionablePaint.configDependencies
                        ]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || this._transitionablePaint.isIndoorDependent(), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new so(e.paint);
                    }
                }
            }
            onAdd(t1) {}
            onRemove(t1) {}
            isDraped(t1) {
                return !this.is3D(!0) && Eo.has(this.type);
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e) {
                if ("custom" === this.type && "visibility" === t1) return void (this.visibility = e);
                const r = this._unevaluatedLayout;
                r._properties.properties[t1] && (r.setValue(t1, e), this.expressionDependencies.configDependencies = new Set([
                    ...this.expressionDependencies.configDependencies,
                    ...r.configDependencies
                ]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || r.isIndoorDependent(), "visibility" === t1 && this.possiblyEvaluateVisibility());
            }
            setAppearances(t1) {
                this.appearances = [], t1.forEach((t1)=>{
                    this.appearances.push(new To(t1.condition, t1.name, t1.properties, this.scope, this.options, this.iconImageUseTheme));
                });
            }
            possiblyEvaluateVisibility() {
                this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({
                    zoom: 0
                }));
            }
            getPaintProperty(t1) {
                return t1.endsWith(Vo) ? this._transitionablePaint.getTransition(t1.slice(0, -11)) : this._transitionablePaint.getValue(t1);
            }
            isPaintProperty(t1) {
                return !!this._transitionablePaint._properties.properties[t1];
            }
            setPaintProperty(t1, e) {
                const r = this._transitionablePaint, n = r._properties.properties;
                if (t1.endsWith(Vo)) {
                    const i = t1.slice(0, -11);
                    return n[i] && r.setTransition(i, e || void 0), !1;
                }
                if (!n[t1]) return !1;
                const i = r._values[t1], s = i.value.isDataDriven(), a = i.value;
                r.setValue(t1, e), this.expressionDependencies.configDependencies = new Set([
                    ...this.expressionDependencies.configDependencies,
                    ...r.configDependencies
                ]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || r.isIndoorDependent(), this._handleSpecialPaintPropertyUpdate(t1);
                const o = r._values[t1].value, l = o.isDataDriven(), u = t1.endsWith("pattern") || "line-dasharray" === t1;
                return l || s || u || this._handleOverridablePaintPropertyUpdate(t1, a, o);
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            getProgramIds() {
                return null;
            }
            getDefaultProgramParams(t1, e, r) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e, this.iconImageUseTheme)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e);
            }
            serialize() {
                const t1 = {
                    id: this.id,
                    type: this.type,
                    slot: this.slot,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return 0 !== this.appearances.length && (t1.appearances = this.appearances.map((t1)=>t1.serialize())), $t(t1, (t1, e)=>!(void 0 === t1 || "layout" === e && !Object.keys(t1).length || "paint" === e && !Object.keys(t1).length));
            }
            is3D(t1) {
                return !1;
            }
            hasElevation() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            hasShadowPass() {
                return !1;
            }
            canCastShadows() {
                return !1;
            }
            hasLightBeamPass() {
                return !1;
            }
            cutoffRange() {
                return 0;
            }
            tileCoverLift() {
                return 0;
            }
            resize() {}
            _clear() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e = this.paint.get(t1);
                    if (e instanceof io && zs(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
                }
                for (const t1 of this.appearances)if (!xi(t1.condition.expression)) return !0;
                return !1;
            }
            compileFilter(t1) {
                this._filterCompiled || (this._featureFilter = mo(this.filter, this.scope, t1), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
            getLayerRenderingStats() {
                return this._stats;
            }
            resetLayerRenderingStats(t1) {
                this._stats && ("shadow" === t1.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
            }
            getAppearances() {
                return this.appearances;
            }
            queryRenderedFeatures(t1, e, r) {
                return {};
            }
            queryRadius(t1) {}
            queryIntersectsFeature(t1, e, r, n, i, s, a, o, l, u) {}
        }
        const Do = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class Co {
            constructor(t1, e){
                this._structArray = t1, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        const Ro = new ArrayBuffer(0);
        class Lo {
            constructor(){
                this._reallocCount = 0, this.capacity = 0, this.length = 0;
            }
            static serialize(t1, e) {
                return t1._trim(), e && t1.arrayBuffer && e.add(t1.arrayBuffer), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e = Object.create(this.prototype);
                return e.arrayBuffer = t1.arrayBuffer, e.length = t1.length, t1.arrayBuffer ? e.capacity = t1.arrayBuffer.byteLength / e.bytesPerElement : (e.capacity = 0, e.arrayBuffer = Ro), e._refreshViews(), e;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this._reallocCount++, this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e = this.uint8;
                    this._refreshViews(), e && this.uint8.set(e);
                }
            }
            reserveForAdditional(t1) {
                this.reserve(this.length + t1);
            }
            _refreshViews() {
                throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
            }
            emplace(...t1) {
                throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
            }
            emplaceBack(...t1) {
                throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function Oo(t1, e = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = Do[t1.type].BYTES_PER_ELEMENT, s = r = Uo(r, Math.max(e, i)), a = t1.components || 1;
                    return n = Math.max(n, i), r += i * a, {
                        name: t1.name,
                        type: t1.type,
                        components: a,
                        offset: s
                    };
                }),
                size: Uo(r, Math.max(n, e)),
                alignment: e
            };
        }
        function Uo(t1, e) {
            return Math.ceil(t1 / e) * e;
        }
        class No extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e, this.int16[n + 1] = r, t1;
            }
        }
        No.prototype.bytesPerElement = 4, Qs(No, "StructArrayLayout2i4");
        class jo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        jo.prototype.bytesPerElement = 6, Qs(jo, "StructArrayLayout3i6");
        class Go extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t1;
            }
        }
        Go.prototype.bytesPerElement = 8, Qs(Go, "StructArrayLayout4i8");
        class $o extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.float32[1 * t1 + 0] = e, t1;
            }
        }
        $o.prototype.bytesPerElement = 4, Qs($o, "StructArrayLayout1f4");
        class qo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 4 * t1, s = 2 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.float32[s + 1] = n, t1;
            }
        }
        qo.prototype.bytesPerElement = 8, Qs(qo, "StructArrayLayout2i1f8");
        class Xo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 4 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        Xo.prototype.bytesPerElement = 8, Qs(Xo, "StructArrayLayout3i8");
        class Ho extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 5 * t1;
                return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = s, t1;
            }
        }
        Ho.prototype.bytesPerElement = 10, Qs(Ho, "StructArrayLayout5i10");
        class Zo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 6 * t1, u = 12 * t1, c = 3 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t1;
            }
        }
        Zo.prototype.bytesPerElement = 12, Qs(Zo, "StructArrayLayout2i4ub1f12");
        class Wo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        Wo.prototype.bytesPerElement = 12, Qs(Wo, "StructArrayLayout3f12");
        class Yo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 6 * t1, o = 3 * t1;
                return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t1;
            }
        }
        Yo.prototype.bytesPerElement = 12, Qs(Yo, "StructArrayLayout4ui1f12");
        class Jo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t1;
            }
        }
        Jo.prototype.bytesPerElement = 8, Qs(Jo, "StructArrayLayout4ui8");
        class Ko extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, a) {
                const o = 6 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t1;
            }
        }
        Ko.prototype.bytesPerElement = 12, Qs(Ko, "StructArrayLayout6i12");
        class Qo extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e, r, n, i, s, a, o, l, u, c, h);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
                const d = 12 * t1;
                return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.uint16[d + 4] = s, this.uint16[d + 5] = a, this.uint16[d + 6] = o, this.uint16[d + 7] = l, this.int16[d + 8] = u, this.int16[d + 9] = c, this.int16[d + 10] = h, this.int16[d + 11] = p, t1;
            }
        }
        Qo.prototype.bytesPerElement = 24, Qs(Qo, "StructArrayLayout4i4ui4i24");
        class tl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, a) {
                const o = 10 * t1, l = 5 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t1;
            }
        }
        tl.prototype.bytesPerElement = 20, Qs(tl, "StructArrayLayout3i3f20");
        class el extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t1;
            }
        }
        el.prototype.bytesPerElement = 16, Qs(el, "StructArrayLayout4f16");
        class rl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint32[1 * t1 + 0] = e, t1;
            }
        }
        rl.prototype.bytesPerElement = 4, Qs(rl, "StructArrayLayout1ul4");
        class nl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t1;
            }
        }
        nl.prototype.bytesPerElement = 4, Qs(nl, "StructArrayLayout2ui4");
        class il extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
                const d = this.length;
                return this.resize(d + 1), this.emplace(d, t1, e, r, n, i, s, a, o, l, u, c, h, p);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, d) {
                const f = 20 * t1, m = 10 * t1;
                return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.int16[f + 4] = s, this.float32[m + 3] = a, this.float32[m + 4] = o, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[f + 14] = c, this.uint32[m + 8] = h, this.uint16[f + 18] = p, this.uint16[f + 19] = d, t1;
            }
        }
        il.prototype.bytesPerElement = 40, Qs(il, "StructArrayLayout5i4f1i1ul2ui40");
        class sl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 8 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t1;
            }
        }
        sl.prototype.bytesPerElement = 16, Qs(sl, "StructArrayLayout3i2i2i16");
        class al extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 4 * t1, o = 8 * t1;
                return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t1;
            }
        }
        al.prototype.bytesPerElement = 16, Qs(al, "StructArrayLayout2f1f2i16");
        class ol extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, a) {
                const o = 20 * t1, l = 5 * t1;
                return this.uint8[o + 0] = e, this.uint8[o + 1] = r, this.float32[l + 1] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t1;
            }
        }
        ol.prototype.bytesPerElement = 20, Qs(ol, "StructArrayLayout2ub4f20");
        class ll extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        ll.prototype.bytesPerElement = 6, Qs(ll, "StructArrayLayout3ui6");
        class ul extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b) {
                const w = this.length;
                return this.resize(w + 1), this.emplace(w, t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b, w) {
                const _ = 30 * t1, A = 15 * t1, I = 60 * t1;
                return this.int16[_ + 0] = e, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = a, this.uint16[_ + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = d, this.float32[A + 10] = f, this.float32[A + 11] = m, this.uint8[I + 48] = y, this.uint8[I + 49] = g, this.uint8[I + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[I + 58] = w, t1;
            }
        }
        ul.prototype.bytesPerElement = 60, Qs(ul, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class cl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, I, M, S, P, z, B, k, T, V) {
                const E = this.length;
                return this.resize(E + 1), this.emplace(E, t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, I, M, S, P, z, B, k, T, V);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, I, M, S, P, z, B, k, T, V, E) {
                const F = 20 * t1, D = 40 * t1, C = 80 * t1;
                return this.float32[F + 0] = e, this.float32[F + 1] = r, this.int16[D + 4] = n, this.int16[D + 5] = i, this.int16[D + 6] = s, this.int16[D + 7] = a, this.int16[D + 8] = o, this.int16[D + 9] = l, this.int16[D + 10] = u, this.int16[D + 11] = c, this.int16[D + 12] = h, this.uint16[D + 13] = p, this.uint16[D + 14] = d, this.uint16[D + 15] = f, this.uint16[D + 16] = m, this.uint16[D + 17] = y, this.uint16[D + 18] = g, this.uint16[D + 19] = x, this.uint16[D + 20] = v, this.uint16[D + 21] = b, this.uint16[D + 22] = w, this.uint16[D + 23] = _, this.uint16[D + 24] = A, this.uint16[D + 25] = I, this.uint16[D + 26] = M, this.uint16[D + 27] = S, this.uint32[F + 14] = P, this.float32[F + 15] = z, this.float32[F + 16] = B, this.float32[F + 17] = k, this.float32[F + 18] = T, this.uint8[C + 76] = V, this.uint16[D + 39] = E, t1;
            }
        }
        cl.prototype.bytesPerElement = 80, Qs(cl, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
        class hl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, a) {
                const o = 6 * t1;
                return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.float32[o + 3] = i, this.float32[o + 4] = s, this.float32[o + 5] = a, t1;
            }
        }
        hl.prototype.bytesPerElement = 24, Qs(hl, "StructArrayLayout6f24");
        class pl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 5 * t1;
                return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t1;
            }
        }
        pl.prototype.bytesPerElement = 20, Qs(pl, "StructArrayLayout5f20");
        class dl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 7 * t1;
                return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = a, this.float32[l + 6] = o, t1;
            }
        }
        dl.prototype.bytesPerElement = 28, Qs(dl, "StructArrayLayout7f28");
        class fl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, t1, e, r, n, i, s, a, o, l, u, c);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h) {
                const p = 11 * t1;
                return this.float32[p + 0] = e, this.float32[p + 1] = r, this.float32[p + 2] = n, this.float32[p + 3] = i, this.float32[p + 4] = s, this.float32[p + 5] = a, this.float32[p + 6] = o, this.float32[p + 7] = l, this.float32[p + 8] = u, this.float32[p + 9] = c, this.float32[p + 10] = h, t1;
            }
        }
        fl.prototype.bytesPerElement = 44, Qs(fl, "StructArrayLayout11f44");
        class ml extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l) {
                const u = this.length;
                return this.resize(u + 1), this.emplace(u, t1, e, r, n, i, s, a, o, l);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u) {
                const c = 9 * t1;
                return this.float32[c + 0] = e, this.float32[c + 1] = r, this.float32[c + 2] = n, this.float32[c + 3] = i, this.float32[c + 4] = s, this.float32[c + 5] = a, this.float32[c + 6] = o, this.float32[c + 7] = l, this.float32[c + 8] = u, t1;
            }
        }
        ml.prototype.bytesPerElement = 36, Qs(ml, "StructArrayLayout9f36");
        class yl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e, this.float32[n + 1] = r, t1;
            }
        }
        yl.prototype.bytesPerElement = 8, Qs(yl, "StructArrayLayout2f8");
        class gl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 6 * t1;
                return this.uint32[3 * t1 + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t1;
            }
        }
        gl.prototype.bytesPerElement = 12, Qs(gl, "StructArrayLayout1ul3ui12");
        class xl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint16[1 * t1 + 0] = e, t1;
            }
        }
        xl.prototype.bytesPerElement = 2, Qs(xl, "StructArrayLayout1ui2");
        class vl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m) {
                const y = this.length;
                return this.resize(y + 1), this.emplace(y, t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y) {
                const g = 16 * t1;
                return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = s, this.float32[g + 5] = a, this.float32[g + 6] = o, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = d, this.float32[g + 13] = f, this.float32[g + 14] = m, this.float32[g + 15] = y, t1;
            }
        }
        vl.prototype.bytesPerElement = 64, Qs(vl, "StructArrayLayout16f64");
        class bl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 10 * t1, u = 5 * t1;
                return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = s, this.float32[u + 3] = a, this.float32[u + 4] = o, t1;
            }
        }
        bl.prototype.bytesPerElement = 20, Qs(bl, "StructArrayLayout4ui3f20");
        class wl extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.int16[1 * t1 + 0] = e, t1;
            }
        }
        wl.prototype.bytesPerElement = 2, Qs(wl, "StructArrayLayout1i2");
        class _l extends Lo {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint8[1 * t1 + 0] = e, t1;
            }
        }
        _l.prototype.bytesPerElement = 1, Qs(_l, "StructArrayLayout1ub1");
        class Al extends Co {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        Al.prototype.size = 40;
        class Il extends il {
            get(t1) {
                return new Al(this, t1);
            }
        }
        Qs(Il, "CollisionBoxArray");
        class Ml extends Co {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 49] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 50] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 13] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t1) {
                this._structArray.uint8[this._pos1 + 58] = t1;
            }
        }
        Ml.prototype.size = 60;
        class Sl extends ul {
            get(t1) {
                return new Ml(this, t1);
            }
        }
        Qs(Sl, "PlacedSymbolArray");
        class Pl extends Co {
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 0];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 1];
            }
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 5];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 6];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 13];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 14];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 14] = t1;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 15];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get zOffset() {
                return this._structArray.float32[this._pos4 + 18];
            }
            set zOffset(t1) {
                this._structArray.float32[this._pos4 + 18] = t1;
            }
            get hasIconTextFit() {
                return this._structArray.uint8[this._pos1 + 76];
            }
            get elevationFeatureIndex() {
                return this._structArray.uint16[this._pos2 + 39];
            }
        }
        Pl.prototype.size = 80;
        class zl extends cl {
            get(t1) {
                return new Pl(this, t1);
            }
        }
        Qs(zl, "SymbolInstanceArray");
        class Bl extends $o {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        Qs(Bl, "GlyphOffsetArray");
        class kl extends No {
            getx(t1) {
                return this.int16[2 * t1 + 0];
            }
            gety(t1) {
                return this.int16[2 * t1 + 1];
            }
        }
        Qs(kl, "SymbolLineVertexArray");
        class Tl extends Co {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        Tl.prototype.size = 12;
        class Vl extends gl {
            get(t1) {
                return new Tl(this, t1);
            }
        }
        Qs(Vl, "FeatureIndexArray");
        class El extends nl {
            geta_centroid_pos0(t1) {
                return this.uint16[2 * t1 + 0];
            }
            geta_centroid_pos1(t1) {
                return this.uint16[2 * t1 + 1];
            }
        }
        Qs(El, "FillExtrusionCentroidArray");
        class Fl extends Co {
            get a_join_normal_inside0() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get a_join_normal_inside1() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get a_join_normal_inside2() {
                return this._structArray.int16[this._pos2 + 2];
            }
        }
        Fl.prototype.size = 6;
        class Dl extends jo {
            get(t1) {
                return new Fl(this, t1);
            }
        }
        Qs(Dl, "FillExtrusionWallArray");
        const Cl = Oo([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), Rl = Oo([
            {
                name: "a_circle_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), Ll = Oo([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class Ol {
            constructor(t1 = []){
                this.segments = t1;
            }
            _prepareSegment(t1, e, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > Ol.MAX_VERTEX_ARRAY_LENGTH && Zt(`Max vertices per segment is ${Ol.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > Ol.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e,
                    primitiveOffset: r,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            prepareSegment(t1, e, r, n) {
                return this._prepareSegment(t1, e.length, r.length, n);
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e in t1.vaos)t1.vaos[e].destroy();
            }
            static simpleSegment(t1, e, r, n) {
                return new Ol([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        function Ul(t1, e) {
            return 256 * (t1 = Dt(Math.floor(t1), 0, 255)) + Dt(Math.floor(e), 0, 255);
        }
        Ol.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Qs(Ol, "SegmentVector");
        const Nl = Oo([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), jl = Oo([
            {
                name: "a_pattern_b",
                components: 4,
                type: "Uint16"
            }
        ]), Gl = Oo([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        class $l {
            constructor(){
                this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e, r, n) {
                this.ids.push(ql(t1)), this.positions.push(e, r, n);
            }
            eachPosition(t1, e) {
                const r = ql(t1);
                let n = 0, i = this.ids.length - 1;
                for(; n < i;){
                    const t1 = n + i >> 1;
                    this.ids[t1] >= r ? i = t1 : n = t1 + 1;
                }
                for(; this.ids[n] === r;)e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;
            }
            static serialize(t1, e) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return Xl(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e = new $l;
                let r;
                e.ids = t1.ids, e.positions = t1.positions;
                for (const t1 of e.ids)t1 !== r && e.uniqueIds.push(t1), r = t1;
                return e.indexed = !0, e;
            }
        }
        function ql(t1) {
            const e = +t1;
            return Number.isSafeInteger(e) ? e : Qe(String(t1));
        }
        function Xl(t1, e, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let s = r - 1, a = n + 1;
                for(;;){
                    do {
                        s++;
                    }while (t1[s] < i)
                    do {
                        a--;
                    }while (t1[a] > i)
                    if (s >= a) break;
                    Hl(t1, s, a), Hl(e, 3 * s, 3 * a), Hl(e, 3 * s + 1, 3 * a + 1), Hl(e, 3 * s + 2, 3 * a + 2);
                }
                a - r < n - a ? (Xl(t1, e, r, a), r = a + 1) : (Xl(t1, e, a + 1, n), n = a);
            }
        }
        function Hl(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        Qs($l, "FeaturePositionMap");
        class Zl {
            constructor(t1){
                this.gl = t1.gl, this.initialized = !1;
            }
            fetchUniformLocation(t1, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t1, e), this.initialized = !0), !!this.location;
            }
            set(t1, e, r) {
                throw new Error("Uniform#set() must be implemented by each concrete Uniform");
            }
        }
        class Wl extends Zl {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }
        class Yl extends Zl {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class Jl extends Zl {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }
        class Kl extends Zl {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }
        class Ql extends Zl {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class tu extends Zl {
            constructor(t1){
                super(t1), this.current = ur.transparent.toPremultipliedRenderColor(null);
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const eu = new Float32Array(16);
        class ru extends Zl {
            constructor(t1){
                super(t1), this.current = eu;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t1 = 1; t1 < 16; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        const nu = new Float32Array(9), iu = new Float32Array(4);
        class su extends Zl {
            constructor(t1){
                super(t1), this.current = iu;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 4; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        function au(t1) {
            return [
                Ul(255 * t1.r, 255 * t1.g),
                Ul(255 * t1.b, 255 * t1.a)
            ];
        }
        function ou(t1, e, r, n, i, s, a, o) {
            return !!t1 && ("composite" === t1.kind || "source" === t1.kind ? "none" === t1.evaluate(new Ja(0, {
                brightness: s,
                worldview: o
            }), e, r, i, n, a) : "none" === t1.value);
        }
        class lu {
            constructor(t1, e, r, n){
                this.value = t1, this.uniformNames = e.map((t1)=>`u_${t1}`), this.type = r, this.context = n;
            }
            setUniform(t1, e, r, n, i) {
                const s = n.constantOr(this.value);
                e.set(t1, i, s instanceof ur ? s.toPremultipliedRenderColor(this.lutExpression && "constant" === this.lutExpression.kind && "none" === this.lutExpression.value ? null : this.context.lut) : s);
            }
            getBinding(t1, e) {
                return "color" === this.type ? new tu(t1) : new Yl(t1);
            }
        }
        class uu {
            constructor(t1, e){
                this.uniformNames = e.map((t1)=>`u_${t1}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t1, e) {
                this.pixelRatio = t1.pixelRatio || 1, this.pattern = t1.tl.concat(t1.br), this.patternTransition = e ? e.tl.concat(e.br) : this.pattern;
            }
            setUniform(t1, e, r, n, i) {
                let s = null;
                "u_pattern" !== i && "u_dash" !== i || (s = this.pattern), "u_pattern_b" === i && (s = this.patternTransition), "u_pixel_ratio" === i && (s = this.pixelRatio), s && e.set(t1, i, s);
            }
            getBinding(t1, e) {
                return "u_pattern" === e || "u_pattern_b" === e || "u_dash" === e ? new Ql(t1) : new Yl(t1);
            }
        }
        class cu {
            constructor(t1, e, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e, r, n, i, s, a, o) {
                const l = this.paintVertexArray.length, u = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate(new Ja(0, {
                    brightness: s,
                    worldview: o
                }), e, {}, i, n, a) : "constant" === this.expression.kind && this.expression.value, c = ou(this.lutExpression, e, {}, n, i, s, a, o);
                this.paintVertexArray.resize(t1), this._setPaintValue(l, t1, u, c ? null : this.context.lut);
            }
            updatePaintArray(t1, e, r, n, i, s, a, o) {
                const l = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate({
                    zoom: 0,
                    brightness: a,
                    worldview: o
                }, r, n, void 0, i) : "constant" === this.expression.kind && this.expression.value, u = ou(this.lutExpression, r, n, i, void 0, a, void 0, o);
                this._setPaintValue(t1, e, l, u ? null : this.context.lut);
            }
            _setPaintValue(t1, e, r, n) {
                if ("color" === this.type) {
                    const i = au(r.toPremultipliedRenderColor(n));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, i[0], i[1]);
                } else {
                    for(let n = t1; n < e; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && "constant" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || "constant" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class hu {
            constructor(t1, e, r, n, i, s){
                this.expression = t1, this.uniformNames = e.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.context = i, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new s;
            }
            populatePaintArray(t1, e, r, n, i, s, a, o) {
                const l = this.expression.evaluate(new Ja(this.context.zoom, {
                    brightness: s,
                    worldview: o
                }), e, {}, i, n, a), u = this.expression.evaluate(new Ja(this.context.zoom + 1, {
                    brightness: s,
                    worldview: o
                }), e, {}, i, n, a), c = ou(this.lutExpression, e, {}, n, i, s, a, o), h = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(h, t1, l, u, c ? null : this.context.lut);
            }
            updatePaintArray(t1, e, r, n, i, s, a, o) {
                const l = this.expression.evaluate({
                    zoom: this.context.zoom,
                    brightness: a,
                    worldview: o
                }, r, n, void 0, i), u = this.expression.evaluate({
                    zoom: this.context.zoom + 1,
                    brightness: a,
                    worldview: o
                }, r, n, void 0, i), c = ou(this.lutExpression, r, n, i, void 0, a, void 0, o);
                this._setPaintValue(t1, e, l, u, c ? null : this.context.lut);
            }
            _setPaintValue(t1, e, r, n, i) {
                if ("color" === this.type) {
                    const s = au(r.toPremultipliedRenderColor(i)), a = au(n.toPremultipliedRenderColor(i));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1]);
                } else {
                    for(let i = t1; i < e; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, a = Dt(this.expression.interpolationFactor(s, this.context.zoom, this.context.zoom + 1), 0, 1);
                e.set(t1, i, a);
            }
            getBinding(t1, e) {
                return new Yl(t1);
            }
        }
        class pu {
            constructor(t1, e, r, n, i){
                this.expression = t1, this.layerId = i, this.paintVertexAttributes = ("array" === r ? Gl : Nl).members;
                for(let t1 = 0; t1 < e.length; ++t1);
                this.paintVertexArray = new n, this.paintTransitionVertexArray = new Jo;
            }
            populatePaintArray(t1, e, r, n) {
                const i = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValues(i, t1, e.patterns && e.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e, r, n, i, s, a) {
                this._setPaintValues(t1, e, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t1, e, r, n) {
                if (!n || !r) return;
                const i = n[r[0]], s = n[r[1]];
                if (i) {
                    if (i) {
                        const { tl: r, br: n, pixelRatio: s } = i;
                        for(let i = t1; i < e; i++)this.paintVertexArray.emplace(i, r[0], r[1], n[0], n[1], s);
                    }
                    if (s) {
                        this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
                        const { tl: r, br: n } = s;
                        for(let i = t1; i < e; i++)this.paintTransitionVertexArray.emplace(i, r[0], r[1], n[0], n[1]);
                    }
                }
            }
            upload(t1) {
                const e = this.expression.isStateDependent || !this.expression.isLightConstant;
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t1.createVertexBuffer(this.paintTransitionVertexArray, jl.members, e));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();
            }
        }
        class du {
            constructor(t1, e, r = ()=>!0){
                this.binders = {}, this._buffers = [], this.context = e;
                const n = [];
                for(const i in t1.paint._values){
                    const s = t1.paint.get(i);
                    if (i.endsWith("-use-theme")) continue;
                    if (!r(i)) continue;
                    if (!(s instanceof io && zs(s.property.specification))) continue;
                    const a = yu(i, t1.type), o = s.value, l = s.property.specification.type, u = !!s.property.useIntegerZoom, c = "line-dasharray" === i || i.endsWith("pattern"), h = t1.paint.get(`${i}-use-theme`), p = "line-dasharray" === i && "constant" !== t1.layout.get("line-cap").value.kind || h && "constant" !== h.value.kind;
                    if ("constant" !== o.kind || p) if ("source" === o.kind || p || c) {
                        const e = vu(i, l, "source");
                        this.binders[i] = c ? new pu(o, a, l, e, t1.id) : new cu(o, a, l, e), n.push(`/a_${i}`);
                    } else {
                        const t1 = vu(i, l, "composite");
                        this.binders[i] = new hu(o, a, l, u, e, t1), n.push(`/z_${i}`);
                    }
                    else this.binders[i] = c ? new uu(o.value, a) : new lu(o.value, a, l, e), n.push(`/u_${i}`);
                    h && (this.binders[i].lutExpression = h.value);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e = this.binders[t1];
                return e instanceof cu || e instanceof hu ? e.maxValue : 0;
            }
            populatePaintArrays(t1, e, r, n, i, s, a, o) {
                for(const l in this.binders){
                    const u = this.binders[l];
                    u.context = this.context, (u instanceof cu || u instanceof hu || u instanceof pu) && u.populatePaintArray(t1, e, r, n, i, s, a, o);
                }
            }
            setConstantPatternPositions(t1, e) {
                for(const r in this.binders){
                    const n = this.binders[r];
                    n instanceof uu && n.setConstantPatternPositions(t1, e);
                }
            }
            getPatternTransitionVertexBuffer(t1) {
                const e = this.binders[t1];
                return e instanceof pu ? e.paintTransitionVertexBuffer : null;
            }
            updatePaintArrays(t1, e, r, n, i, s, a, o, l, u) {
                let c = !1;
                const h = Object.keys(t1), p = 0 !== h.length && !o, d = p ? h : e.uniqueIds;
                this.context.lut = i.lut;
                for(const o in this.binders){
                    const h = this.binders[o];
                    if (h.context = this.context, (h instanceof cu || h instanceof hu || h instanceof pu) && h.expression && h.expression.kind && "constant" !== h.expression.kind && (!0 === h.expression.isStateDependent || !1 === h.expression.isLightConstant)) {
                        const f = i.paint.get(o);
                        h.expression = f.value;
                        for (const r of d){
                            const i = t1[r.toString()];
                            e.eachPosition(r, (t1, e, r)=>{
                                const o = n.feature(t1);
                                h.updatePaintArray(e, r, o, i, s, a, l, u);
                            });
                        }
                        if (!p) for (const e of r.uniqueIds){
                            const i = t1[e.toString()];
                            r.eachPosition(e, (t1, e, r)=>{
                                const o = n.feature(t1);
                                h.updatePaintArray(e, r, o, i, s, a, l, u);
                            });
                        }
                        c = !0;
                    }
                }
                return c;
            }
            defines() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof lu || r instanceof uu) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1) {
                const e = [];
                for(const r in this.binders){
                    const n = this.binders[r];
                    if (n instanceof lu || n instanceof uu || n instanceof hu) for (const i of n.uniformNames)e.push({
                        name: i,
                        property: r,
                        binding: n.getBinding(t1, i)
                    });
                }
                return e;
            }
            setUniforms(t1, e, r, n, i) {
                for (const { name: e, property: s, binding: a } of r)this.binders[s].setUniform(t1, a, i, n.get(s), e);
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof cu || e instanceof hu || e instanceof pu) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer), e instanceof pu && e.paintTransitionVertexBuffer && this._buffers.push(e.paintTransitionVertexBuffer);
                }
            }
            upload(t1) {
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof cu || r instanceof hu || r instanceof pu) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof cu || e instanceof hu || e instanceof pu) && e.destroy();
                }
            }
        }
        class fu {
            constructor(t1, e, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new du(n, e, r);
                this.needsUpload = !1, this._featureMap = new $l, this._featureMapWithoutIds = new $l, this._bufferOffset = 0, this._idlessCounter = 0;
            }
            populatePaintArrays(t1, e, r, n, i, s, a, o, l) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e, n, i, s, a, o, l);
                void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t1) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t1), this._idlessCounter += 1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e, r, n, i, s, a, o) {
                for (const l of r)this.needsUpload = this.programConfigurations[l.id].updatePaintArrays(t1, this._featureMap, this._featureMapWithoutIds, e, l, n, i, s, a || 0, o) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e in this.programConfigurations)this.programConfigurations[e].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        const mu = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "icon-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-emissive-strength": [
                "emissive_strength"
            ],
            "icon-emissive-strength": [
                "emissive_strength"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "symbol-z-offset": [
                "z_offset"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio",
                "pattern_b"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio",
                "pattern_b"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio",
                "pattern_b"
            ],
            "line-dasharray": [
                "dash"
            ],
            "fill-bridge-guard-rail-color": [
                "structure_color"
            ],
            "fill-tunnel-structure-color": [
                "structure_color"
            ]
        };
        function yu(t1, e) {
            return mu[t1] || [
                t1.replace(`${e}-`, "").replace(/-/g, "_")
            ];
        }
        const gu = {
            "line-pattern": {
                source: Yo,
                composite: Yo
            },
            "fill-pattern": {
                source: Yo,
                composite: Yo
            },
            "fill-extrusion-pattern": {
                source: Yo,
                composite: Yo
            },
            "line-dasharray": {
                source: Jo,
                composite: Jo
            }
        }, xu = {
            color: {
                source: yl,
                composite: el
            },
            number: {
                source: $o,
                composite: yl
            }
        };
        function vu(t1, e, r) {
            const n = gu[t1];
            return n && n[r] || xu[e][r];
        }
        Qs(lu, "ConstantBinder"), Qs(uu, "PatternConstantBinder"), Qs(cu, "SourceExpressionBinder"), Qs(pu, "PatternCompositeBinder"), Qs(hu, "CompositeExpressionBinder"), Qs(du, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), Qs(fu, "ProgramConfigurationSet");
        const bu = jn / Math.PI / 2, wu = 64, _u = [
            wu,
            32,
            16
        ], Au = -bu, Iu = bu;
        function Mu(t1, e, r, n = bu) {
            return r = Bt(r), [
                t1 * Math.sin(r) * n,
                -e * n,
                t1 * Math.cos(r) * n
            ];
        }
        function Su(t1, e, r) {
            return Mu(Math.cos(Bt(t1)), Math.sin(Bt(t1)), e, r);
        }
        const Pu = 6371008.8, zu = 2 * Math.PI * Pu;
        class Bu {
            constructor(t1, e){
                if (isNaN(t1) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t1}, ${e})`);
                if (this.lng = +t1, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new Bu(Rt(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e = Math.PI / 180, r = this.lat * e, n = t1.lat * e, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e);
                return Pu * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e = 360 * t1 / 40075017, r = e / Math.cos(Math.PI / 180 * this.lat);
                return new ku({
                    lng: this.lng - r,
                    lat: this.lat - e
                }, {
                    lng: this.lng + r,
                    lat: this.lat + e
                });
            }
            toEcef(t1) {
                return Su(this.lat, this.lng, bu + t1 * bu / Pu);
            }
            static convert(t1) {
                if (t1 instanceof Bu) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new Bu(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new Bu(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        class ku {
            constructor(t1, e){
                t1 && (e ? this.setSouthWest(t1).setNorthEast(e) : Array.isArray(t1) && 4 === t1.length ? this.setSouthWest([
                    t1[0],
                    t1[1]
                ]).setNorthEast([
                    t1[2],
                    t1[3]
                ]) : this.setSouthWest(t1[0]).setNorthEast(t1[1]));
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof Bu ? new Bu(t1.lng, t1.lat) : Bu.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof Bu ? new Bu(t1.lng, t1.lat) : Bu.convert(t1), this;
            }
            extend(t1) {
                const e = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof Bu) n = t1, i = t1;
                else {
                    if (!(t1 instanceof ku)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(ku.convert(t1)) : this.extend(Bu.convert(t1)) : "object" == typeof t1 && null !== t1 && t1.hasOwnProperty("lat") && (t1.hasOwnProperty("lon") || t1.hasOwnProperty("lng")) ? this.extend(Bu.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Bu(n.lng, n.lat), this._ne = new Bu(i.lng, i.lat)), this;
            }
            getCenter() {
                return new Bu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new Bu(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new Bu(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e, lat: r } = Bu.convert(t1);
                let n = this._sw.lng <= e && e <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                if (t1) return t1 instanceof ku ? t1 : new ku(t1);
            }
        }
        function Tu(t1) {
            return zu * Math.cos(t1 * Math.PI / 180);
        }
        function Vu(t1) {
            return (180 + t1) / 360;
        }
        function Eu(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function Fu(t1, e) {
            return t1 / Tu(e);
        }
        function Du(t1) {
            return 360 * t1 - 180;
        }
        function Cu(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function Ru(t1, e) {
            return t1 * Tu(Cu(e));
        }
        const Lu = 85.051129;
        function Ou(t1) {
            return Math.cos(Bt(Dt(t1, -85.051129, Lu)));
        }
        function Uu(t1, e) {
            const r = Dt(e, 0, 25.5), n = Math.pow(2, r);
            return Ou(t1) * zu / (512 * n);
        }
        function Nu(t1) {
            return 1 / Math.cos(t1 * Math.PI / 180);
        }
        function ju(t1, e = 0) {
            const r = Math.exp(Math.PI * (1 - (t1.y + e / jn) / (1 << t1.z) * 2));
            return 80150034 * r / (r * r + 1) / jn / (1 << t1.z);
        }
        class Gu {
            constructor(t1, e, r = 0){
                this.x = +t1, this.y = +e, this.z = +r;
            }
            static fromLngLat(t1, e = 0) {
                const r = Bu.convert(t1);
                return new Gu(Vu(r.lng), Eu(r.lat), Fu(e, r.lat));
            }
            toLngLat() {
                return new Bu(Du(this.x), Cu(this.y));
            }
            toAltitude() {
                return Ru(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / zu * Nu(Cu(this.y));
            }
        }
        function $u(t1, e, r, n, i, s, a, o, l) {
            const u = (e + n) / 2, c = (r + i) / 2, h = new Mt(u, c);
            o(h), function(t1, e, r, n, i, s) {
                const a = r - i, o = n - s;
                return Math.abs((n - e) * a - (r - t1) * o) / Math.hypot(a, o);
            }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? ($u(t1, e, r, u, c, s, h, o, l), $u(t1, u, c, n, i, h, a, o, l)) : t1.push(a);
        }
        function qu(t1, e, r) {
            let n = t1[0], i = n.x, s = n.y;
            e(n);
            const a = [
                n
            ];
            for(let o = 1; o < t1.length; o++){
                const l = t1[o], { x: u, y: c } = l;
                e(l), $u(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;
            }
            return a;
        }
        function Xu(t1, e, r, n) {
            if (n(e, r)) {
                const i = e.add(r)._mult(.5);
                Xu(t1, e, i, n), Xu(t1, i, r, n);
            } else t1.push(r);
        }
        function Hu(t1, e) {
            let r = t1[0];
            const n = [
                r
            ];
            for(let i = 1; i < t1.length; i++){
                const s = t1[i];
                Xu(n, r, s, e), r = s;
            }
            return n;
        }
        const Zu = Math.pow(2, 14) - 1, Wu = -Zu - 1;
        function Yu(t1, e) {
            const r = Math.round(t1.x * e), n = Math.round(t1.y * e);
            return t1.x = Dt(r, Wu, Zu), t1.y = Dt(n, Wu, Zu), (r < t1.x || r > t1.x + 1 || n < t1.y || n > t1.y + 1) && Zt("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t1;
        }
        function Ju(t1, e, r) {
            const n = t1.loadGeometry(), i = t1.extent, s = jn / i;
            if (e && r && r.projection.isReprojectedInTileSpace) {
                const s = 1 << e.z, { scale: a, x: o, y: l, projection: u } = r, c = (t1)=>{
                    const r = Du((e.x + t1.x / i) / s), n = Cu((e.y + t1.y / i) / s), c = u.project(r, n);
                    t1.x = (c.x * a - o) * i, t1.y = (c.y * a - l) * i;
                };
                for(let e = 0; e < n.length; e++)if (1 !== t1.type) n[e] = qu(n[e], c, 1);
                else {
                    const t1 = [];
                    for (const r of n[e])r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t1.push(r));
                    n[e] = t1;
                }
            }
            for (const t1 of n)for (const e of t1)Yu(e, s);
            return n;
        }
        function Ku(t1, e) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e ? Ju(t1) : []
            };
        }
        class Qu {
            constructor(t1, e, r, n, i){
                this.properties = {}, this.extent = r, this.type = 0, this.id = void 0, this._pbf = t1, this._geometry = -1, this._keys = n, this._values = i, t1.readFields(tc, this, e);
            }
            loadGeometry() {
                const t1 = this._pbf;
                t1.pos = this._geometry;
                const e = t1.readVarint() + t1.pos, r = [];
                let n, i = 1, s = 0, a = 0, o = 0;
                for(; t1.pos < e;){
                    if (s <= 0) {
                        const e = t1.readVarint();
                        i = 7 & e, s = e >> 3;
                    }
                    if (s--, 1 === i || 2 === i) a += t1.readSVarint(), o += t1.readSVarint(), 1 === i && (n && r.push(n), n = []), n && n.push(new Mt(a, o));
                    else {
                        if (7 !== i) throw new Error(`unknown command ${i}`);
                        n && n.push(n[0].clone());
                    }
                }
                return n && r.push(n), r;
            }
            bbox() {
                const t1 = this._pbf;
                t1.pos = this._geometry;
                const e = t1.readVarint() + t1.pos;
                let r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0;
                for(; t1.pos < e;){
                    if (n <= 0) {
                        const e = t1.readVarint();
                        r = 7 & e, n = e >> 3;
                    }
                    if (n--, 1 === r || 2 === r) i += t1.readSVarint(), s += t1.readSVarint(), i < a && (a = i), i > o && (o = i), s < l && (l = s), s > u && (u = s);
                    else if (7 !== r) throw new Error(`unknown command ${r}`);
                }
                return [
                    a,
                    l,
                    o,
                    u
                ];
            }
            toGeoJSON(t1, e, r) {
                const n = this.extent * Math.pow(2, r), i = this.extent * t1, s = this.extent * e, a = this.loadGeometry();
                function o(t1) {
                    return [
                        360 * (t1.x + i) / n - 180,
                        360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t1.y + s) / n) * Math.PI)) - 90
                    ];
                }
                function l(t1) {
                    return t1.map(o);
                }
                let u;
                if (1 === this.type) {
                    const t1 = [];
                    for (const e of a)t1.push(e[0]);
                    const e = l(t1);
                    u = 1 === t1.length ? {
                        type: "Point",
                        coordinates: e[0]
                    } : {
                        type: "MultiPoint",
                        coordinates: e
                    };
                } else if (2 === this.type) {
                    const t1 = a.map(l);
                    u = 1 === t1.length ? {
                        type: "LineString",
                        coordinates: t1[0]
                    } : {
                        type: "MultiLineString",
                        coordinates: t1
                    };
                } else {
                    if (3 !== this.type) throw new Error("unknown feature type");
                    {
                        const t1 = function(t1) {
                            const e = t1.length;
                            if (e <= 1) return [
                                t1
                            ];
                            const r = [];
                            let n, i;
                            for(let s = 0; s < e; s++){
                                const e = ec(t1[s]);
                                0 !== e && (void 0 === i && (i = e < 0), i === e < 0 ? (n && r.push(n), n = [
                                    t1[s]
                                ]) : n && n.push(t1[s]));
                            }
                            return n && r.push(n), r;
                        }(a), e = [];
                        for (const r of t1)e.push(r.map(l));
                        u = 1 === e.length ? {
                            type: "Polygon",
                            coordinates: e[0]
                        } : {
                            type: "MultiPolygon",
                            coordinates: e
                        };
                    }
                }
                const c = {
                    type: "Feature",
                    geometry: u,
                    properties: this.properties
                };
                return null != this.id && (c.id = this.id), c;
            }
        }
        function tc(t1, e, r) {
            1 === t1 ? e.id = r.readVarint() : 2 === t1 ? function(t1, e) {
                const r = t1.readVarint() + t1.pos;
                for(; t1.pos < r;){
                    const r = e._keys[t1.readVarint()], n = e._values[t1.readVarint()];
                    e.properties[r] = n;
                }
            }(r, e) : 3 === t1 ? e.type = r.readVarint() : 4 === t1 && (e._geometry = r.pos);
        }
        function ec(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        Qu.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class rc {
            constructor(t1, e){
                this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(nc, this, e), this.length = this._features.length;
            }
            feature(t1) {
                if (t1 < 0 || t1 >= this._features.length) throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[t1];
                const e = this._pbf.readVarint() + this._pbf.pos;
                return new Qu(this._pbf, e, this.extent, this._keys, this._values);
            }
        }
        function nc(t1, e, r) {
            15 === t1 ? e.version = r.readVarint() : 1 === t1 ? e.name = r.readString() : 5 === t1 ? e.extent = r.readVarint() : 2 === t1 ? e._features.push(r.pos) : 3 === t1 ? e._keys.push(r.readString()) : 4 === t1 && e._values.push(function(t1) {
                let e = null;
                const r = t1.readVarint() + t1.pos;
                for(; t1.pos < r;){
                    const r = t1.readVarint() >> 3;
                    e = 1 === r ? t1.readString() : 2 === r ? t1.readFloat() : 3 === r ? t1.readDouble() : 4 === r ? t1.readVarint64() : 5 === r ? t1.readVarint() : 6 === r ? t1.readSVarint() : 7 === r ? t1.readBoolean() : null;
                }
                if (null == e) throw new Error("unknown feature value");
                return e;
            }(r));
        }
        class ic {
            constructor(t1, e){
                this.layers = t1.readFields(sc, {}, e);
            }
        }
        function sc(t1, e, r) {
            if (3 === t1) {
                const t1 = new rc(r, r.readVarint() + r.pos);
                t1.length && (e[t1.name] = t1);
            }
        }
        const ac = "3d_elevation_id", oc = "level";
        class lc {
            constructor(){
                this._valid = !1;
            }
            reset(t1) {
                return this.feature = t1, this._valid = !0, this._geometry = t1.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = !1), this;
            }
            geometry(t1, e) {
                return this._valid && t1(e(this._geometry)), this;
            }
            require(t1, e, r) {
                return this.get(t1, !0, e, r);
            }
            optional(t1, e, r) {
                return this.get(t1, !1, e, r);
            }
            success() {
                return this._valid;
            }
            get(t1, e, r, n) {
                const i = this.feature.properties.hasOwnProperty(t1) ? +this.feature.properties[t1] : void 0;
                return this._valid && void 0 !== i && !Number.isNaN(i) ? r(n ? n(i) : i) : e && (this._valid = !1), this;
            }
        }
        class uc {
            constructor(t1, e){
                this.featureFunc = t1, this.vertexFunc = e;
            }
            parseFeature(t1, e, r) {
                return this.featureFunc(t1, e, r);
            }
            parseVertex(t1, e, r) {
                return this.vertexFunc(t1, e, r);
            }
        }
        const cc = new uc((t1, e, r)=>t1.reset(e).require(ac, (t1)=>{
                r.id = t1;
            }).optional("fixed_height_relative", (t1)=>{
                r.constantHeight = t1;
            }, pc.decodeRelativeHeight).geometry((t1)=>{
                r.bounds = t1;
            }, bn).success(), (t1, e, r)=>t1.reset(e).require(ac, (t1)=>{
                r.id = t1;
            }).require("elevation_idx", (t1)=>{
                r.idx = t1;
            }).require("extent", (t1)=>{
                r.extent = t1;
            }).require("height_relative", (t1)=>{
                r.height = t1;
            }, pc.decodeRelativeHeight).geometry((t1)=>{
                r.position = t1;
            }, pc.getPoint).success()), hc = new uc((t1, e, r)=>t1.reset(e).require(ac, (t1)=>{
                r.id = t1;
            }).optional("fixed_height", (t1)=>{
                r.constantHeight = t1;
            }, pc.decodeMetricHeight).geometry((t1)=>{
                r.bounds = t1;
            }, bn).success(), (t1, e, r)=>t1.reset(e).require(ac, (t1)=>{
                r.id = t1;
            }).require("elevation_idx", (t1)=>{
                r.idx = t1;
            }).require("extent", (t1)=>{
                r.extent = t1;
            }).require("height", (t1)=>{
                r.height = t1;
            }, pc.decodeMetricHeight).geometry((t1)=>{
                r.position = t1;
            }, pc.getPoint).success());
        class pc {
            static getPoint(t1) {
                return ht(t1[0][0].x, t1[0][0].y);
            }
            static decodeRelativeHeight(t1) {
                return 1e-4 * t1 * 5;
            }
            static decodeMetricHeight(t1) {
                return 1e-4 * t1;
            }
            static getVersionSchema(t1) {
                return t1 ? "1.0.1" === t1 ? hc : void 0 : cc;
            }
            static parse(t1) {
                const e = [], r = [], n = t1.length, i = new lc;
                for(let s = 0; s < n; s++){
                    const n = t1.feature(s), a = n.properties.version, o = pc.getVersionSchema(a);
                    if (void 0 === o) {
                        Zt(`Unknown elevation feature version number ${a || "(unknown)"}`);
                        continue;
                    }
                    const l = n.properties.type;
                    if (!l) continue;
                    const u = Qu.types[n.type];
                    if ("Point" === u && "curve_point" === l) {
                        const t1 = {};
                        o.parseVertex(i, n, t1) && e.push(t1);
                    } else if ("Polygon" === u && "curve_meta" === l) {
                        const t1 = {};
                        o.parseFeature(i, n, t1) && r.push(t1);
                    }
                }
                return {
                    vertices: e,
                    features: r
                };
            }
        }
        class dc {
            constructor(t1, e){
                this.pos = t1, this.dir = e;
            }
            intersectsPlane(t1, e, r) {
                const n = xt(e, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e[0] + (t1[1] - this.pos[1]) * e[1]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, !0;
            }
        }
        class fc {
            constructor(t1, e){
                this.pos = t1, this.dir = e;
            }
            intersectsPlane(t1, e, r) {
                const n = O(e, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e[0] + (t1[1] - this.pos[1]) * e[1] + (t1[2] - this.pos[2]) * e[2]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
            }
            closestPointOnSphere(t1, r, n) {
                if (function(t1, r) {
                    var n = t1[0], i = t1[1], s = t1[2], a = r[0], o = r[1], l = r[2];
                    return Math.abs(n - a) <= e * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= e * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(s - l) <= e * Math.max(1, Math.abs(s), Math.abs(l));
                }(this.pos, t1) || 0 === r) return n[0] = n[1] = n[2] = 0, !1;
                const [i, s, a] = this.dir, o = this.pos[0] - t1[0], l = this.pos[1] - t1[1], u = this.pos[2] - t1[2], c = i * i + s * s + a * a, h = 2 * (o * i + l * s + u * a), p = h * h - 4 * c * (o * o + l * l + u * u - r * r);
                if (p < 0) {
                    const t1 = Math.max(-h / 2, 0), e = o + i * t1, c = l + s * t1, p = u + a * t1, d = Math.hypot(e, c, p);
                    return n[0] = e * r / d, n[1] = c * r / d, n[2] = p * r / d, !1;
                }
                {
                    const t1 = (-h - Math.sqrt(p)) / (2 * c);
                    if (t1 < 0) {
                        const t1 = Math.hypot(o, l, u);
                        return n[0] = o * r / t1, n[1] = l * r / t1, n[2] = u * r / t1, !1;
                    }
                    return n[0] = o + i * t1, n[1] = l + s * t1, n[2] = u + a * t1, !0;
                }
            }
        }
        class mc {
            constructor(t1, e, r, n, i){
                this.TL = t1, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;
            }
            static fromInvProjectionMatrix(t1, e, r) {
                const n = [
                    -1,
                    1,
                    1
                ], i = [
                    1,
                    1,
                    1
                ], s = [
                    1,
                    -1,
                    1
                ], a = [
                    -1,
                    -1,
                    1
                ], o = j(n, n, t1), l = j(i, i, t1), u = j(s, s, t1), c = j(a, a, t1);
                return new mc(o, l, u, c, e / r);
            }
        }
        function yc(t1, e, r) {
            let n = 1 / 0, i = -1 / 0;
            const s = [];
            for (const a of t1){
                H(s, a, e);
                const t1 = O(s, r);
                n = Math.min(n, t1), i = Math.max(i, t1);
            }
            return [
                n,
                i
            ];
        }
        function gc(t1, e) {
            let r = !0;
            for(let n = 0; n < t1.planes.length; n++){
                const i = t1.planes[n];
                let s = 0;
                for(let t1 = 0; t1 < e.length; t1++)s += +(O(i, e[t1]) + i[3] >= 0);
                if (0 === s) return 0;
                s !== e.length && (r = !1);
            }
            return r ? 2 : 1;
        }
        function xc(t1, e) {
            for (const r of t1.projections){
                const n = yc(e, t1.points[0], r.axis);
                if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;
            }
            return 1;
        }
        function vc(t1, e) {
            let r = 0;
            const n = [
                0,
                0,
                0,
                0
            ];
            for(let i = 0; i < t1.length; i++)n[0] = t1[i][0], n[1] = t1[i][1], n[2] = t1[i][2], n[3] = 1, Q(n, e) >= 0 && r++;
            return r;
        }
        class bc {
            constructor(t1, e){
                this.points = t1 || new Array(8).fill([
                    0,
                    0,
                    0
                ]), this.planes = e || new Array(6).fill([
                    0,
                    0,
                    0,
                    0
                ]), this.bounds = wc.fromPoints(this.points), this.projections = [], this.frustumEdges = [
                    H([], this.points[2], this.points[3]),
                    H([], this.points[0], this.points[3]),
                    H([], this.points[4], this.points[0]),
                    H([], this.points[5], this.points[1]),
                    H([], this.points[6], this.points[2]),
                    H([], this.points[7], this.points[3])
                ];
                for (const t1 of this.frustumEdges){
                    const e = [
                        0,
                        -t1[2],
                        t1[1]
                    ], r = [
                        t1[2],
                        0,
                        -t1[0]
                    ];
                    this.projections.push({
                        axis: e,
                        projection: yc(this.points, this.points[0], e)
                    }), this.projections.push({
                        axis: r,
                        projection: yc(this.points, this.points[0], r)
                    });
                }
            }
            static fromInvProjectionMatrix(t1, e, r, n) {
                const i = Math.pow(2, r), s = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((r)=>{
                    const s = tt([], r, t1), a = 1 / s[3] / e * i;
                    return (o = s)[0] = (l = s)[0] * (u = [
                        a,
                        a,
                        n ? 1 / s[3] : a,
                        a
                    ])[0], o[1] = l[1] * u[1], o[2] = l[2] * u[2], o[3] = l[3] * u[3], o;
                    //TURBOPACK unreachable
                    ;
                    var o, l, u;
                }), a = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((t1)=>{
                    const e = L([], U([], H([], s[t1[0]], s[t1[1]]), H([], s[t1[2]], s[t1[1]]))), r = -O(e, s[t1[1]]);
                    return e.concat(r);
                }), o = [];
                for(let t1 = 0; t1 < s.length; t1++)o.push([
                    s[t1][0],
                    s[t1][1],
                    s[t1][2]
                ]);
                return new bc(o, a);
            }
            intersectsPrecise(t1, e, r) {
                for(let r = 0; r < e.length; r++)if (!vc(t1, e[r])) return 0;
                for(let e = 0; e < this.planes.length; e++)if (!vc(t1, this.planes[e])) return 0;
                for (const e of r)for (const r of this.frustumEdges){
                    const n = U([], e, r), i = I(n);
                    if (0 === i) continue;
                    V(n, n, 1 / i);
                    const s = yc(this.points, this.points[0], n), a = yc(t1, this.points[0], n);
                    if (s[0] > a[1] || a[0] > s[1]) return 0;
                }
                return 1;
            }
            containsPoint(t1) {
                for (const e of this.planes){
                    const r = e[3];
                    if (O([
                        e[0],
                        e[1],
                        e[2]
                    ], t1) + r < 0) return !1;
                }
                return !0;
            }
        }
        class wc {
            static fromPoints(t1) {
                const e = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], r = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const n of t1)k(e, e, n), T(r, r, n);
                return new wc(e, r);
            }
            static fromTileIdAndHeight(t1, e, r) {
                const n = 1 << t1.canonical.z, i = t1.canonical.x, s = t1.canonical.y;
                return new wc([
                    i / n,
                    s / n,
                    e
                ], [
                    (i + 1) / n,
                    (s + 1) / n,
                    r
                ]);
            }
            static applyTransform(t1, e) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)j(r[t1], r[t1], e);
                return wc.fromPoints(r);
            }
            static applyTransformFast(t1, e) {
                const r = [
                    e[12],
                    e[13],
                    e[14]
                ], n = [
                    ...r
                ];
                for(let i = 0; i < 3; i++)for(let s = 0; s < 3; s++){
                    const a = e[4 * s + i], o = a * t1.min[s], l = a * t1.max[s];
                    r[i] += Math.min(o, l), n[i] += Math.max(o, l);
                }
                return new wc(r, n);
            }
            static projectAabbCorners(t1, e) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)j(r[t1], r[t1], e);
                return r;
            }
            constructor(t1, e){
                this.min = t1, this.max = e, this.center = V([], P([], this.min, this.max), .5);
            }
            quadrant(t1) {
                const e = [
                    t1 % 2 == 0,
                    t1 < 2
                ], r = A(this.min), n = A(this.max);
                for(let t1 = 0; t1 < e.length; t1++)r[t1] = e[t1] ? this.min[t1] : this.center[t1], n[t1] = e[t1] ? this.center[t1] : this.max[t1];
                return n[2] = this.max[2], new wc(r, n);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            distanceZ(t1) {
                return Math.max(Math.min(this.max[2], t1[2]), this.min[2]) - t1[2];
            }
            getCorners() {
                const t1 = this.min, e = this.max;
                return [
                    [
                        t1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        e[1],
                        e[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        e[2]
                    ]
                ];
            }
            intersects(t1) {
                return this.intersectsAabb(t1.bounds) ? gc(t1, this.getCorners()) : 0;
            }
            intersectsFlat(t1) {
                return this.intersectsAabb(t1.bounds) ? gc(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsPrecise(t1, e) {
                return e || this.intersects(t1) ? xc(t1, this.getCorners()) : 0;
            }
            intersectsPreciseFlat(t1, e) {
                return e || this.intersectsFlat(t1) ? xc(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsAabb(t1) {
                for(let e = 0; e < 3; ++e)if (this.min[e] > t1.max[e] || t1.min[e] > this.max[e]) return !1;
                return !0;
            }
            intersectsAabbXY(t1) {
                return !(this.min[0] > t1.max[0] || t1.min[0] > this.max[0] || this.min[1] > t1.max[1] || t1.min[1] > this.max[1]);
            }
            encapsulate(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1.min[e]), this.max[e] = Math.max(this.max[e], t1.max[e]);
            }
            encapsulatePoint(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1[e]), this.max[e] = Math.max(this.max[e], t1[e]);
            }
            closestPoint(t1) {
                return [
                    Math.max(Math.min(this.max[0], t1[0]), this.min[0]),
                    Math.max(Math.min(this.max[1], t1[1]), this.min[1]),
                    Math.max(Math.min(this.max[2], t1[2]), this.min[2])
                ];
            }
        }
        Qs(wc, "Aabb");
        class _c {
            constructor(t1, e){
                this.feature = t1, this.metersToTile = e, this.index = 0;
            }
            get() {
                const t1 = this.feature.vertices[this.index], e = this.feature.vertexProps[this.index].dir, r = e[1], n = -e[0], i = (t1.extent + 1) * this.metersToTile;
                return [
                    new Mt(Math.trunc(t1.position[0] + r * i), Math.trunc(t1.position[1] + n * i)),
                    new Mt(Math.trunc(t1.position[0] - r * i), Math.trunc(t1.position[1] - n * i))
                ];
            }
            next() {
                this.index++;
            }
            valid() {
                return this.index < this.feature.vertices.length;
            }
        }
        class Ac {
            constructor(t1, e, r, n, i, s){
                if (this.vertices = new Array, this.vertexProps = new Array, this.edges = new Array, this.edgeProps = new Array, this._tmpVec2 = [
                    ct(),
                    ct(),
                    ct(),
                    ct(),
                    ct(),
                    ct(),
                    ct()
                ], this.id = t1, this.heightRange = {
                    min: r,
                    max: r
                }, this.safeArea = e, this.constantHeight = r, null == this.constantHeight && (null != this.constantHeight || 0 !== n.length)) {
                    this.vertices = n, this.edges = i, this.edges = this.edges.filter((t1)=>{
                        return t1.a < this.vertices.length && t1.b < this.vertices.length && !((e = this.vertices[t1.a].position)[0] === (r = this.vertices[t1.b].position)[0] && e[1] === r[1]);
                        //TURBOPACK unreachable
                        ;
                        var e, r;
                    }), this.heightRange = {
                        min: Number.POSITIVE_INFINITY,
                        max: Number.NEGATIVE_INFINITY
                    };
                    for (const t1 of this.vertices)this.vertexProps.push({
                        dir: ht(0, 0)
                    }), this.heightRange.min = Math.min(this.heightRange.min, t1.height), this.heightRange.max = Math.max(this.heightRange.max, t1.height);
                    for (const t1 of this.edges){
                        const e = this.vertices[t1.a].position, r = this.vertices[t1.b].position, n = ft(ct(), r, e), i = yt(n), s = mt(ct(), n, 1 / i);
                        this.edgeProps.push({
                            vec: n,
                            dir: s,
                            len: i
                        });
                        const a = this.vertexProps[t1.a].dir, o = this.vertexProps[t1.b].dir;
                        dt(a, a, s), dt(o, o, s);
                    }
                    for (const t1 of this.vertexProps)0 === t1.dir[0] && 0 === t1.dir[1] || gt(t1.dir, t1.dir);
                    this.tessellate(s);
                }
            }
            pointElevation(t1) {
                if (null != this.constantHeight) return this.constantHeight;
                const e = this.getClosestEdge(t1);
                if (null == e) return 0;
                const [r, n] = e;
                return dr(this.vertices[this.edges[r].a].height, this.vertices[this.edges[r].b].height, n);
            }
            computeSlopeNormal(t1, e) {
                const r = this.getClosestEdge(t1);
                if (!r) return M(0, 0, 1);
                const n = r[0], i = this.edges[n], s = this.edgeProps[n].vec, a = M(s[0], s[1], (this.vertices[i.b].height - this.vertices[i.a].height) * e), o = M(a[1], -a[0], 0);
                U(o, o, a);
                const l = I(o);
                return l > 0 ? V(o, o, 1 / l) : S(o, 0, 0, 1);
            }
            getSafeArea() {
                return this.safeArea;
            }
            isTunnel() {
                return this.heightRange.max <= -5;
            }
            getClosestEdge(t1) {
                if (0 === this.edges.length) return;
                let e = 0, r = Number.POSITIVE_INFINITY, n = 0;
                const [i, s, a, o, l, u, c] = this._tmpVec2;
                pt(c, t1.x, t1.y);
                const h = new dc(c, null);
                for(let t1 = 0; t1 < this.edges.length; t1++){
                    const p = this.edges[t1], d = this.edgeProps[t1].dir;
                    h.dir = d;
                    const f = this.vertices[p.a].position, m = this.vertices[p.b].position, y = h.intersectsPlane(f, this.vertexProps[p.a].dir, i), g = h.intersectsPlane(m, this.vertexProps[p.b].dir, s);
                    if (!y || !g) continue;
                    ft(a, s, i), ft(o, c, i);
                    const x = xt(a, a), v = x > 0 ? xt(o, a) / x : 0, b = Dt(v, 0, 1), w = Math.abs((v - b) * this.edgeProps[t1].len);
                    ft(l, c, f), pt(u, d[1], -d[0]);
                    const _ = w + Math.abs(xt(l, u));
                    _ < r && (e = t1, r = _, n = b);
                }
                return [
                    e,
                    n
                ];
            }
            tessellate(t1) {
                const e = _(), r = _(), n = _(), i = _();
                for(let s = this.edges.length - 1; s >= 0; --s){
                    const a = this.edges[s].a, o = this.edges[s].b, { position: l, height: u, extent: c } = this.vertices[a], { position: h, height: p, extent: d } = this.vertices[o], f = this.vertexProps[a].dir, m = this.vertexProps[o].dir;
                    if (S(e, l[0] / t1, l[1] / t1, u), S(r, h[0] / t1, h[1] / t1, p), S(n, f[1], -f[0], 0), V(n, n, c), S(i, m[1], -m[0], 0), V(i, i, d), this.distSqLines(M(e[0] + .5 * n[0], e[1] + .5 * n[1], e[2] + .5 * n[2]), M(r[0] - .5 * i[0], r[1] - .5 * i[1], r[2] - .5 * i[2]), M(e[0] - .5 * n[0], e[1] - .5 * n[1], e[2] - .5 * n[2]), M(r[0] + .5 * i[0], r[1] + .5 * i[1], r[2] + .5 * i[2])) <= .0025000000000000005) continue;
                    const y = this.vertices.length, g = dt(ct(), l, h);
                    this.vertices.push({
                        position: mt(g, g, .5),
                        height: .5 * (u + p),
                        extent: .5 * (c + d)
                    });
                    const x = dt(ct(), f, m);
                    this.vertexProps.push({
                        dir: gt(x, x)
                    }), this.edges.splice(s, 1), this.edgeProps.splice(s, 1), this.edges.push({
                        a,
                        b: y
                    }), this.edges.push({
                        a: y,
                        b: o
                    });
                    const v = ft(ct(), this.vertices[y].position, l), b = yt(v), w = {
                        vec: v,
                        dir: mt(ct(), v, 1 / b),
                        len: b
                    };
                    this.edgeProps.push(w), this.edgeProps.push(w);
                }
            }
            distSqLines(t1, e, r, n) {
                const i = z(_(), e, t1), s = z(_(), n, r), a = z(_(), t1, r), o = O(i, i), l = O(i, s), u = O(i, a), c = O(s, s), h = O(s, a), p = o * c - l * l;
                if (0 === p) return D(N(i, r, n, O(a, s) / O(s, s)), t1);
                const d = (o * h - l * u) / p;
                return D(N(i, t1, e, (l * h - u * c) / p), N(s, r, n, d));
            }
        }
        class Ic {
            static parseFrom(t1, e) {
                const r = pc.parse(t1);
                if (!r) return [];
                let { vertices: n, features: i } = r;
                const s = 1 / ju(e);
                i.sort((t1, e)=>t1.id - e.id), n.sort((t1, e)=>t1.id - e.id || t1.idx - e.idx), n = n.filter((t1, e, r)=>e === r.findIndex((e)=>e.id === t1.id && e.idx === t1.idx));
                const a = new Array;
                let o = 0;
                const l = n.length;
                for (const t1 of i){
                    if (t1.constantHeight) {
                        a.push(new Ac(t1.id, t1.bounds, t1.constantHeight));
                        continue;
                    }
                    for(; o !== l && n[o].id < t1.id;)o++;
                    if (o === l || n[o].id !== t1.id) continue;
                    const e = new Array, r = new Array, i = o;
                    for(; o !== l && n[o].id === t1.id;){
                        const t1 = n[o];
                        if (e.push({
                            position: t1.position,
                            height: t1.height,
                            extent: t1.extent
                        }), o !== i && n[o - 1].idx === t1.idx - 1) {
                            const t1 = o - i;
                            r.push({
                                a: t1 - 1,
                                b: t1
                            });
                        }
                        o++;
                    }
                    a.push(new Ac(t1.id, t1.bounds, void 0, e, r, s));
                }
                return a;
            }
            static getElevationFeature(t1, e) {
                if (!e) return;
                const r = +t1.properties[ac];
                return Number.isNaN(r) ? void 0 : e.find((t1)=>t1.id === r);
            }
        }
        class Mc {
            constructor(t1, e){
                this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t1.equals(e) || (this.zScale = Math.pow(2, e.z - t1.z), this.xOffset = (t1.x * this.zScale - e.x) * jn, this.yOffset = (t1.y * this.zScale - e.y) * jn);
            }
            constantElevation(t1, e) {
                if (null != t1.constantHeight) return this.computeBiasedHeight(t1.constantHeight, e);
            }
            pointElevation(t1, e, r) {
                const n = this.constantElevation(e, r);
                return null != n ? n : (t1.x = t1.x * this.zScale + this.xOffset, t1.y = t1.y * this.zScale + this.yOffset, this.computeBiasedHeight(e.pointElevation(t1), r));
            }
            computeBiasedHeight(t1, e) {
                return e <= 0 ? t1 : t1 + e * Ct(0, e, t1 >= 0 ? t1 : Math.abs(.5 * t1));
            }
        }
        Qs(Ac, "ElevationFeature");
        class Sc {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.projection = t1.projection, this.layoutVertexArray = new No, this.indexArray = new ll, this.segments = new Ol, this.programConfigurations = new fu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.elevationMode = this.layers[0].layout.get("circle-elevation-reference"), this.hasElevation = !1, "none" !== this.elevationMode && (this.elevatedLayoutVertexArray = new $o), this.worldview = t1.worldview, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {}
            updateAppearances(t1, e, r, n) {}
            populate(t1, e, r, n) {
                const i = this.layers[0], s = [];
                let a = null;
                "circle" === i.type && (a = i.layout.get("circle-sort-key"));
                for (const { feature: i, id: o, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = Ku(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, {
                        worldview: this.worldview,
                        activeFloors: e.activeFloors
                    }), c, r)) continue;
                    const h = a ? a.evaluate(c, {}, r) : void 0, p = {
                        id: o,
                        properties: i.properties,
                        type: i.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : Ju(i, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    s.push(p);
                }
                a && s.sort((t1, e)=>t1.sortKey - e.sortKey);
                let o = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new Ko, o = n.projection);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n, l = t1[s].feature;
                    this.addFeature(n, i, s, e.availableImages, r, o, e.brightness, e.elevationFeatures), e.featureIndex.insert(l, i, s, a, this.index);
                }
                this.hasElevation || (this.elevatedLayoutVertexArray = void 0);
            }
            update(t1, e, r, n, i, s, a) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, this.worldview);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Cl.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Ll.members)), this.elevatedLayoutVertexArray && (this.elevatedLayoutVertexBuffer = t1.createVertexBuffer(this.elevatedLayoutVertexArray, Rl.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy());
            }
            addFeature(t1, e, r, n, i, s, a, o) {
                let l;
                "none" !== this.elevationMode && (l = Ic.getElevationFeature(t1, o));
                for (const r of e)for (const e of r){
                    const r = e.x, n = e.y;
                    if (r < 0 || r >= jn || n < 0 || n >= jn) continue;
                    if (s) {
                        const t1 = s.projectTilePoint(r, n, i), e = s.upVector(i, r, n);
                        this.addGlobeExtVertex(t1, e), this.addGlobeExtVertex(t1, e), this.addGlobeExtVertex(t1, e), this.addGlobeExtVertex(t1, e);
                    }
                    const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), o = a.vertexLength;
                    if (this.addCircleVertex(r, n, -1, -1), this.addCircleVertex(r, n, 1, -1), this.addCircleVertex(r, n, 1, 1), this.addCircleVertex(r, n, -1, 1), "none" !== this.elevationMode) {
                        const t1 = l ? l.pointElevation(new Mt(r, n)) : 0;
                        this.hasElevation = this.hasElevation || 0 !== t1;
                        for(let e = 0; e < 4; e++)this.elevatedLayoutVertexArray.emplaceBack(t1);
                    }
                    this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n, i, a, void 0, this.worldview);
            }
            addCircleVertex(t1, e, r, n) {
                this.layoutVertexArray.emplaceBack(2 * t1 + (r + 1) / 2, 2 * e + (n + 1) / 2);
            }
            addGlobeExtVertex(t1, e) {
                const r = 16384;
                this.globeExtVertexArray.emplaceBack(t1.x, t1.y, t1.z, e[0] * r, e[1] * r, e[2] * r);
            }
        }
        function Pc(t1, e) {
            for(let r = 0; r < t1.length; r++)if (Lc(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (Lc(t1, e[r])) return !0;
            return !!Tc(t1, e);
        }
        function zc(t1, e, r) {
            return !!Lc(t1, e) || !!Dc(e, t1, r);
        }
        function Bc(t1, e) {
            if (1 === t1.length) return Rc(e, t1[0]);
            for(let r = 0; r < e.length; r++){
                const n = e[r];
                for(let e = 0; e < n.length; e++)if (Lc(t1, n[e])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (Rc(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (Tc(t1, e[r])) return !0;
            return !1;
        }
        function kc(t1, e, r) {
            if (t1.length > 1) {
                if (Tc(t1, e)) return !0;
                for(let n = 0; n < e.length; n++)if (Dc(e[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (Dc(t1[n], e, r)) return !0;
            return !1;
        }
        function Tc(t1, e) {
            if (0 === t1.length || 0 === e.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e.length - 1; t1++)if (Vc(n, i, e[t1], e[t1 + 1])) return !0;
            }
            return !1;
        }
        function Vc(t1, e, r, n) {
            return Wt(t1, r, n) !== Wt(e, r, n) && Wt(t1, e, r) !== Wt(t1, e, n);
        }
        function Ec(t1, e, r) {
            return (t1.x - r.x) * (e.y - r.y) - (t1.y - r.y) * (e.x - r.x);
        }
        function Fc(t1, e, r, n) {
            const i = Ec(t1, e, n), s = Ec(t1, e, r);
            if (Math.sign(i) === Math.sign(s)) return;
            const a = Ec(r, n, t1), o = a + s - i;
            return Math.sign(a) !== Math.sign(o) ? [
                a / (a - o),
                s / (s - i)
            ] : void 0;
        }
        function Dc(t1, e, r) {
            const n = r * r;
            if (1 === e.length) return t1.distSqr(e[0]) < n;
            for(let r = 1; r < e.length; r++)if (Cc(t1, e[r - 1], e[r]) < n) return !0;
            return !1;
        }
        function Cc(t1, e, r) {
            const n = e.distSqr(r);
            if (0 === n) return t1.distSqr(e);
            const i = ((t1.x - e.x) * (r.x - e.x) + (t1.y - e.y) * (r.y - e.y)) / n;
            return t1.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
        }
        function Rc(t1, e) {
            let r, n, i, s = !1;
            for(let a = 0; a < t1.length; a++){
                r = t1[a];
                for(let t1 = 0, a = r.length - 1; t1 < r.length; a = t1++)n = r[t1], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }
            return s;
        }
        function Lc(t1, e) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const s = t1[n], a = t1[i];
                s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);
            }
            return r;
        }
        function Oc(t1, e, r, n, i) {
            for (const s of t1)if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;
            const s = [
                new Mt(e, r),
                new Mt(e, i),
                new Mt(n, i),
                new Mt(n, r)
            ];
            if (t1.length > 2) {
                for (const e of s)if (Lc(t1, e)) return !0;
            }
            for(let e = 0; e < t1.length - 1; e++)if (Uc(t1[e], t1[e + 1], s)) return !0;
            return !1;
        }
        function Uc(t1, e, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e.x < n.x || t1.x > i.x && e.x > i.x || t1.y < n.y && e.y < n.y || t1.y > i.y && e.y > i.y) return !1;
            const s = Wt(t1, e, r[0]);
            return s !== Wt(t1, e, r[1]) || s !== Wt(t1, e, r[2]) || s !== Wt(t1, e, r[3]);
        }
        function Nc(t1, e, r, n, i, s) {
            let a = e.y - t1.y, o = t1.x - e.x;
            if (s = s || 0) {
                const t1 = a * a + o * o;
                if (0 === t1) return !0;
                const e = Math.sqrt(t1);
                a /= e, o /= e;
            }
            return !((r.x - t1.x) * a + (r.y - t1.y) * o - s < 0 || (n.x - t1.x) * a + (n.y - t1.y) * o - s < 0 || (i.x - t1.x) * a + (i.y - t1.y) * o - s < 0);
        }
        function jc(t1, e, r, n, i, s, a) {
            return !(Nc(t1, e, n, i, s, a) || Nc(e, r, n, i, s, a) || Nc(r, t1, n, i, s, a) || Nc(n, i, t1, e, r, a) || Nc(i, s, t1, e, r, a) || Nc(s, n, t1, e, r, a));
        }
        function Gc(t1, e, r) {
            const n = e.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t1);
        }
        function $c(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function qc(t1, e, r, n, i) {
            if (!e[0] && !e[1]) return t1;
            const s = Mt.convert(e)._mult(i);
            "viewport" === r && s._rotate(-n);
            const a = [];
            for(let e = 0; e < t1.length; e++)a.push(t1[e].sub(s));
            return a;
        }
        function Xc(t1, e, r, n) {
            const i = Mt.convert(t1)._mult(n);
            return "viewport" === e && i._rotate(-r), i;
        }
        let Hc, Zc;
        function Wc(t1, e, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
            return [
                t1 * n - 2 * Math.PI * 6378137 / 2,
                e * n - 2 * Math.PI * 6378137 / 2
            ];
        }
        Qs(Sc, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        class Yc {
            constructor(t1, e, r){
                this.z = t1, this.x = e, this.y = r, this.key = Qc(0, t1, t1, e, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            isChildOf(t1) {
                const e = this.z - t1.z;
                return 0 === t1.z || t1.z < this.z && t1.x === this.x >> e && t1.y === this.y >> e;
            }
            url(t1, e) {
                const r = function(t1, e, r) {
                    var n = Wc(256 * t1, 256 * (e = Math.pow(2, r) - e - 1), r), i = Wc(256 * (t1 + 1), 256 * (e + 1), r);
                    return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
                }(this.x, this.y, this.z), n = function(t1, e, r) {
                    let n, i = "";
                    for(let s = t1; s > 0; s--)n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class Jc {
            constructor(t1, e){
                this.wrap = t1, this.canonical = e, this.key = Qc(t1, e.z, e.z, e.x, e.y);
            }
        }
        class Kc {
            constructor(t1, e, r, n, i){
                this.overscaledZ = t1, this.wrap = e, this.canonical = new Yc(r, +n, +i), this.key = 0 === e && t1 === r ? this.canonical.key : Qc(e, t1, r, n, i);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                const e = this.canonical.z - t1;
                return t1 > this.canonical.z ? new Kc(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Kc(t1, this.wrap, t1, this.canonical.x >> e, this.canonical.y >> e);
            }
            calculateScaledKey(t1, e = !0) {
                if (this.overscaledZ === t1 && e) return this.key;
                if (t1 > this.canonical.z) return Qc(this.wrap * +e, t1, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r = this.canonical.z - t1;
                    return Qc(this.wrap * +e, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
                }
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.z < this.canonical.z && t1.canonical.x === this.canonical.x >> e && t1.canonical.y === this.canonical.y >> e;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new Kc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new Kc(e, this.wrap, e, r, n),
                    new Kc(e, this.wrap, e, r + 1, n),
                    new Kc(e, this.wrap, e, r, n + 1),
                    new Kc(e, this.wrap, e, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new Kc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new Kc(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new Jc(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function Qc(t1, e, r, n, i) {
            const s = 1 << Math.min(r, 22);
            let a = s * (i % s) + n % s;
            return t1 && r < 22 && (a += s * s * ((t1 < 0 ? -2 * t1 - 1 : 2 * t1) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);
        }
        const th = [
            (t1)=>{
                let e = t1.canonical.x - 1, r = t1.wrap;
                return e < 0 && (e = (1 << t1.canonical.z) - 1, r--), new Kc(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>{
                let e = t1.canonical.x + 1, r = t1.wrap;
                return e === 1 << t1.canonical.z && (e = 0, r++), new Kc(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>new Kc(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, (0 === t1.canonical.y ? 1 << t1.canonical.z : t1.canonical.y) - 1),
            (t1)=>new Kc(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y === (1 << t1.canonical.z) - 1 ? 0 : t1.canonical.y + 1)
        ];
        Qs(Yc, "CanonicalTileID"), Qs(Kc, "OverscaledTileID", {
            omit: [
                "projMatrix",
                "expandedProjMatrix"
            ]
        });
        const eh = Oo([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: rh } = eh, nh = Oo([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var ih = Oo([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        function sh(t1) {
            return t1 * bu / Pu;
        }
        const ah = [
            new wc([
                Au,
                Au,
                Au
            ], [
                Iu,
                Iu,
                Iu
            ]),
            new wc([
                Au,
                Au,
                Au
            ], [
                0,
                0,
                Iu
            ]),
            new wc([
                0,
                Au,
                Au
            ], [
                Iu,
                0,
                Iu
            ]),
            new wc([
                Au,
                0,
                Au
            ], [
                0,
                Iu,
                Iu
            ]),
            new wc([
                0,
                0,
                Au
            ], [
                Iu,
                Iu,
                Iu
            ])
        ];
        function oh(t1, e, r, n = !0) {
            const i = V([], t1._camera.position, t1.worldSize), s = [
                e,
                r,
                1,
                1
            ];
            tt(s, s, t1.pixelMatrixInverse), J(s, s, 1 / s[3]);
            const a = L([], H([], s, i)), o = t1.globeMatrix, l = [
                o[12],
                o[13],
                o[14]
            ], u = H([], l, i), c = I(u), h = L([], u), p = t1.worldSize / (2 * Math.PI), d = O(h, a), f = Math.asin(p / c);
            if (f < Math.acos(d)) {
                if (!n) return null;
                const t1 = [], e = [];
                V(t1, a, c / d), L(e, H(e, t1, u)), L(a, P(a, u, V(a, e, Math.tan(f) * c)));
            }
            const m = [];
            new fc(i, a).closestPointOnSphere(l, p, m);
            const y = L([], ee(o, 0)), g = L([], ee(o, 1)), x = L([], ee(o, 2)), v = O(y, m), b = O(g, m), w = O(x, m), _ = kt(Math.asin(-b / p));
            let A = kt(Math.atan2(v, w));
            A = t1.center.lng + function(t1, e) {
                const r = (e - t1 + 180) % 360 - 180;
                return r < -180 ? r + 360 : r;
            }(t1.center.lng, A);
            const M = Vu(A), S = Dt(Eu(_), 0, 1);
            return new Gu(M, S);
        }
        class lh {
            constructor(t1, e, r){
                this.a = H([], t1, r), this.b = H([], e, r), this.center = r;
                const n = L([], this.a), i = L([], this.b);
                this.angle = Math.acos(O(n, i));
            }
        }
        function uh(t1, e) {
            if (0 === t1.angle) return null;
            let r;
            return r = 0 === t1.a[e] ? 1 / t1.angle * .5 * Math.PI : 1 / t1.angle * Math.atan(t1.b[e] / t1.a[e] / Math.sin(t1.angle) - 1 / Math.tan(t1.angle)), r < 0 || r > 1 ? null : function(t1, e, r, n) {
                const i = Math.sin(r);
                return t1 * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
            }(t1.a[e], t1.b[e], t1.angle, Dt(r, 0, 1)) + t1.center[e];
        }
        function ch(t1) {
            if (t1.z <= 1) return ah[t1.z + 2 * t1.y + t1.x];
            const e = mh(fh(t1));
            return wc.fromPoints(e);
        }
        function hh(t1, e, r) {
            return V(t1, t1, 1 - r), E(t1, t1, e, r);
        }
        function ph(t1, e, r) {
            for (const n of t1)j(n, n, e), V(n, n, r);
        }
        function dh(t1, e, r, n) {
            const i = e / t1.worldSize, s = t1.globeMatrix;
            if (r.z <= 1) {
                const t1 = ch(r).getCorners();
                return ph(t1, s, i), wc.fromPoints(t1);
            }
            const a = fh(r, n), o = mh(a, bu + sh(t1._tileCoverLift));
            ph(o, s, i);
            const l = Number.MAX_VALUE, u = [
                -l,
                -l,
                -l
            ], c = [
                l,
                l,
                l
            ];
            if (a.contains(t1.center)) {
                for (const t1 of o)k(c, c, t1), T(u, u, t1);
                u[2] = 0;
                const e = t1.point, r = [
                    e.x * i,
                    e.y * i,
                    0
                ];
                return k(c, c, r), T(u, u, r), new wc(c, u);
            }
            if (t1._tileCoverLift > 0) {
                for (const t1 of o)k(c, c, t1), T(u, u, t1);
                return new wc(c, u);
            }
            const h = [
                s[12] * i,
                s[13] * i,
                s[14] * i
            ], p = a.getCenter(), d = Dt(t1.center.lat, -85.051129, Lu), f = Dt(p.lat, -85.051129, Lu), m = Vu(t1.center.lng), y = Eu(d);
            let g = m - Vu(p.lng);
            const x = y - Eu(f);
            g > .5 ? g -= 1 : g < -.5 && (g += 1);
            let v = 0;
            Math.abs(g) > Math.abs(x) ? v = g >= 0 ? 1 : 3 : (v = x >= 0 ? 0 : 2, E(h, h, [
                s[4] * i,
                s[5] * i,
                s[6] * i
            ], -Math.sin(Bt(x >= 0 ? a.getSouth() : a.getNorth())) * bu));
            const b = o[v], w = o[(v + 1) % 4], _ = new lh(b, w, h), A = [
                uh(_, 0) || b[0],
                uh(_, 1) || b[1],
                uh(_, 2) || b[2]
            ], I = Ih(t1.zoom);
            if (I > 0) {
                const n = function({ x: t1, y: e, z: r }, n, i, s, a) {
                    const o = 1 / (1 << r);
                    let l = t1 * o, u = l + o, c = e * o, h = c + o, p = 0;
                    const d = (l + u) / 2 - s;
                    return d > .5 ? p = -1 : d < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [
                        [
                            l,
                            h,
                            0
                        ],
                        [
                            u,
                            h,
                            0
                        ],
                        [
                            u,
                            c,
                            0
                        ],
                        [
                            l,
                            c,
                            0
                        ]
                    ];
                }(r, e, t1._pixelsPerMercatorPixel, m, y);
                for(let t1 = 0; t1 < o.length; t1++)hh(o[t1], n[t1], I);
                const i = P([], n[v], n[(v + 1) % 4]);
                V(i, i, .5), hh(A, i, I);
            }
            for (const t1 of o)k(c, c, t1), T(u, u, t1);
            return c[2] = Math.min(b[2], w[2]), k(c, c, A), T(u, u, A), new wc(c, u);
        }
        function fh({ x: t1, y: e, z: r }, n = !1) {
            const i = 1 / (1 << r), s = new Bu(Du(t1 * i), e === (1 << r) - 1 && n ? -90 : Cu((e + 1) * i)), a = new Bu(Du((t1 + 1) * i), 0 === e && n ? 90 : Cu(e * i));
            return new ku(s, a);
        }
        function mh(t1, e = bu) {
            const r = Bt(t1.getNorth()), n = Bt(t1.getSouth()), i = Math.cos(r), s = Math.cos(n), a = Math.sin(r), o = Math.sin(n), l = t1.getWest(), u = t1.getEast();
            return [
                Mu(s, o, l, e),
                Mu(s, o, u, e),
                Mu(i, a, u, e),
                Mu(i, a, l, e)
            ];
        }
        function yh(t1, e, r, n) {
            const i = 1 << r.z, s = (t1 / jn + r.x) / i;
            return Su(Cu((e / jn + r.y) / i), Du(s), n);
        }
        function gh({ min: t1, max: e }) {
            return 16383 / Math.max(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
        }
        const xh = new Float64Array(16);
        function vh(t1) {
            const e = gh(t1), r = g(xh, [
                e,
                e,
                e
            ]);
            return p(r, r, R([], t1.min));
        }
        function bh(t1) {
            const e = function(t1, e) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = e[0], t1[13] = e[1], t1[14] = e[2], t1[15] = 1, t1;
            }(xh, t1.min), r = 1 / gh(t1);
            return d(e, e, [
                r,
                r,
                r
            ]);
        }
        function wh(t1) {
            const e = jn / (2 * Math.PI);
            return t1 / (2 * Math.PI) / e;
        }
        function _h(t1, e) {
            return jn / (512 * Math.pow(2, t1)) * gh(ch(e));
        }
        function Ah(t1, e, r, n, i) {
            const s = wh(r), a = [
                t1,
                e,
                -r / (2 * Math.PI)
            ], o = u(new Float64Array(16));
            return p(o, o, a), d(o, o, [
                s,
                s,
                s
            ]), f(o, o, Bt(-i)), m(o, o, Bt(-n)), o;
        }
        function Ih(t1) {
            return Ct(5, 6, t1);
        }
        function Mh(t1, e) {
            const r = Su(e.lat, e.lng), n = function(t1) {
                const e = Su(t1._center.lat, t1._center.lng);
                let r = U([], M(0, 1, 0), e);
                const n = x([], -t1.angle, e);
                r = j(r, r, n), x(n, -t1._pitch, r);
                const i = L([], e);
                return V(i, i, sh(t1.cameraToCenterDistance / t1.pixelsPerMeter)), j(i, i, n), P([], e, i);
            }(t1);
            return a = (i = z([], n, r))[0], o = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], d = (p = Math.sqrt((a * a + o * o + l * l) * (u * u + c * c + h * h))) && O(i, s) / p, Math.acos(Math.min(Math.max(d, -1), 1));
            //TURBOPACK unreachable
            ;
            var i, s, a, o, l, u, c, h, p, d;
        }
        function Sh(t1, e) {
            return Mh(t1, e) > Math.PI / 2 * 1.01;
        }
        const Ph = Bt(85), zh = Math.cos(Ph), Bh = Math.sin(Ph), kh = o(), Th = (t1)=>{
            const e = [];
            return "map" === t1.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"), "map" === t1.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"), e;
        };
        function Vh(t1, e, r, n, i, s, a, o, l) {
            if (s && t1.queryGeometry.isAboveHorizon) return !1;
            s && (l *= t1.pixelToTileUnitsFactor);
            const u = t1.tileID.canonical, c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
            for (const h of e)for (const e of h){
                const h = e.add(o), p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0, d = r.projection.projectTilePoint(h.x, h.y, u);
                if (p > 0) {
                    const t1 = r.projection.upVector(u, h.x, h.y);
                    d.x += t1[0] * c * p, d.y += t1[1] * c * p, d.z += t1[2] * c * p;
                }
                const f = s ? h : Eh(d.x, d.y, d.z, n), m = s ? t1.tilespaceRays.map((t1)=>Ch(t1, p)) : t1.queryGeometry.screenGeometry, y = tt([], [
                    d.x,
                    d.y,
                    d.z,
                    1
                ], n);
                if (!a && s ? l *= y[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / y[3]), s) {
                    const t1 = Cu((e.y / jn + u.y) / (1 << u.z));
                    l /= r.projection.pixelsPerMeter(t1, 1) / Fu(1, t1);
                }
                if (zc(m, f, l)) return !0;
            }
            return !1;
        }
        function Eh(t1, e, r, n) {
            const i = tt([], [
                t1,
                e,
                r,
                1
            ], n);
            return new Mt(i[0] / i[3], i[1] / i[3]);
        }
        const Fh = M(0, 0, 0), Dh = M(0, 0, 1);
        function Ch(t1, e) {
            const r = _();
            return Fh[2] = e, t1.intersectsPlane(Fh, Dh, r), new Mt(r[0], r[1]);
        }
        class Rh extends Sc {
        }
        let Lh, Oh, Uh, Nh;
        function jh(t1, { width: e, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e * r * n);
            return t1.width = e, t1.height = r, t1.data = i, t1;
        }
        function Gh(t1, e, r) {
            const { width: n, height: i } = e;
            n === t1.width && i === t1.height || ($h(t1, e, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, n),
                height: Math.min(t1.height, i)
            }, r, null), t1.width = n, t1.height = i, t1.data = e.data);
        }
        function $h(t1, e, r, n, i, s, a, o) {
            if (0 === i.width || 0 === i.height) return e;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const l = t1.data, u = e.data, c = 4 === s && o;
            for(let o = 0; o < i.height; o++){
                const h = ((r.y + o) * t1.width + r.x) * s, p = ((n.y + o) * e.width + n.x) * s;
                if (c) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * s + 3, r = p + t1 * s;
                    u[r + 0] = 255, u[r + 1] = 255, u[r + 2] = 255, u[r + 3] = l[e];
                }
                else if (a) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * s, r = p + t1 * s, n = new ur(l[e + 0] / 255, l[e + 1] / 255, l[e + 2] / 255, l[e + 3]).toNonPremultipliedRenderColor(a).toArray();
                    u[r + 0] = n[0], u[r + 1] = n[1], u[r + 2] = n[2], u[r + 3] = n[3];
                }
                else for(let t1 = 0; t1 < i.width * s; t1++)u[p + t1] = l[h + t1];
            }
            return e;
        }
        Qs(Rh, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class qh {
            constructor(t1, e){
                jh(this, t1, 1, e);
            }
            resize(t1) {
                Gh(this, new qh(t1), 1);
            }
            clone() {
                return new qh({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i) {
                $h(t1, e, r, n, i, 1, null);
            }
        }
        class Xh {
            constructor(t1, e){
                jh(this, t1, 4, e);
            }
            resize(t1) {
                Gh(this, new Xh(t1), 4);
            }
            replace(t1, e) {
                e ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new Xh({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i, s, a) {
                $h(t1, e, r, n, i, 4, s, a);
            }
        }
        class Hh {
            constructor(t1, e){
                this.width = t1.width, this.height = t1.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;
            }
        }
        function Zh(t1) {
            const e = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new Xh({
                width: r,
                height: n
            }), s = (r, n, s)=>{
                e[t1.evaluationKey] = s;
                const a = t1.expression.evaluate(e), o = a ? a.toNonPremultipliedRenderColor(null) : null;
                o && (i.data[r + n + 0] = Math.floor(255 * o.r), i.data[r + n + 1] = Math.floor(255 * o.g), i.data[r + n + 2] = Math.floor(255 * o.b), i.data[r + n + 3] = Math.floor(255 * o.a));
            };
            if (t1.clips) for(let e = 0, i = 0; e < n; ++e, i += 4 * r)for(let n = 0, a = 0; n < r; n++, a += 4){
                const o = n / (r - 1), { start: l, end: u } = t1.clips[e];
                s(i, a, l * (1 - o) + u * o);
            }
            else for(let t1 = 0, e = 0; t1 < r; t1++, e += 4)s(0, e, t1 / (r - 1));
            return i;
        }
        Qs(qh, "AlphaImage"), Qs(Xh, "RGBAImage");
        const Wh = Oo([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), Yh = Oo([
            {
                name: "a_road_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), Jh = Oo([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_height",
                components: 1,
                type: "Float32"
            }
        ], 4), Kh = Oo([
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ], 4);
        function Qh(t1, e, r = 2) {
            const n = e && e.length, i = n ? e[0] * r : t1.length;
            let s = tp(t1, 0, i, r, !0);
            const a = [];
            if (!s || s.next === s.prev) return a;
            let o, l, u;
            if (n && (s = function(t1, e, r, n) {
                const i = [];
                for(let r = 0, s = e.length; r < s; r++){
                    const a = tp(t1, e[r] * n, r < s - 1 ? e[r + 1] * n : t1.length, n, !1);
                    a === a.next && (a.steiner = !0), i.push(hp(a));
                }
                i.sort(op);
                for(let t1 = 0; t1 < i.length; t1++)r = lp(i[t1], r);
                return r;
            }(t1, e, s, r)), t1.length > 80 * r) {
                o = t1[0], l = t1[1];
                let e = o, n = l;
                for(let s = r; s < i; s += r){
                    const r = t1[s], i = t1[s + 1];
                    r < o && (o = r), i < l && (l = i), r > e && (e = r), i > n && (n = i);
                }
                u = Math.max(e - o, n - l), u = 0 !== u ? 32767 / u : 0;
            }
            return rp(s, a, r, o, l, u, 0), a;
        }
        function tp(t1, e, r, n, i) {
            let s;
            if (i === function(t1, e, r, n) {
                let i = 0;
                for(let s = e, a = r - n; s < r; s += n)i += (t1[a] - t1[s]) * (t1[s + 1] + t1[a + 1]), a = s;
                return i;
            }(t1, e, r, n) > 0) for(let i = e; i < r; i += n)s = _p(i / n | 0, t1[i], t1[i + 1], s);
            else for(let i = r - n; i >= e; i -= n)s = _p(i / n | 0, t1[i], t1[i + 1], s);
            return s && yp(s, s.next) && (Ap(s), s = s.next), s;
        }
        function ep(t1, e) {
            if (!t1) return t1;
            e || (e = t1);
            let r, n = t1;
            do {
                if (r = !1, n.steiner || !yp(n, n.next) && 0 !== mp(n.prev, n, n.next)) n = n.next;
                else {
                    if (Ap(n), n = e = n.prev, n === n.next) break;
                    r = !0;
                }
            }while (r || n !== e)
            return e;
        }
        function rp(t1, e, r, n, i, s, a) {
            if (!t1) return;
            !a && s && function(t1, e, r, n) {
                let i = t1;
                do {
                    0 === i.z && (i.z = cp(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                }while (i !== t1)
                i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                    let e, r = 1;
                    do {
                        let n, i = t1;
                        t1 = null;
                        let s = null;
                        for(e = 0; i;){
                            e++;
                            let a = i, o = 0;
                            for(let t1 = 0; t1 < r && (o++, a = a.nextZ, a); t1++);
                            let l = r;
                            for(; o > 0 || l > 0 && a;)0 !== o && (0 === l || !a || i.z <= a.z) ? (n = i, i = i.nextZ, o--) : (n = a, a = a.nextZ, l--), s ? s.nextZ = n : t1 = n, n.prevZ = s, s = n;
                            i = a;
                        }
                        s.nextZ = null, r *= 2;
                    }while (e > 1)
                }(i);
            }(t1, n, i, s);
            let o = t1;
            for(; t1.prev !== t1.next;){
                const l = t1.prev, u = t1.next;
                if (s ? ip(t1, n, i, s) : np(t1)) e.push(l.i, t1.i, u.i), Ap(t1), t1 = u.next, o = u.next;
                else if ((t1 = u) === o) {
                    a ? 1 === a ? rp(t1 = sp(ep(t1), e), e, r, n, i, s, 2) : 2 === a && ap(t1, e, r, n, i, s) : rp(ep(t1), e, r, n, i, s, 1);
                    break;
                }
            }
        }
        function np(t1) {
            const e = t1.prev, r = t1, n = t1.next;
            if (mp(e, r, n) >= 0) return !1;
            const i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = Math.min(i, s, a), h = Math.min(o, l, u), p = Math.max(i, s, a), d = Math.max(o, l, u);
            let f = n.next;
            for(; f !== e;){
                if (f.x >= c && f.x <= p && f.y >= h && f.y <= d && dp(i, o, s, l, a, u, f.x, f.y) && mp(f.prev, f, f.next) >= 0) return !1;
                f = f.next;
            }
            return !0;
        }
        function ip(t1, e, r, n) {
            const i = t1.prev, s = t1, a = t1.next;
            if (mp(i, s, a) >= 0) return !1;
            const o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, d = Math.min(o, l, u), f = Math.min(c, h, p), m = Math.max(o, l, u), y = Math.max(c, h, p), g = cp(d, f, e, r, n), x = cp(m, y, e, r, n);
            let v = t1.prevZ, b = t1.nextZ;
            for(; v && v.z >= g && b && b.z <= x;){
                if (v.x >= d && v.x <= m && v.y >= f && v.y <= y && v !== i && v !== a && dp(o, c, l, h, u, p, v.x, v.y) && mp(v.prev, v, v.next) >= 0) return !1;
                if (v = v.prevZ, b.x >= d && b.x <= m && b.y >= f && b.y <= y && b !== i && b !== a && dp(o, c, l, h, u, p, b.x, b.y) && mp(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            for(; v && v.z >= g;){
                if (v.x >= d && v.x <= m && v.y >= f && v.y <= y && v !== i && v !== a && dp(o, c, l, h, u, p, v.x, v.y) && mp(v.prev, v, v.next) >= 0) return !1;
                v = v.prevZ;
            }
            for(; b && b.z <= x;){
                if (b.x >= d && b.x <= m && b.y >= f && b.y <= y && b !== i && b !== a && dp(o, c, l, h, u, p, b.x, b.y) && mp(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            return !0;
        }
        function sp(t1, e) {
            let r = t1;
            do {
                const n = r.prev, i = r.next.next;
                !yp(n, i) && gp(n, r, r.next, i) && bp(n, i) && bp(i, n) && (e.push(n.i, r.i, i.i), Ap(r), Ap(r.next), r = t1 = i), r = r.next;
            }while (r !== t1)
            return ep(r);
        }
        function ap(t1, e, r, n, i, s) {
            let a = t1;
            do {
                let t1 = a.next.next;
                for(; t1 !== a.prev;){
                    if (a.i !== t1.i && fp(a, t1)) {
                        let o = wp(a, t1);
                        return a = ep(a, a.next), o = ep(o, o.next), rp(a, e, r, n, i, s, 0), void rp(o, e, r, n, i, s, 0);
                    }
                    t1 = t1.next;
                }
                a = a.next;
            }while (a !== t1)
        }
        function op(t1, e) {
            let r = t1.x - e.x;
            return 0 === r && (r = t1.y - e.y, 0 === r) && (r = (t1.next.y - t1.y) / (t1.next.x - t1.x) - (e.next.y - e.y) / (e.next.x - e.x)), r;
        }
        function lp(t1, e) {
            const r = function(t1, e) {
                let r = e;
                const n = t1.x, i = t1.y;
                let s, a = -1 / 0;
                if (yp(t1, r)) return r;
                do {
                    if (yp(t1, r.next)) return r.next;
                    if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
                        const t1 = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (t1 <= n && t1 > a && (a = t1, s = r.x < r.next.x ? r : r.next, t1 === n)) return s;
                    }
                    r = r.next;
                }while (r !== e)
                if (!s) return null;
                const o = s, l = s.x, u = s.y;
                let c = 1 / 0;
                r = s;
                do {
                    if (n >= r.x && r.x >= l && n !== r.x && pp(i < u ? n : a, i, l, u, i < u ? a : n, i, r.x, r.y)) {
                        const e = Math.abs(i - r.y) / (n - r.x);
                        bp(r, t1) && (e < c || e === c && (r.x > s.x || r.x === s.x && up(s, r))) && (s = r, c = e);
                    }
                    r = r.next;
                }while (r !== o)
                return s;
            }(t1, e);
            if (!r) return e;
            const n = wp(r, t1);
            return ep(n, n.next), ep(r, r.next);
        }
        function up(t1, e) {
            return mp(t1.prev, t1, e.prev) < 0 && mp(e.next, t1, t1.next) < 0;
        }
        function cp(t1, e, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function hp(t1) {
            let e = t1, r = t1;
            do {
                (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
            }while (e !== t1)
            return r;
        }
        function pp(t1, e, r, n, i, s, a, o) {
            return (i - a) * (e - o) >= (t1 - a) * (s - o) && (t1 - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o);
        }
        function dp(t1, e, r, n, i, s, a, o) {
            return !(t1 === a && e === o) && pp(t1, e, r, n, i, s, a, o);
        }
        function fp(t1, e) {
            return t1.next.i !== e.i && t1.prev.i !== e.i && !function(t1, e) {
                let r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e.i && r.next.i !== e.i && gp(r, r.next, t1, e)) return !0;
                    r = r.next;
                }while (r !== t1)
                return !1;
            }(t1, e) && (bp(t1, e) && bp(e, t1) && function(t1, e) {
                let r = t1, n = !1;
                const i = (t1.x + e.x) / 2, s = (t1.y + e.y) / 2;
                do {
                    r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                }while (r !== t1)
                return n;
            }(t1, e) && (mp(t1.prev, t1, e.prev) || mp(t1, e.prev, e)) || yp(t1, e) && mp(t1.prev, t1, t1.next) > 0 && mp(e.prev, e, e.next) > 0);
        }
        function mp(t1, e, r) {
            return (e.y - t1.y) * (r.x - e.x) - (e.x - t1.x) * (r.y - e.y);
        }
        function yp(t1, e) {
            return t1.x === e.x && t1.y === e.y;
        }
        function gp(t1, e, r, n) {
            const i = vp(mp(t1, e, r)), s = vp(mp(t1, e, n)), a = vp(mp(r, n, t1)), o = vp(mp(r, n, e));
            return i !== s && a !== o || !(0 !== i || !xp(t1, r, e)) || !(0 !== s || !xp(t1, n, e)) || !(0 !== a || !xp(r, t1, n)) || !(0 !== o || !xp(r, e, n));
        }
        function xp(t1, e, r) {
            return e.x <= Math.max(t1.x, r.x) && e.x >= Math.min(t1.x, r.x) && e.y <= Math.max(t1.y, r.y) && e.y >= Math.min(t1.y, r.y);
        }
        function vp(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function bp(t1, e) {
            return mp(t1.prev, t1, t1.next) < 0 ? mp(t1, e, t1.next) >= 0 && mp(t1, t1.prev, e) >= 0 : mp(t1, e, t1.prev) < 0 || mp(t1, t1.next, e) < 0;
        }
        function wp(t1, e) {
            const r = Ip(t1.i, t1.x, t1.y), n = Ip(e.i, e.x, e.y), i = t1.next, s = e.prev;
            return t1.next = e, e.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
        }
        function _p(t1, e, r, n) {
            const i = Ip(t1, e, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function Ap(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function Ip(t1, e, r) {
            return {
                i: t1,
                x: e,
                y: r,
                prev: null,
                next: null,
                z: 0,
                prevZ: null,
                nextZ: null,
                steiner: !1
            };
        }
        function Mp(t1, e) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, s;
            for(let e = 0; e < r; e++){
                const r = Yt(t1[e]);
                0 !== r && (t1[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                    t1[e]
                ]) : i.push(t1[e]));
            }
            if (i && n.push(i), e > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e || (un(n[t1], e, 1, n[t1].length - 1, Sp), n[t1] = n[t1].slice(0, e));
            return n;
        }
        function Sp(t1, e) {
            return e.area - t1.area;
        }
        function Pp(t1, e, r = 1) {
            if (!t1) return null;
            const n = "string" == typeof t1 ? Or.from(t1).getPrimary() : t1.getPrimary(), i = "string" == typeof t1 ? null : t1.getSecondary();
            for (const t1 of [
                n,
                i
            ]){
                if (!t1) continue;
                const n = t1.id.toString();
                e.has(n) || e.set(n, []), t1.scaleSelf(r), e.get(n).push(t1);
            }
            return {
                primary: n.toString(),
                secondary: i ? i.toString() : null
            };
        }
        function zp(t1, e, r, n) {
            const i = n.patternDependencies;
            let s = !1;
            for (const n of e){
                const e = n.paint.get(`${t1}-pattern`);
                e.isConstant() || (s = !0), Pp(e.constantOr(null), i, r) && (s = !0);
            }
            return s;
        }
        function Bp(t1, e, r, n, i, s) {
            const a = s.patternDependencies;
            for (const o of e){
                const e = o.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e.kind) {
                    let t1 = e.evaluate({
                        zoom: n
                    }, r, {}, s.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1;
                    const l = Pp(t1, a, i);
                    if (!l) continue;
                    const { primary: u, secondary: c } = l;
                    u && (r.patterns[o.id] = [
                        u,
                        c
                    ].filter(Boolean));
                }
            }
            return r;
        }
        class kp {
            constructor(){
                this.portals = [];
            }
            static isOnBorder(t1, e) {
                return t1 <= 0 && e <= 0 || t1 >= jn && e >= jn;
            }
            static evaluate(t1) {
                if (0 === t1.length) return new kp;
                let e = [];
                for (const r of t1)e.push(...r.portals);
                if (0 === e.length) return new kp;
                for (const t1 of e){
                    const e = t1.va, r = t1.vb;
                    (kp.isOnBorder(e.x, r.x) || kp.isOnBorder(e.y, r.y)) && (t1.type = "border");
                }
                const r = e.filter((t1)=>"unevaluated" !== t1.type), n = e.filter((t1)=>"unevaluated" === t1.type);
                if (0 === n.length) return new kp;
                n.sort((t1, e)=>t1.hash === e.hash ? t1.isTunnel === e.isTunnel ? 0 : t1.isTunnel ? -1 : 1 : t1.hash < e.hash ? 1 : -1), e = r.concat(n);
                let i = r.length, s = i, a = i;
                do {
                    if (s++, s === e.length || e[i].hash !== e[s].hash) {
                        if (s - i === 2) {
                            a < i && (e[a] = e[i], e[i] = null);
                            const t1 = e[a], r = e[s - 1];
                            t1.type = t1.isTunnel !== r.isTunnel ? "tunnel" : "polygon", t1.connection = {
                                a: t1.connection.a,
                                b: r.connection.a
                            }, a++;
                        }
                        i = s;
                    }
                }while (i !== e.length)
                return e.splice(a), e.sort((t1, e)=>t1.hash < e.hash ? 1 : -1), {
                    portals: e
                };
            }
        }
        Qs(kp, "ElevationPortalGraph");
        class Tp {
            constructor(t1, e, r){
                this.outPositions = t1, this.outNormals = e, this.outIndices = r, this.vertexLookup = new Map;
            }
            addVertex(t1, e, r) {
                let n = t1[2];
                null != r && (n *= r);
                const i = `${t1[0]},${t1[1]},${t1[2]},${e[0]},${e[1]},${e[2]}`, s = this.vertexLookup.get(i);
                if (null != s) return s;
                const a = this.outPositions.length;
                this.vertexLookup.set(i, a);
                const o = Math.trunc(16384 * e[0]), l = Math.trunc(16384 * e[1]), u = Math.trunc(16384 * e[2]);
                return this.outPositions.emplaceBack(t1[0], t1[1], n), this.outNormals.emplaceBack(o, l, u), a;
            }
            addTriangle(t1, e, r) {
                this.outIndices.emplaceBack(t1, e, r);
            }
            addTriangles(t1, e, r) {
                if (0 === t1.length) return;
                const n = 1 === r.length, i = _(), s = _();
                for(let a = 0; a < t1.length; a += 3){
                    const o = e[t1[a + 0]], l = e[t1[a + 1]], u = e[t1[a + 2]], c = n ? r[0] : r[t1[a + 1]], h = n ? r[0] : r[t1[a + 2]];
                    S(i, o.x, o.y, n ? r[0] : r[t1[a + 0]]);
                    const p = this.addVertex(i, s);
                    S(i, l.x, l.y, c);
                    const d = this.addVertex(i, s);
                    S(i, u.x, u.y, h);
                    const f = this.addVertex(i, s);
                    this.outIndices.emplaceBack(p, d, f);
                }
            }
            addQuad(t1, e, r, n, i, s) {
                const a = this.addVertex(t1, i, s), o = this.addVertex(e, i, s), l = this.addVertex(r, i, s), u = this.addVertex(n, i, s);
                this.addTriangle(a, o, l), this.addTriangle(l, u, a);
            }
            getVertexCount() {
                return this.outPositions.length;
            }
            clearVertexLookup() {
                this.vertexLookup.clear();
            }
        }
        class Vp {
            constructor(t1, e, r, n){
                this.unevaluatedPortals = new kp, this.bridgeFeatureSections = [], this.tunnelFeatureSections = [], this.vertexHashLookup = new Map, this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new qo, this.vertexNormals = new Xo, this.indexArray = new ll, this.tileToMeters = ju(t1), this.bridgeProgramConfigurations = new fu(e, {
                    zoom: r,
                    lut: n
                }, (t1)=>"fill-tunnel-structure-color" !== t1), this.tunnelProgramConfigurations = new fu(e, {
                    zoom: r,
                    lut: n
                }, (t1)=>"fill-bridge-guard-rail-color" !== t1);
            }
            addVertices(t1, e) {
                const r = this.unevalVertices.length;
                for(let r = 0; r < t1.length; r++)this.unevalVertices.push(t1[r]), this.unevalHeights.push(e[r]);
                return r;
            }
            addTriangles(t1, e, r) {
                const n = r ? this.unevalTunnelTriangles : this.unevalTriangles;
                for (const r of t1)n.push(r + e);
            }
            addRenderableRing(t1, e, r, n, i, s) {
                const a = [
                    new Mt(i.min.x, i.min.y),
                    new Mt(i.max.x, i.min.y),
                    new Mt(i.max.x, i.max.y),
                    new Mt(i.min.x, i.max.y)
                ];
                for(let o = 0; o < r - 1; o++){
                    const r = e + o, l = r + 1, u = this.unevalVertices[r], c = this.unevalVertices[l];
                    if (!(u.x >= i.min.x && u.x <= i.max.x && u.y >= i.min.y && u.y <= i.max.y || c.x >= i.min.x && c.x <= i.max.x && c.y >= i.min.y && c.y <= i.max.y || Uc(u, c, a))) continue;
                    if (this.isOnBorder(u.x, c.x) || this.isOnBorder(u.y, c.y)) continue;
                    const h = Vp.computeEdgeHash(this.unevalVertices[r], this.unevalVertices[l]);
                    let p, d = this.vertexHashLookup.get(Vp.computePosHash(u));
                    null != d ? p = d.next : (d = this.vertexHashLookup.get(Vp.computePosHash(c)), p = null != d ? d.prev : h), this.unevalEdges.push({
                        polygonIdx: t1,
                        a: r,
                        b: l,
                        hash: h,
                        portalHash: p,
                        isTunnel: n,
                        type: "unevaluated",
                        featureInfo: s
                    });
                }
            }
            addPortalCandidates(t1, e, r, n, i) {
                if (0 !== e.length) {
                    this.vertexHashLookup.clear();
                    for (const i of e){
                        if (0 === i.length) continue;
                        const e = i[0];
                        let s = Vp.computeEdgeHash(e[e.length - 2], e[e.length - 1]);
                        for(let i = 0; i < e.length - 1; i++){
                            const a = e[i + 0], o = e[i + 1], l = ht(o.x - a.x, o.y - a.y), u = yt(l);
                            if (0 === u) continue;
                            let c = "unevaluated";
                            const h = n.pointElevation(a), p = n.pointElevation(o);
                            Math.abs(h) < .01 && Math.abs(p) < .01 ? c = "entrance" : (this.isOnBorder(a.x, o.x) || this.isOnBorder(a.y, o.y)) && (c = "border");
                            const d = Vp.computeEdgeHash(a, o);
                            this.unevaluatedPortals.portals.push({
                                connection: {
                                    a: t1,
                                    b: void 0
                                },
                                va: a,
                                vb: o,
                                vab: l,
                                length: u,
                                hash: d,
                                isTunnel: r,
                                type: c
                            });
                            const f = Vp.computePosHash(a);
                            this.vertexHashLookup.set(f, {
                                prev: s,
                                next: d
                            }), s = d;
                        }
                    }
                }
            }
            construct(t1) {
                if (0 === this.unevalVertices.length) return;
                const e = ()=>({
                        vertexOffset: 0,
                        primitiveOffset: this.indexArray.length
                    }), r = (t1)=>{
                    t1.primitiveLength = this.indexArray.length - t1.primitiveOffset;
                }, n = new Tp(this.vertexPositions, this.vertexNormals, this.indexArray);
                this.prepareEdges(t1.portals, this.unevalEdges);
                const i = e(), s = e(), a = e(), o = (t1, e)=>{
                    t1.sort((t1, r)=>t1.type === e && r.type !== e ? -1 : t1.type !== e && r.type === e ? 1 : 0);
                    const r = t1.findIndex((t1)=>t1.type !== e);
                    return r >= 0 ? r : t1.length;
                };
                let l = 0;
                this.unevalEdges.length > 0 && (l = o(this.unevalEdges, "none"), this.constructBridgeStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
                    min: 0,
                    max: l
                }, this.tileToMeters)), r(a);
                const u = e(), c = e();
                if (this.unevalEdges.length > 0) {
                    const t1 = this.unevalEdges.splice(l), e = o(t1, "tunnel") + l;
                    this.unevalEdges.push(...t1), this.constructTunnelStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
                        min: 0,
                        max: l
                    }, {
                        min: l,
                        max: e
                    });
                }
                r(u), n.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r(c), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r(s), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [
                    -.1
                ]), r(i), this.maskSegments = Ol.simpleSegment(0, c.primitiveOffset, 0, c.primitiveLength), this.depthSegments = Ol.simpleSegment(0, s.primitiveOffset, 0, s.primitiveLength), this.renderableBridgeSegments = Ol.simpleSegment(0, a.primitiveOffset, 0, a.primitiveLength), this.renderableTunnelSegments = Ol.simpleSegment(0, u.primitiveOffset, 0, u.primitiveLength), this.shadowCasterSegments = Ol.simpleSegment(0, i.primitiveOffset, 0, i.primitiveLength);
            }
            update(t1, e, r, n, i, s, a, o) {
                this.bridgeProgramConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, o), this.tunnelProgramConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, o);
            }
            upload(t1) {
                this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t1.createVertexBuffer(this.vertexPositions, Jh.members), this.vertexBufferNormal = t1.createVertexBuffer(this.vertexNormals, Kh.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.bridgeProgramConfigurations.upload(t1), this.tunnelProgramConfigurations.upload(t1));
            }
            destroy() {
                this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableBridgeSegments.destroy(), this.renderableTunnelSegments.destroy(), this.shadowCasterSegments.destroy()), this.bridgeProgramConfigurations.destroy(), this.tunnelProgramConfigurations.destroy();
            }
            populatePaintArrays(t1, e, r, n, i) {
                const s = (s, a)=>{
                    for(let o = 0; o < a.length - 1; o++){
                        const l = a[o].featureIndex, u = a[o + 1].vertexStart, c = t1.feature(l);
                        s.populatePaintArrays(u, c, l, {}, r, e, n, void 0, i);
                    }
                };
                s(this.bridgeProgramConfigurations, this.bridgeFeatureSections), s(this.tunnelProgramConfigurations, this.tunnelFeatureSections);
            }
            computeVertexConnections(t1, e, r, n, i) {
                const s = new Map;
                for(let a = n; a < i; a++){
                    const n = r[a], i = n.a, o = n.b, l = Vp.computePosHash(t1[i]), u = Vp.computePosHash(t1[o]);
                    let c = s.get(l);
                    c || (c = {}, s.set(l, c));
                    let h = s.get(u);
                    h || (h = {}, s.set(u, h)), e[i] <= 0 && e[o] <= 0 || (c.to = o, h.from = i);
                }
                return s;
            }
            isTerminalVertex(t1, e) {
                const r = Vp.computePosHash(this.unevalVertices[t1]), n = e.get(r);
                return !n || !n.from || !n.to;
            }
            constructBridgeStructures(t1, e, r, n, i, s) {
                t1.clearVertexLookup();
                const a = this.computeVertexConnections(e, r, n, i.min, i.max), o = 1 / s, l = .5 * o, u = (t1, n)=>S(t1, e[n].x, e[n].y, r[n] * o), c = _(), h = _(), p = _(), d = _(), f = _(), m = (t1, r)=>{
                    const n = a.get(Vp.computePosHash(e[r])), i = n.from, s = n.to;
                    if (!i || !s) return;
                    u(c, i), u(h, r), u(p, s), q(d), X(c, h) || (H(f, h, c), L(d, f)), X(p, h) || (H(f, p, h), P(d, d, L(f, f)));
                    const o = W(d);
                    return o > 0 ? V(t1, d, 1 / o) : void 0;
                };
                let y = Number.POSITIVE_INFINITY;
                this.sortSubarray(n, i.min, i.max, (t1, e)=>t1.featureInfo.featureIndex - e.featureInfo.featureIndex);
                const g = _(), x = _(), v = _(), b = _(), w = _(), A = _(), I = _(), M = _(), z = _(), B = [
                    _(),
                    _(),
                    _(),
                    _()
                ], k = [
                    _(),
                    _(),
                    _(),
                    _()
                ], T = [
                    {
                        coord: new Mt(0, 0),
                        height: 0
                    },
                    {
                        coord: new Mt(0, 0),
                        height: 0
                    }
                ], E = (t1, e)=>t1 > e;
                for(let u = i.min; u < i.max; u++){
                    const i = n[u];
                    if (!i.featureInfo.guardRailEnabled) continue;
                    if (!this.prepareEdgePoints(T, e, r, i, E)) continue;
                    const [c, h] = T;
                    if (S(g, c.coord.x, c.coord.y, o * c.height), S(x, h.coord.x, h.coord.y, o * h.height), X(g, x)) continue;
                    H(v, x, g), L(v, v);
                    const p = m(M, i.a) || v, d = m(z, i.b) || v;
                    S(b, p[1], -p[0], 0), L(b, b), S(w, d[1], -d[0], 0), L(w, w), U(M, b, p), L(A, M), U(M, w, d), L(I, M), P(B[0], g, V(M, H(M, b, A), l)), P(B[1], g, V(M, P(M, b, A), l)), P(B[2], g, V(M, A, l)), B[3] = g, P(k[0], x, V(M, H(M, w, I), l)), P(k[1], x, V(M, P(M, w, I), l)), P(k[2], x, V(M, I, l)), k[3] = x, y = this.addFeatureSection(i.featureInfo.featureIndex, y, this.bridgeFeatureSections, t1);
                    const f = t1.addVertex(B[0], b, s), _ = t1.addVertex(B[1], b, s), F = t1.addVertex(k[0], w, s), D = t1.addVertex(k[1], w, s);
                    t1.addTriangle(f, _, F), t1.addTriangle(_, D, F);
                    const C = t1.addVertex(B[1], A, s), O = t1.addVertex(B[2], A, s), N = t1.addVertex(k[1], I, s), j = t1.addVertex(k[2], I, s);
                    t1.addTriangle(C, O, N), t1.addTriangle(O, j, N), R(b, b), R(w, w);
                    const G = t1.addVertex(B[2], b, s), $ = t1.addVertex(B[3], b, s), q = t1.addVertex(k[2], w, s), Z = t1.addVertex(k[3], w, s);
                    t1.addTriangle(G, $, q), t1.addTriangle($, Z, q);
                    const W = this.isTerminalVertex(i.a, a), Y = this.isTerminalVertex(i.b, a);
                    c.height < .01 && W && t1.addQuad(B[3], B[2], B[1], B[0], R(p, p), s), h.height < .01 && Y && t1.addQuad(k[0], k[1], k[2], k[3], d, s);
                }
                this.bridgeFeatureSections.push({
                    featureIndex: Number.POSITIVE_INFINITY,
                    vertexStart: t1.getVertexCount()
                });
            }
            constructTunnelStructures(t1, e, r, n, i, s) {
                t1.clearVertexLookup();
                let a = Number.POSITIVE_INFINITY;
                const o = (t1, e)=>t1.featureInfo.featureIndex - e.featureInfo.featureIndex;
                this.sortSubarray(n, i.min, i.max, o), this.sortSubarray(n, s.min, s.max, o);
                const l = (t1)=>L(t1, t1), u = [
                    {
                        coord: new Mt(0, 0),
                        height: 0
                    },
                    {
                        coord: new Mt(0, 0),
                        height: 0
                    }
                ], c = (t1, e)=>t1 < e, h = _(), p = _(), d = _(), f = _(), m = _();
                for(let s = i.min; s < i.max; s++){
                    if (!this.prepareEdgePoints(u, e, r, n[s], c)) continue;
                    const [i, o] = u, y = l(S(m, -(o.coord.y - i.coord.y), o.coord.x - i.coord.x, 0));
                    a = this.addFeatureSection(n[s].featureInfo.featureIndex, a, this.tunnelFeatureSections, t1), t1.addQuad(S(h, i.coord.x, i.coord.y, i.height), S(p, o.coord.x, o.coord.y, o.height), S(d, o.coord.x, o.coord.y, n[s].isTunnel ? -.1 : 0), S(f, i.coord.x, i.coord.y, n[s].isTunnel ? -.1 : 0), y);
                }
                for(let i = s.min; i < s.max; i++){
                    const s = n[i];
                    s.isTunnel && ([s.a, s.b] = [
                        s.b,
                        s.a
                    ]);
                    const o = e[s.a], u = e[s.b], c = l(S(m, -(u.y - o.y), u.x - o.x, 0));
                    a = this.addFeatureSection(s.featureInfo.featureIndex, a, this.tunnelFeatureSections, t1), t1.addQuad(S(h, u.x, u.y, 0), S(p, o.x, o.y, 0), S(d, o.x, o.y, r[s.a] + 4), S(f, u.x, u.y, r[s.b] + 4), c), t1.addQuad(S(h, o.x, o.y, 0), S(p, u.x, u.y, 0), S(d, u.x, u.y, r[s.b] + 4), S(f, o.x, o.y, r[s.a] + 4), c);
                }
                this.tunnelFeatureSections.push({
                    featureIndex: Number.POSITIVE_INFINITY,
                    vertexStart: t1.getVertexCount()
                });
            }
            setElevatedPoint(t1, e, r, n) {
                t1.coord.x = e, t1.coord.y = r, t1.height = n;
            }
            prepareEdgePoints(t1, e, r, n, i) {
                let s = e[n.a].x, a = e[n.a].y, o = e[n.b].x, l = e[n.b].y, u = r[n.a], c = r[n.b];
                const h = i(u, 0), p = i(c, 0);
                if (h && p) return this.setElevatedPoint(t1[0], s, a, u), this.setElevatedPoint(t1[1], o, l, c), !0;
                if (!h && !p) return !1;
                if (h) {
                    if (!p) {
                        const t1 = c / (c - u);
                        o = dr(o, s, t1), l = dr(l, a, t1), c = dr(c, u, t1);
                    }
                } else {
                    const t1 = u / (u - c);
                    s = dr(s, o, t1), a = dr(a, l, t1), u = dr(u, c, t1);
                }
                return this.setElevatedPoint(t1[0], s, a, u), this.setElevatedPoint(t1[1], o, l, c), !0;
            }
            prepareEdges(t1, e) {
                if (0 === e.length) return;
                e.sort((t1, e)=>t1.hash === e.hash ? e.polygonIdx - t1.polygonIdx : e.hash > t1.hash ? 1 : -1);
                let r = 0, n = 0, i = 0, s = e[r].polygonIdx;
                do {
                    n++, (n === e.length || e[r].hash !== e[n].hash) && ((1 === n - r || e[n - 1].polygonIdx !== s) && (i < r && (e[i] = e[r], e[r] = null), e[i].type = "none", i++), r = n, r !== e.length && (s = e[r].polygonIdx));
                }while (r !== e.length)
                if (e.splice(i), 0 !== e.length && 0 !== t1.length) {
                    e.sort((t1, e)=>t1.portalHash < e.portalHash ? 1 : -1);
                    let r = 0, n = 0;
                    for(; r !== e.length && n !== t1.length;){
                        const i = e[r], s = t1[n];
                        i.portalHash > s.hash ? r++ : s.hash > i.portalHash ? n++ : (i.type = s.type, r++);
                    }
                }
            }
            isOnBorder(t1, e) {
                return t1 <= 0 && e <= 0 || t1 >= jn && e >= jn;
            }
            addFeatureSection(t1, e, r, n) {
                return t1 !== e && (e = t1, r.push({
                    featureIndex: t1,
                    vertexStart: n.getVertexCount()
                }), n.clearVertexLookup()), e;
            }
            sortSubarray(t1, e, r, n) {
                const i = t1.slice(e, r);
                i.sort(n), t1.splice(e, i.length, ...i);
            }
            static computeEdgeHash(t1, e) {
                return (t1.y === e.y && t1.x > e.x || t1.y > e.y) && ([t1, e] = [
                    e,
                    t1
                ]), BigInt(Vp.computePosHash(t1)) << 32n | BigInt(Vp.computePosHash(e));
            }
            static computePosHash(t1) {
                return ((65535 & t1.x) << 16 | 65535 & t1.y) >>> 0;
            }
        }
        function Ep(t1, e) {
            return t1 > e ? 1 : t1 < e ? -1 : 0;
        }
        class Fp {
            constructor(t1 = Ep, e = !1){
                this._compare = t1, this._root = null, this._size = 0, this._noDuplicates = !!e;
            }
            rotateLeft(t1) {
                var e = t1.right;
                e && (t1.right = e.left, e.left && (e.left.parent = t1), e.parent = t1.parent), t1.parent ? t1 === t1.parent.left ? t1.parent.left = e : t1.parent.right = e : this._root = e, e && (e.left = t1), t1.parent = e;
            }
            rotateRight(t1) {
                var e = t1.left;
                e && (t1.left = e.right, e.right && (e.right.parent = t1), e.parent = t1.parent), t1.parent ? t1 === t1.parent.left ? t1.parent.left = e : t1.parent.right = e : this._root = e, e && (e.right = t1), t1.parent = e;
            }
            _splay(t1) {
                for(; t1.parent;){
                    var e = t1.parent;
                    e.parent ? e.left === t1 && e.parent.left === e ? (this.rotateRight(e.parent), this.rotateRight(e)) : e.right === t1 && e.parent.right === e ? (this.rotateLeft(e.parent), this.rotateLeft(e)) : e.left === t1 && e.parent.right === e ? (this.rotateRight(e), this.rotateLeft(e)) : (this.rotateLeft(e), this.rotateRight(e)) : e.left === t1 ? this.rotateRight(e) : this.rotateLeft(e);
                }
            }
            splay(t1) {
                for(var e, r, n, i, s; t1.parent;)(r = (e = t1.parent).parent) && r.parent ? ((n = r.parent).left === r ? n.left = t1 : n.right = t1, t1.parent = n) : (t1.parent = null, this._root = t1), i = t1.left, s = t1.right, t1 === e.left ? (r && (r.left === e ? (e.right ? (r.left = e.right, r.left.parent = r) : r.left = null, e.right = r, r.parent = e) : (i ? (r.right = i, i.parent = r) : r.right = null, t1.left = r, r.parent = t1)), s ? (e.left = s, s.parent = e) : e.left = null, t1.right = e, e.parent = t1) : (r && (r.right === e ? (e.left ? (r.right = e.left, r.right.parent = r) : r.right = null, e.left = r, r.parent = e) : (s ? (r.left = s, s.parent = r) : r.left = null, t1.right = r, r.parent = t1)), i ? (e.right = i, i.parent = e) : e.right = null, t1.left = e, e.parent = t1);
            }
            replace(t1, e) {
                t1.parent ? t1 === t1.parent.left ? t1.parent.left = e : t1.parent.right = e : this._root = e, e && (e.parent = t1.parent);
            }
            minNode(t1 = this._root) {
                if (t1) for(; t1.left;)t1 = t1.left;
                return t1;
            }
            maxNode(t1 = this._root) {
                if (t1) for(; t1.right;)t1 = t1.right;
                return t1;
            }
            insert(t1, e) {
                var r = this._root, n = null, i = this._compare;
                if (this._noDuplicates) for(; r;){
                    if (n = r, 0 === i(r.key, t1)) return;
                    r = i(r.key, t1) < 0 ? r.right : r.left;
                }
                else for(; r;)n = r, r = i(r.key, t1) < 0 ? r.right : r.left;
                return r = {
                    key: t1,
                    data: e,
                    left: null,
                    right: null,
                    parent: n
                }, n ? i(n.key, r.key) < 0 ? n.right = r : n.left = r : this._root = r, this.splay(r), this._size++, r;
            }
            find(t1) {
                for(var e = this._root, r = this._compare; e;){
                    var n = r(e.key, t1);
                    if (n < 0) e = e.right;
                    else {
                        if (!(n > 0)) return e;
                        e = e.left;
                    }
                }
                return null;
            }
            contains(t1) {
                for(var e = this._root, r = this._compare; e;){
                    var n = r(t1, e.key);
                    if (0 === n) return !0;
                    e = n < 0 ? e.left : e.right;
                }
                return !1;
            }
            remove(t1) {
                var e = this.find(t1);
                if (!e) return !1;
                if (this.splay(e), e.left) if (e.right) {
                    var r = this.minNode(e.right);
                    r.parent !== e && (this.replace(r, r.right), r.right = e.right, r.right.parent = r), this.replace(e, r), r.left = e.left, r.left.parent = r;
                } else this.replace(e, e.left);
                else this.replace(e, e.right);
                return this._size--, !0;
            }
            removeNode(t1) {
                if (!t1) return !1;
                if (this.splay(t1), t1.left) if (t1.right) {
                    var e = this.minNode(t1.right);
                    e.parent !== t1 && (this.replace(e, e.right), e.right = t1.right, e.right.parent = e), this.replace(t1, e), e.left = t1.left, e.left.parent = e;
                } else this.replace(t1, t1.left);
                else this.replace(t1, t1.right);
                return this._size--, !0;
            }
            erase(t1) {
                var e = this.find(t1);
                if (e) {
                    this.splay(e);
                    var r = e.left, n = e.right, i = null;
                    r && (r.parent = null, i = this.maxNode(r), this.splay(i), this._root = i), n && (r ? i.right = n : this._root = n, n.parent = i), this._size--;
                }
            }
            pop() {
                var t1 = this._root, e = null;
                if (t1) {
                    for(; t1.left;)t1 = t1.left;
                    e = {
                        key: t1.key,
                        data: t1.data
                    }, this.remove(t1.key);
                }
                return e;
            }
            next(t1) {
                var e = t1;
                if (e) if (e.right) for(e = e.right; e && e.left;)e = e.left;
                else for(e = t1.parent; e && e.right === t1;)t1 = e, e = e.parent;
                return e;
            }
            prev(t1) {
                var e = t1;
                if (e) if (e.left) for(e = e.left; e && e.right;)e = e.right;
                else for(e = t1.parent; e && e.left === t1;)t1 = e, e = e.parent;
                return e;
            }
            forEach(t1) {
                for(var e = this._root, r = [], n = !1, i = 0; !n;)e ? (r.push(e), e = e.left) : r.length > 0 ? (t1(e = r.pop(), i++), e = e.right) : n = !0;
                return this;
            }
            range(t1, e, r, n) {
                const i = [], s = this._compare;
                let a, o = this._root;
                for(; 0 !== i.length || o;)if (o) i.push(o), o = o.left;
                else {
                    if (o = i.pop(), a = s(o.key, e), a > 0) break;
                    if (s(o.key, t1) >= 0 && r.call(n, o)) return this;
                    o = o.right;
                }
                return this;
            }
            keys() {
                for(var t1 = this._root, e = [], r = [], n = !1; !n;)t1 ? (e.push(t1), t1 = t1.left) : e.length > 0 ? (t1 = e.pop(), r.push(t1.key), t1 = t1.right) : n = !0;
                return r;
            }
            values() {
                for(var t1 = this._root, e = [], r = [], n = !1; !n;)t1 ? (e.push(t1), t1 = t1.left) : e.length > 0 ? (t1 = e.pop(), r.push(t1.data), t1 = t1.right) : n = !0;
                return r;
            }
            at(t1) {
                for(var e = this._root, r = [], n = !1, i = 0; !n;)if (e) r.push(e), e = e.left;
                else if (r.length > 0) {
                    if (e = r.pop(), i === t1) return e;
                    i++, e = e.right;
                } else n = !0;
                return null;
            }
            load(t1 = [], e = [], r = !1) {
                if (0 !== this._size) throw new Error("bulk-load: tree is not empty");
                const n = t1.length;
                return r && Cp(t1, e, 0, n - 1, this._compare), this._root = Dp(null, t1, e, 0, n), this._size = n, this;
            }
            min() {
                var t1 = this.minNode(this._root);
                return t1 ? t1.key : null;
            }
            max() {
                var t1 = this.maxNode(this._root);
                return t1 ? t1.key : null;
            }
            isEmpty() {
                return null === this._root;
            }
            get size() {
                return this._size;
            }
            static createTree(t1, e, r, n, i) {
                return new Fp(r, i).load(t1, e, n);
            }
        }
        function Dp(t1, e, r, n, i) {
            const s = i - n;
            if (s > 0) {
                const a = n + Math.floor(s / 2), o = {
                    key: e[a],
                    data: r[a],
                    parent: t1
                };
                return o.left = Dp(o, e, r, n, a), o.right = Dp(o, e, r, a + 1, i), o;
            }
            return null;
        }
        function Cp(t1, e, r, n, i) {
            if (r >= n) return;
            const s = t1[r + n >> 1];
            let a = r - 1, o = n + 1;
            for(;;){
                do {
                    a++;
                }while (i(t1[a], s) < 0)
                do {
                    o--;
                }while (i(t1[o], s) > 0)
                if (a >= o) break;
                let r = t1[a];
                t1[a] = t1[o], t1[o] = r, r = e[a], e[a] = e[o], e[o] = r;
            }
            Cp(t1, e, r, o, i), Cp(t1, e, o + 1, n, i);
        }
        const Rp = 11102230246251565e-32, Lp = 134217729, Op = (3 + 8 * Rp) * Rp;
        function Up(t1, e, r, n, i) {
            let s, a, o, l, u = e[0], c = n[0], h = 0, p = 0;
            c > u == c > -u ? (s = u, u = e[++h]) : (s = c, c = n[++p]);
            let d = 0;
            if (h < t1 && p < r) for(c > u == c > -u ? (a = u + s, o = s - (a - u), u = e[++h]) : (a = c + s, o = s - (a - c), c = n[++p]), s = a, 0 !== o && (i[d++] = o); h < t1 && p < r;)c > u == c > -u ? (a = s + u, l = a - s, o = s - (a - l) + (u - l), u = e[++h]) : (a = s + c, l = a - s, o = s - (a - l) + (c - l), c = n[++p]), s = a, 0 !== o && (i[d++] = o);
            for(; h < t1;)a = s + u, l = a - s, o = s - (a - l) + (u - l), u = e[++h], s = a, 0 !== o && (i[d++] = o);
            for(; p < r;)a = s + c, l = a - s, o = s - (a - l) + (c - l), c = n[++p], s = a, 0 !== o && (i[d++] = o);
            return 0 === s && 0 !== d || (i[d++] = s), d;
        }
        function Np(t1) {
            return new Float64Array(t1);
        }
        const jp = Np(4), Gp = Np(8), $p = Np(12), qp = Np(16), Xp = Np(4);
        function Hp(t1, e, r) {
            null === e ? (t1.inOut = !1, t1.otherInOut = !0) : (t1.isSubject === e.isSubject ? (t1.inOut = !e.inOut, t1.otherInOut = e.otherInOut) : (t1.inOut = !e.otherInOut, t1.otherInOut = e.isVertical() ? !e.inOut : e.inOut), e && (t1.prevInResult = !Zp(e, r) || e.isVertical() ? e.prevInResult : e)), t1.resultTransition = Zp(t1, r) ? function(t1, e) {
                let r, n = !t1.inOut, i = !t1.otherInOut;
                switch(e){
                    case 0:
                        r = n && i;
                        break;
                    case 1:
                        r = n || i;
                        break;
                    case 3:
                        r = n !== i;
                        break;
                    case 2:
                        r = t1.isSubject ? n && !i : i && !n;
                }
                return r ? 1 : -1;
            }(t1, r) : 0;
        }
        function Zp(t1, e) {
            switch(t1.type){
                case 0:
                    switch(e){
                        case 0:
                            return !t1.otherInOut;
                        case 1:
                            return t1.otherInOut;
                        case 2:
                            return t1.isSubject && t1.otherInOut || !t1.isSubject && !t1.otherInOut;
                        case 3:
                            return !0;
                    }
                    break;
                case 2:
                    return 0 === e || 1 === e;
                case 3:
                    return 2 === e;
                case 1:
                    return !1;
            }
            return !1;
        }
        class Wp {
            constructor(t1, e, r, n, i){
                this.left = e, this.point = t1, this.otherEvent = r, this.isSubject = n ?? !1, this.type = i || 0, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = !0;
            }
            isBelow(t1) {
                const e = this.point, r = this.otherEvent.point;
                return this.left ? (e[0] - t1[0]) * (r[1] - t1[1]) - (r[0] - t1[0]) * (e[1] - t1[1]) > 0 : (r[0] - t1[0]) * (e[1] - t1[1]) - (e[0] - t1[0]) * (r[1] - t1[1]) > 0;
            }
            isAbove(t1) {
                return !this.isBelow(t1);
            }
            isVertical() {
                return this.point[0] === this.otherEvent.point[0];
            }
            get inResult() {
                return 0 !== this.resultTransition;
            }
            clone() {
                const t1 = new Wp(this.point, this.left, this.otherEvent, this.isSubject, this.type);
                return t1.contourId = this.contourId, t1.resultTransition = this.resultTransition, t1.prevInResult = this.prevInResult, t1.isExteriorRing = this.isExteriorRing, t1.inOut = this.inOut, t1.otherInOut = this.otherInOut, t1;
            }
        }
        function Yp(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1];
        }
        function Jp(t1, e, r) {
            const n = function(t1, e, r, n, i, s) {
                const a = (e - s) * (r - i), o = (t1 - i) * (n - s), l = a - o;
                if (0 === a || 0 === o || a > 0 != o > 0) return l;
                const u = Math.abs(a + o);
                return Math.abs(l) >= 33306690738754716e-32 * u ? l : -function(t1, e, r, n, i, s, a) {
                    let o, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, I;
                    const M = t1 - i, S = r - i, P = e - s, z = n - s;
                    b = M * z, p = Lp * M, d = p - (p - M), f = M - d, p = Lp * z, m = p - (p - z), y = z - m, w = f * y - (b - d * m - f * m - d * y), _ = P * S, p = Lp * P, d = p - (p - P), f = P - d, p = Lp * S, m = p - (p - S), y = S - m, A = f * y - (_ - d * m - f * m - d * y), g = w - A, h = w - g, jp[0] = w - (g + h) + (h - A), x = b + g, h = x - b, v = b - (x - h) + (g - h), g = v - _, h = v - g, jp[1] = v - (g + h) + (h - _), I = x + g, h = I - x, jp[2] = x - (I - h) + (g - h), jp[3] = I;
                    let B = function(t1, e) {
                        let r = e[0];
                        for(let t1 = 1; t1 < 4; t1++)r += e[t1];
                        return r;
                    }(0, jp), k = 22204460492503146e-32 * a;
                    if (B >= k || -B >= k) return B;
                    if (h = t1 - M, o = t1 - (M + h) + (h - i), h = r - S, u = r - (S + h) + (h - i), h = e - P, l = e - (P + h) + (h - s), h = n - z, c = n - (z + h) + (h - s), 0 === o && 0 === l && 0 === u && 0 === c) return B;
                    if (k = 11093356479670487e-47 * a + Op * Math.abs(B), B += M * c + z * o - (P * u + S * l), B >= k || -B >= k) return B;
                    b = o * z, p = Lp * o, d = p - (p - o), f = o - d, p = Lp * z, m = p - (p - z), y = z - m, w = f * y - (b - d * m - f * m - d * y), _ = l * S, p = Lp * l, d = p - (p - l), f = l - d, p = Lp * S, m = p - (p - S), y = S - m, A = f * y - (_ - d * m - f * m - d * y), g = w - A, h = w - g, Xp[0] = w - (g + h) + (h - A), x = b + g, h = x - b, v = b - (x - h) + (g - h), g = v - _, h = v - g, Xp[1] = v - (g + h) + (h - _), I = x + g, h = I - x, Xp[2] = x - (I - h) + (g - h), Xp[3] = I;
                    const T = Up(4, jp, 4, Xp, Gp);
                    b = M * c, p = Lp * M, d = p - (p - M), f = M - d, p = Lp * c, m = p - (p - c), y = c - m, w = f * y - (b - d * m - f * m - d * y), _ = P * u, p = Lp * P, d = p - (p - P), f = P - d, p = Lp * u, m = p - (p - u), y = u - m, A = f * y - (_ - d * m - f * m - d * y), g = w - A, h = w - g, Xp[0] = w - (g + h) + (h - A), x = b + g, h = x - b, v = b - (x - h) + (g - h), g = v - _, h = v - g, Xp[1] = v - (g + h) + (h - _), I = x + g, h = I - x, Xp[2] = x - (I - h) + (g - h), Xp[3] = I;
                    const V = Up(T, Gp, 4, Xp, $p);
                    b = o * c, p = Lp * o, d = p - (p - o), f = o - d, p = Lp * c, m = p - (p - c), y = c - m, w = f * y - (b - d * m - f * m - d * y), _ = l * u, p = Lp * l, d = p - (p - l), f = l - d, p = Lp * u, m = p - (p - u), y = u - m, A = f * y - (_ - d * m - f * m - d * y), g = w - A, h = w - g, Xp[0] = w - (g + h) + (h - A), x = b + g, h = x - b, v = b - (x - h) + (g - h), g = v - _, h = v - g, Xp[1] = v - (g + h) + (h - _), I = x + g, h = I - x, Xp[2] = x - (I - h) + (g - h), Xp[3] = I;
                    const E = Up(V, $p, 4, Xp, qp);
                    return qp[E - 1];
                }(t1, e, r, n, i, s, u);
            }(t1[0], t1[1], e[0], e[1], r[0], r[1]);
            return n > 0 ? -1 : n < 0 ? 1 : 0;
        }
        function Kp(t1, e) {
            const r = t1.point, n = e.point;
            return r[0] > n[0] ? 1 : r[0] < n[0] ? -1 : r[1] !== n[1] ? r[1] > n[1] ? 1 : -1 : function(t1, e, r) {
                return t1.left !== e.left ? t1.left ? 1 : -1 : 0 !== Jp(r, t1.otherEvent.point, e.otherEvent.point) ? t1.isBelow(e.otherEvent.point) ? -1 : 1 : !t1.isSubject && e.isSubject ? 1 : -1;
            }(t1, e, r);
        }
        function Qp(t1, e, r) {
            const n = new Wp(e, !1, t1, t1.isSubject), i = new Wp(e, !0, t1.otherEvent, t1.isSubject);
            return Yp(t1.point, t1.otherEvent.point) && console.warn("what is that, a collapsed segment?", t1), n.contourId = i.contourId = t1.contourId, Kp(i, t1.otherEvent) > 0 && (t1.otherEvent.left = !0, i.left = !1), t1.otherEvent.otherEvent = i, t1.otherEvent = n, r.push(i), r.push(n), r;
        }
        function td(t1, e) {
            return t1[0] * e[1] - t1[1] * e[0];
        }
        function ed(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1];
        }
        function rd(t1, e, r) {
            const n = function(t1, e, r, n) {
                const i = [
                    e[0] - t1[0],
                    e[1] - t1[1]
                ], s = [
                    n[0] - r[0],
                    n[1] - r[1]
                ];
                function a(t1, e, r) {
                    return [
                        t1[0] + e * r[0],
                        t1[1] + e * r[1]
                    ];
                }
                const o = [
                    r[0] - t1[0],
                    r[1] - t1[1]
                ];
                let l = td(i, s), u = l * l;
                const c = ed(i, i);
                if (u > 0) {
                    const e = td(o, s) / l;
                    if (e < 0 || e > 1) return null;
                    const n = td(o, i) / l;
                    return n < 0 || n > 1 ? null : 0 === e || 1 === e ? [
                        a(t1, e, i)
                    ] : 0 === n || 1 === n ? [
                        a(r, n, s)
                    ] : [
                        a(t1, e, i)
                    ];
                }
                if (l = td(o, i), u = l * l, u > 0) return null;
                const h = ed(i, o) / c, p = h + ed(i, s) / c, d = Math.min(h, p), f = Math.max(h, p);
                return d <= 1 && f >= 0 ? 1 === d ? [
                    a(t1, d > 0 ? d : 0, i)
                ] : 0 === f ? [
                    a(t1, f < 1 ? f : 1, i)
                ] : [
                    a(t1, d > 0 ? d : 0, i),
                    a(t1, f < 1 ? f : 1, i)
                ] : null;
            }(t1.point, t1.otherEvent.point, e.point, e.otherEvent.point), i = n ? n.length : 0;
            if (0 === i || 1 === i && (Yp(t1.point, e.point) || Yp(t1.otherEvent.point, e.otherEvent.point)) || 2 === i && t1.isSubject === e.isSubject) return 0;
            if (1 === i) return !Yp(t1.point, n[0]) && !Yp(t1.otherEvent.point, n[0]) && Qp(t1, n[0], r), !Yp(e.point, n[0]) && !Yp(e.otherEvent.point, n[0]) && Qp(e, n[0], r), 1;
            const s = [];
            let a = !1, o = !1;
            return Yp(t1.point, e.point) ? a = !0 : 1 === Kp(t1, e) ? s.push(e, t1) : s.push(t1, e), Yp(t1.otherEvent.point, e.otherEvent.point) ? o = !0 : 1 === Kp(t1.otherEvent, e.otherEvent) ? s.push(e.otherEvent, t1.otherEvent) : s.push(t1.otherEvent, e.otherEvent), a && o || a ? (e.type = 1, t1.type = e.inOut === t1.inOut ? 2 : 3, a && !o && Qp(s[1].otherEvent, s[0].point, r), 2) : o ? (Qp(s[0], s[1].point, r), 3) : s[0] !== s[3].otherEvent ? (Qp(s[0], s[1].point, r), Qp(s[1], s[2].point, r), 3) : (Qp(s[0], s[1].point, r), Qp(s[3].otherEvent, s[2].point, r), 3);
        }
        function nd(t1, e) {
            if (t1 === e) return 0;
            if (0 !== Jp(t1.point, t1.otherEvent.point, e.point) || 0 !== Jp(t1.point, t1.otherEvent.point, e.otherEvent.point)) return Yp(t1.point, e.point) ? t1.isBelow(e.otherEvent.point) ? -1 : 1 : t1.point[0] === e.point[0] ? t1.point[1] < e.point[1] ? -1 : 1 : 1 === Kp(t1, e) ? e.isAbove(t1.point) ? -1 : 1 : t1.isBelow(e.point) ? -1 : 1;
            if (t1.isSubject !== e.isSubject) return t1.isSubject ? -1 : 1;
            {
                let r = t1.point, n = e.point;
                if (r[0] === n[0] && r[1] === n[1]) return r = t1.otherEvent.point, n = e.otherEvent.point, r[0] === n[0] && r[1] === n[1] ? 0 : (t1.contourId ?? 0) > (e.contourId ?? 0) ? 1 : -1;
            }
            return 1 === Kp(t1, e) ? 1 : -1;
        }
        class id {
            constructor(){
                this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;
            }
            isExterior() {
                return null == this.holeOf;
            }
        }
        function sd(t1, e, r, n) {
            let i, s = t1 + 1, a = e[t1].point;
            const o = e.length;
            for(s < o && (i = e[s].point); s < o && i[0] === a[0] && i[1] === a[1];){
                if (!r[s]) return s;
                s++, s < o && (i = e[s].point);
            }
            for(s = t1 - 1; r[s] && s > n;)s--;
            return s;
        }
        function ad(t1, e, r) {
            const n = new id;
            if (null != t1.prevInResult) {
                const i = t1.prevInResult, s = i.outputContourId;
                if (i.resultTransition > 0) {
                    const t1 = e[s];
                    if (null != t1.holeOf) {
                        const i = t1.holeOf;
                        e[i].holeIds.push(r), n.holeOf = i, n.depth = e[s].depth;
                    } else e[s].holeIds.push(r), n.holeOf = s, n.depth = e[s].depth + 1;
                } else n.holeOf = null, n.depth = e[s].depth;
            } else n.holeOf = null, n.depth = 0;
            return n;
        }
        const od = Math.max, ld = Math.min;
        let ud = 0;
        function cd(t1, e, r, n, i, s) {
            let a, o, l, u, c, h;
            for(a = 0, o = t1.length - 1; a < o; a++){
                if (l = t1[a], u = t1[a + 1], c = new Wp(l, !1, void 0, e), h = new Wp(u, !1, c, e), c.otherEvent = h, l[0] === u[0] && l[1] === u[1]) continue;
                c.contourId = h.contourId = r, s || (c.isExteriorRing = !1, h.isExteriorRing = !1), Kp(c, h) > 0 ? h.left = !0 : c.left = !0;
                const o = l[0], p = l[1];
                i[0] = ld(i[0], o), i[1] = ld(i[1], p), i[2] = od(i[2], o), i[3] = od(i[3], p), n.push(c), n.push(h);
            }
        }
        const hd = [];
        function pd(t1, e, r) {
            let n = t1, i = e;
            "number" == typeof t1[0][0][0] && (n = [
                t1
            ]), "number" == typeof e[0][0][0] && (i = [
                e
            ]);
            let s = function(t1, e, r) {
                let n = null;
                return t1.length * e.length === 0 && (0 === r ? n = hd : 2 === r ? n = t1 : (1 === r || 3 === r) && (n = 0 === t1.length ? e : t1)), n;
            }(n, i, r);
            if (s) return s === hd ? null : s;
            const a = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ], o = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ], l = function(t1, e, r, n, i) {
                const s = new Nn(void 0, Kp);
                let a, o, l, u, c, h;
                for(l = 0, u = t1.length; l < u; l++)for(a = t1[l], c = 0, h = a.length; c < h; c++)o = 0 === c, o && ud++, cd(a[c], !0, ud, s, r, o);
                for(l = 0, u = e.length; l < u; l++)for(a = e[l], c = 0, h = a.length; c < h; c++)o = 0 === c, 2 === i && (o = !1), o && ud++, cd(a[c], !1, ud, s, n, o);
                return s;
            }(n, i, a, o, r);
            if (s = function(t1, e, r, n, i) {
                let s = null;
                return (r[0] > n[2] || n[0] > r[2] || r[1] > n[3] || n[1] > r[3]) && (0 === i ? s = hd : 2 === i ? s = t1 : (1 === i || 3 === i) && (s = t1.concat(e))), s;
            }(n, i, a, o, r), s) return s === hd ? null : s;
            const u = function(t1, e, r, n, i, s) {
                const a = new Fp(nd), o = [], l = Math.min(n[2], i[2]);
                let u, c, h;
                for(; 0 !== t1.length;){
                    let e = t1.pop();
                    if (o.push(e), 0 === s && e.point[0] > l || 2 === s && e.point[0] > n[2]) break;
                    if (e.left) {
                        c = u = a.insert(e), h = a.minNode(), u = u !== h ? a.prev(u) : null, c = a.next(c);
                        const r = u ? u.key : null;
                        let n;
                        if (Hp(e, r, s), c && 2 === rd(e, c.key, t1) && (Hp(e, r, s), Hp(c.key, e, s)), u && 2 === rd(u.key, e, t1)) {
                            let t1 = u;
                            t1 = t1 !== h ? a.prev(t1) : null, n = t1 ? t1.key : null, Hp(r, n, s), Hp(e, r, s);
                        }
                    } else e = e.otherEvent, c = u = a.find(e), u && c && (u = u !== h ? a.prev(u) : null, c = a.next(c), a.remove(e), c && u && rd(u.key, c.key, t1));
                }
                return o;
            }(l, 0, 0, a, o, r), c = function(t1) {
                let e, r;
                const n = function(t1) {
                    let e, r, n, i, s;
                    const a = [];
                    for(r = 0, n = t1.length; r < n; r++)e = t1[r], (e.left && e.inResult || !e.left && e.otherEvent.inResult) && a.push(e);
                    let o = !1;
                    for(; !o;)for(o = !0, r = 0, n = a.length; r < n; r++)r + 1 < n && 1 === Kp(a[r], a[r + 1]) && (i = a[r], a[r] = a[r + 1], a[r + 1] = i, o = !1);
                    for(r = 0, n = a.length; r < n; r++)e = a[r], e.otherPos = r;
                    for(r = 0, n = a.length; r < n; r++)e = a[r], e.left || (s = e.otherPos, e.otherPos = e.otherEvent.otherPos, e.otherEvent.otherPos = s);
                    return a;
                }(t1), i = {}, s = [];
                for(e = 0, r = n.length; e < r; e++){
                    if (i[e]) continue;
                    const t1 = s.length, r = ad(n[e], s, t1), a = (e)=>{
                        i[e] = !0, e < n.length && n[e] && (n[e].outputContourId = t1);
                    };
                    let o = e, l = e;
                    for(r.points.push(n[e].point); a(o), o = n[o].otherPos, a(o), r.points.push(n[o].point), o = sd(o, n, i, l), !(o == l || o >= n.length) && n[o];);
                    s.push(r);
                }
                return s;
            }(u), h = [];
            for(let t1 = 0; t1 < c.length; t1++){
                let e = c[t1];
                if (e.isExterior()) {
                    let t1 = [
                        e.points
                    ];
                    for(let r = 0; r < e.holeIds.length; r++)t1.push(c[e.holeIds[r]].points);
                    h.push(t1);
                }
            }
            return h;
        }
        function dd(t1, e, r, n) {
            const i = [], s = 0 === n ? (t1, e, r, n, i, s)=>{
                t1.push(new Mt(s, r + (s - e) / (n - e) * (i - r)));
            } : (t1, e, r, n, i, s)=>{
                t1.push(new Mt(e + (s - r) / (i - r) * (n - e), s));
            };
            for (const a of t1){
                const t1 = [];
                for (const i of a){
                    if (i.length <= 2) continue;
                    const a = [];
                    for(let t1 = 0; t1 < i.length - 1; t1++){
                        const o = i[t1].x, l = i[t1].y, u = i[t1 + 1].x, c = i[t1 + 1].y, h = 0 === n ? o : l, p = 0 === n ? u : c;
                        h < e ? p > e && s(a, o, l, u, c, e) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t1]), p < e && h >= e && s(a, o, l, u, c, e), p > r && h <= r && s(a, o, l, u, c, r);
                    }
                    let o = i[i.length - 1];
                    const l = 0 === n ? o.x : o.y;
                    l >= e && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t1.push(a));
                }
                t1.length && i.push(t1);
            }
            return i;
        }
        function fd(t1, e) {
            const r = pd(yd(t1), yd([
                e
            ]), 0);
            return null == r ? [] : gd(r);
        }
        function md(t1, e) {
            const r = 65536;
            let n = yd(t1, r);
            const i = [];
            for(; e.valid(); e.next()){
                const [t1, n] = e.get(), s = t1.x * r, a = t1.y * r, o = n.x * r, l = n.y * r, u = o - s, c = l - a, h = Math.hypot(u, c);
                if (0 === h) continue;
                const p = Math.trunc(c / h * 3), d = -Math.trunc(u / h * 3);
                i.push([
                    [
                        [
                            s,
                            a
                        ],
                        [
                            o,
                            l
                        ],
                        [
                            o + p,
                            l + d
                        ],
                        [
                            s + p,
                            a + d
                        ],
                        [
                            s,
                            a
                        ]
                    ]
                ]);
            }
            return i.length > 0 && (n = pd(n, i, 2)), gd(n, 1 / r, 128);
        }
        function yd(t1, e = 1) {
            return [
                t1.map((t1)=>t1.map((t1)=>[
                            t1.x * e,
                            t1.y * e
                        ]))
            ];
        }
        function gd(t1, e = 1, r) {
            return t1.map((t1)=>t1.map((t1, n)=>{
                    const i = t1.map((t1)=>{
                        let n = t1[0], i = t1[1];
                        return r && (n = Math.round(n / r) * r, i = Math.round(i / r) * r), new Mt(n * e, i * e)._round();
                    });
                    return n > 0 && i.reverse(), i;
                }));
        }
        class xd {
            constructor(t1, e){
                this.layoutVertexArray = new No, this.indexArray = new ll, this.lineIndexArray = new nl, this.triangleSegments = new Ol, this.lineSegments = new Ol, this.programConfigurations = new fu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.uploaded = !1, e && (this.elevatedLayoutVertexArray = new $o);
            }
            update(t1, e, r, n, i, s, a, o) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, o);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            needsUpload() {
                return this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Wh.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t1.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t1.createVertexBuffer(this.elevatedLayoutVertexArray, Yh.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());
            }
            populatePaintArrays(t1, e, r, n, i, s, a) {
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, e, r, n, i, s, void 0, a);
            }
        }
        class vd {
            constructor(t1){
                this.zoom = t1.zoom, this.pixelRatio = t1.pixelRatio, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.lut = t1.lut, this.bufferData = new xd(t1, !1), this.elevationBufferData = new xd(t1, !0), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference"), this.sourceLayerIndex = t1.sourceLayerIndex, this.worldview = t1.worldview, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {}
            updateAppearances(t1, e, r, n) {}
            populate(t1, e, r, n) {
                this.hasPattern = zp("fill", this.layers, this.pixelRatio, e);
                const i = this.layers[0].layout.get("fill-sort-key"), s = [];
                for (const { feature: a, id: o, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = Ku(a, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, {
                        worldview: this.worldview,
                        activeFloors: e.activeFloors
                    }), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0, p = {
                        id: o,
                        properties: a.properties,
                        type: a.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : Ju(a, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    s.push(p);
                }
                i && s.sort((t1, e)=>t1.sortKey - e.sortKey);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    if (this.hasPattern) {
                        const t1 = Bp("fill", this.layers, n, this.zoom, this.pixelRatio, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness, e.elevationFeatures);
                    e.featureIndex.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            update(t1, e, r, n, i, s, a) {
                this.bufferData.update(t1, e, r, n, i, s, a, this.worldview), this.elevationBufferData.update(t1, e, r, n, i, s, a, this.worldview), this.elevatedStructures && this.elevatedStructures.update(t1, e, r, n, i, s, a, this.worldview);
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const i of this.patternFeatures)this.addFeature(i, i.geometry, i.index, e, r, n, s, t1.elevationFeatures);
            }
            isEmpty() {
                return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();
            }
            uploadPending() {
                return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();
            }
            upload(t1) {
                this.bufferData.upload(t1), this.elevationBufferData.upload(t1), this.elevatedStructures && this.elevatedStructures.upload(t1);
            }
            destroy() {
                this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();
            }
            addFeature(t1, e, r, n, i, s = [], a, o) {
                const l = Mp(e, 500);
                "none" !== this.elevationMode ? this.addElevatedRoadFeature(t1, l, n, r, o) : this.addGeometry(l, this.bufferData), this.bufferData.populatePaintArrays(t1, r, i, s, n, a, this.worldview), this.elevationBufferData.populatePaintArrays(t1, r, i, s, n, a, this.worldview);
            }
            getUnevaluatedPortalGraph() {
                return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;
            }
            setEvaluatedPortalGraph(t1, e, r, n, i) {
                this.elevatedStructures && (this.elevatedStructures.construct(t1), this.elevatedStructures.populatePaintArrays(e, r, n, i, this.worldview));
            }
            addElevatedRoadFeature(t1, e, r, n, i) {
                const s = new Array, a = Ic.getElevationFeature(t1, i);
                if (!a) return void this.addGeometry(e, this.bufferData);
                {
                    const t1 = this.clipPolygonsToTile(e, 1);
                    t1.length > 0 && s.push({
                        polygons: t1,
                        elevationFeature: a,
                        elevationTileID: r
                    });
                }
                const o = {
                    guardRailEnabled: this.layers[0].layout.get("fill-construct-bridge-guard-rail").evaluate(t1, {}, r),
                    featureIndex: n
                };
                for (const e of s)if (e.elevationFeature) {
                    if ("hd-road-base" === this.elevationMode) {
                        this.elevatedStructures || (this.elevatedStructures = new Vp(e.elevationTileID, this.layers, this.zoom, this.lut));
                        const r = e.elevationFeature.isTunnel();
                        let n = 0;
                        t1.properties.hasOwnProperty(oc) && (n = +t1.properties[oc]), this.elevatedStructures.addPortalCandidates(e.elevationFeature.id, e.polygons, r, e.elevationFeature, n);
                    }
                    null == e.elevationFeature.constantHeight && (e.polygons = this.prepareElevatedPolygons(e.polygons, e.elevationFeature, e.elevationTileID));
                    const i = new Mc(r, e.elevationTileID);
                    this.addElevatedGeometry(e.polygons, i, e.elevationFeature, "hd-road-base" === this.elevationMode ? 0 : .05, n, o);
                }
            }
            addElevatedGeometry(t1, e, r, n, i, s) {
                const a = {
                    elevation: r,
                    elevationSampler: e,
                    bias: n,
                    index: i,
                    featureInfo: s
                }, [o, l] = this.addGeometry(t1, this.elevationBufferData, a);
                null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = {
                    min: o,
                    max: l
                } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, o), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, l));
            }
            addGeometry(t1, e, r) {
                let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, s = null;
                r && (s = r.elevationSampler.constantElevation(r.elevation, r.bias), null != s && (n = s, i = s));
                const a = (t1, a, o)=>{
                    if (null != r) if (a.push(t1), null != s) e.elevatedLayoutVertexArray.emplaceBack(s), o.push(s);
                    else {
                        const s = r.elevationSampler.pointElevation(t1, r.elevation, r.bias);
                        e.elevatedLayoutVertexArray.emplaceBack(s), o.push(s), n = Math.min(n, s), i = Math.max(i, s);
                    }
                };
                for (const n of t1){
                    let t1 = 0;
                    for (const e of n)t1 += e.length;
                    const i = e.triangleSegments.prepareSegment(t1, e.layoutVertexArray, e.indexArray), s = i.vertexLength, o = [], l = [], u = [], c = [], h = [], p = e.layoutVertexArray.length;
                    for (const t1 of n){
                        if (0 === t1.length) continue;
                        t1 !== n[0] && l.push(o.length / 2);
                        const i = e.lineSegments.prepareSegment(t1.length, e.layoutVertexArray, e.lineIndexArray), s = i.vertexLength;
                        r && h.push(e.layoutVertexArray.length - p), a(t1[0], u, c), e.layoutVertexArray.emplaceBack(t1[0].x, t1[0].y), e.lineIndexArray.emplaceBack(s + t1.length - 1, s), o.push(t1[0].x), o.push(t1[0].y);
                        for(let r = 1; r < t1.length; r++)a(t1[r], u, c), e.layoutVertexArray.emplaceBack(t1[r].x, t1[r].y), e.lineIndexArray.emplaceBack(s + r - 1, s + r), o.push(t1[r].x), o.push(t1[r].y);
                        i.vertexLength += t1.length, i.primitiveLength += t1.length;
                    }
                    const d = Qh(o, l);
                    for(let t1 = 0; t1 < d.length; t1 += 3)e.indexArray.emplaceBack(s + d[t1], s + d[t1 + 1], s + d[t1 + 2]);
                    if (d.length > 0 && r && "hd-road-base" === this.elevationMode) {
                        const t1 = r.elevation.isTunnel(), e = r.elevation.safeArea, n = this.elevatedStructures.addVertices(u, c);
                        this.elevatedStructures.addTriangles(d, n, t1);
                        const i = h.length;
                        if (i > 0) {
                            for(let s = 0; s < i - 1; s++)this.elevatedStructures.addRenderableRing(r.index, h[s] + n, h[s + 1] - h[s], t1, e, r.featureInfo);
                            this.elevatedStructures.addRenderableRing(r.index, h[i - 1] + n, u.length - h[i - 1], t1, e, r.featureInfo);
                        }
                    }
                    i.vertexLength += t1, i.primitiveLength += d.length / 3;
                }
                return [
                    n,
                    i
                ];
            }
            prepareElevatedPolygons(t1, e, r) {
                const n = 1 / ju(r), i = [];
                for (const r of t1){
                    const t1 = md(r, new _c(e, n));
                    i.push(...t1);
                }
                return i;
            }
            clipPolygonsToTile(t1, e) {
                const r = -e, n = -e, i = jn + e, s = jn + e;
                let a = 0;
                const o = [], l = [];
                for(; a < t1.length; a++){
                    const e = t1[a], u = bn(e);
                    (u.min.x >= r && u.max.x <= i && u.min.y >= n && u.max.y <= s ? o : l).push(e);
                }
                if (o.length === t1.length) return t1;
                const u = [
                    new Mt(r, n),
                    new Mt(i, n),
                    new Mt(i, s),
                    new Mt(r, s),
                    new Mt(r, n)
                ], c = o;
                for (const t1 of l)c.push(...fd(t1, u));
                return c;
            }
        }
        let bd, wd, _d, Ad;
        Qs(vd, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        }), Qs(xd, "FillBufferData"), Qs(Vp, "ElevatedStructures");
        class Id {
            constructor(t1, e, r, n){
                if (this.triangleCount = e.length / 3, this.min = new Mt(0, 0), this.max = new Mt(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t1.length) return;
                const [i, s] = [
                    t1[0].clone(),
                    t1[0].clone()
                ];
                for(let e = 1; e < t1.length; ++e){
                    const r = t1[e];
                    i.x = Math.min(i.x, r.x), i.y = Math.min(i.y, r.y), s.x = Math.max(s.x, r.x), s.y = Math.max(s.y, r.y);
                }
                if (n) {
                    const t1 = Math.ceil(Math.max(s.x - i.x, s.y - i.y) / n);
                    r = Math.max(r, t1);
                }
                if (0 === r) return;
                this.min = i, this.max = s;
                const a = this.max.sub(this.min);
                a.x = Math.max(a.x, 1), a.y = Math.max(a.y, 1);
                const o = Math.max(a.x, a.y) / r;
                this.cellsX = Math.max(1, Math.ceil(a.x / o)), this.cellsY = Math.max(1, Math.ceil(a.y / o)), this.xScale = 1 / o, this.yScale = 1 / o;
                const l = [];
                for(let r = 0; r < this.triangleCount; r++){
                    const n = t1[e[3 * r + 0]].sub(this.min), i = t1[e[3 * r + 1]].sub(this.min), s = t1[e[3 * r + 2]].sub(this.min), a = Md(Math.floor(Math.min(n.x, i.x, s.x)), this.xScale, this.cellsX), u = Md(Math.floor(Math.max(n.x, i.x, s.x)), this.xScale, this.cellsX), c = Md(Math.floor(Math.min(n.y, i.y, s.y)), this.yScale, this.cellsY), h = Md(Math.floor(Math.max(n.y, i.y, s.y)), this.yScale, this.cellsY), p = new Mt(0, 0), d = new Mt(0, 0), f = new Mt(0, 0), m = new Mt(0, 0);
                    for(let t1 = c; t1 <= h; ++t1){
                        p.y = d.y = t1 * o, f.y = m.y = (t1 + 1) * o;
                        for(let e = a; e <= u; ++e)p.x = f.x = e * o, d.x = m.x = (e + 1) * o, (jc(n, i, s, p, d, m) || jc(n, i, s, p, m, f)) && l.push({
                            cellIdx: t1 * this.cellsX + e,
                            triIdx: r
                        });
                    }
                }
                if (0 === l.length) return;
                l.sort((t1, e)=>t1.cellIdx - e.cellIdx || t1.triIdx - e.triIdx);
                let u = 0;
                for(; u < l.length;){
                    const t1 = l[u].cellIdx, e = {
                        start: this.payload.length,
                        len: 0
                    };
                    for(; u < l.length && l[u].cellIdx === t1;)++e.len, this.payload.push(l[u++].triIdx);
                    this.cells[t1] = e;
                }
            }
            _lazyInitLookup() {
                this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
            }
            queryPoint(t1, e) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > t1.x || t1.y > this.max.y || this.min.y > t1.y) return;
                const r = Md(t1.x - this.min.x, this.xScale, this.cellsX), n = Md(t1.y - this.min.y, this.yScale, this.cellsY), i = this.cells[n * this.cellsX + r];
                if (i) {
                    this._lazyInitLookup();
                    for(let t1 = 0; t1 < i.len; t1++){
                        const r = this.payload[i.start + t1], n = Math.floor(r / 8), s = 1 << r % 8;
                        if (!(this.lookup[n] & s) && (this.lookup[n] |= s, e.push(r), e.length === this.triangleCount)) return;
                    }
                }
            }
            query(t1, e, r) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > e.x) return;
                if (t1.y > this.max.y || this.min.y > e.y) return;
                this._lazyInitLookup();
                const n = Md(t1.x - this.min.x, this.xScale, this.cellsX), i = Md(e.x - this.min.x, this.xScale, this.cellsX), s = Md(t1.y - this.min.y, this.yScale, this.cellsY), a = Md(e.y - this.min.y, this.yScale, this.cellsY);
                for(let t1 = s; t1 <= a; t1++)for(let e = n; e <= i; e++){
                    const n = this.cells[t1 * this.cellsX + e];
                    if (n) for(let t1 = 0; t1 < n.len; t1++){
                        const e = this.payload[n.start + t1], i = Math.floor(e / 8), s = 1 << e % 8;
                        if (!(this.lookup[i] & s) && (this.lookup[i] |= s, r.push(e), r.length === this.triangleCount)) return;
                    }
                }
            }
        }
        function Md(t1, e, r) {
            return Math.max(0, Math.min(r - 1, Math.floor(t1 * e)));
        }
        Qs(Id, "TriangleGridIndex");
        class Sd {
            constructor(t1){
                this.zoom = t1.zoom, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.footprints = [], this.worldview = t1.worldview, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {
                for (const r of this.footprints)e.push({
                    footprint: r,
                    id: t1
                });
            }
            updateAppearances(t1, e, r, n) {}
            populate(t1, e, r, n) {
                const i = [];
                for (const { feature: s, id: a, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = Ku(s, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, {
                        worldview: this.worldview,
                        activeFloors: e.activeFloors
                    }), u, r)) continue;
                    const c = {
                        id: a,
                        properties: s.properties,
                        type: s.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : Ju(s, r, n),
                        patterns: {}
                    };
                    i.push(c);
                }
                for (const n of i){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness), e.featureIndex.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            isEmpty() {
                return 0 === this.footprints.length;
            }
            uploadPending() {
                return !1;
            }
            upload(t1) {}
            update(t1, e, r, n, i, s, a) {}
            destroy() {}
            addFeature(t1, e, r, n, i, s = [], a) {
                for (const t1 of Mp(e, 2)){
                    const e = [], r = [], n = [], i = new Mt(1 / 0, 1 / 0), s = new Mt(-1 / 0, -1 / 0);
                    for (const a of t1)if (0 !== a.length) {
                        a !== t1[0] && n.push(r.length / 2);
                        for(let t1 = 0; t1 < a.length; t1++)r.push(a[t1].x), r.push(a[t1].y), e.push(a[t1]), i.x = Math.min(i.x, a[t1].x), i.y = Math.min(i.y, a[t1].y), s.x = Math.max(s.x, a[t1].x), s.y = Math.max(s.y, a[t1].y);
                    }
                    const a = Qh(r, n), o = new Id(e, a, 8, 256);
                    this.footprints.push({
                        vertices: e,
                        indices: a,
                        grid: o,
                        min: i,
                        max: s
                    });
                }
            }
        }
        Qs(Sd, "ClipBucket", {
            omit: [
                "layers"
            ]
        });
        const Pd = Oo([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), zd = Oo([
            {
                name: "a_pos_end",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_angular_offset_factor",
                components: 1,
                type: "Int16"
            }
        ]), Bd = Oo([
            {
                name: "a_flood_light_ground_radius",
                components: 1,
                type: "Float32"
            }
        ]), kd = Oo([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), Td = Oo([
            {
                name: "a_join_normal_inside",
                components: 3,
                type: "Int16"
            }
        ]), Vd = Oo([
            {
                name: "a_hidden_by_landmark",
                components: 1,
                type: "Uint8"
            }
        ]), Ed = Oo([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: Fd } = Pd, Dd = Number.MAX_SAFE_INTEGER, Cd = Dd - 1;
        function Rd(t1, e, r, n) {
            return t1.order < e || t1.order === Dd || !(t1.clipMask & r) || function(t1, e) {
                return 0 !== e.length && void 0 === e.find((e)=>e === t1);
            }(n, t1.clipScope);
        }
        function Ld(t1, e) {
            return t1.x - e.x || t1.y - e.y;
        }
        function Od(t1, e) {
            return 0 === Ld(t1.min, e.min) && 0 === Ld(t1.max, e.max);
        }
        function Ud(t1, e) {
            return !(t1.min.x > e.max.x || t1.max.x < e.min.x || t1.min.y > e.max.y || t1.max.y < e.min.y);
        }
        function Nd(t1, e) {
            if (t1.length !== e.length) return !1;
            for(let r = 0; r < t1.length; r++)if (t1[r].sourceId !== e[r].sourceId || !Od(t1[r], e[r]) || t1[r].order !== e[r].order || t1[r].clipMask !== e[r].clipMask || !St(t1[r].clipScope, e[r].clipScope)) return !1;
            return !0;
        }
        function jd(t1, e, r) {
            const n = 1 / jn, i = 1 / (1 << r.canonical.z), s = (e.x * n + r.canonical.x) * i + r.wrap, a = (e.y * n + r.canonical.y) * i;
            return {
                min: new Mt((t1.x * n + r.canonical.x) * i + r.wrap, (t1.y * n + r.canonical.y) * i),
                max: new Mt(s, a)
            };
        }
        function Gd(t1, e, r) {
            const n = 1 << r.canonical.z, i = ((e.x - r.wrap) * n - r.canonical.x) * jn, s = (e.y * n - r.canonical.y) * jn;
            return {
                min: new Mt(((t1.x - r.wrap) * n - r.canonical.x) * jn, (t1.y * n - r.canonical.y) * jn),
                max: new Mt(i, s)
            };
        }
        function $d(t1, e, r, n, i, s, a) {
            const o = t1.indices, l = t1.vertices, u = [];
            for(let c = n; c < n + i; c += 3){
                const n = e[r[c + 0] + s], i = e[r[c + 1] + s], h = e[r[c + 2] + s], p = Math.min(n.x, i.x, h.x), d = Math.max(n.x, i.x, h.x), f = Math.min(n.y, i.y, h.y), m = Math.max(n.y, i.y, h.y);
                u.length = 0, t1.grid.query(new Mt(p, f), new Mt(d, m), u);
                for(let t1 = 0; t1 < u.length; t1++){
                    const e = u[t1];
                    if (jc(l[o[3 * e + 0]], l[o[3 * e + 1]], l[o[3 * e + 2]], n, i, h, a)) return !0;
                }
            }
            return !1;
        }
        function qd(t1, e, r, n) {
            if (!t1 || !r) return !1;
            let i = t1.vertices;
            if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {
                if (r.vertices.length < t1.vertices.length) return qd(r, n, t1, e);
                const s = e.canonical, a = n.canonical, o = Math.pow(2, a.z - s.z);
                i = t1.vertices.map((t1)=>new Mt((t1.x + s.x * jn) * o - a.x * jn, (t1.y + s.y * jn) * o - a.y * jn));
            }
            return $d(r, i, t1.indices, 0, t1.indices.length, 0, 0);
        }
        function Xd(t1, e, r, n) {
            const i = Math.pow(2, n.z - r.z);
            return new Mt((t1 + r.x * jn) * i - n.x * jn, (e + r.y * jn) * i - n.y * jn);
        }
        function Hd(t1, e) {
            const r = [];
            e.grid.queryPoint(t1, r);
            const n = e.indices, i = e.vertices;
            for(let e = 0; e < r.length; e++){
                const s = r[e];
                if (Lc([
                    i[n[3 * s + 0]],
                    i[n[3 * s + 1]],
                    i[n[3 * s + 2]]
                ], t1)) return !0;
            }
            return !1;
        }
        const Zd = [
            new Mt(0, 0),
            new Mt(jn, 0),
            new Mt(jn, jn),
            new Mt(0, jn)
        ];
        function Wd(t1, e) {
            const r = [];
            let n = [];
            if (!e || t1.length < 2) return [
                t1
            ];
            if (2 === t1.length) return Uc(t1[0], t1[1], Zd) ? [
                t1
            ] : [];
            for(let e = 0; e < t1.length + 2; e++){
                const i = t1[e % t1.length], s = t1[(e + 1) % t1.length], a = Uc(0 === e ? t1[t1.length - 1] : t1[(e - 1) % t1.length], i, Zd), o = Uc(i, s, Zd), l = a || o;
                l && n.push(i), l && o || n.length > 0 && (n.length > 1 && r.push(n), n = []);
            }
            return n.length > 1 && r.push(n), r;
        }
        const Yd = Qu.types, Jd = [
            "fill-extrusion-base",
            "fill-extrusion-height",
            "fill-extrusion-color",
            "fill-extrusion-pattern",
            "fill-extrusion-flood-light-wall-radius",
            "fill-extrusion-line-width",
            "fill-extrusion-emissive-strength"
        ], Kd = [
            "fill-extrusion-flood-light-ground-radius"
        ], Qd = Math.pow(2, 13), tf = Math.pow(2, 15) - 1, ef = new Mt(0, 1), rf = 2147483648;
        function nf(t1, e, r, n, i, s, a, o) {
            t1.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * Qd) << 1) + i, Math.round(o));
        }
        function sf(t1, e, r) {
            t1.emplaceBack(e.x * jn, e.y * jn, r ? 1 : 0);
        }
        function af(t1, e, r, n, i, s) {
            t1.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, s);
        }
        function of(t1, e, r) {
            const n = 16384;
            t1.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class lf {
            constructor(){
                this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
            }
        }
        class uf {
            constructor(){
                this.centroidXY = new Mt(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Mt(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Mt(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0, this.buildingId = 0;
            }
            span() {
                return new Mt(this.max.x - this.min.x, this.max.y - this.min.y);
            }
        }
        class cf {
            constructor(){
                this.acc = new Mt(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
            }
            startRing(t1, e) {
                t1.min.x === Number.MAX_VALUE && (t1.min.x = t1.max.x = e.x, t1.min.y = t1.max.y = e.y);
            }
            appendEdge(t1, e, r) {
                this.accCount++, this.acc._add(e);
                let n = !!this.borders;
                e.x < t1.min.x ? (t1.min.x = e.x, n = !0) : e.x > t1.max.x && (t1.max.x = e.x, n = !0), e.y < t1.min.y ? (t1.min.y = e.y, n = !0) : e.y > t1.max.y && (t1.max.y = e.y, n = !0), ((0 === e.x || e.x === jn) && e.x === r.x) != ((0 === e.y || e.y === jn) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);
            }
            checkBorderIntersection(t1, e) {
                e.x < 0 != t1.x < 0 && this.addBorderIntersection(0, dr(e.y, t1.y, (0 - e.x) / (t1.x - e.x))), e.x > jn != t1.x > jn && this.addBorderIntersection(1, dr(e.y, t1.y, (jn - e.x) / (t1.x - e.x))), e.y < 0 != t1.y < 0 && this.addBorderIntersection(2, dr(e.x, t1.x, (0 - e.y) / (t1.y - e.y))), e.y > jn != t1.y > jn && this.addBorderIntersection(3, dr(e.x, t1.x, (jn - e.y) / (t1.y - e.y)));
            }
            addBorderIntersection(t1, e) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r = this.borders[t1];
                e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
            }
            processBorderOverlap(t1, e) {
                if (t1.x === e.x) {
                    if (t1.y === e.y) return;
                    const r = 0 === t1.x ? 0 : 1;
                    this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t1.y);
                } else {
                    const r = 0 === t1.y ? 2 : 3;
                    this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t1.x);
                }
            }
            centroid() {
                return 0 === this.accCount ? new Mt(0, 0) : new Mt(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
            }
            intersectsCount() {
                return this.borders ? this.borders.reduce((t1, e)=>t1 + +(e[0] !== Number.MAX_VALUE), 0) : 0;
            }
        }
        function hf(t1, e) {
            const r = t1.add(e)._unit(), n = Dt(t1.x * r.x + t1.y * r.y, -1, 1);
            var i, s, a;
            return a = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(a))) / 4 * tf * ((i = t1).x * (s = e).y - i.y * s.x < 0 ? -1 : 1);
        }
        const pf = [
            (t1)=>t1.x < 0,
            (t1)=>t1.x > jn,
            (t1)=>t1.y < 0,
            (t1)=>t1.y > jn
        ];
        function df(t1, e, r, n) {
            const i = [
                4
            ];
            if (0 === n) return i;
            r._mult(n);
            const s = t1.sub(r), a = e.sub(r), o = [
                t1,
                e,
                s,
                a
            ];
            for(let t1 = 0; t1 < 4; t1++)for (const e of o)if (pf[t1](e)) {
                i.push(t1);
                break;
            }
            return i;
        }
        class ff {
            constructor(t1){
                this.groundRadiusArray = null, this.groundRadiusBuffer = null, this.vertexArray = new Ho, this.indexArray = new ll, this.programConfigurations = new fu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>Kd.includes(t1)), this._segments = new Ol, this.hiddenByLandmarkVertexArray = new _l, this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [
                    0,
                    0,
                    0,
                    0,
                    0
                ], this.regionSegments = {}, this.regionSegments[4] = new Ol;
            }
            getDefaultSegment() {
                return this.regionSegments[4];
            }
            hasData() {
                return 0 !== this.vertexArray.length;
            }
            addData(t1, e, r, n = !1) {
                const i = t1.length;
                if (i > 2) {
                    let s = Math.max(0, this._segments.get().length - 1);
                    const a = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[s].length);
                    let o;
                    s !== this._segments.get().length - 1 && (s++, this._segmentToGroundQuads[s] = [], this._segmentToRegionTriCounts[s] = [
                        0,
                        0,
                        0,
                        0,
                        0
                    ]);
                    {
                        const e = t1[0], r = t1[1];
                        o = hf(e.sub(t1[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());
                    }
                    for(let l = 0; l < i; l++){
                        const u = l === i - 1 ? 0 : l + 1, c = t1[l], h = t1[u], p = t1[u === i - 1 ? 0 : u + 1], d = h.sub(c)._perp()._unit(), f = hf(d, p.sub(h)._perp()._unit()), m = o, y = f;
                        if (vf(c, h, e) || n && bf(c, e) && bf(h, e)) {
                            o = f;
                            continue;
                        }
                        const g = a.vertexLength;
                        af(this.vertexArray, c, h, 1, 1, m), af(this.vertexArray, c, h, 1, 0, m), af(this.vertexArray, c, h, 0, 1, y), af(this.vertexArray, c, h, 0, 0, y), a.vertexLength += 4;
                        const x = df(c, h, d, r);
                        for (const t1 of x)this._segmentToGroundQuads[s].push({
                            id: g,
                            region: t1
                        }), this._segmentToRegionTriCounts[s][t1] += 2, a.primitiveLength += 2;
                        o = f;
                    }
                }
            }
            prepareBorderSegments() {
                if (!this.hasData()) return;
                const t1 = this._segments.get(), e = t1.length;
                for(let t1 = 0; t1 < e; t1++)this._segmentToGroundQuads[t1].sort((t1, e)=>t1.region - e.region);
                for(let r = 0; r < e; r++){
                    const e = this._segmentToGroundQuads[r], n = t1[r], i = this._segmentToRegionTriCounts[r];
                    i.reduce((t1, e)=>t1 + e, 0);
                    let s = 0;
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = i[t1];
                        if (0 !== e) {
                            let r = this.regionSegments[t1];
                            r || (r = this.regionSegments[t1] = new Ol);
                            const i = {
                                vertexOffset: n.vertexOffset,
                                primitiveOffset: n.primitiveOffset + s,
                                vertexLength: n.vertexLength,
                                primitiveLength: e
                            };
                            r.get().push(i);
                        }
                        s += e;
                    }
                    for(let t1 = 0; t1 < e.length; t1++){
                        const r = e[t1].id;
                        this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);
                    }
                }
                this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
            }
            addPaintPropertiesData(t1, e, r, n, i, s, a) {
                this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t1, e, r, n, i, s, void 0, a);
            }
            upload(t1) {
                this.hasData() && (this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, zd.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), null != this.groundRadiusArray && (this.groundRadiusBuffer = t1.createVertexBuffer(this.groundRadiusArray, Bd.members)));
            }
            uploadPaintProperties(t1) {
                this.hasData() && this.programConfigurations.upload(t1);
            }
            update(t1, e, r, n, i, s, a, o) {
                this.hasData() && this.programConfigurations.updatePaintArrays(t1, e, r, n, i, s, a, o);
            }
            updateHiddenByLandmark(t1) {
                this.updateHiddenByLandmarkRange(t1.groundVertexArrayOffset, t1.groundVertexCount, !!(t1.flags & rf));
            }
            updateHiddenByLandmarkRange(t1, e, r) {
                if (!this.hasData()) return;
                const n = e + t1;
                if (0 !== e) {
                    for(let e = t1; e < n; ++e)this.hiddenByLandmarkVertexArray.emplace(e, r ? 1 : 0);
                    this._needsHiddenByLandmarkUpdate = !0;
                }
            }
            uploadHiddenByLandmark(t1) {
                this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t1.createVertexBuffer(this.hiddenByLandmarkVertexArray, Vd.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
            }
            destroy() {
                if (this.vertexBuffer) {
                    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this.groundRadiusBuffer && this.groundRadiusBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = this.regionSegments[t1];
                        e && e.destroy();
                    }
                }
            }
        }
        class mf {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaling = t1.overscaling, this.layers = t1.layers, this.pixelRatio = t1.pixelRatio, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t1.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ll, this.footprintVertices = new No, this.footprintSegments = [], this.layoutVertexArray = new Go, this.centroidVertexArray = new El, this.wallVertexArray = new Dl, this.indexArray = new ll, this.programConfigurations = new fu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>Jd.includes(t1)), this.segments = new Ol, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.groundEffect = new ff(t1), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [], this.worldview = t1.worldview, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {}
            updateAppearances(t1, e, r, n) {}
            populate(t1, e, r, n) {
                this.features = [], this.hasPattern = zp("fill-extrusion", this.layers, this.pixelRatio, e), this.featuresOnBorder = [], this.borderFeatureIndices = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE
                ], this.tileToMeter = ju(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
                for (const { feature: i, id: s, index: a, sourceLayerIndex: o } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = Ku(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, {
                        worldview: this.worldview,
                        activeFloors: e.activeFloors
                    }), l, r)) continue;
                    const u = {
                        id: s,
                        sourceLayerIndex: o,
                        index: a,
                        geometry: t1 ? l.geometry : Ju(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }, c = this.layoutVertexArray.length, h = "Polygon" === Yd[u.type];
                    if (this.hasPattern) this.features.push({
                        featureId: i.id,
                        feature: Bp("fill-extrusion", this.layers, u, this.zoom, this.pixelRatio, e)
                    });
                    else if (this.wallMode) for (const t1 of u.geometry)for (const s of Wd(t1, h))this.addFeature(i.id, u, [
                        s
                    ], a, r, {}, e.availableImages, n, e.brightness);
                    else this.addFeature(i.id, u, u.geometry, a, r, {}, e.availableImages, n, e.brightness);
                    e.featureIndex.insert(i, u.geometry, a, o, this.index, c);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const { featureId: t1, feature: a } of this.features){
                    const o = "Polygon" === Yd[a.type], { geometry: l } = a;
                    if (this.wallMode) for (const u of l)for (const l of Wd(u, o))this.addFeature(t1, a, [
                        l
                    ], a.index, e, r, n, i, s);
                    else this.addFeature(t1, a, l, a.index, e, r, n, i, s);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
            }
            update(t1, e, r, n, i, s, a) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, this.worldview), this.groundEffect.update(t1, e, i, r, n, s, a, this.worldview);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Fd), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t1.createVertexBuffer(this.wallVertexArray, Td.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t1.createVertexBuffer(this.layoutVertexExtArray, Ed.members, !0)), this.groundEffect.upload(t1)), this.groundEffect.uploadPaintProperties(t1), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            uploadCentroid(t1) {
                this.groundEffect.uploadHiddenByLandmark(t1), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, kd.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e, r, n, i, s, a, o, l) {
                const u = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, c = [
                    new Mt(0, 0),
                    new Mt(jn, jn)
                ], h = o.projection, p = "globe" === h.name, d = this.wallMode || "Polygon" === Yd[e.type], f = new cf;
                f.centroidDataIndex = this.centroidData.length;
                const m = new uf;
                m.buildingId = t1, e.properties && e.properties.hasOwnProperty("building_id") && (m.buildingId = Number(e.properties.building_id));
                const y = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, i) <= 0, g = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, i);
                let x;
                if (m.height = g, m.vertexArrayOffset = this.layoutVertexArray.length, m.groundVertexArrayOffset = this.groundEffect.vertexArray.length, p && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ko), this.wallMode) {
                    if (p) return void Zt("Non zero fill-extrusion-line-width is not yet supported on globe.");
                    if (1 !== r.length) return;
                    x = function(t1) {
                        const e = t1[0].x === t1[t1.length - 1].x && t1[0].y === t1[t1.length - 1].y, r = function(t1) {
                            let e = 0;
                            const r = t1.length;
                            for(let n = 0; n < r; n++)e += (t1[(n + 1) % r].x - t1[n].x) * (t1[(n + 1) % r].y + t1[n].y);
                            return e >= 0;
                        }(t1);
                        r || (t1 = t1.reverse());
                        const n = {
                            geometry: [],
                            joinNormals: [],
                            indices: []
                        }, i = [], s = [], a = [];
                        let o = t1.length;
                        for(; o >= 2 && t1[o - 1].equals(t1[o - 2]);)o--;
                        if (o < (e ? 3 : 2)) return n;
                        let l, u, c, h, p, d = 0;
                        for(; d < o - 1 && t1[d].equals(t1[d + 1]);)d++;
                        e && (l = t1[o - 2], p = t1[d].sub(l)._unit()._perp());
                        for(let r = d; r < o; r++){
                            if (c = r === o - 1 ? e ? t1[d + 1] : void 0 : t1[r + 1], c && t1[r].equals(c)) continue;
                            p && (h = p), l && (u = l), l = t1[r], p = c ? c.sub(l)._unit()._perp() : h, h = h || p;
                            let n = h.add(p);
                            0 === n.x && 0 === n.y || n._unit();
                            const f = n.x * p.x + n.y * p.y, m = 0 !== f ? 1 / f : 1 / 0, y = h.x * p.y - h.y * p.x > 0;
                            let g = "miter";
                            const x = 2;
                            "miter" === g && m > x && (g = "bevel"), "bevel" === g && (m > 100 && (g = "flipbevel"), m < x && (g = "miter"));
                            const v = (t1, e, r, n)=>{
                                const o = new Mt(t1.x, t1.y), l = new Mt(t1.x, t1.y);
                                o.x += e.x * n, o.y += e.y * n, l.x -= e.x * Math.max(r, 1), l.y -= e.y * Math.max(r, 1), a.push(e), i.push(o), s.push(l);
                            };
                            if ("miter" === g) n._mult(m), v(l, n, 0, 0);
                            else if ("flipbevel" === g) n = p.mult(-1), v(l, n, 0, 0), v(l, n.mult(-1), 0, 0);
                            else {
                                const t1 = -Math.sqrt(m * m - 1), e = y ? t1 : 0, r = y ? 0 : t1;
                                u && v(l, h, e, r), c && v(l, p, e, r);
                            }
                        }
                        n.geometry = [
                            ...i,
                            ...s.reverse(),
                            i[0]
                        ], n.joinNormals = [
                            ...a,
                            ...a.reverse(),
                            a[a.length - 1]
                        ];
                        const f = n.geometry.length - 1;
                        for(let t1 = 0; t1 < f / 2; t1++)if (t1 + 1 < f / 2) {
                            let e = t1, r = t1 + 1, i = f - 1 - t1, s = f - 2 - t1;
                            e = 0 === e ? f - 1 : e - 1, r = 0 === r ? f - 1 : r - 1, i = 0 === i ? f - 1 : i - 1, s = 0 === s ? f - 1 : s - 1, n.indices.push(i), n.indices.push(r), n.indices.push(e), n.indices.push(i), n.indices.push(s), n.indices.push(r);
                        }
                        return n;
                    }(r[0]), r = [
                        x.geometry
                    ];
                }
                const v = (t1, e)=>t1 < (e.length - 1) / 2 || t1 === e.length - 1, b = this.wallMode ? [
                    r
                ] : Mp(r, 500);
                for(let t1 = b.length - 1; t1 >= 0; t1--){
                    const e = b[t1];
                    (0 === e.length || wf(e[0])) && b.splice(t1, 1);
                }
                let w;
                if (p) w = Mf(b, c, i);
                else {
                    w = [];
                    for (const t1 of b)w.push({
                        polygon: t1,
                        bounds: c
                    });
                }
                const _ = d ? this.edgeRadius : 0, A = _ > 0 && this.zoom < 17, I = (t1, e)=>{
                    if (0 === t1.length) return !1;
                    const r = t1[t1.length - 1];
                    return e.x === r.x && e.y === r.y;
                };
                for (const { polygon: t1, bounds: e } of w){
                    let r = 0, n = 0;
                    for (const e of t1)d && !e[0].equals(e[e.length - 1]) && e.push(e[0]), n += d ? e.length - 1 : e.length;
                    const s = this.segments.prepareSegment((d ? 5 : 4) * n, this.layoutVertexArray, this.indexArray);
                    m.footprintSegIdx < 0 && (m.footprintSegIdx = this.footprintSegments.length), m.polygonSegIdx < 0 && (m.polygonSegIdx = this.polygonSegments.length);
                    const a = {
                        triangleArrayOffset: this.indexArray.length,
                        triangleCount: 0,
                        triangleSegIdx: this.segments.segments.length - 1
                    }, o = new lf;
                    if (o.vertexOffset = this.footprintVertices.length, o.indexOffset = 3 * this.footprintIndices.length, o.ringIndices = [], d) {
                        const n = [], a = [];
                        r = s.vertexLength;
                        for(let r = 0; r < t1.length; r++){
                            const l = t1[r];
                            l.length && 0 !== r && a.push(n.length / 2);
                            const c = [];
                            let d, f;
                            d = l[1].sub(l[0])._perp()._unit(), o.ringIndices.push(l.length - 1);
                            for(let t1 = 1; t1 < l.length; t1++){
                                const e = l[t1], r = l[t1 === l.length - 1 ? 1 : t1 + 1], a = e.clone();
                                if (_) {
                                    f = r.sub(e)._perp()._unit();
                                    const t1 = d.add(f)._unit(), n = _ * Math.min(4, 1 / (d.x * t1.x + d.y * t1.y));
                                    a.x += n * t1.x, a.y += n * t1.y, a.x = Math.round(a.x), a.y = Math.round(a.y), d = f;
                                }
                                if (!y || 0 !== _ && !A || I(c, a) || c.push(a), nf(this.layoutVertexArray, a.x, a.y, 0, 0, 1, 1, 0), this.wallMode) {
                                    const e = v(t1, l);
                                    sf(this.wallVertexArray, x.joinNormals[t1], !e);
                                }
                                s.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), n.push(e.x, e.y), p && of(this.layoutVertexExtArray, h.projectTilePoint(a.x, a.y, i), h.upVector(i, a.x, a.y));
                            }
                            y && (0 === _ || A) && (0 !== c.length && I(c, c[0]) && c.pop(), this.groundEffect.addData(c, e, u));
                        }
                        const l = this.wallMode ? x.indices : Qh(n, a);
                        for(let t1 = 0; t1 < l.length; t1 += 3)this.footprintIndices.emplaceBack(o.vertexOffset + l[t1 + 0], o.vertexOffset + l[t1 + 1], o.vertexOffset + l[t1 + 2]), this.indexArray.emplaceBack(r + l[t1], r + l[t1 + 2], r + l[t1 + 1]), s.primitiveLength++;
                        o.indexCount += l.length, o.vertexCount += this.footprintVertices.length - o.vertexOffset;
                    }
                    for(let n = 0; n < t1.length; n++){
                        const a = t1[n];
                        f.startRing(m, a[0]);
                        let o = a.length > 4 && _f(a[a.length - 2], a[0], a[1]), l = _ ? gf(a[a.length - 2], a[0], a[1], _) : 0;
                        const c = [];
                        let g, b, w;
                        b = a[1].sub(a[0])._perp()._unit();
                        let A = !0;
                        for(let t1 = 1, n = 0; t1 < a.length; t1++){
                            let u = a[t1 - 1], d = a[t1];
                            const M = a[t1 === a.length - 1 ? 1 : t1 + 1];
                            if (f.appendEdge(m, d, u), vf(d, u, e)) {
                                _ && (b = M.sub(d)._perp()._unit(), A = !A);
                                continue;
                            }
                            const S = d.sub(u)._perp(), P = S.x / (Math.abs(S.x) + Math.abs(S.y)), z = S.y > 0 ? 1 : 0, B = u.dist(d);
                            if (n + B > 32768 && (n = 0), _) {
                                w = M.sub(d)._perp()._unit();
                                let t1 = xf(u, d, M, yf(b, w), _);
                                isNaN(t1) && (t1 = 0);
                                const e = d.sub(u)._unit();
                                u = u.add(e.mult(l))._round(), d = d.add(e.mult(-t1))._round(), l = t1, b = w, y && this.zoom >= 17 && (I(c, u) || c.push(u), I(c, d) || c.push(d));
                            }
                            const k = s.vertexLength, T = a.length > 4 && _f(u, d, M);
                            let V = Af(n, o, A);
                            if (nf(this.layoutVertexArray, u.x, u.y, P, z, 0, 0, V), nf(this.layoutVertexArray, u.x, u.y, P, z, 0, 1, V), this.wallMode) {
                                const e = v(t1 - 1, a), r = x.joinNormals[t1 - 1];
                                sf(this.wallVertexArray, r, e), sf(this.wallVertexArray, r, e);
                            }
                            if (n += B, V = Af(n, T, !A), o = T, nf(this.layoutVertexArray, d.x, d.y, P, z, 0, 0, V), nf(this.layoutVertexArray, d.x, d.y, P, z, 0, 1, V), this.wallMode) {
                                const e = v(t1, a), r = x.joinNormals[t1];
                                sf(this.wallVertexArray, r, e), sf(this.wallVertexArray, r, e);
                            }
                            if (s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, _) {
                                const n = r + (1 === t1 ? a.length - 2 : t1 - 2), i = 1 === t1 ? r : n + 1;
                                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, i, k + 3), s.primitiveLength += 2, void 0 === g && (g = k), !vf(M, a[t1], e)) {
                                    const e = t1 === a.length - 1 ? g : s.vertexLength;
                                    this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, i, e + 1), s.primitiveLength += 3;
                                }
                                A = !A;
                            }
                            if (p) {
                                const t1 = this.layoutVertexExtArray, e = h.projectTilePoint(u.x, u.y, i), r = h.projectTilePoint(d.x, d.y, i), n = h.upVector(i, u.x, u.y), s = h.upVector(i, d.x, d.y);
                                of(t1, e, n), of(t1, e, n), of(t1, r, s), of(t1, r, s);
                            }
                        }
                        d && (r += a.length - 1), y && _ && this.zoom >= 17 && (0 !== c.length && I(c, c[0]) && c.pop(), this.groundEffect.addData(c, e, u, _ > 0));
                    }
                    this.footprintSegments.push(o), a.triangleCount = this.indexArray.length - a.triangleArrayOffset, this.polygonSegments.push(a), ++m.footprintSegLen, ++m.polygonSegLen;
                }
                if (m.vertexCount = this.layoutVertexArray.length - m.vertexArrayOffset, m.groundVertexCount = this.groundEffect.vertexArray.length - m.groundVertexArrayOffset, 0 !== m.vertexCount) {
                    if (m.centroidXY = f.borders ? ef : this.encodeCentroid(f, m), this.centroidData.push(m), f.borders) {
                        this.featuresOnBorder.push(f);
                        const t1 = this.featuresOnBorder.length - 1;
                        for(let e = 0; e < f.borders.length; e++)f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t1);
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, s, a, i, l, void 0, this.worldview), this.groundEffect.addPaintPropertiesData(e, n, s, a, i, l, this.worldview), this.maxHeight = Math.max(this.maxHeight, g);
                }
            }
            sortBorders() {
                for(let t1 = 0; t1 < this.borderFeatureIndices.length; t1++)this.borderFeatureIndices[t1].sort((e, r)=>this.featuresOnBorder[e].borders[t1][0] - this.featuresOnBorder[r].borders[t1][0]);
            }
            splitToSubtiles() {
                const t1 = [];
                for(let e = 0; e < this.centroidData.length; e++){
                    const r = this.centroidData[e], n = +(r.min.y + r.max.y > jn), i = 2 * n + (+(r.min.x + r.max.x > jn) ^ n);
                    for(let n = 0; n < r.polygonSegLen; n++){
                        const s = r.polygonSegIdx + n;
                        t1.push({
                            centroidIdx: e,
                            subtile: i,
                            polygonSegmentIdx: s,
                            triangleSegmentIdx: this.polygonSegments[s].triangleSegIdx
                        });
                    }
                }
                const e = new ll;
                t1.sort((t1, e)=>t1.triangleSegmentIdx === e.triangleSegmentIdx ? t1.subtile - e.subtile : t1.triangleSegmentIdx - e.triangleSegmentIdx);
                let r = 0, n = 0, i = 0;
                for (const e of t1){
                    if (e.triangleSegmentIdx !== r) break;
                    i++;
                }
                const s = t1.length;
                for(; n !== t1.length;){
                    r = t1[n].triangleSegmentIdx;
                    let a = 0, o = n, l = n;
                    for(let e = o; e < i && t1[e].subtile === a; e++)l++;
                    for(; o !== i;){
                        const n = t1[o];
                        a = n.subtile;
                        const s = this.centroidData[n.centroidIdx].min.clone(), u = this.centroidData[n.centroidIdx].max.clone(), c = {
                            vertexOffset: this.segments.segments[r].vertexOffset,
                            primitiveOffset: e.length,
                            vertexLength: this.segments.segments[r].vertexLength,
                            primitiveLength: 0,
                            sortKey: void 0,
                            vaos: {}
                        };
                        for(let r = o; r < l; r++){
                            const n = t1[r], i = this.polygonSegments[n.polygonSegmentIdx], a = this.centroidData[n.centroidIdx].min, o = this.centroidData[n.centroidIdx].max, l = this.indexArray.uint16;
                            for(let t1 = i.triangleArrayOffset; t1 < i.triangleArrayOffset + i.triangleCount; t1++)e.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
                            c.primitiveLength += i.triangleCount, s.x = Math.min(s.x, a.x), s.y = Math.min(s.y, a.y), u.x = Math.max(u.x, o.x), u.y = Math.max(u.y, o.y);
                        }
                        c.primitiveLength > 0 && this.triangleSubSegments.push({
                            segment: c,
                            min: s,
                            max: u
                        }), o = l;
                        for(let e = o; e < i && t1[e].subtile === t1[o].subtile; e++)l++;
                    }
                    n = i;
                    for(let e = n; e < s && t1[e].triangleSegmentIdx === t1[n].triangleSegmentIdx; e++)i++;
                }
                e._trim(), this.indexArray = e;
            }
            getVisibleSegments(t1, e, r) {
                const n = new Ol;
                if (this.wallMode) {
                    for (const t1 of this.triangleSubSegments)n.segments.push(t1.segment);
                    return n;
                }
                let i = 0, s = 0;
                const a = 1 << t1.canonical.z;
                if (e) {
                    const r = e.getMinMaxForTile(t1);
                    r && (i = r.min, s = r.max);
                }
                s += this.maxHeight;
                const o = t1.toUnwrapped();
                let l;
                const u = [
                    o.canonical.x / a + o.wrap,
                    o.canonical.y / a
                ], c = [
                    (o.canonical.x + 1) / a + o.wrap,
                    (o.canonical.y + 1) / a
                ], h = (t1, e, r)=>[
                        t1[0] * (1 - r[0]) + e[0] * r[0],
                        t1[1] * (1 - r[1]) + e[1] * r[1]
                    ], p = [], d = [];
                for (const t1 of this.triangleSubSegments){
                    p[0] = t1.min.x / jn, p[1] = t1.min.y / jn, d[0] = t1.max.x / jn, d[1] = t1.max.y / jn;
                    const e = h(u, c, p), a = h(u, c, d);
                    if (0 === new wc([
                        e[0],
                        e[1],
                        i
                    ], [
                        a[0],
                        a[1],
                        s
                    ]).intersectsPrecise(r)) {
                        l && (n.segments.push(l), l = void 0);
                        continue;
                    }
                    const o = t1.segment;
                    l && l.vertexOffset !== o.vertexOffset && (n.segments.push(l), l = void 0), l ? (l.vertexLength += o.vertexLength, l.primitiveLength += o.primitiveLength) : l = {
                        vertexOffset: o.vertexOffset,
                        primitiveLength: o.primitiveLength,
                        vertexLength: o.vertexLength,
                        primitiveOffset: o.primitiveOffset,
                        sortKey: void 0,
                        vaos: {}
                    };
                }
                return l && n.segments.push(l), n;
            }
            encodeCentroid(t1, e) {
                const r = t1.centroid(), n = e.span(), i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)), s = Math.min(7, Math.round(n.y * this.tileToMeter / 10));
                return new Mt(Dt(r.x, 1, 8191) << 3 | i, Dt(r.y, 1, 8191) << 3 | s);
            }
            encodeBorderCentroid(t1) {
                if (!t1.borders) return new Mt(0, 0);
                const e = t1.borders, r = Number.MAX_VALUE;
                if (e[0][0] !== r || e[1][0] !== r) {
                    const t1 = e[0][0] !== r ? 0 : 1;
                    return new Mt(6 | (e[0][0] !== r ? 0 : 65528), (e[t1][0] + e[t1][1]) / 2 << 3 | 6);
                }
                {
                    const t1 = e[2][0] !== r ? 2 : 3;
                    return new Mt((e[t1][0] + e[t1][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));
                }
            }
            showCentroid(t1) {
                const e = this.centroidData[t1.centroidDataIndex];
                e.flags &= 2147483647, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);
            }
            writeCentroidToBuffer(t1) {
                this.groundEffect.updateHiddenByLandmark(t1);
                const e = t1.vertexArrayOffset, r = t1.vertexCount + t1.vertexArrayOffset, n = t1.flags & rf ? ef : t1.centroidXY, i = this.centroidVertexArray.geta_centroid_pos0(e);
                if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {
                    for(let t1 = e; t1 < r; ++t1)this.centroidVertexArray.emplace(t1, n.x, n.y);
                    this.needsCentroidUpdate = !0;
                }
            }
            createCentroidsBuffer() {
                this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped());
                if (Nd(this.activeReplacements, n)) return;
                if (this.activeReplacements = n, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
                else for (const t1 of this.centroidData)t1.flags &= 2147483647;
                const i = [];
                for (const e of this.activeReplacements){
                    if (e.order < r) continue;
                    const n = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t1.canonical.z));
                    if (e.footprint.buildingIds) for (const t1 of this.centroidData)t1.flags & rf || e.min.x > t1.max.x || t1.min.x > e.max.x || e.min.y > t1.max.y || t1.min.y > e.max.y || e.footprint.buildingIds.has(t1.buildingId) && (t1.flags |= rf);
                    else for (const r of this.centroidData)if (!(r.flags & rf || e.min.x > r.max.x || r.min.x > e.max.x || e.min.y > r.max.y || r.min.y > e.max.y)) for(let s = 0; s < r.footprintSegLen; s++){
                        const a = this.footprintSegments[r.footprintSegIdx + s];
                        if (i.length = 0, Sf(this.footprintVertices, a.vertexOffset, a.vertexCount, e.footprintTileId.canonical, t1.canonical, i), $d(e.footprint, i, this.footprintIndices.uint16, a.indexOffset, a.indexCount, -a.vertexOffset, -n)) {
                            r.flags |= rf;
                            break;
                        }
                    }
                }
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
                this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ];
            }
            footprintContainsPoint(t1, e, r) {
                let n = !1;
                for(let i = 0; i < r.footprintSegLen; i++){
                    const s = this.footprintSegments[r.footprintSegIdx + i];
                    let a = 0;
                    for (const r of s.ringIndices){
                        for(let i = a, o = r + a - 1; i < r + a; o = i++){
                            const r = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 0], a = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 1], l = this.footprintVertices.int16[2 * (o + s.vertexOffset) + 1];
                            a > e != l > e && t1 < (this.footprintVertices.int16[2 * (o + s.vertexOffset) + 0] - r) * (e - a) / (l - a) + r && (n = !n);
                        }
                        a = r;
                    }
                }
                return n;
            }
            getHeightAtTileCoord(t1, e) {
                let r = Number.NEGATIVE_INFINITY, n = !0;
                const i = 4 * (t1 + jn) * jn + (e + jn);
                if (this.partLookup.hasOwnProperty(i)) {
                    const t1 = this.partLookup[i];
                    return t1 ? {
                        height: t1.height,
                        hidden: !!(t1.flags & rf)
                    } : void 0;
                }
                for (const s of this.centroidData)t1 > s.max.x || s.min.x > t1 || e > s.max.y || s.min.y > e || s.height <= r || this.footprintContainsPoint(t1, e, s) && (r = s.height, this.partLookup[i] = s, n = !!(s.flags & rf));
                if (r !== Number.NEGATIVE_INFINITY) return {
                    height: r,
                    hidden: n
                };
                this.partLookup[i] = void 0;
            }
        }
        function yf(t1, e) {
            const r = t1.add(e)._unit();
            return t1.x * r.x + t1.y * r.y;
        }
        function gf(t1, e, r, n) {
            const i = e.sub(t1)._perp()._unit(), s = r.sub(e)._perp()._unit();
            return xf(t1, e, r, yf(i, s), n);
        }
        function xf(t1, e, r, n, i) {
            const s = Math.sqrt(1 - n * n);
            return Math.min(t1.dist(e) / 3, e.dist(r) / 3, i * s / n);
        }
        function vf(t1, e, r) {
            return t1.x < r[0].x && e.x < r[0].x || t1.x > r[1].x && e.x > r[1].x || t1.y < r[0].y && e.y < r[0].y || t1.y > r[1].y && e.y > r[1].y;
        }
        function bf(t1, e) {
            return t1.x < e[0].x || t1.x > e[1].x || t1.y < e[0].y || t1.y > e[1].y;
        }
        function wf(t1) {
            return t1.every((t1)=>t1.x <= 0) || t1.every((t1)=>t1.x >= jn) || t1.every((t1)=>t1.y <= 0) || t1.every((t1)=>t1.y >= jn);
        }
        function _f(t1, e, r) {
            if (t1.x < 0 || t1.x >= jn || e.x < 0 || e.x >= jn || r.x < 0 || r.x >= jn) return !1;
            const n = r.sub(e), i = n.perp(), s = t1.sub(e);
            return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;
        }
        function Af(t1, e, r) {
            const n = e ? 2 | t1 : -3 & t1;
            return r ? 1 | n : -2 & n;
        }
        function If() {
            const t1 = Math.PI / 32, e = Math.tan(t1), r = Pu;
            return r * Math.sqrt(1 + 2 * e * e) - r;
        }
        function Mf(t1, e, r) {
            const n = 1 << r.z, i = Du(r.x / n), s = Du((r.x + 1) / n), a = Cu(r.y / n), o = Cu((r.y + 1) / n);
            return function(t1, e, r, n, i = 0, s) {
                const a = [];
                if (!t1.length || !r || !n) return a;
                const o = (t1, e)=>{
                    for (const r of t1)a.push({
                        polygon: r,
                        bounds: e
                    });
                }, l = Math.ceil(Math.log2(r)), u = Math.ceil(Math.log2(n)), c = l - u, h = [];
                for(let t1 = 0; t1 < Math.abs(c); t1++)h.push(c > 0 ? 0 : 1);
                for(let t1 = 0; t1 < Math.min(l, u); t1++)h.push(0), h.push(1);
                let p = t1;
                if (p = dd(p, e[0].y - i, e[1].y + i, 1), p = dd(p, e[0].x - i, e[1].x + i, 0), !p.length) return a;
                const d = [];
                for(h.length ? d.push({
                    polygons: p,
                    bounds: e,
                    depth: 0
                }) : o(p, e); d.length;){
                    const t1 = d.pop(), e = t1.depth, r = h[e], n = t1.bounds[0], a = t1.bounds[1], l = 0 === r ? n.x : n.y, u = 0 === r ? a.x : a.y, c = ("TURBOPACK compile-time truthy", 1) ? s(r, l, u) : "TURBOPACK unreachable", p = dd(t1.polygons, l - i, c + i, r), f = dd(t1.polygons, c - i, u + i, r);
                    if (p.length) {
                        const t1 = [
                            n,
                            new Mt(0 === r ? c : a.x, 1 === r ? c : a.y)
                        ];
                        h.length > e + 1 ? d.push({
                            polygons: p,
                            bounds: t1,
                            depth: e + 1
                        }) : o(p, t1);
                    }
                    if (f.length) {
                        const t1 = [
                            new Mt(0 === r ? c : n.x, 1 === r ? c : n.y),
                            a
                        ];
                        h.length > e + 1 ? d.push({
                            polygons: f,
                            bounds: t1,
                            depth: e + 1
                        }) : o(f, t1);
                    }
                }
                return a;
            }(t1, e, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t1, e, i)=>{
                if (0 === t1) return .5 * (e + i);
                {
                    const t1 = Cu((r.y + e / jn) / n);
                    return (Eu(.5 * (Cu((r.y + i / jn) / n) + t1)) * n - r.y) * jn;
                }
            });
        }
        function Sf(t1, e, r, n, i, s) {
            const a = Math.pow(2, n.z - i.z);
            for(let o = 0; o < r; o++){
                let r = t1.int16[2 * (o + e) + 0], l = t1.int16[2 * (o + e) + 1];
                r = (r + i.x * jn) * a - n.x * jn, l = (l + i.y * jn) * a - n.y * jn, s.push(new Mt(r, l));
            }
        }
        let Pf, zf;
        Qs(mf, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), Qs(uf, "PartData"), Qs(lf, "FootprintSegment"), Qs(cf, "BorderCentroidData"), Qs(ff, "GroundEffect");
        class Bf extends Mt {
            constructor(t1, e, r){
                super(t1, e), this.z = r;
            }
        }
        class kf extends Bf {
            constructor(t1, e, r, n){
                super(t1, e, r), this.w = n;
            }
        }
        function Tf(t1, e, r, n) {
            const i = "x" === r ? "y" : "x", s = (n - t1[r]) / (e[r] - t1[r]);
            t1[i] = Math.round(t1[i] + (e[i] - t1[i]) * s), t1[r] = n, t1.hasOwnProperty("z") && (t1.z = dr(t1.z, e.z, s)), t1.hasOwnProperty("w") && (t1.w = dr(t1.w, e.w, s));
        }
        function Vf(t1, e, r, n) {
            const i = r, s = n;
            for (const r of [
                "x",
                "y"
            ]){
                let n = t1, a = e;
                n[r] >= a[r] && (n = e, a = t1), n[r] < i && a[r] > i && Tf(n, a, r, i), n[r] < s && a[r] > s && Tf(a, n, r, s);
            }
        }
        function Ef(t1, e, r, n, i, s) {
            const a = [];
            for(let o = 0; o < t1.length; o++){
                const l = t1[o];
                let u;
                const c = a.length;
                let h = 0;
                for(let t1 = 0; t1 < l.length - 1; t1++){
                    let c = l[t1], p = l[t1 + 1], d = 0;
                    const f = h;
                    let m, y;
                    s && (d = Math.hypot(p.x - c.x, p.y - c.y), h += d, m = c, y = p), c.x < e && p.x < e || (c.x < e ? c = new Mt(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x < e && (p = new Mt(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y < r && p.y < r || (c.y < r ? c = new Mt(c.x + (r - c.y) / (p.y - c.y) * (p.x - c.x), r)._round() : p.y < r && (p = new Mt(c.x + (r - c.y) / (p.y - c.y) * (p.x - c.x), r)._round()), c.x >= n && p.x >= n || (c.x >= n ? c = new Mt(n, c.y + (n - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x >= n && (p = new Mt(n, c.y + (n - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y >= i && p.y >= i || (c.y >= i ? c = new Mt(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round() : p.y >= i && (p = new Mt(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round()), u && c.equals(u[u.length - 1]) || (u = [
                        c
                    ], a.push(u), s && s.push({
                        progress: {
                            min: f + Df(m, y, c) * d,
                            max: 1
                        },
                        parentIndex: o,
                        prevPoint: m,
                        nextPoint: y
                    })), u.push(p), s && (s[s.length - 1].progress.max = f + Df(m, y, p) * d, s[s.length - 1].nextPoint = y)))));
                }
                if (s && h > 0) for(let t1 = c; t1 < a.length; t1++)s[t1].progress.min /= h, s[t1].progress.max /= h;
            }
            return a;
        }
        function Ff(t1, e, r, n, i) {
            if (t1.length < 2) return void n.push(t1);
            const s = [];
            for(; e.valid();){
                const [r, n] = e.get();
                for(let e = 0; e < t1.length - 1; e++){
                    const i = t1[e], a = t1[e + 1], o = Fc(i, a, r, n);
                    if (o) {
                        const [t1] = o, r = new Mt(dr(i.x, a.x, t1), dr(i.y, a.y, t1));
                        s.push({
                            t: e + t1,
                            distance: 0,
                            point: r
                        });
                    }
                }
                e.next();
            }
            if (0 === s.length) return void n.push(t1);
            s.sort((t1, e)=>t1.t - e.t);
            let a = 0, o = 0, l = [];
            for(n.push(l); a !== t1.length;){
                if (o === s.length) {
                    for(; a !== t1.length;)0 !== l.length && l[l.length - 1].equals(t1[a]) || l.push(t1[a]), a++;
                    break;
                }
                s[o].t <= a ? (0 !== l.length && l[l.length - 1].equals(s[o].point) || l.push(s[o].point), Math.trunc(s[o].t), o++) : (0 !== l.length && l[l.length - 1].equals(t1[a]) || l.push(t1[a]), a++);
            }
        }
        function Df(t1, e, r) {
            return t1.x !== e.x ? (r.x - t1.x) / (e.x - t1.x) : t1.y !== e.y ? (r.y - t1.y) / (e.y - t1.y) : 0;
        }
        function Cf(t1, e) {
            return t1.x * e.x + t1.y * e.y;
        }
        function Rf(t1, e) {
            if (1 === t1.length) {
                let r = 0;
                const n = e[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e[r++], !i) return 1 / 0;
                for(; r < e.length; r++){
                    const s = e[r], a = t1[0], o = i.sub(n), l = s.sub(n), u = a.sub(n), c = Cf(o, o), h = Cf(o, l), p = Cf(l, l), d = Cf(u, o), f = Cf(u, l), m = c * p - h * h, y = (p * d - h * f) / m, g = (c * f - h * d) / m, x = n.z * (1 - y - g) + i.z * y + s.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        function Lf(t1, e, r) {
            let n = 1 / 0;
            Bc(r, e) && (n = Rf(r, e[0]));
            for(let i = 0; i < e.length; i++){
                const s = e[i], a = t1[i];
                for(let t1 = 0; t1 < s.length - 1; t1++){
                    const e = s[t1], i = [
                        e,
                        s[t1 + 1],
                        a[t1 + 1],
                        a[t1],
                        e
                    ];
                    Pc(r, i) && (n = Math.min(n, Rf(r, i)));
                }
            }
            return n !== 1 / 0 && n;
        }
        function Of(t1, e, r, n, i, s, a, o, l, u, c) {
            return "globe" === t1.projection.name ? function(t1, e, r, n, i, s, a, o, l, u, c) {
                const h = [], p = [], d = t1.projection.upVectorScale(c, t1.center.lat, t1.worldSize).metersToTile, f = [
                    0,
                    0,
                    0,
                    1
                ], m = [
                    0,
                    0,
                    0,
                    1
                ], y = (t1, e, r, n)=>{
                    t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = 1;
                }, g = If();
                r > 0 && (r += g), n += g;
                for (const g of e){
                    const e = [], x = [];
                    for (const h of g){
                        const p = h.x + i.x, g = h.y + i.y, v = t1.projection.projectTilePoint(p, g, c), b = t1.projection.upVector(c, h.x, h.y);
                        let w = r, _ = n;
                        if (a) {
                            const t1 = Uf(p, g, r, n, a, o, l, u);
                            w += t1.base, _ += t1.top;
                        }
                        0 !== r ? y(f, v.x + b[0] * d * w, v.y + b[1] * d * w, v.z + b[2] * d * w) : y(f, v.x, v.y, v.z), y(m, v.x + b[0] * d * _, v.y + b[1] * d * _, v.z + b[2] * d * _), j(f, f, s), j(m, m, s), e.push(new Bf(f[0], f[1], f[2])), x.push(new Bf(m[0], m[1], m[2]));
                    }
                    h.push(e), p.push(x);
                }
                return [
                    h,
                    p
                ];
            }(t1, e, r, n, i, s, a, o, l, u, c) : a ? function(t1, e, r, n, i, s, a, o, l) {
                const u = [], c = [], h = [
                    0,
                    0,
                    0,
                    1
                ];
                for (const p of t1){
                    const t1 = [], d = [];
                    for (const u of p){
                        const c = u.x + n.x, p = u.y + n.y, f = Uf(c, p, e, r, s, a, o, l);
                        h[0] = c, h[1] = p, h[2] = f.base, h[3] = 1, tt(h, h, i), h[3] = Math.max(h[3], 1e-5);
                        const m = new Bf(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                        h[0] = c, h[1] = p, h[2] = f.top, h[3] = 1, tt(h, h, i), h[3] = Math.max(h[3], 1e-5);
                        const y = new Bf(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                        t1.push(m), d.push(y);
                    }
                    u.push(t1), c.push(d);
                }
                return [
                    u,
                    c
                ];
            }(e, r, n, i, s, a, o, l, u) : function(t1, e, r, n, i) {
                const s = [], a = [], o = i[8] * e, l = i[9] * e, u = i[10] * e, c = i[11] * e, h = i[8] * r, p = i[9] * r, d = i[10] * r, f = i[11] * r;
                for (const e of t1){
                    const t1 = [], r = [];
                    for (const s of e){
                        const e = s.x + n.x, a = s.y + n.y, m = i[0] * e + i[4] * a + i[12], y = i[1] * e + i[5] * a + i[13], g = i[2] * e + i[6] * a + i[14], x = i[3] * e + i[7] * a + i[15], v = m + o, b = y + l, w = g + u, _ = Math.max(x + c, 1e-5), A = m + h, I = y + p, M = g + d, S = Math.max(x + f, 1e-5);
                        t1.push(new Bf(v / _, b / _, w / _)), r.push(new Bf(A / S, I / S, M / S));
                    }
                    s.push(t1), a.push(r);
                }
                return [
                    s,
                    a
                ];
            }(e, r, n, i, s);
        }
        function Uf(t1, e, r, n, i, s, a, o) {
            const l = a * i.getElevationAt(t1, e, !0, !0), u = 0 !== s[0], c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function(t1, e, r) {
                const n = Math.floor(e[0] / 8), i = Math.floor(e[1] / 8), s = 10 * (e[0] - 8 * n), a = 10 * (e[1] - 8 * i), o = t1.getElevationAt(n, i, !0, !0), l = t1.getMeterToDEM(r), u = Math.floor(.5 * (s * l - 1)), c = Math.floor(.5 * (a * l - 1)), h = t1.tileCoordToPixel(n, i), p = 2 * u + 1, d = 2 * c + 1, f = function(t1, e, r, n, i) {
                    return [
                        t1.getElevationAtPixel(e, r, !0),
                        t1.getElevationAtPixel(e + i, r, !0),
                        t1.getElevationAtPixel(e, r + i, !0),
                        t1.getElevationAtPixel(e + n, r + i, !0)
                    ];
                }(t1, h.x - u, h.y - c, p, d), m = Math.abs(f[0] - f[1]), y = Math.abs(f[2] - f[3]), g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]), x = Math.min(.25, .5 * l * (m + y) / p), v = Math.min(.25, .5 * l * g / d);
                return o + Math.max(x * s, v * a);
            }(i, s, o) : l;
            return {
                base: l + (0 === r ? -1 : r),
                top: u ? Math.max(c + n, l + r + 2) : l + n
            };
        }
        class Nf {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{};
            }
        }
        class jf {
            constructor(){
                this.tasks = {}, this.taskQueue = [], jt([
                    "process"
                ], this), this.invoker = new Nf(this.process), this.nextId = 0;
            }
            add(t1, e) {
                const r = this.nextId++, n = function({ type: t1, isSymbolTile: e, zoom: r }) {
                    return r = r || 0, "message" === t1 ? 0 : "maybePrepare" !== t1 || e ? "parseTile" !== t1 || e ? "parseTile" === t1 && e ? 300 - r : "maybePrepare" === t1 && e ? 400 - r : 500 : 200 - r : 100 - r;
                }(e);
                if (0 === n) {
                    try {
                        t1();
                    } finally{}
                    return null;
                }
                return this.tasks[r] = {
                    fn: t1,
                    metadata: e,
                    priority: n,
                    id: r
                }, this.taskQueue.push(r), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r];
                    }
                };
            }
            process() {
                try {
                    if (this.taskQueue = this.taskQueue.filter((t1)=>!!this.tasks[t1]), !this.taskQueue.length) return;
                    const t1 = this.pick();
                    if (null === t1) return;
                    const e = this.tasks[t1];
                    if (delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), !e) return;
                    e.fn();
                } finally{}
            }
            pick() {
                let t1 = null, e = 1 / 0;
                for(let r = 0; r < this.taskQueue.length; r++){
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e && (e = n.priority, t1 = r);
                }
                if (null === t1) return null;
                const r = this.taskQueue[t1];
                return this.taskQueue.splice(t1, 1), r;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class Gf {
            constructor(t1, e, r){
                this.target = t1, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, jt([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new jf;
            }
            send(t1, e, r, n, i = !1, s) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s, this.callbacks[a] = r);
                const o = new Set;
                return this.target.postMessage({
                    id: a,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: ea(e, o)
                }, o), {
                    cancel: ()=>{
                        r && delete this.callbacks[a], this.target.postMessage({
                            id: a,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e = t1.data;
                if (!e) return;
                const r = e.id;
                if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {
                    const t1 = this.cancelCallbacks[r];
                    delete this.cancelCallbacks[r], t1 && t1.cancel();
                } else if (e.mustQueue || Kt(self)) {
                    const t1 = this.callbacks[r], n = this.scheduler.add(()=>this.processTask(r, e), t1 && t1.metadata || {
                        type: "message"
                    });
                    n && (this.cancelCallbacks[r] = n);
                } else this.processTask(r, e);
            }
            processTask(t1, e) {
                if (delete this.cancelCallbacks[t1], "<response>" === e.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e.error ? r(ra(e.error)) : r(null, ra(e.data)));
                } else {
                    const r = new Set, n = e.hasCallback ? (e, n)=>{
                        this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e ? ea(e) : null,
                            data: ea(n, r)
                        }, r);
                    } : ()=>{}, i = ra(e.data);
                    if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e.type.split("."), { source: r, scope: s } = i;
                        this.parent.getWorkerSource(e.sourceMapId, t1[0], r, s)[t1[1]](i, n);
                    } else n(new Error(`Could not find function ${e.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }
        var $f = {
            workerUrl: "",
            workerClass: null,
            workerParams: void 0
        };
        function qf(t1) {
            return null != $f.workerClass ? new $f.workerClass : new self.Worker($f.workerUrl, Object.assign({
                name: t1
            }, $f.workerParams));
        }
        const Xf = "mapboxgl_preloaded_worker_pool";
        class Hf {
            constructor(t1){
                this.active = {}, this.name = t1;
            }
            acquire(t1, e = Hf.workerCount) {
                if (!this.workers) for(this.workers = []; this.workers.length < e;){
                    const e = qf(`${this.name || ""}WorkerPool: ${t1}-${this.workers.length}`);
                    this.workers.push(e);
                }
                return this.active[t1] = !0, this.workers.slice();
            }
            release(t1) {
                delete this.active[t1], this.workers && 0 === this.numActive() && (this.workers.forEach((t1)=>{
                    t1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[Xf];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        Hf.workerCount = 2;
        class Zf {
            constructor(t1, e, r = "Worker", n = Hf.workerCount){
                this.workerPool = t1, this.actors = [], this.currentActor = 0, this.id = Ut();
                const i = this.workerPool.acquire(this.id, n);
                for(let t1 = 0; t1 < i.length; t1++){
                    const n = new Zf.Actor(i[t1], e, this.id);
                    n.name = `${r} ${t1}`, this.actors.push(n);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t1, e, r) {
                Lt(this.actors, (r, n)=>{
                    r.send(t1, e, n);
                }, r = r || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((t1)=>{
                    t1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        let Wf, Yf;
        function Jf() {
            return Wf || (Wf = new Hf), Wf;
        }
        Zf.Actor = Gf;
        const Kf = 4096;
        class Qf {
            constructor(t1){
                this.module = t1, this.memoryStack = this.module.malloc(Kf), this.memoryStackNextFree = this.memoryStack;
            }
            createIntArray(t1) {
                const e = this.memoryStackNextFree;
                return this.memoryStackNextFree += t1.length * Int32Array.BYTES_PER_ELEMENT, this.memoryStackNextFree - this.memoryStack > Kf ? -1 : (new Int32Array(this.module.heap32.buffer, e, t1.length).set(t1), e);
            }
            createFloatArray(t1) {
                const e = this.memoryStackNextFree;
                return this.memoryStackNextFree += t1.length * Float32Array.BYTES_PER_ELEMENT, this.memoryStackNextFree - this.memoryStack > Kf ? -1 : (new Float32Array(this.module.heapF32.buffer, e, t1.length).set(t1), e);
            }
            readStringBuffer(t1) {
                let e = "";
                for(; 0 !== this.module.heapU8[t1];)e += String.fromCharCode(this.module.heapU8[t1]), ++t1;
                return e;
            }
            setStyle(t1) {
                const e = t1.normalScale;
                this.module.setStyle(e[0], e[1], e[2], t1.tileToMeters);
            }
            setAOOptions(t1, e) {
                this.module.setAOOptions(t1 ? 1 : 0, e);
            }
            setMetricOptions(t1, e) {
                this.module.setMetricOptions(t1 ? 1 : 0, e);
            }
            setStructuralOptions(t1) {
                this.module.setStructuralOptions(t1 ? 1 : 0);
            }
            setFacadeOptions(t1, e) {
                this.module.setFacadeOptions(t1, e ? 1 : 0);
            }
            setFauxFacadeOptions(t1, e, r) {
                this.module.setFauxFacadeOptions(t1 ? 1 : 0, e ? 1 : 0, r);
            }
            setFacadeClassifierOptions(t1) {
                this.module.setFacadeClassifierOptions(t1);
            }
            generateMesh(t1, e) {
                this.memoryStackNextFree = this.memoryStack;
                for (const e of t1){
                    const t1 = this.createIntArray(e.ringIndices), r = this.createFloatArray(e.coordinates);
                    if (-1 === t1 || -1 === r) return `building_gen: Out of stack memory: ${this.memoryStackNextFree - this.memoryStack}/4096`;
                    this.module.addFeature(e.id, e.sourceId, e.minHeight, e.height, e.roofType, r, t1, e.ringIndices.length - 1);
                }
                for (const t1 of e){
                    let e;
                    e = t1.entrances ? JSON.parse(t1.entrances) : [];
                    const r = this.createFloatArray(e), n = this.createFloatArray(t1.coordinates);
                    if (-1 === r || -1 === n) return `building_gen: Out of stack memory: ${this.memoryStackNextFree - this.memoryStack}/4096`;
                    this.module.addFacade(t1.sourceId, t1.crossPerc, t1.distanceToRoad, r, e.length, n, t1.coordinates.length);
                }
                if (!this.module.generateMesh()) {
                    const t1 = this.module.getLastError();
                    return this.readStringBuffer(t1);
                }
                const r = this.module.getMeshCount(), n = new Array(r);
                for(let t1 = 0; t1 < r; t1++){
                    const e = this.module.getPositionsPtr(t1), r = this.module.getPositionsLength(t1), i = new Float32Array(this.module.heapF32.buffer, e, r), s = this.module.getNormalsPtr(t1), a = this.module.getNormalsLength(t1), o = new Float32Array(this.module.heapF32.buffer, s, a), l = this.module.getAOPtr(t1), u = this.module.getAOLength(t1), c = new Float32Array(this.module.heapF32.buffer, l, u), h = this.module.getUVPtr(t1), p = this.module.getUVLength(t1), d = new Float32Array(this.module.heapF32.buffer, h, p), f = this.module.getFauxFacadePtr(t1), m = this.module.getFauxFacadeLength(t1), y = new Uint8Array(this.module.heapU8.buffer, f, m), g = this.module.getIndicesPtr(t1), x = this.module.getIndicesLength(t1), v = new Int16Array(this.module.heap16.buffer, g, x), b = this.module.getBuildingPart(t1);
                    n[t1] = {
                        positions: i,
                        normals: o,
                        ao: c,
                        uv: d,
                        isFauxFacade: y,
                        indices: v,
                        buildingPart: b
                    };
                }
                const i = this.module.getRingCount(), s = [];
                for(let t1 = 0; t1 < i; t1++){
                    const e = this.module.getRingPtr(t1), r = this.module.getRingLength(t1), n = new Float32Array(this.module.heapF32.buffer, e, r);
                    s.push(n);
                }
                return {
                    meshes: n,
                    outerRingLength: this.module.getOuterRingLength(),
                    modifiedPolygonRings: s
                };
            }
        }
        let tm, em, rm, nm, im, sm = null, am = null, om = null, lm = null;
        function um() {
            return Kt(self) && self.worker.dracoUrl ? self.worker.dracoUrl : em || oe.DRACO_URL;
        }
        function cm() {
            if (Kt(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
            if (nm) return nm;
            const t1 = new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                3,
                2,
                0,
                0,
                5,
                3,
                1,
                0,
                1,
                12,
                1,
                0,
                10,
                22,
                2,
                12,
                0,
                65,
                0,
                65,
                0,
                65,
                0,
                252,
                10,
                0,
                0,
                11,
                7,
                0,
                65,
                0,
                253,
                15,
                26,
                11
            ]);
            if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
            return nm = WebAssembly.validate(t1) ? oe.MESHOPT_SIMD_URL : oe.MESHOPT_URL, nm;
        }
        function hm() {
            return lm;
        }
        const pm = 5120, dm = 5121, fm = 5122, mm = 5123, ym = 5125, gm = 5126, xm = {
            [pm]: Int8Array,
            [dm]: Uint8Array,
            [fm]: Int16Array,
            [mm]: Uint16Array,
            [ym]: Uint32Array,
            [gm]: Float32Array
        }, vm = {
            [pm]: "DT_INT8",
            [dm]: "DT_UINT8",
            [fm]: "DT_INT16",
            [mm]: "DT_UINT16",
            [ym]: "DT_UINT32",
            [gm]: "DT_FLOAT32"
        }, bm = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        };
        function wm(t1, e, r) {
            const n = r.json.bufferViews.length, i = r.buffers.length;
            e.bufferView = n, r.json.bufferViews[n] = {
                buffer: i,
                byteLength: t1.byteLength
            }, r.buffers[i] = t1;
        }
        const _m = "KHR_draco_mesh_compression";
        function Am(t1, e) {
            const r = t1.extensions && t1.extensions[_m];
            if (!r) return;
            const n = new rm.Decoder, i = km(e, r.bufferView), s = new rm.Mesh;
            if (!n.DecodeArrayToMesh(i, i.byteLength, s)) throw new Error("Failed to decode Draco mesh");
            const a = e.json.accessors[t1.indices], o = xm[a.componentType], l = a.count * o.BYTES_PER_ELEMENT, u = rm._malloc(l);
            o === Uint16Array ? n.GetTrianglesUInt16Array(s, l, u) : n.GetTrianglesUInt32Array(s, l, u), wm(rm.memory.buffer.slice(u, u + l), a, e), rm._free(u);
            for (const i of Object.keys(r.attributes)){
                const a = n.GetAttributeByUniqueId(s, r.attributes[i]), o = e.json.accessors[t1.attributes[i]], l = vm[o.componentType], u = o.count * bm[o.type] * xm[o.componentType].BYTES_PER_ELEMENT, c = rm._malloc(u);
                n.GetAttributeDataArrayForAllPoints(s, a, rm[l], u, c), wm(rm.memory.buffer.slice(c, c + u), o, e), rm._free(c);
            }
            n.destroy(), s.destroy(), delete t1.extensions[_m];
        }
        const Im = "EXT_meshopt_compression";
        function Mm(t1, e) {
            if (!t1.extensions || !t1.extensions[Im]) return;
            const r = t1.extensions[Im], n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0), i = new Uint8Array(r.count * r.byteStride);
            im.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t1.buffer = e.buffers.length, t1.byteOffset = 0, e.buffers[t1.buffer] = i.buffer, delete t1.extensions[Im];
        }
        const Sm = 1179937895, Pm = new TextDecoder("utf8");
        function zm(t1, e) {
            return new URL(t1, e).href;
        }
        function Bm(t1, e, r, n) {
            return fetch(zm(t1.uri, n)).then((t1)=>t1.arrayBuffer()).then((t1)=>{
                e.buffers[r] = t1;
            });
        }
        function km(t1, e) {
            const r = t1.json.bufferViews[e];
            return new Uint8Array(t1.buffers[r.buffer], r.byteOffset || 0, r.byteLength);
        }
        function Tm(t1, e, r, n) {
            if (t1.uri) {
                const i = zm(t1.uri, n);
                return fetch(i).then((t1)=>t1.blob()).then((t1)=>createImageBitmap(t1)).then((t1)=>{
                    e.images[r] = t1;
                });
            }
            if (void 0 !== t1.bufferView) {
                const n = km(e, t1.bufferView), i = new Blob([
                    n
                ], {
                    type: t1.mimeType
                });
                return createImageBitmap(i).then((t1)=>{
                    e.images[r] = t1;
                });
            }
        }
        function Vm(t1, e = 0, r) {
            const n = {
                json: null,
                images: [],
                buffers: []
            };
            if (new Uint32Array(t1, e, 1)[0] === Sm) {
                const r = new Uint32Array(t1, e);
                let i = 2;
                const s = (r[i++] >> 2) - 3, a = r[i++] >> 2;
                if (i++, n.json = JSON.parse(Pm.decode(r.subarray(i, i + a))), i += a, i < s) {
                    const s = r[i++];
                    i++;
                    const a = e + (i << 2);
                    n.buffers[0] = t1.slice(a, a + s);
                }
            } else n.json = JSON.parse(Pm.decode(new Uint8Array(t1, e)));
            const { buffers: i, images: s, meshes: a, extensionsUsed: o, bufferViews: l } = n.json;
            let u = Promise.resolve();
            if (i) {
                const t1 = [];
                for(let e = 0; e < i.length; e++){
                    const s = i[e];
                    s.uri ? t1.push(Bm(s, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);
                }
                u = Promise.all(t1);
            }
            return u.then(()=>{
                const t1 = [], e = o && o.includes(_m), i = o && o.includes(Im);
                if (e && t1.push(function() {
                    if (!rm) return null != tm ? tm : (tm = function(t1) {
                        let e, r = null;
                        function n() {
                            e = new Uint8Array(r.buffer);
                        }
                        function i() {
                            throw new Error("Unexpected Draco error.");
                        }
                        const s = {
                            a: {
                                a: i,
                                d: function(t1, r, n) {
                                    return e.copyWithin(t1, r, r + n);
                                },
                                c: function(t1) {
                                    const i = e.length, s = Math.max(t1 >>> 0, Math.ceil(1.2 * i)), a = Math.ceil((s - i) / 65536);
                                    try {
                                        return r.grow(a), n(), !0;
                                    } catch (t1) {
                                        return !1;
                                    }
                                },
                                b: i
                            }
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t1, s) : t1.then((t1)=>t1.arrayBuffer()).then((t1)=>WebAssembly.instantiate(t1, s))).then((t1)=>{
                            const { Rb: i, Qb: s, P: a, T: o, X: l, Ja: u, La: c, Qa: h, Va: p, Wa: d, eb: f, jb: m, f: y, e: g, yb: x, zb: v, Ab: b, Bb: w, Db: _, Gb: A } = t1.instance.exports;
                            r = g;
                            const I = (()=>{
                                let t1 = 0, r = 0, n = 0, a = 0;
                                return (o)=>{
                                    n && (i(a), i(t1), r += n, n = t1 = 0), t1 || (r += 128, t1 = s(r));
                                    const l = o.length + 7 & -8;
                                    let u = t1;
                                    l >= r && (n = l, u = a = s(l));
                                    for(let t1 = 0; t1 < o.length; t1++)e[u + t1] = o[t1];
                                    return u;
                                };
                            })();
                            return n(), y(), {
                                memory: g,
                                _free: i,
                                _malloc: s,
                                Mesh: class {
                                    constructor(){
                                        this.ptr = a();
                                    }
                                    destroy() {
                                        o(this.ptr);
                                    }
                                },
                                Decoder: class {
                                    constructor(){
                                        this.ptr = u();
                                    }
                                    destroy() {
                                        m(this.ptr);
                                    }
                                    DecodeArrayToMesh(t1, e, r) {
                                        const n = I(t1), i = c(this.ptr, n, e, r.ptr);
                                        return !!l(i);
                                    }
                                    GetAttributeByUniqueId(t1, e) {
                                        return {
                                            ptr: h(this.ptr, t1.ptr, e)
                                        };
                                    }
                                    GetTrianglesUInt16Array(t1, e, r) {
                                        p(this.ptr, t1.ptr, e, r);
                                    }
                                    GetTrianglesUInt32Array(t1, e, r) {
                                        d(this.ptr, t1.ptr, e, r);
                                    }
                                    GetAttributeDataArrayForAllPoints(t1, e, r, n, i) {
                                        f(this.ptr, t1.ptr, e.ptr, r, n, i);
                                    }
                                },
                                DT_INT8: x(),
                                DT_UINT8: v(),
                                DT_INT16: b(),
                                DT_UINT16: w(),
                                DT_UINT32: _(),
                                DT_FLOAT32: A()
                            };
                        });
                    }(fetch(um())), tm.then((t1)=>{
                        rm = t1, tm = void 0;
                    }));
                }()), i && t1.push(function() {
                    if (im) return;
                    const t1 = function(t1) {
                        let e;
                        const r = WebAssembly.instantiateStreaming(t1, {}).then((t1)=>{
                            e = t1.instance, e.exports.__wasm_call_ctors();
                        }), n = {
                            NONE: "",
                            OCTAHEDRAL: "meshopt_decodeFilterOct",
                            QUATERNION: "meshopt_decodeFilterQuat",
                            EXPONENTIAL: "meshopt_decodeFilterExp"
                        }, i = {
                            ATTRIBUTES: "meshopt_decodeVertexBuffer",
                            TRIANGLES: "meshopt_decodeIndexBuffer",
                            INDICES: "meshopt_decodeIndexSequence"
                        };
                        return {
                            ready: r,
                            supported: !0,
                            decodeGltfBuffer (t1, r, s, a, o, l) {
                                !function(t1, e, r, n, i, s, a) {
                                    const o = t1.exports.sbrk, l = n + 3 & -4, u = o(l * i), c = o(s.length), h = new Uint8Array(t1.exports.memory.buffer);
                                    h.set(s, c);
                                    const p = e(u, n, i, c, s.length);
                                    if (0 === p && a && a(u, l, i), r.set(h.subarray(u, u + n * i)), o(u - o(0)), 0 !== p) throw new Error(`Malformed buffer data: ${p}`);
                                }(e, e.exports[i[o]], t1, r, s, a, e.exports[n[l]]);
                            }
                        };
                    }(fetch(cm()));
                    return t1.ready.then(()=>{
                        im = t1;
                    });
                }()), s) for(let e = 0; e < s.length; e++)t1.push(Tm(s[e], n, e, r));
                return (t1.length ? Promise.all(t1) : Promise.resolve()).then(()=>{
                    if (e && a) for (const { primitives: t1 } of a)for (const e of t1)Am(e, n);
                    if (i && a && l) for (const t1 of l)Mm(t1, n);
                    return n;
                });
            });
        }
        function Em(t1) {
            return fetch(t1).then((t1)=>t1.arrayBuffer()).then((e)=>Vm(e, 0, t1));
        }
        function Fm(t1) {
            switch(t1){
                case WebGL2RenderingContext.RGBA8:
                    return WebGL2RenderingContext.RGBA;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                    return WebGL2RenderingContext.DEPTH_COMPONENT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                    return WebGL2RenderingContext.DEPTH_STENCIL;
                case WebGL2RenderingContext.R8:
                case WebGL2RenderingContext.R32F:
                    return WebGL2RenderingContext.RED;
            }
        }
        function Dm(t1) {
            switch(t1){
                case WebGL2RenderingContext.RGBA8:
                    return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                    return WebGL2RenderingContext.UNSIGNED_SHORT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                    return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                case WebGL2RenderingContext.R8:
                    return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.R32F:
                    return WebGL2RenderingContext.FLOAT;
            }
        }
        class Cm {
            constructor(t1, e, r, n){
                this.context = t1, this.format = r, this.useMipmap = n && n.useMipmap, this.texture = t1.gl.createTexture(), this.update(e, {
                    premultiply: n && n.premultiply
                });
            }
            update(t1, e) {
                const r = t1 && t1 instanceof HTMLVideoElement && 0 === t1.width ? t1.videoWidth : t1.width, n = t1 && t1 instanceof HTMLVideoElement && 0 === t1.height ? t1.videoHeight : t1.height, { context: i } = this, { gl: s } = i, { x: a, y: o } = e && e.position ? e.position : {
                    x: 0,
                    y: 0
                }, l = a + r, u = o + n;
                !this.size || this.size[0] === l && this.size[1] === u || (s.bindTexture(s.TEXTURE_2D, null), s.deleteTexture(this.texture), this.texture = s.createTexture(), this.size = null), s.bindTexture(s.TEXTURE_2D, this.texture), i.pixelStoreUnpackFlipY.set(!1), i.pixelStoreUnpack.set(1), i.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA8 && (!e || !1 !== e.premultiply));
                const c = t1 instanceof HTMLImageElement || t1 instanceof HTMLCanvasElement || t1 instanceof HTMLVideoElement || t1 instanceof ImageData || ImageBitmap && t1 instanceof ImageBitmap;
                if (!this.size && l > 0 && u > 0) {
                    const t1 = this.useMipmap ? Math.floor(Math.log2(Math.max(l, u))) + 1 : 1;
                    s.texStorage2D(s.TEXTURE_2D, t1, this.format, l, u), this.size = [
                        l,
                        u
                    ];
                }
                this.size && (c ? s.texSubImage2D(s.TEXTURE_2D, 0, a, o, Fm(this.format), Dm(this.format), t1) : "data" in t1 && t1.data && s.texSubImage2D(s.TEXTURE_2D, 0, a, o, r, n, Fm(this.format), Dm(this.format), t1.data)), this.useMipmap && s.generateMipmap(s.TEXTURE_2D);
            }
            bind(t1, e, r = !1) {
                const { context: n } = this, { gl: i } = n;
                i.bindTexture(i.TEXTURE_2D, this.texture), t1 !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t1), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t1 === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            bindExtraParam(t1, e, r, n, i) {
                const { context: s } = this, { gl: a } = s;
                a.bindTexture(a.TEXTURE_2D, this.texture), e !== this.magFilter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e), this.magFilter = e), t1 !== this.minFilter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, this.useMipmap ? t1 === a.NEAREST ? a.NEAREST_MIPMAP_NEAREST : a.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), r !== this.wrapS && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, n), this.wrapT = n), i !== this.compareMode && (i ? (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_COMPARE_MODE, a.COMPARE_REF_TO_TEXTURE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_COMPARE_FUNC, i)) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_COMPARE_MODE, a.NONE), this.compareMode = i);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        class Rm {
            constructor(t1, e){
                this.context = t1, this.texture = e;
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_2D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
        }
        const Lm = Oo([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), Om = Oo([
            {
                name: "a_color_3f",
                components: 3,
                type: "Float32"
            }
        ]), Um = Oo([
            {
                name: "a_color_4f",
                components: 4,
                type: "Float32"
            }
        ]), Nm = Oo([
            {
                name: "a_uv_2f",
                components: 2,
                type: "Float32"
            }
        ]), jm = Oo([
            {
                name: "a_normal_3f",
                components: 3,
                type: "Float32"
            }
        ]), Gm = Oo([
            {
                name: "a_normal_matrix0",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix1",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix2",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix3",
                components: 4,
                type: "Float32"
            }
        ]), $m = Oo([
            {
                name: "a_pbr",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_heightBasedEmissiveStrength",
                components: 3,
                type: "Float32"
            }
        ]);
        function qm(t1, e) {
            const r = Hm(t1.projection, t1.zoom, t1.width, t1.height), n = function(t1, e, r, n, i) {
                const s = new Bu(r.lng - 180 * Zm, r.lat), a = new Bu(r.lng + 180 * Zm, r.lat), o = t1.project(s.lng, s.lat), l = t1.project(a.lng, a.lat), c = -Math.atan2(l.y - o.y, l.x - o.x), p = Gu.fromLngLat(r);
                p.y = Dt(p.y, -1 + Zm, 1 - Zm);
                const f = p.toLngLat(), m = t1.project(f.lng, f.lat), g = Gu.fromLngLat(f);
                g.x += Zm;
                const x = g.toLngLat(), v = t1.project(x.lng, x.lat), b = Ym(v.x - m.x, v.y - m.y, c), w = Gu.fromLngLat(f);
                w.y += Zm;
                const _ = w.toLngLat(), A = t1.project(_.lng, _.lat), I = Ym(A.x - m.x, A.y - m.y, c), M = Math.abs(b.x) / Math.abs(I.y), S = u([]);
                y(S, S, -c * (1 - (i ? 0 : n)));
                const P = u([]);
                return d(P, P, [
                    1,
                    1 - (1 - M) * n,
                    1
                ]), P[4] = -I.x / I.y * n, y(P, P, c), h(P, S, P), P;
            }(t1.projection, 0, t1.center, r, e), i = Xm(t1);
            return d(n, n, [
                i,
                i,
                1
            ]), n;
        }
        function Xm(t1) {
            const e = t1.projection, r = Hm(t1.projection, t1.zoom, t1.width, t1.height), n = Wm(e, t1.center), i = Wm(e, Bu.convert(e.center));
            return Math.pow(2, n * r + (1 - r) * i);
        }
        function Hm(t1, e, r, n, i = 1 / 0) {
            const s = t1.range;
            if (!s) return 0;
            const a = Math.min(i, Math.max(r, n)), o = Math.log2(a / 1024);
            return Ct(s[0] + o, s[1] + o, e);
        }
        const Zm = 1 / 4e4;
        function Wm(t1, e) {
            const r = Dt(e.lat, -85.051129, Lu), n = new Bu(e.lng - 180 * Zm, r), i = new Bu(e.lng + 180 * Zm, r), s = t1.project(n.lng, r), a = t1.project(i.lng, r), o = Gu.fromLngLat(n), l = Gu.fromLngLat(i), u = a.x - s.x, c = a.y - s.y, h = l.x - o.x, p = l.y - o.y, d = Math.sqrt((h * h + p * p) / (u * u + c * c));
            return Math.log2(d);
        }
        function Ym(t1, e, r) {
            const n = Math.cos(r), i = Math.sin(r);
            return {
                x: t1 * n - e * i,
                y: t1 * i + e * n
            };
        }
        function Jm(t1, e, r) {
            u(t1), y(t1, t1, Bt(e[2])), f(t1, t1, Bt(e[0])), m(t1, t1, Bt(e[1])), d(t1, t1, r), h(t1, t1, [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1
            ]);
        }
        function Km(t1, e, r, n, i, s, a, o) {
            const l = [
                r[0] - e[0],
                r[1] - e[1],
                0
            ], u = [
                n[0] - e[0],
                n[1] - e[1],
                0
            ];
            if (I(l) < 1e-12 || I(u) < 1e-12) return rt(t1);
            const c = U([], l, u);
            L(c, c), z(u, n, e), l[2] = (s - i) * o, u[2] = (a - i) * o;
            const h = l;
            return U(h, l, u), L(h, h), ut(t1, c, h);
        }
        function Qm(t1, e, r = !1) {
            const n = Ih(e.zoom), i = function(t1, e, r) {
                const n = e.worldSize, i = [
                    t1[12],
                    t1[13],
                    t1[14]
                ], s = Cu(i[1] / n), a = Du(i[0] / n), o = u([]), l = Fu(1, s) * n, c = Fu(1, 0) * n * Uu(s, e.zoom), f = 1 / wh(n);
                let m = c * f;
                if (r) {
                    const t1 = Hm(e.projection, e.zoom, e.width, e.height, 1024);
                    m = f * e.projection.pixelSpaceConversion(e.center.lat, n, t1);
                }
                const y = Su(s, a);
                P(y, y, V([], L([], y), l * m * i[2]));
                const g = function(t1) {
                    const e = [
                        t1[0],
                        t1[1],
                        t1[2]
                    ];
                    let r = [
                        0,
                        1,
                        0
                    ];
                    const n = U([], r, e);
                    return U(r, e, n), 0 === C(r) && (r = [
                        0,
                        1,
                        0
                    ], U(n, e, r)), L(n, n), L(r, r), L(e, e), [
                        n[0],
                        n[1],
                        n[2],
                        0,
                        r[0],
                        r[1],
                        r[2],
                        0,
                        e[0],
                        e[1],
                        e[2],
                        0,
                        t1[0],
                        t1[1],
                        t1[2],
                        1
                    ];
                }(y);
                d(o, o, [
                    m,
                    m,
                    m * l
                ]), p(o, o, [
                    -i[0],
                    -i[1],
                    -i[2]
                ]);
                const x = h([], e.globeMatrix, g);
                return h(x, x, o), h(x, x, t1), x;
            }(t1, e, r);
            if (n > 0) {
                const r = function(t1, e) {
                    const r = e.worldSize, n = Fu(1, 0) * r * Uu(e.center.lat, e.zoom) / wh(r), i = Fu(1, e.center.lat) * r, s = u([]);
                    m(s, s, Bt(e.center.lng)), f(s, s, Bt(e.center.lat)), p(s, s, [
                        0,
                        0,
                        bu
                    ]), d(s, s, [
                        n,
                        n,
                        n * i
                    ]);
                    const a = e.point;
                    return p(s, s, [
                        -a.x,
                        -a.y,
                        0
                    ]), h(s, s, t1), h(s, e.globeMatrix, s);
                }(t1, e);
                return function(t1, e, r) {
                    const n = (t1, e, r)=>{
                        const n = I(t1), i = I(e), s = hh(t1, e, r);
                        return V(s, s, 1 / I(s) * dr(n, i, r));
                    }, i = n([
                        t1[0],
                        t1[1],
                        t1[2]
                    ], [
                        e[0],
                        e[1],
                        e[2]
                    ], r), s = n([
                        t1[4],
                        t1[5],
                        t1[6]
                    ], [
                        e[4],
                        e[5],
                        e[6]
                    ], r), a = n([
                        t1[8],
                        t1[9],
                        t1[10]
                    ], [
                        e[8],
                        e[9],
                        e[10]
                    ], r), o = hh([
                        t1[12],
                        t1[13],
                        t1[14]
                    ], [
                        e[12],
                        e[13],
                        e[14]
                    ], r);
                    return [
                        i[0],
                        i[1],
                        i[2],
                        0,
                        s[0],
                        s[1],
                        s[2],
                        0,
                        a[0],
                        a[1],
                        a[2],
                        0,
                        o[0],
                        o[1],
                        o[2],
                        1
                    ];
                }(i, r, n);
            }
            return i;
        }
        function ty(t1, e, r, n) {
            const i = wc.projectAabbCorners(n, r);
            let s = Number.MAX_VALUE;
            for(let t1 = 0; t1 < i.length; ++t1){
                const r = i[t1];
                r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < s && (s = r[2]);
            }
            const a = function(t1) {
                const e = [];
                let r = 0;
                for(let e = 1; e < t1.length; e++)(t1[e][0] < t1[r][0] || t1[e][0] === t1[r][0] && t1[e][1] < t1[r][1]) && (r = e);
                let n, i = r;
                const s = new Uint8Array(t1.length);
                do {
                    if (s[i]) break;
                    e.push(new Mt(t1[i][0], t1[i][1])), s[i] = 1, n = (i + 1) % t1.length;
                    for(let e = 0; e < t1.length; e++){
                        if (t1[e][0] === t1[n][0] && t1[e][1] === t1[n][1] || t1[e][0] === t1[i][0] && t1[e][1] === t1[i][1]) continue;
                        const r = [
                            t1[e][0] - t1[i][0],
                            t1[e][1] - t1[i][1]
                        ], s = [
                            t1[n][0] - t1[i][0],
                            t1[n][1] - t1[i][1]
                        ], a = r[0] * s[1] - r[1] * s[0];
                        (a > 0 || 0 === a && r[0] * s[0] + r[1] * s[1] >= 0 && r[0] * r[0] + r[1] * r[1] > s[0] * s[0] + s[1] * s[1]) && (n = e);
                    }
                    i = n;
                }while (i !== r)
                return e.length > 0 && e.push(e[0]), e;
            }(i);
            if (Pc(t1, a)) return s;
        }
        const ey = 64, ry = {
            CoordinateSpaceTile: 1,
            HasMapboxMeshFeatures: 4,
            HasMeshoptCompression: 8
        };
        function ny(t1, e, r, n, i, s, a, o, l, c = !1) {
            const f = r.zoom, m = r.project(n), y = Uu(n.lat, f), g = 1 / y;
            u(t1), p(t1, t1, [
                m.x + a[0] * g,
                m.y + a[1] * g,
                a[2]
            ]);
            let x = 1, v = 1;
            const w = r.worldSize;
            if (c) {
                if ("mercator" === r.projection.name) {
                    let t1 = 0;
                    r.elevation && (t1 = r.elevation.getAtPointOrZero(new Gu(m.x / w, m.y / w), 0));
                    const e = tt([], [
                        m.x,
                        m.y,
                        t1,
                        1
                    ], r.projMatrix)[3] / r.cameraToCenterDistance;
                    x = e, v = e * Uu(r.center.lat, f);
                } else if ("globe" === r.projection.name) {
                    const e = Qm(t1, r), i = [
                        0,
                        0,
                        0,
                        1
                    ];
                    tt(i, i, h([], r.projMatrix, e));
                    const s = i[3] / r.cameraToCenterDistance, a = Ih(f), o = r.projection.pixelsPerMeter(n.lat, w) * Uu(n.lat, f), l = r.projection.pixelsPerMeter(r.center.lat, w) * Uu(r.center.lat, f);
                    x = s / dr(o, Ou(r.center.lat), a), v = s * y / o, x *= l, v *= l;
                }
            } else x = g;
            d(t1, t1, [
                x,
                x,
                v
            ]);
            const _ = [
                ...t1
            ], A = e.orientation, I = [];
            if (Jm(I, [
                A[0] + (i ? i[0] : 0),
                A[1] + (i ? i[1] : 0),
                A[2] + (i ? i[2] : 0)
            ], s), h(t1, _, I), o && r.elevation) {
                let i = 0;
                const s = [];
                if (l && r.elevation) {
                    i = function(t1, e, r, n, i) {
                        const s = e.elevation;
                        if (!s) return 0;
                        const a = wc.projectAabbCorners(r, n), o = Fu(1, i.lat) * e.worldSize, l = function(t1, e) {
                            const r = [
                                0,
                                0,
                                1
                            ], n = [
                                {
                                    corners: [
                                        0,
                                        1,
                                        3,
                                        2
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        1,
                                        5,
                                        2,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        4,
                                        1,
                                        5
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        2,
                                        6,
                                        3,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        4,
                                        7,
                                        5,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        3,
                                        4,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                }
                            ];
                            for (const i of n){
                                const n = t1[i.corners[0]], s = t1[i.corners[1]], a = t1[i.corners[2]], o = [
                                    s[0] - n[0],
                                    s[1] - n[1],
                                    e * (s[2] - n[2])
                                ], l = U(o, o, [
                                    a[0] - n[0],
                                    a[1] - n[1],
                                    e * (a[2] - n[2])
                                ]);
                                L(l, l), i.dotProductWithUp = O(l, r);
                            }
                            return n.sort((t1, e)=>t1.dotProductWithUp - e.dotProductWithUp), n[0].corners;
                        }(a, o), u = a[l[0]], c = a[l[1]], h = a[l[2]], p = a[l[3]], d = s.getAtPointOrZero(new Gu(u[0] / e.worldSize, u[1] / e.worldSize), 0), f = s.getAtPointOrZero(new Gu(c[0] / e.worldSize, c[1] / e.worldSize), 0), m = s.getAtPointOrZero(new Gu(h[0] / e.worldSize, h[1] / e.worldSize), 0), y = s.getAtPointOrZero(new Gu(p[0] / e.worldSize, p[1] / e.worldSize), 0), g = (d + y) / 2, x = (f + m) / 2;
                        return g > x ? f < m ? Km(t1, c, p, u, f, y, d, o) : Km(t1, h, u, p, m, d, y, o) : d < y ? Km(t1, u, c, h, d, f, m, o) : Km(t1, p, h, c, y, m, f, o), Math.max(g, x);
                    }(s, r, e.aabb, t1, n);
                    const a = h([], b([], s), I);
                    h(t1, _, a);
                } else i = r.elevation.getAtPointOrZero(new Gu(m.x / w, m.y / w), 0);
                0 !== i && (t1[14] += i);
            }
        }
        class iy {
            constructor(t1, e, r, n, i){
                this.materialOverrides = new Map, this.nodeOverrides = new Map, this.materialOverrideNames = [], this.nodeOverrideNames = [], this.featureProperties = {}, this.id = t1, this.uri = e, this.position = null != r ? new Bu(r[0], r[1]) : new Bu(0, 0), this.orientation = null != n ? n : [
                    0,
                    0,
                    0
                ], this.nodes = i, this.uploaded = !1, this.aabb = new wc([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]), this.matrix = [];
            }
            _applyTransformations(t1, e) {
                h(t1.globalMatrix, e, t1.localMatrix);
                const r = this.nodeOverrides.get(t1.name);
                if (void 0 !== r) {
                    const e = [];
                    i = r.orientation, u(n = e), m(n, n, Bt(i[1])), y(n, n, Bt(i[2])), f(n, n, Bt(i[0])), h(t1.globalMatrix, t1.globalMatrix, e);
                }
                var n, i;
                if (t1.meshes) for (const e of t1.meshes){
                    const r = wc.applyTransformFast(e.aabb, t1.globalMatrix);
                    this.aabb.encapsulate(r);
                }
                if (t1.children) for (const e of t1.children)this._applyTransformations(e, t1.globalMatrix);
            }
            computeBoundsAndApplyParent() {
                const t1 = u([]);
                this.aabb = new wc([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]);
                for (const e of this.nodes)this._applyTransformations(e, t1);
            }
            computeModelMatrix(t1, e, r, n, i, s, a = !1) {
                ny(this.matrix, this, t1.transform, this.position, e, r, n, i, s, a);
            }
            upload(t1) {
                if (!this.uploaded) {
                    for (const e of this.nodes)oy(e, t1);
                    for (const t1 of this.nodes)ly(t1);
                    this.uploaded = !0;
                }
            }
            destroy() {
                for (const t1 of this.nodes)cy(t1);
            }
        }
        function sy(t1, e, r = !1) {
            t1.uploaded || (t1.gfxTexture = new Cm(e, t1.image, r ? e.gl.R8 : e.gl.RGBA8, {
                useMipmap: t1.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST
            }), t1.uploaded = !0, t1.image = null);
        }
        function ay(t1, e, r) {
            t1.indexBuffer = e.createIndexBuffer(t1.indexArray, !1, !0), t1.vertexBuffer = e.createVertexBuffer(t1.vertexArray, Lm.members, !1, !0), t1.normalArray && (t1.normalBuffer = e.createVertexBuffer(t1.normalArray, jm.members, !1, !0)), t1.texcoordArray && (t1.texcoordBuffer = e.createVertexBuffer(t1.texcoordArray, Nm.members, !1, !0)), t1.colorArray && (t1.colorBuffer = e.createVertexBuffer(t1.colorArray, (12 === t1.colorArray.bytesPerElement ? Om : Um).members, !1, !0)), t1.featureArray && (t1.pbrBuffer = e.createVertexBuffer(t1.featureArray, $m.members, !0)), t1.segments = Ol.simpleSegment(0, 0, t1.vertexArray.length, t1.indexArray.length);
            const n = t1.material;
            n.pbrMetallicRoughness.baseColorTexture && sy(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && sy(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && sy(n.normalTexture, e), n.occlusionTexture && sy(n.occlusionTexture, e, r), n.emissionTexture && sy(n.emissionTexture, e);
        }
        function oy(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes)ay(n, e, r);
            if (t1.children) for (const n of t1.children)oy(n, e, r);
        }
        function ly(t1) {
            if (t1.meshes) for (const e of t1.meshes)e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
            if (t1.children) for (const e of t1.children)ly(e);
        }
        function uy(t1) {
            t1.pbrMetallicRoughness.baseColorTexture && t1.pbrMetallicRoughness.baseColorTexture.gfxTexture && t1.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), t1.pbrMetallicRoughness.metallicRoughnessTexture && t1.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && t1.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), t1.normalTexture && t1.normalTexture.gfxTexture && t1.normalTexture.gfxTexture.destroy(), t1.emissionTexture && t1.emissionTexture.gfxTexture && t1.emissionTexture.gfxTexture.destroy(), t1.occlusionTexture && t1.occlusionTexture.gfxTexture && t1.occlusionTexture.gfxTexture.destroy();
        }
        function cy(t1) {
            if (t1.meshes) for (const e of t1.meshes)e.vertexBuffer && (e.vertexBuffer.destroy(), e.indexBuffer.destroy(), e.normalBuffer && e.normalBuffer.destroy(), e.texcoordBuffer && e.texcoordBuffer.destroy(), e.colorBuffer && e.colorBuffer.destroy(), e.pbrBuffer && e.pbrBuffer.destroy(), e.segments.destroy(), e.material && uy(e.material));
            if (t1.children) for (const e of t1.children)cy(e);
        }
        function hy(t1, e) {
            const r = t1.json.bufferViews[e.bufferView], n = xm[e.componentType];
            return new n(t1.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== bm[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : bm[e.type]));
        }
        function py(t1, e, r, n) {
            const i = xm[e.componentType], s = function(t1) {
                switch(t1){
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        return 1;
                }
            }(i), a = t1.json.bufferViews[e.bufferView], o = a.byteStride ? a.byteStride / i.BYTES_PER_ELEMENT : bm[e.type], l = r.float32, u = l.length / r.capacity;
            for(let t1 = 0, r = 0; t1 < e.count * o; t1 += o, r += u)for(let e = 0; e < u; e++)l[r + e] = n[t1 + e] * s;
            r._trim();
        }
        function dy(t1, e, r) {
            const n = t1.indices, i = t1.attributes, s = {};
            s.indexArray = new ll;
            const a = e.json.accessors[n], o = a.count / 3;
            s.indexArray.reserve(o);
            const l = hy(e, a);
            for(let t1 = 0; t1 < o; t1++)s.indexArray.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
            s.indexArray._trim(), s.vertexArray = new Wo;
            const u = e.json.accessors[i.POSITION];
            s.vertexArray.reserve(u.count);
            const c = hy(e, u);
            for(let t1 = 0; t1 < u.count; t1++)s.vertexArray.emplaceBack(c[3 * t1], c[3 * t1 + 1], c[3 * t1 + 2]);
            if (s.vertexArray._trim(), s.aabb = new wc(u.min, u.max), s.centroid = function(t1, e) {
                const r = [
                    0,
                    0,
                    0
                ], n = t1.length;
                if (n > 0) {
                    for(let i = 0; i < n; i++){
                        const n = 3 * t1[i];
                        r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];
                    }
                    r[0] /= n, r[1] /= n, r[2] /= n;
                }
                return r;
            }(l, c), void 0 !== i.COLOR_0) {
                const t1 = e.json.accessors[i.COLOR_0], r = bm[t1.type], n = hy(e, t1);
                s.colorArray = 3 === r ? new Wo : new el, s.colorArray.resize(t1.count), py(e, t1, s.colorArray, n);
            }
            if (void 0 !== i.NORMAL) {
                s.normalArray = new Wo;
                const t1 = e.json.accessors[i.NORMAL];
                s.normalArray.resize(t1.count);
                const r = hy(e, t1);
                py(e, t1, s.normalArray, r);
            }
            if (void 0 !== i.TEXCOORD_0 && r.length > 0) {
                s.texcoordArray = new yl;
                const t1 = e.json.accessors[i.TEXCOORD_0];
                s.texcoordArray.resize(t1.count);
                const r = hy(e, t1);
                py(e, t1, s.texcoordArray, r);
            }
            if (void 0 !== i._FEATURE_ID_RGBA4444) {
                const t1 = e.json.accessors[i._FEATURE_ID_RGBA4444];
                e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (s.featureData = hy(e, t1));
            }
            void 0 !== i._FEATURE_RGBA4444 && (s.featureData = new Uint32Array(hy(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));
            const h = t1.material;
            return s.material = function(t1, e) {
                const { emissiveFactor: r = [
                    0,
                    0,
                    0
                ], alphaMode: n = "OPAQUE", alphaCutoff: i = .5, normalTexture: s, occlusionTexture: a, emissiveTexture: o, doubleSided: l, name: u } = t1, { baseColorFactor: c = [
                    1,
                    1,
                    1,
                    1
                ], metallicFactor: h = 1, roughnessFactor: p = 1, baseColorTexture: d, metallicRoughnessTexture: f } = t1.pbrMetallicRoughness || {}, m = a ? e[a.index] : void 0;
                if (a && a.extensions && a.extensions.KHR_texture_transform && m) {
                    const t1 = a.extensions.KHR_texture_transform;
                    m.offsetScale = [
                        t1.offset[0],
                        t1.offset[1],
                        t1.scale[0],
                        t1.scale[1]
                    ];
                }
                return {
                    name: u,
                    pbrMetallicRoughness: {
                        baseColorFactor: new ur(...c),
                        metallicFactor: h,
                        roughnessFactor: p,
                        baseColorTexture: d ? e[d.index] : void 0,
                        metallicRoughnessTexture: f ? e[f.index] : void 0
                    },
                    doubleSided: l,
                    emissiveFactor: new ur(...r),
                    alphaMode: n,
                    alphaCutoff: i,
                    normalTexture: s ? e[s.index] : void 0,
                    occlusionTexture: m,
                    emissionTexture: o ? e[o.index] : void 0,
                    defined: void 0 === t1.defined
                };
            }(void 0 !== h ? e.json.materials[h] : {
                defined: !1
            }, r), s;
        }
        function fy(t1, e, r) {
            const { matrix: n, rotation: i, translation: s, scale: a, mesh: o, extras: u, children: c, name: h } = t1, p = {};
            if (p.name = h, p.localMatrix = n || function(t1, e, r, n) {
                var i = e[0], s = e[1], a = e[2], o = e[3], l = i + i, u = s + s, c = a + a, h = i * l, p = i * u, d = i * c, f = s * u, m = s * c, y = a * c, g = o * l, x = o * u, v = o * c, b = n[0], w = n[1], _ = n[2];
                return t1[0] = (1 - (f + y)) * b, t1[1] = (p + v) * b, t1[2] = (d - x) * b, t1[3] = 0, t1[4] = (p - v) * w, t1[5] = (1 - (h + y)) * w, t1[6] = (m + g) * w, t1[7] = 0, t1[8] = (d + x) * _, t1[9] = (m - g) * _, t1[10] = (1 - (h + f)) * _, t1[11] = 0, t1[12] = r[0], t1[13] = r[1], t1[14] = r[2], t1[15] = 1, t1;
            }([], i || [
                0,
                0,
                0,
                1
            ], s || [
                0,
                0,
                0
            ], a || [
                1,
                1,
                1
            ]), p.globalMatrix = l(p.localMatrix), void 0 !== o) {
                p.meshes = r[o];
                const t1 = p.anchor = [
                    0,
                    0
                ];
                for (const e of p.meshes){
                    const { min: r, max: n } = e.aabb;
                    t1[0] += r[0] + n[0], t1[1] += r[1] + n[1];
                }
                t1[0] = Math.floor(t1[0] / p.meshes.length / 2), t1[1] = Math.floor(t1[1] / p.meshes.length / 2);
            }
            if (u && (u.id && (p.id = u.id), u.lights && (p.lights = function(t1) {
                if (!t1.length) return [];
                const e = function(t1) {
                    const e = atob(t1), r = new Uint8Array(e.length);
                    for(let t1 = 0; t1 < e.length; t1++)r[t1] = e.codePointAt(t1);
                    return r;
                }(t1), r = [], n = e.length / 24, i = new Uint16Array(e.buffer), s = new Float32Array(e.buffer);
                for(let t1 = 0; t1 < n; t1++){
                    const e = i[2 * t1 * 6] / 30, n = i[2 * t1 * 6 + 1] / 30, a = i[2 * t1 * 6 + 10] / 100, o = s[6 * t1 + 1], l = s[6 * t1 + 2], u = s[6 * t1 + 3], c = s[6 * t1 + 4], h = u - o, p = c - l, d = Math.hypot(h, p);
                    r.push({
                        pos: [
                            o + .5 * h,
                            l + .5 * p,
                            n
                        ],
                        normal: [
                            p / d,
                            -h / d,
                            0
                        ],
                        width: d,
                        height: e,
                        depth: a,
                        points: [
                            o,
                            l,
                            u,
                            c
                        ]
                    });
                }
                return r;
            }(u.lights)), u.MAPBOX_geometry_bloom && (p.isGeometryBloom = u.MAPBOX_geometry_bloom)), c) {
                const t1 = [];
                for (const n of c)t1.push(fy(e.json.nodes[n], e, r));
                p.children = t1;
            }
            return p;
        }
        function my(t1) {
            if (0 === t1.vertices.length || 0 === t1.indices.length) return null;
            const e = new Id(t1.vertices, t1.indices, 8, 256), [r, n] = [
                e.min.clone(),
                e.max.clone()
            ];
            return {
                vertices: t1.vertices,
                indices: t1.indices,
                grid: e,
                min: r,
                max: n
            };
        }
        function yy(t1) {
            if (!t1.extras || !t1.extras.ground) return null;
            const e = t1.extras.ground;
            if (!e || !Array.isArray(e) || 0 === e.length) return null;
            const r = e[0];
            if (!r || !Array.isArray(r) || 0 === r.length) return null;
            const n = [];
            for (const t1 of r){
                if (!Array.isArray(t1) || 2 !== t1.length) continue;
                const e = t1[0], r = t1[1];
                "number" == typeof e && "number" == typeof r && n.push(new Mt(e, r));
            }
            if (n.length < 3) return null;
            n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();
            let i = 0;
            for(let t1 = 0; t1 < n.length; t1++){
                const e = n[t1], r = n[(t1 + 1) % n.length], s = n[(t1 + 2) % n.length];
                i += (e.x - r.x) * (s.y - r.y) - (s.x - r.x) * (e.y - r.y);
            }
            i > 0 && n.reverse();
            const s = Qh(n.flatMap((t1)=>[
                    t1.x,
                    t1.y
                ]), []);
            return 0 === s.length ? null : {
                vertices: n,
                indices: s
            };
        }
        function gy(t1, e) {
            const r = [], n = [];
            let i = 0;
            const s = [];
            for (const a of t1){
                i = r.length;
                const t1 = a.vertexArray.float32, o = a.indexArray.uint16;
                for(let n = 0; n < a.vertexArray.length; n++)s[0] = t1[3 * n + 0], s[1] = t1[3 * n + 1], s[2] = t1[3 * n + 2], j(s, s, e), r.push(new Mt(s[0], s[1]));
                for(let t1 = 0; t1 < 3 * a.indexArray.length; t1++)n.push(o[t1] + i);
            }
            if (n.length % 3 != 0) return null;
            for(let t1 = 0; t1 < n.length; t1 += 3){
                const e = r[n[t1 + 0]], i = r[n[t1 + 1]], s = r[n[t1 + 2]];
                (e.x - i.x) * (s.y - i.y) - (s.x - i.x) * (e.y - i.y) > 0 && ([n[t1 + 1], n[t1 + 2]] = [
                    n[t1 + 2],
                    n[t1 + 1]
                ]);
            }
            return {
                vertices: r,
                indices: n
            };
        }
        function xy(t1) {
            const e = function(t1, e) {
                const r = [], n = WebGL2RenderingContext;
                if (t1.json.textures) for (const i of t1.json.textures){
                    const s = {
                        magFilter: n.LINEAR,
                        minFilter: n.NEAREST,
                        wrapS: n.REPEAT,
                        wrapT: n.REPEAT
                    };
                    void 0 !== i.sampler && Object.assign(s, t1.json.samplers[i.sampler]), r.push({
                        image: e[i.source],
                        sampler: s,
                        uploaded: !1
                    });
                }
                return r;
            }(t1, t1.images), r = function(t1, e) {
                const r = [];
                for (const n of t1.json.meshes){
                    const i = [];
                    for (const r of n.primitives)i.push(dy(r, t1, e));
                    r.push(i);
                }
                return r;
            }(t1, e), { scenes: n, scene: i, nodes: s } = t1.json, a = n ? n[i || 0].nodes : [
                ...s.keys()
            ], o = [];
            for (const e of a)o.push(fy(s[e], t1, r));
            return function(t1, e, r) {
                const n = {}, i = new Set;
                for(let s = 0; s < t1.length; s++){
                    const t1 = r[e[s]];
                    if (!t1.extras) continue;
                    const a = t1.extras["mapbox:footprint:version"], o = t1.extras["mapbox:footprint:id"];
                    (a || o) && i.add(s), "1.0.0" === a && o && (n[o] = s);
                }
                for(let s = 0; s < t1.length; s++){
                    if (i.has(s)) continue;
                    const a = t1[s], o = r[e[s]];
                    if (!o.extras) continue;
                    let l = null;
                    a.id in n && (l = gy(t1[n[a.id]].meshes, a.localMatrix)), l || (l = yy(o)), l && (a.footprint = my(l));
                }
                if (i.size > 0) {
                    const e = Array.from(i.values()).sort((t1, e)=>t1 - e);
                    for(let r = e.length - 1; r >= 0; r--)t1.splice(e[r], 1);
                }
            }(o, a, t1.json.nodes), o;
        }
        function vy(t1) {
            t1.heightmap = new Float32Array(4096), t1.heightmap.fill(-1);
            const e = t1.vertexArray.float32, r = t1.aabb.min[0] - 1, n = t1.aabb.min[1] - 1, i = ey / (t1.aabb.max[0] - r + 2), s = ey / (t1.aabb.max[1] - n + 2);
            for(let a = 0; a < e.length; a += 3){
                const o = e[a + 2], l = (e[a + 0] - r) * i | 0, u = (e[a + 1] - n) * s | 0;
                o > t1.heightmap[u * ey + l] && (t1.heightmap[u * ey + l] = o);
            }
        }
        function by(t1, e, r, n, i) {
            r.reserve(r.length + 4 * t1.length), n.reserve(n.length + 10 * t1.length), i.reserve(i.length + 10 * t1.length);
            let s = n.length;
            for (const a of t1){
                const t1 = Math.min(10, Math.max(4, 1.3 * a.height)) * e, o = [
                    -a.normal[1],
                    a.normal[0],
                    0
                ], l = Math.min(.29, .1 * a.width / a.depth), u = a.width - 2 * a.depth * e * (l + .01), c = E([], a.pos, o, u / 2), h = E([], a.pos, o, -u / 2), p = [
                    c[0],
                    c[1],
                    c[2] + a.height
                ], d = [
                    h[0],
                    h[1],
                    h[2] + a.height
                ], f = E([], a.normal, o, l);
                V(f, f, t1);
                const m = E([], a.normal, o, -l);
                V(m, m, t1), P(f, c, f), P(m, h, m), c[2] += .1, h[2] += .1, n.emplaceBack(f[0], f[1], f[2]), n.emplaceBack(m[0], m[1], m[2]), n.emplaceBack(c[0], c[1], c[2]), n.emplaceBack(h[0], h[1], h[2]), n.emplaceBack(p[0], p[1], p[2]), n.emplaceBack(d[0], d[1], d[2]), n.emplaceBack(c[0], c[1], c[2]), n.emplaceBack(h[0], h[1], h[2]), n.emplaceBack(f[0], f[1], f[2]), n.emplaceBack(m[0], m[1], m[2]);
                const y = u / t1 / 2;
                i.emplaceBack(-y - l, -1, y, .8), i.emplaceBack(y + l, -1, y, .8), i.emplaceBack(-y, 0, y, 1.3), i.emplaceBack(y, 0, y, 1.3), i.emplaceBack(y + l, -.8, y, .7), i.emplaceBack(y + l, -.8, y, .7), i.emplaceBack(0, 0, y, 1.3), i.emplaceBack(0, 0, y, 1.3), i.emplaceBack(y + l, -1.2, y, .8), i.emplaceBack(y + l, -1.2, y, .8), r.emplaceBack(6 + s, 4 + s, 8 + s), r.emplaceBack(7 + s, 9 + s, 5 + s), r.emplaceBack(0 + s, 1 + s, 2 + s), r.emplaceBack(1 + s, 3 + s, 2 + s), s += 10;
            }
        }
        function wy(t1, e) {
            const r = {};
            r.indexArray = new ll, r.vertexArray = new Wo, r.colorArray = new el, by(t1, e, r.indexArray, r.vertexArray, r.colorArray);
            const n = {
                defined: !0
            };
            n.emissiveFactor = ur.black;
            const i = {};
            return i.baseColorFactor = ur.white, n.pbrMetallicRoughness = i, r.material = n, r.aabb = new wc([
                1 / 0,
                1 / 0,
                1 / 0
            ], [
                -1 / 0,
                -1 / 0,
                -1 / 0
            ]), r;
        }
        const _y = Oo([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), Ay = Oo([
            {
                name: "a_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), Iy = Oo([
            {
                name: "a_centroid_3",
                components: 3,
                type: "Int16"
            }
        ]), My = Oo([
            {
                name: "a_part_color_emissive",
                components: 2,
                type: "Uint16"
            }
        ]), Sy = Oo([
            {
                name: "a_faux_facade_color_emissive",
                components: 2,
                type: "Uint16"
            }
        ]), Py = Oo([
            {
                name: "a_faux_facade_data",
                components: 4,
                type: "Uint16"
            }
        ]), zy = Oo([
            {
                name: "a_faux_facade_vertical_range",
                components: 2,
                type: "Uint16"
            }
        ]), By = Oo([
            {
                name: "a_bloom_attenuation",
                components: 4,
                type: "Float32"
            }
        ]), ky = Oo([
            {
                name: "a_flood_light_wall_radius_1i16",
                components: 1,
                type: "Uint16"
            }
        ]), Ty = Qu.types, Vy = 32767;
        function Ey(t1, e) {
            const r = jn + e;
            for (const n of t1)for (const t1 of n)if (t1.x < -e || t1.x > r || t1.y < -e || t1.y > r) return !1;
            return !0;
        }
        function Fy(t1) {
            switch(t1){
                case "flat":
                    return 3;
                case "hipped":
                    return 1;
                case "gabled":
                    return 2;
                case "parapet":
                    return 0;
                case "mansard":
                    return 4;
                case "skillion":
                    return 5;
                case "pyramidal":
                    return 6;
                default:
                    throw new Error(`Unknown roof shape: ${t1}`);
            }
        }
        class Dy {
            constructor(){
                this.layoutVertexArray = new Wo, this.layoutAttenuationArray = new el, this.layoutColorArray = new nl, this.indexArray = new ll, this.indexArrayForConflation = new ll, this.segmentsBucket = new Ol;
            }
        }
        class Cy {
            constructor(t1){
                this.layoutFacadePaintArray = null, this.layoutFacadeDataArray = null, this.layoutFacadeVerticalRangeArray = null, this.segmentsBucket = new Ol, this.entranceBloom = new Dy;
                const e = 66560;
                this.layoutVertexArray = new Wo, this.layoutVertexArray.reserve(e), this.layoutNormalArray = new jo, this.layoutNormalArray.reserve(e), this.layoutCentroidArray = new jo, this.layoutCentroidArray.reserve(e), this.layoutColorArray = new nl, this.layoutColorArray.reserve(e), this.layoutFloodLightDataArray = new xl, this.layoutFloodLightDataArray.reserve(e), this.layoutAOArray = new _l, this.layoutAOArray.reserve(e), this.indexArray = new ll, this.indexArray.reserve(66560), this.indexArrayForConflation = new ll, this.segmentsBucket = new Ol, this.entranceBloom = new Dy, t1 && (this.layoutFacadePaintArray = new nl, this.layoutFacadeDataArray = new Jo, this.layoutFacadeVerticalRangeArray = new nl);
            }
            reserve(t1, e, r) {
                this.layoutVertexArray.reserveForAdditional(t1), this.layoutCentroidArray.reserveForAdditional(t1), this.layoutFloodLightDataArray.reserveForAdditional(t1), this.layoutNormalArray.reserveForAdditional(t1), this.layoutAOArray.reserveForAdditional(t1), this.layoutColorArray.reserveForAdditional(t1), this.indexArray.reserveForAdditional(e), r && (this.layoutFacadePaintArray.reserveForAdditional(t1), this.layoutFacadeDataArray.reserveForAdditional(t1), this.layoutFacadeVerticalRangeArray.reserveForAdditional(t1));
            }
        }
        class Ry {
            constructor(t1){
                this.colorBufferUploaded = !1, this.maxHeight = 0, this.replacementUpdateTime = 0, this.activeReplacements = [], this.footprints = [], this.footprintsVertices = new yl, this.footprintsIndices = new xl, this.footprintsMin = new Mt(1 / 0, 1 / 0), this.footprintsMax = new Mt(-1 / 0, -1 / 0), this.featuresOnBorder = [], this.buildingWithoutFacade = new Cy(!1), this.buildingWithFacade = new Cy(!0), this.indexArrayForConflationUploaded = !1, this.featureFootprintLookup = new Map, this.buildingIds = new Set, this.footprintLookup = {}, this.zoom = t1.zoom, this.canonical = t1.canonical, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.worldview = t1.worldview, this.lut = t1.lut, this.programConfigurations = new fu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection, this.groundEffect = new ff(t1), this.groundEffect.groundRadiusArray = new $o, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {
                const r = new Id([], [], 1), n = {
                    vertices: [],
                    indices: new Uint32Array(0),
                    grid: r,
                    min: this.footprintsMin,
                    max: this.footprintsMax,
                    buildingIds: this.buildingIds
                };
                e.push({
                    footprint: n,
                    id: t1
                });
            }
            updateAppearances(t1, e, r, n) {}
            prepare() {
                return function() {
                    if (null != lm || null != om) return null;
                    if (null != am) return am;
                    const t1 = fetch(oe.BUILDING_GEN_URL);
                    return am = (function(t1) {
                        let e, r, n, i, s;
                        function a() {
                            e = new Uint8Array(s.buffer), r = new Int16Array(s.buffer), n = new Int32Array(s.buffer), i = new Float32Array(s.buffer);
                        }
                        function o() {
                            throw new Error("Unexpected BuildingGen error.");
                        }
                        const l = ()=>{}, u = {
                            a: {
                                a: o,
                                f: function(t1) {
                                    const r = e.length, n = Math.max(t1 >>> 0, Math.ceil(1.2 * r)), i = Math.ceil((n - r) / 65536);
                                    try {
                                        return s.grow(i), a(), !0;
                                    } catch (t1) {
                                        return !1;
                                    }
                                },
                                g: o,
                                b: l,
                                c: l,
                                d: l,
                                e: l
                            }
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t1, u) : t1.then((t1)=>t1.arrayBuffer()).then((t1)=>WebAssembly.instantiate(t1, u))).then((t1)=>{
                            const o = t1.instance.exports;
                            return (0, o.g)(), s = o.f, a(), new Qf({
                                setStyle: o.h,
                                setAOOptions: o.i,
                                setMetricOptions: o.j,
                                setStructuralOptions: o.k,
                                setFacadeOptions: o.l,
                                setFauxFacadeOptions: o.m,
                                setFacadeClassifierOptions: o.n,
                                addFeature: o.o,
                                addFacade: o.p,
                                generateMesh: o.q,
                                getLastError: o.r,
                                getOuterRingLength: o.s,
                                getMeshCount: o.t,
                                getPositionsPtr: o.u,
                                getPositionsLength: o.v,
                                getNormalsPtr: o.w,
                                getNormalsLength: o.x,
                                getAOPtr: o.y,
                                getAOLength: o.z,
                                getUVPtr: o.A,
                                getUVLength: o.B,
                                getFauxFacadePtr: o.C,
                                getFauxFacadeLength: o.D,
                                getIndicesPtr: o.E,
                                getIndicesLength: o.F,
                                getBuildingPart: o.G,
                                getRingCount: o.H,
                                getRingPtr: o.I,
                                getRingLength: o.J,
                                malloc: o.K,
                                free: o.L,
                                heapU8: e,
                                heap16: r,
                                heap32: n,
                                heapF32: i
                            });
                        });
                    })(t1).then((t1)=>(am = null, lm = t1, lm)).catch((t1)=>{
                        Zt("Could not load building-gen"), am = null, om = t1;
                    }), am;
                }();
            }
            populate(t1, e, r, n) {
                const i = hm();
                if (!i) return;
                const s = ju(r);
                this.tileToMeter = s, this.brightness = e.brightness, i.setStyle({
                    normalScale: [
                        1,
                        -1,
                        s
                    ],
                    tileToMeters: s
                }), i.setAOOptions(!1, .3), i.setMetricOptions(!1, 16), i.setStructuralOptions(!0), i.setFacadeClassifierOptions(3);
                const a = new Map, o = new Map;
                let l = 0;
                for (const { feature: e } of t1){
                    if ("LineString" !== Ty[e.type]) {
                        a.set(e.id, e.properties.source_id);
                        continue;
                    }
                    const t1 = this.layers[0]._featureFilter.needGeometry;
                    if (t1 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), e, r)) continue;
                    const i = Ku(e, t1);
                    if (!t1 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), i, r)) continue;
                    const s = t1 ? i.geometry : Ju(e, r, n), u = [];
                    for (const t1 of s)for (const e of t1)u.push(e.x), u.push(e.y);
                    const c = {
                        coordinates: u,
                        crossPerc: e.properties.cross_perc,
                        distanceToRoad: e.properties.distance_to_road,
                        entrances: e.properties.entrances,
                        sourceId: 0
                    }, h = e.properties.source_id;
                    let p = o.get(h);
                    p || (p = [], o.set(h, p)), p.push(c), ++l;
                }
                this.maxHeight = 0;
                const u = new Array, c = new Set, h = (t1)=>{
                    null != t1 && c.add(t1);
                }, p = (t1, e)=>{
                    null != t1 && u.push({
                        buildingId: t1,
                        footprintIndex: e
                    });
                }, d = 64 * (t1.length - l), f = d / 2;
                this.buildingWithFacade.reserve(d, f, !0), this.buildingWithoutFacade.reserve(2 * d, 2 * f, !1), this.footprintsIndices.reserve(16 * (t1.length - l)), this.footprintsVertices.reserve(8 * (t1.length - l));
                for (const { feature: l, id: u, index: d, sourceLayerIndex: f } of t1){
                    if ("LineString" === Ty[l.type]) continue;
                    const t1 = this.layers[0]._featureFilter.needGeometry;
                    if (t1 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), l, r)) continue;
                    let m = null;
                    if (l.properties && l.properties.hasOwnProperty("building_id") && (m = Number(l.properties.building_id), c.has(m))) continue;
                    const y = Ku(l, t1);
                    if (!t1 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), y, r)) continue;
                    const g = t1 ? y.geometry : Ju(l, r, n), x = Mp(g, 500);
                    let v = !1;
                    for (const t1 of x)if (1 !== t1.length) {
                        v = !0;
                        break;
                    }
                    if (v) {
                        h(m);
                        continue;
                    }
                    if (!Ey(g, 163)) {
                        h(m);
                        continue;
                    }
                    const b = this.layers[0], w = Fy(b.layout.get("building-roof-shape").evaluate(l, {}, r)), _ = b.layout.get("building-base").evaluate(l, {}, r), A = b.layout.get("building-height").evaluate(l, {}, r), I = b.layout.get("building-flood-light-ground-radius").evaluate(l, {}, r), M = b.paint.get("building-ambient-occlusion-intensity"), S = I / this.tileToMeter;
                    l.properties["building-part"] = "roof";
                    const P = b.paint.get("building-color").evaluate(l, {}, this.canonical).toPremultipliedRenderColor(this.lut), z = b.paint.get("building-emissive-strength").evaluate(l, {}, this.canonical);
                    l.properties["building-part"] = "wall";
                    const B = b.paint.get("building-color").evaluate(l, {}, this.canonical).toPremultipliedRenderColor(this.lut), k = b.paint.get("building-emissive-strength").evaluate(l, {}, this.canonical);
                    l.properties["building-part"] = "window";
                    const T = b.paint.get("building-color").evaluate(l, {}, this.canonical).toPremultipliedRenderColor(this.lut), V = b.paint.get("building-emissive-strength").evaluate(l, {}, this.canonical);
                    l.properties["building-part"] = "door";
                    const E = b.paint.get("building-color").evaluate(l, {}, this.canonical).toPremultipliedRenderColor(this.lut), F = b.paint.get("building-emissive-strength").evaluate(l, {}, this.canonical);
                    let D = b.layout.get("building-flood-light-wall-radius").evaluate(l, {}, r);
                    D = Dt(D, 0, 2048);
                    const C = D / 2048 * Vy, R = a.get(u), L = o.get(R) || [], O = 0 !== L.length && b.layout.get("building-facade").evaluate(l, {}, r);
                    i.setFacadeOptions(4, !0), i.setFauxFacadeOptions(O, !1, 1);
                    let U = 0, N = 0, j = 0, G = 0, $ = 0, q = 0, X = 0, H = 0, Z = 0, W = 0, Y = 0;
                    if (O) {
                        let t1 = Math.round(b.layout.get("building-facade-floors").evaluate(l, {}, r));
                        if (0 === _) {
                            t1 = Math.max(1, t1 - (L.length > 0 ? 1 : 0));
                            let e = 4;
                            if (A > 100) {
                                const t1 = [
                                    10,
                                    13,
                                    15
                                ];
                                e = t1[l.id ? l.id % t1.length : 0];
                            } else A <= 10 && (e = 3);
                            i.setFacadeOptions(e, !0), $ = (A < 15 ? 1.3 : 1.61803) * e / s;
                        } else $ = _ / s;
                        q = A / s, $ = Math.min($, q), j = b.layout.get("building-facade-unit-width").evaluate(l, {}, r) / s, G = (q - $) / t1, i.setFauxFacadeOptions(!0, !0, j);
                        const e = b.layout.get("building-facade-window").evaluate(l, {}, r);
                        U = e[0], N = e[1], X = Math.floor(65535 * Math.min(1, $ / jn)), H = Math.floor(65535 * Math.min(1, q / jn)), Z = Math.floor(255 * U) << 8 | Math.floor(255 * N), W = Math.floor(65535 * Math.min(1, j / jn)), Y = Math.floor(65535 * Math.min(1, G / jn));
                    }
                    const J = Array(x.length), K = {
                        x: 1 / 0,
                        y: 1 / 0
                    }, Q = {
                        x: -1 / 0,
                        y: -1 / 0
                    }, tt = {
                        x: 0,
                        y: 0
                    };
                    let et = 0;
                    for(let t1 = 0; t1 < x.length; t1++){
                        const e = x[t1];
                        if (e.length > 0) {
                            const r = [], n = Array(e.length + 1);
                            n[0] = 0;
                            for(let t1 = 0; t1 < e.length; t1++){
                                const i = e[t1];
                                for(let t1 = 0; t1 < i.length; t1++){
                                    const e = i[i.length - t1 - 1];
                                    K.x = Math.min(K.x, e.x), K.y = Math.min(K.y, e.y), Q.x = Math.max(Q.x, e.x), Q.y = Math.max(Q.y, e.y), tt.x += e.x, tt.y += e.y, et++, r.push(e.x), r.push(e.y);
                                }
                                n[t1 + 1] = r.length;
                            }
                            J[t1] = {
                                id: l.id ? l.id : 0,
                                height: A,
                                minHeight: _,
                                sourceId: 0,
                                roofType: w,
                                coordinates: r,
                                ringIndices: n
                            };
                        }
                    }
                    tt.x /= et || 1, tt.y /= et || 1;
                    const rt = i.generateMesh(J, L);
                    if ("string" == typeof rt) {
                        Zt(`Unable to generate building ${l.id}: ${rt}`), h(m);
                        continue;
                    }
                    if (0 === rt.meshes.length || 0 === rt.modifiedPolygonRings.length) {
                        h(m);
                        continue;
                    }
                    const nt = O ? this.buildingWithFacade : this.buildingWithoutFacade;
                    let it = 0;
                    for (const t1 of rt.meshes)it += t1.positions.length / 3;
                    const st = nt.segmentsBucket.prepareSegment(it, nt.layoutVertexArray, nt.indexArray), at = [];
                    let ot = null, lt = 0, ut = -1;
                    const ct = nt.layoutVertexArray.length, ht = ct + it;
                    nt.layoutVertexArray.resize(ht), nt.layoutCentroidArray.resize(ht), nt.layoutNormalArray.resize(ht), nt.layoutAOArray.resize(ht), nt.layoutColorArray.resize(ht), nt.layoutFloodLightDataArray.resize(ht), O && (nt.layoutFacadePaintArray.resize(ht), nt.layoutFacadeDataArray.resize(ht), nt.layoutFacadeVerticalRangeArray.resize(ht));
                    const pt = nt.indexArray.length;
                    let dt = 0, ft = ct;
                    for (const t1 of rt.meshes){
                        let e, r;
                        if (1 === t1.buildingPart) e = P, r = z;
                        else if (0 === t1.buildingPart) e = B, r = k;
                        else if (2 === t1.buildingPart) e = T, r = V;
                        else {
                            if (3 !== t1.buildingPart) continue;
                            e = E, r = F;
                        }
                        if (r = Dt(r, 0, 1), 3 === t1.buildingPart) {
                            const e = new Array;
                            for(let r = 0; r < t1.positions.length; r += 12){
                                const n = t1.positions[r + 0], i = t1.positions[r + 1], s = t1.positions[r + 3], a = t1.positions[r + 4], o = t1.positions[r + 2], l = t1.positions[r + 8] - o, u = 1, c = s - n, h = a - i, p = Math.hypot(c, h);
                                e.push({
                                    pos: [
                                        n + .5 * c,
                                        i + .5 * h,
                                        o
                                    ],
                                    normal: [
                                        h / p,
                                        -c / p,
                                        0
                                    ],
                                    width: p,
                                    height: l,
                                    depth: u,
                                    points: [
                                        n,
                                        i,
                                        s,
                                        a
                                    ]
                                });
                            }
                            const r = nt.entranceBloom.segmentsBucket.prepareSegment(10 * e.length, nt.entranceBloom.layoutVertexArray, nt.entranceBloom.indexArray), n = nt.entranceBloom.layoutVertexArray.length;
                            lt = nt.entranceBloom.indexArray.length, by(e, .5 / this.tileToMeter, nt.entranceBloom.indexArray, nt.entranceBloom.layoutVertexArray, nt.entranceBloom.layoutAttenuationArray);
                            const i = nt.entranceBloom.layoutVertexArray.length - n;
                            ut = nt.entranceBloom.indexArray.length - lt;
                            for(let t1 = 0; t1 < i; t1++)nt.entranceBloom.layoutColorArray.emplaceBack(255 * E.r << 8 | 255 * E.g, 255 * E.b << 8 | 51 * F);
                            r.vertexLength += i, r.primitiveLength += ut, ot = {
                                part: t1.buildingPart,
                                vertexOffset: n,
                                vertexLength: i
                            };
                        }
                        nt.layoutVertexArray.float32.set(t1.positions, 3 * ft);
                        const n = t1.positions.length / 3;
                        for(let i = 0; i < n; ++i){
                            const n = 3 * i;
                            dt = Math.max(dt, t1.positions[n + 2]);
                            const s = t1.normals[n + 1] * Vy, a = t1.normals[n + 2] * Vy, o = 3 * (ft + i);
                            nt.layoutNormalArray.int16[o] = t1.normals[n] * Vy, nt.layoutNormalArray.int16[o + 1] = s, nt.layoutNormalArray.int16[o + 2] = a;
                            const l = t1.ao[i];
                            nt.layoutAOArray.uint8[ft + i] = 255 * l;
                            const u = 1 + (l - 1) * M, c = 255 * e.b * u << 8 | 255 * r;
                            nt.layoutColorArray.uint16[2 * (ft + i)] = 255 * e.r * u << 8 | 255 * e.g * u, nt.layoutColorArray.uint16[2 * (ft + i) + 1] = c;
                        }
                        const i = Math.floor(tt.x), s = Math.floor(tt.y), a = Math.floor(A);
                        for(let t1 = 0; t1 < n; ++t1){
                            const e = 3 * (ft + t1);
                            nt.layoutCentroidArray.int16[e] = i, nt.layoutCentroidArray.int16[e + 1] = s, nt.layoutCentroidArray.int16[e + 2] = a;
                        }
                        if (nt.layoutFloodLightDataArray.uint16.fill(0 === t1.buildingPart ? C : 0, ft, ft + n), O) {
                            const e = 255 * T.r << 8 | 255 * T.g, r = 255 * T.b << 8 | 255 * V;
                            for(let t1 = 0; t1 < n; ++t1){
                                const n = 2 * (ft + t1);
                                nt.layoutFacadePaintArray.uint16[n] = e, nt.layoutFacadePaintArray.uint16[n + 1] = r;
                            }
                            for(let e = 0; e < n; ++e)if (t1.isFauxFacade[e]) {
                                const r = Math.min(65535, Math.floor(t1.uv[2 * e] * rt.outerRingLength));
                                nt.layoutFacadeDataArray.emplace(ft + e, 1 | r, Z, W, Y), nt.layoutFacadeVerticalRangeArray.emplace(ft + e, X, H);
                            } else nt.layoutFacadeDataArray.emplace(ft + e, 0, 0, 0, 0), nt.layoutFacadeVerticalRangeArray.emplace(ft + e, 0, 0);
                        }
                        const o = st.vertexLength, l = t1.indices.length / 3, u = nt.indexArray.length;
                        nt.indexArray.resize(u + l);
                        for(let e = 0; e < l; ++e){
                            const r = 3 * e, n = 3 * u + r;
                            nt.indexArray.uint16[n] = o + t1.indices[r], nt.indexArray.uint16[n + 1] = o + t1.indices[r + 1], nt.indexArray.uint16[n + 2] = o + t1.indices[r + 2];
                        }
                        1 !== t1.buildingPart && 0 !== t1.buildingPart && 2 !== t1.buildingPart && 3 !== t1.buildingPart || at.push({
                            part: t1.buildingPart,
                            vertexOffset: ft,
                            vertexLength: t1.positions.length / 3
                        }), ft += n, st.vertexLength += n, st.primitiveLength += t1.indices.length / 3;
                    }
                    this.maxHeight = Math.max(this.maxHeight, dt);
                    const mt = nt.indexArray.length - pt, yt = this.footprintsIndices.length, gt = this.footprintsVertices.length, xt = [], vt = new Mt(1 / 0, 1 / 0), bt = new Mt(-1 / 0, -1 / 0), wt = this.groundEffect.vertexArray.length;
                    for (const t1 of rt.modifiedPolygonRings){
                        const e = [], r = new Mt(1 / 0, 1 / 0), n = new Mt(-1 / 0, -1 / 0);
                        for(let i = 0; i < t1.length; i += 2){
                            const s = t1.length - i - 2;
                            r.x = Math.min(r.x, t1[s]), r.y = Math.min(r.y, t1[s + 1]), n.x = Math.max(n.x, t1[s]), n.y = Math.max(n.y, t1[s + 1]);
                            const a = new Mt(t1[s], t1[s + 1]);
                            e.push(a), xt.push(a.x, a.y), this.footprintsVertices.emplaceBack(a.x, a.y);
                        }
                        vt.x = Math.min(vt.x, r.x), vt.y = Math.min(vt.y, r.y), bt.x = Math.max(bt.x, n.x), bt.y = Math.max(bt.y, n.y), this.groundEffect.addData(e, [
                            r,
                            n
                        ], S);
                    }
                    const _t = this.groundEffect.vertexArray.length - wt;
                    this.groundEffect.groundRadiusArray.reserveForAdditional(_t);
                    for(let t1 = 0; t1 < _t; t1++)this.groundEffect.groundRadiusArray.emplaceBack(I);
                    (K.x < 0 || Q.x > jn || K.y < 0 || Q.y > jn) && this.featuresOnBorder.push({
                        featureId: l.id,
                        footprintIndex: this.footprints.length
                    });
                    {
                        const t1 = Qh(xt, null, 2);
                        this.footprintsIndices.resize(this.footprintsIndices.length + t1.length), this.footprintsIndices.uint16.set(t1, yt), this.buildingIds.add(null != m ? m : l.id), this.footprintsMin.x = Math.min(this.footprintsMin.x, vt.x), this.footprintsMin.y = Math.min(this.footprintsMin.y, vt.y), this.footprintsMax.x = Math.max(this.footprintsMax.x, bt.x), this.footprintsMax.y = Math.max(this.footprintsMax.y, bt.y);
                        const e = {
                            footprintVertexOffset: gt,
                            footprintVertexLength: this.footprintsVertices.length - gt,
                            footprintIndexOffset: yt,
                            footprintIndexLength: this.footprintsIndices.length - yt,
                            min: vt,
                            max: bt,
                            hiddenFlags: 0,
                            indicesOffset: pt,
                            indicesLength: mt,
                            bloomIndicesOffset: lt,
                            bloomIndicesLength: ut,
                            groundEffectVertexOffset: wt,
                            groundEffectVertexLength: _t,
                            hasFauxFacade: O,
                            height: dt,
                            promoteId: u,
                            feature: y,
                            parts: at,
                            buildingBloom: ot
                        }, r = this.footprints.length;
                        void 0 !== l.id && this.featureFootprintLookup.set(l.id, r), p(m, r), this.footprints.push(e);
                    }
                    this.programConfigurations.populatePaintArrays(nt.layoutVertexArray.length, l, d, {}, e.availableImages, r, e.brightness), this.groundEffect.addPaintPropertiesData(l, d, {}, e.availableImages, r, e.brightness), e.featureIndex.insert(l, g, d, f, this.index, ct);
                }
                u.forEach(({ buildingId: t1, footprintIndex: e })=>{
                    c.has(t1) && (this.footprints[e].hiddenFlags |= 4);
                });
                const m = new Set;
                this.buildingIds.forEach((t1, e, r)=>{
                    c.has(t1) || m.add(t1);
                }), this.buildingIds = m, this.groundEffect.prepareBorderSegments();
            }
            update(t1, e, r, n, i, s, a) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a), this.groundEffect.update(t1, e, i, r, n, s, a), this.evaluate(this.layers[0], t1), this.colorBufferUploaded = !1;
            }
            isEmpty() {
                return 0 === this.buildingWithoutFacade.layoutVertexArray.length && 0 === this.buildingWithFacade.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t1) {
                const e = (e)=>{
                    e.layoutVertexBuffer = t1.createVertexBuffer(e.layoutVertexArray, _y.members), e.layoutNormalBuffer = t1.createVertexBuffer(e.layoutNormalArray, Ay.members), e.layoutCentroidBuffer = t1.createVertexBuffer(e.layoutCentroidArray, Iy.members), e.layoutFloodLightDataBuffer = t1.createVertexBuffer(e.layoutFloodLightDataArray, ky.members), e.layoutFacadeDataArray && e.layoutFacadeDataArray.length && (e.layoutFacadeDataBuffer = t1.createVertexBuffer(e.layoutFacadeDataArray, Py.members)), e.layoutFacadeVerticalRangeArray && e.layoutFacadeVerticalRangeArray.length && (e.layoutFacadeVerticalRangeBuffer = t1.createVertexBuffer(e.layoutFacadeVerticalRangeArray, zy.members)), e.entranceBloom.layoutVertexArray.length && (e.entranceBloom.layoutVertexBuffer = t1.createVertexBuffer(e.entranceBloom.layoutVertexArray, _y.members), e.entranceBloom.layoutAttenuationBuffer = t1.createVertexBuffer(e.entranceBloom.layoutAttenuationArray, By.members)), this.uploadUpdatedColorBuffer(t1), this.uploadUpdatedIndexBuffer(t1);
                };
                this.uploaded || (e(this.buildingWithoutFacade), e(this.buildingWithFacade), this.groundEffect.upload(t1)), this.groundEffect.uploadPaintProperties(t1), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                const t1 = (t1)=>{
                    t1.layoutVertexBuffer && (t1.layoutVertexBuffer.destroy(), t1.layoutNormalBuffer.destroy(), t1.layoutColorBuffer.destroy(), t1.segmentsBucket.destroy(), t1.indexBuffer && t1.indexBuffer.destroy(), t1.entranceBloom.layoutVertexBuffer && (t1.entranceBloom.layoutVertexBuffer.destroy(), t1.entranceBloom.layoutColorBuffer.destroy(), t1.entranceBloom.layoutAttenuationBuffer.destroy(), t1.entranceBloom.indexBuffer.destroy(), t1.entranceBloom.segmentsBucket.destroy()));
                };
                t1(this.buildingWithoutFacade), t1(this.buildingWithFacade), this.groundEffect.destroy(), this.programConfigurations.destroy();
            }
            updateFootprintHiddenFlags(t1, e, r = !0) {
                let n = !1;
                const i = r ? e : 0, s = 0 | (r ? -1 : ~e);
                0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const e of t1){
                    const t1 = this.footprints[e], r = t1.hiddenFlags & s | i;
                    t1.hiddenFlags !== r && (t1.hiddenFlags = r, n = !0, this.groundEffect.updateHiddenByLandmarkRange(t1.groundEffectVertexOffset, t1.groundEffectVertexLength, 0 !== t1.hiddenFlags));
                }
                return n && (this.indexArrayForConflationUploaded = !1), n;
            }
            uploadUpdatedIndexBuffer(t1) {
                if (this.groundEffect.uploadHiddenByLandmark(t1), this.indexArrayForConflationUploaded) return;
                const e = (t1)=>{
                    0 !== t1.indexArray.length && (t1.indexArrayForConflation.resize(t1.indexArray.length), t1.indexArrayForConflation.uint16.set(t1.indexArray.uint16), t1.entranceBloom.indexArrayForConflation.resize(t1.entranceBloom.indexArray.length), t1.entranceBloom.indexArrayForConflation.uint16.set(t1.entranceBloom.indexArray.uint16));
                };
                e(this.buildingWithoutFacade), e(this.buildingWithFacade);
                for (const t1 of this.footprints){
                    const e = t1.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade, r = t1.indicesOffset + t1.indicesLength;
                    if (0 !== t1.hiddenFlags) {
                        for(let n = t1.indicesOffset; n < r; n++)e.indexArrayForConflation.uint16[3 * n + 0] = 0, e.indexArrayForConflation.uint16[3 * n + 1] = 0, e.indexArrayForConflation.uint16[3 * n + 2] = 0;
                        const n = t1.bloomIndicesOffset + t1.bloomIndicesLength;
                        for(let r = t1.bloomIndicesOffset; r < n; r++)e.entranceBloom.indexArrayForConflation.uint16[3 * r + 0] = 0, e.entranceBloom.indexArrayForConflation.uint16[3 * r + 1] = 0, e.entranceBloom.indexArrayForConflation.uint16[3 * r + 2] = 0;
                    }
                }
                const r = (e)=>{
                    0 !== e.indexArray.length && (e.indexBuffer ? e.indexBuffer.updateData(e.indexArrayForConflation) : e.indexBuffer = t1.createIndexBuffer(e.indexArrayForConflation, !0), e.entranceBloom.indexBuffer ? e.entranceBloom.indexBuffer.updateData(e.entranceBloom.indexArrayForConflation) : e.entranceBloom.indexBuffer = t1.createIndexBuffer(e.entranceBloom.indexArrayForConflation, !0));
                };
                r(this.buildingWithoutFacade), r(this.buildingWithFacade), this.indexArrayForConflationUploaded = !0;
            }
            uploadUpdatedColorBuffer(t1) {
                const e = (e)=>{
                    e.layoutColorBuffer ? e.layoutColorBuffer.updateData(e.layoutColorArray) : e.layoutColorBuffer = t1.createVertexBuffer(e.layoutColorArray, My.members, !0), e.layoutFacadePaintArray && (e.layoutFacadePaintBuffer ? e.layoutFacadePaintBuffer.updateData(e.layoutFacadePaintArray) : e.layoutFacadePaintBuffer = t1.createVertexBuffer(e.layoutFacadePaintArray, Sy.members, !0)), e.entranceBloom.layoutColorBuffer ? e.entranceBloom.layoutColorBuffer.updateData(e.entranceBloom.layoutColorArray) : e.entranceBloom.layoutColorBuffer = t1.createVertexBuffer(e.entranceBloom.layoutColorArray, My.members, !0);
                };
                e(this.buildingWithoutFacade), e(this.buildingWithFacade), this.colorBufferUploaded = !0;
            }
            evaluate(t1, e) {
                const r = t1.paint.get("building-ambient-occlusion-intensity");
                for (const n of this.footprints){
                    if (4 & n.hiddenFlags) continue;
                    const i = e[n.promoteId], s = n.feature;
                    s.properties["building-part"] = "roof";
                    const a = t1.paint.get("building-color").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut), o = t1.paint.get("building-emissive-strength").evaluate(s, i, this.canonical);
                    s.properties["building-part"] = "wall";
                    const l = t1.paint.get("building-color").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut), u = t1.paint.get("building-emissive-strength").evaluate(s, i, this.canonical);
                    s.properties["building-part"] = "window";
                    const c = t1.paint.get("building-color").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut), h = t1.paint.get("building-emissive-strength").evaluate(s, i, this.canonical);
                    s.properties["building-part"] = "door";
                    const p = t1.paint.get("building-color").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut), d = t1.paint.get("building-emissive-strength").evaluate(s, i, this.canonical), f = n.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade;
                    for (const t1 of n.parts){
                        let e, i = a;
                        1 === t1.part ? (i = a, e = o) : 0 === t1.part ? (i = l, e = u) : 2 === t1.part ? (i = c, e = h) : 3 === t1.part && (i = p, e = d), e = Dt(e, 0, 1);
                        for(let s = 0; s < t1.vertexLength; s++){
                            const a = t1.vertexOffset + s, o = 1 + (f.layoutAOArray.uint8[a] / 255 - 1) * r;
                            f.layoutColorArray.emplace(a, i.r * o * 255 << 8 | i.g * o * 255, i.b * o * 255 << 8 | 255 * e), n.hasFauxFacade && f.layoutFacadePaintArray.emplace(a, 255 * c.r << 8 | 255 * c.g, 255 * c.b << 8 | 255 * h);
                        }
                    }
                    const m = n.buildingBloom;
                    if (m) for(let t1 = 0; t1 < m.vertexLength; t1++)f.entranceBloom.layoutColorArray.emplace(m.vertexOffset + t1, 255 * p.r << 8 | 255 * p.g, 255 * p.b << 8 | 51 * d);
                }
            }
            needsEvaluation() {
                return !this.colorBufferUploaded;
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped());
                if (Nd(this.activeReplacements, n)) return;
                this.activeReplacements = n;
                for (const t1 of this.footprints)t1.hiddenFlags &= -2;
                const i = [];
                for (const e of this.activeReplacements){
                    if (e.order < r) continue;
                    const n = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t1.canonical.z));
                    for (const r of this.footprints)r.min.x > e.max.x || r.max.x < e.min.x || r.min.y > e.max.y || r.max.y < e.min.y || (i.length = 0, Oy(this.footprintsVertices, r.footprintVertexOffset, r.footprintVertexLength, e.footprintTileId.canonical, t1.canonical, i), $d(e.footprint, i, this.footprintsIndices.uint16, r.footprintIndexOffset, r.footprintIndexLength, 0, -n) && (r.hiddenFlags |= 1));
                }
                0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const t1 of this.footprints)this.groundEffect.updateHiddenByLandmarkRange(t1.groundEffectVertexOffset, t1.groundEffectVertexLength, 0 !== t1.hiddenFlags);
                this.indexArrayForConflationUploaded = !1;
            }
            getFootprint(t1) {
                if (void 0 !== t1.id) {
                    const e = this.featureFootprintLookup.get(t1.id);
                    return this.footprints[e];
                }
                return null;
            }
            getHeightAtTileCoord(t1, e) {
                let r = Number.NEGATIVE_INFINITY, n = !0;
                const i = 4 * (t1 + jn) * jn + (e + jn);
                if (this.footprintLookup.hasOwnProperty(i)) {
                    const t1 = this.footprintLookup[i];
                    return t1 ? {
                        height: t1.height,
                        hidden: 0 !== t1.hiddenFlags
                    } : void 0;
                }
                const s = new Mt(t1, e);
                for (const a of this.footprints)t1 > a.max.x || a.min.x > t1 || e > a.max.y || a.min.y > e || a.height <= r || Ly(s, this.footprintsVertices.float32.subarray(2 * a.footprintVertexOffset, 2 * (a.footprintVertexOffset + a.footprintVertexLength)), this.footprintsIndices.uint16.subarray(a.footprintIndexOffset, a.footprintIndexOffset + a.footprintIndexLength)) && (r = a.height, this.footprintLookup[i] = a, n = 0 !== a.hiddenFlags);
                if (r !== Number.NEGATIVE_INFINITY) return {
                    height: r,
                    hidden: n
                };
                this.footprintLookup[i] = void 0;
            }
        }
        function Ly(t1, e, r) {
            for(let n = 0; n < r.length; n += 3){
                const i = r[n], s = r[n + 1], a = r[n + 2], o = e[2 * i + 0], l = e[2 * i + 1], u = e[2 * s + 0], c = e[2 * s + 1], h = e[2 * a + 0], p = e[2 * a + 1], d = (o - h) * (t1.y - p) - (l - p) * (t1.x - h), f = (u - o) * (t1.y - l) - (c - l) * (t1.x - o);
                if (d < 0 != f < 0 && 0 !== d && 0 !== f) continue;
                const m = (h - u) * (t1.y - c) - (p - c) * (t1.x - u);
                if (0 === m || m < 0 == d + f <= 0) return !0;
            }
            return !1;
        }
        function Oy(t1, e, r, n, i, s) {
            const a = Math.pow(2, n.z - i.z);
            for(let o = 0; o < r; o++){
                let r = t1.float32[2 * (o + e) + 0], l = t1.float32[2 * (o + e) + 1];
                r = (r + i.x * jn) * a - n.x * jn, l = (l + i.y * jn) * a - n.y * jn, s.push(new Mt(r, l));
            }
        }
        let Uy, Ny;
        Qs(Ry, "BuildingBucket", {
            omit: [
                "layers"
            ]
        }), Qs(Cy, "BuildingGeometry"), Qs(Dy, "BuildingBloomGeometry");
        const jy = Oo([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), Gy = Oo([
            {
                name: "a_z_offset_width",
                components: 3,
                type: "Float32"
            }
        ], 4), { members: $y } = jy, qy = Oo([
            {
                name: "a_packed",
                components: 3,
                type: "Float32"
            }
        ]), { members: Xy } = qy, Hy = Oo([
            {
                name: "a_pattern_data",
                components: 3,
                type: "Float32"
            }
        ]), { members: Zy } = Hy;
        class Wy {
            constructor(t1, e){
                this.width = t1, this.height = e, this.nextRow = 0, this.image = new qh({
                    width: t1,
                    height: e
                }), this.positions = {}, this.uploaded = !1;
            }
            getDash(t1, e) {
                const r = this.getKey(t1, e);
                return this.positions[r];
            }
            trim() {
                const t1 = this.width, e = this.height = Nt(this.nextRow);
                this.image.resize({
                    width: t1,
                    height: e
                });
            }
            getKey(t1, e) {
                return t1.join(",") + e;
            }
            getDashRanges(t1, e, r) {
                const n = [];
                let i = t1.length % 2 == 1 ? -t1[t1.length - 1] * r : 0, s = t1[0] * r, a = !0;
                n.push({
                    left: i,
                    right: s,
                    isDash: a,
                    zeroLength: 0 === t1[0]
                });
                let o = t1[0];
                for(let e = 1; e < t1.length; e++){
                    a = !a;
                    const l = t1[e];
                    i = o * r, o += l, s = o * r, n.push({
                        left: i,
                        right: s,
                        isDash: a,
                        zeroLength: 0 === l
                    });
                }
                return n;
            }
            addRoundDash(t1, e, r) {
                const n = e / 2;
                for(let e = -r; e <= r; e++){
                    const i = this.width * (this.nextRow + r + e);
                    let s = 0, a = t1[s];
                    for(let o = 0; o < this.width; o++){
                        o / a.right > 1 && (a = t1[++s]);
                        const l = Math.abs(o - a.left), u = Math.abs(o - a.right), c = Math.min(l, u);
                        let h;
                        const p = e / r * (n + 1);
                        if (a.isDash) {
                            const t1 = n - Math.abs(p);
                            h = Math.sqrt(c * c + t1 * t1);
                        } else h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t1, e) {
                for(let e = t1.length - 1; e >= 0; --e){
                    const r = t1[e], n = t1[e + 1];
                    r.zeroLength ? t1.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t1.splice(e, 1));
                }
                const r = t1[0], n = t1[t1.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let s = 0, a = t1[s];
                for(let r = 0; r < this.width; r++){
                    r / a.right > 1 && (a = t1[++s]);
                    const n = Math.abs(r - a.left), o = Math.abs(r - a.right), l = Math.min(n, o);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));
                }
            }
            addDash(t1, e) {
                const r = this.getKey(t1, e);
                if (this.positions[r]) return this.positions[r];
                const n = "round" === e, i = n ? 7 : 0, s = 2 * i + 1;
                if (this.nextRow + s > this.height) return Zt("LineAtlas out of space"), null;
                0 === t1.length && t1.push(1);
                let a = 0;
                for(let e = 0; e < t1.length; e++)t1[e] < 0 && (Zt("Negative value is found in line dasharray, replacing values with 0"), t1[e] = 0), a += t1[e];
                if (0 !== a) {
                    const r = this.width / a, s = this.getDashRanges(t1, this.width, r);
                    n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
                }
                const o = this.nextRow + i;
                this.nextRow += s;
                const l = {
                    tl: [
                        o,
                        i
                    ],
                    br: [
                        a,
                        0
                    ]
                };
                return this.positions[r] = l, l;
            }
        }
        Qs(Wy, "LineAtlas");
        const Yy = Qu.types, Jy = Math.cos(Math.PI / 180 * 37.5), Ky = Math.cos(Math.PI / 180 * 5);
        class Qy {
            constructor(t1){
                this.evaluationGlobals = {
                    zoom: 0,
                    lineProgress: void 0
                }, this.elevationType = "none", this.zoom = t1.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t1.overscaling, this.pixelRatio = t1.pixelRatio, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.projection = t1.projection, this.hasPattern = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new Zo, this.layoutVertexArray2 = new Wo, this.patternVertexArray = new Wo, this.indexArray = new ll, this.programConfigurations = new fu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segments = new Ol, this.maxLineLength = 0, this.zOffsetVertexArray = new Wo, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.tessellationStep = t1.tessellationStep ? t1.tessellationStep : 128, this.worldview = t1.worldview, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {}
            updateAppearances(t1, e, r, n) {}
            populate(t1, e, r, n) {
                this.hasPattern = zp("line", this.layers, this.pixelRatio, e);
                const i = this.layers[0].layout.get("line-sort-key");
                this.tileToMeter = ju(r);
                const s = this.layers[0].layout.get("line-elevation-reference");
                if ("hd-road-markup" === s) this.elevationType = "road";
                else {
                    const t1 = this.layers[0].layout.get("line-z-offset"), e = t1.isConstant() && !t1.constantOr(0);
                    this.elevationType = "sea" !== s && "ground" !== s && e ? "none" : "offset", "offset" === this.elevationType && "none" === s && Zt(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
                }
                const a = this.layers[0].layout.get("line-cross-slope");
                this.hasCrossSlope = "offset" === this.elevationType && void 0 !== a;
                const o = [];
                for (const { feature: s, id: a, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = Ku(s, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, {
                        worldview: this.worldview,
                        activeFloors: e.activeFloors
                    }), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r) : void 0, p = {
                        id: a,
                        properties: s.properties,
                        type: s.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : Ju(s, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    o.push(p);
                }
                i && o.sort((t1, e)=>t1.sortKey - e.sortKey);
                const { lineAtlas: l, featureIndex: u } = e, c = this.addConstantDashes(l);
                for (const n of o){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    if (c && this.addFeatureDashes(n, l), this.hasPattern) {
                        const t1 = Bp("line", this.layers, n, this.zoom, this.pixelRatio, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, l.positions, e.availableImages, e.brightness, e.elevationFeatures);
                    u.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            addConstantDashes(t1) {
                let e = !1;
                for (const r of this.layers){
                    const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind) e = !0;
                    else {
                        const e = i.value, r = n.value;
                        if (!r) continue;
                        t1.addDash(r, e);
                    }
                }
                return e;
            }
            addFeatureDashes(t1, e) {
                const r = this.zoom;
                for (const n of this.layers){
                    const i = n.paint.get("line-dasharray").value, s = n.layout.get("line-cap").value;
                    if ("constant" === i.kind && "constant" === s.kind) continue;
                    let a, o;
                    if ("constant" === i.kind) {
                        if (a = i.value, !a) continue;
                    } else a = i.evaluate({
                        zoom: r
                    }, t1);
                    o = "constant" === s.kind ? s.value : s.evaluate({
                        zoom: r
                    }, t1), e.addDash(a, o), t1.patterns[n.id] = [
                        e.getKey(a, o)
                    ];
                }
            }
            update(t1, e, r, n, i, s, a, o) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, o);
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const i of this.patternFeatures)this.addFeature(i, i.geometry, i.index, e, r, n, s, t1.elevationFeatures);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, Xy)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t1.createVertexBuffer(this.patternVertexArray, Zy)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, Gy.members, !0)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, $y), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1, e) {
                let r, n;
                if (e && e > 0 ? (r = `mapbox_clip_start_${e}`, n = `mapbox_clip_end_${e}`) : (r = "mapbox_clip_start", n = "mapbox_clip_end"), t1.properties && t1.properties.hasOwnProperty(r) && t1.properties.hasOwnProperty(n)) return {
                    start: +t1.properties[r],
                    end: +t1.properties[n]
                };
            }
            addFeature(t1, e, r, n, i, s, a, o) {
                const l = this.layers[0].layout, u = l.get("line-join").evaluate(t1, {}), c = l.get("line-cap").evaluate(t1, {}), h = l.get("line-miter-limit"), p = l.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1), this.lineFeature = t1;
                const d = !(!t1.properties || !t1.properties.hasOwnProperty("mapbox_line_metrics")) && t1.properties.mapbox_line_metrics;
                this.zOffsetValue = l.get("line-z-offset").value;
                const f = this.layers[0].paint.get("line-width").value;
                if ("constant" !== f.kind && !1 === f.isLineProgressConstant && (this.variableWidthValue = f), "road" === this.elevationType) {
                    const r = this.layoutVertexArray.length;
                    if (!this.addElevatedRoadFeature(t1, e, n, o, u, c, h, p)) {
                        const [i, s] = this.clipRuntimeLinesToTile(e, 1);
                        for(let e = 0; e < i.length; e++){
                            const r = i[e], a = s[e], o = {
                                progress: {
                                    min: a.progress.min,
                                    max: a.progress.max
                                },
                                nextDir: this.computeSegNextDir(a, r),
                                prevDir: this.computeSegPrevDir(a, r)
                            };
                            this.addLine(r, t1, n, u, c, h, p, o, d && a.parentIndex > 0 ? a.parentIndex : null);
                        }
                        this.fillNonElevatedRoadSegment(r);
                    }
                } else for(let r = 0; r < e.length; r++)this.addLine(e[r], t1, n, u, c, h, p, void 0, d && r > 0 ? r : null);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n, a, void 0, this.worldview);
            }
            computeSegNextDir(t1, e) {
                return t1.nextPoint.sub(e.at(-2)).unit();
            }
            computeSegPrevDir(t1, e) {
                return e[1].sub(t1.prevPoint).unit();
            }
            clipLinesToTile(t1, e) {
                return Ef(t1, -e, -e, jn + e, jn + e);
            }
            clipRuntimeLinesToTile(t1, e) {
                const r = [];
                return [
                    Ef(t1, -e, -e, jn + e, jn + e, r),
                    r
                ];
            }
            addElevatedRoadFeature(t1, e, r, n, i, s, a, o) {
                const l = [], u = Ic.getElevationFeature(t1, n);
                if (u) {
                    const t1 = this.clipLinesToTile(e, 1), n = this.prepareElevatedLines(t1, u, r);
                    for (const t1 of n)l.push({
                        geometry: t1,
                        elevation: u,
                        elevationTileID: r,
                        segment: {
                            progress: {
                                min: 0,
                                max: 1
                            },
                            nextDir: void 0,
                            prevDir: void 0
                        }
                    });
                }
                if (0 === l.length) return !1;
                for (const e of l){
                    const n = this.layoutVertexArray.length;
                    this.addLine(e.geometry, t1, r, i, s, a, o);
                    const l = new Mc(r, e.elevationTileID);
                    if (e.elevation) for(let t1 = n; t1 < this.layoutVertexArray.length; t1++){
                        const r = new Mt(this.layoutVertexArray.int16[6 * t1] >> 1, this.layoutVertexArray.int16[6 * t1 + 1] >> 1), n = l.pointElevation(r, e.elevation, .05);
                        this.updateHeightRange(n), this.zOffsetVertexArray.emplaceBack(n, 0, 0);
                    }
                    else this.fillNonElevatedRoadSegment(n);
                }
                return !0;
            }
            prepareElevatedLines(t1, e, r) {
                if (null != e.constantHeight) return t1;
                const n = [], i = 1 / ju(r);
                for (const r of t1)Ff(r, new _c(e, i), 0, n);
                return n;
            }
            fillNonElevatedRoadSegment(t1) {
                for(let e = t1; e < this.layoutVertexArray.length; e++)this.zOffsetVertexArray.emplaceBack(0, 0, 0);
            }
            updateHeightRange(t1) {
                this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t1), this.heightRange.max = Math.max(this.heightRange.max, t1)) : this.heightRange = {
                    min: t1,
                    max: t1
                };
            }
            addLine(t1, e, r, n, i, s, a, o, l) {
                this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0, this.lineClips = l ? this.lineFeatureClips(e, l) : this.lineClips;
                const u = "none" === n;
                this.patternJoinNone = this.hasPattern && u, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
                const c = o && o.progress.min > 0, h = o && o.progress.max < 1;
                if (this.lineClips) {
                    let r = {
                        min: this.lineClips.start,
                        max: this.lineClips.end
                    }, n = 1;
                    if (o) {
                        const t1 = this.lineClips.end - this.lineClips.start;
                        r = function(t1, e, r) {
                            return {
                                min: ae(t1.min, e, r),
                                max: ae(t1.max, e, r)
                            };
                        }(o.progress, {
                            min: 0,
                            max: 1
                        }, r), t1 > 0 && (n = (r.max - r.min) / t1);
                    }
                    const i = +e.properties.mapbox_clip_feature_len, s = +e.properties.mapbox_clip_seg_len;
                    if (Number.isNaN(i) || Number.isNaN(s)) {
                        for(let e = 0; e < t1.length - 1; e++)this.totalDistance += t1[e].dist(t1[e + 1]);
                        const e = this.totalDistance / (r.max - r.min);
                        this.totalFeatureLength = Number.isFinite(e) ? e : 0, this.lineClips.start = r.min, this.lineClips.end = r.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                    } else this.totalFeatureLength = i, this.distance = s * n, this.lineClips.start = r.min, this.lineClips.end = r.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
                    this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
                }
                const p = "Polygon" === Yy[e.type];
                let d = t1.length;
                for(; d >= 2 && t1[d - 1].equals(t1[d - 2]);)d--;
                let f = 0;
                for(; f < d - 1 && t1[f].equals(t1[f + 1]);)f++;
                if (d < (p ? 3 : 2)) return;
                "bevel" === n && (s = 1.05);
                const m = this.segments.prepareSegment(10 * d, this.layoutVertexArray, this.indexArray);
                let y, g, x, v, b, w, _, A;
                o && o.prevDir && (w = o.prevDir.perp()), o && o.nextDir && (_ = o.nextDir.perp()), this.e1 = this.e2 = -1, p && (y = t1[d - 2], b = t1[f].sub(y)._unit()._perp());
                for(let e = f; e < d; e++){
                    if (x = e === d - 1 ? p ? t1[f + 1] : void 0 : t1[e + 1], x && t1[e].equals(x)) continue;
                    b && (v = b), y && (g = y), y = t1[e], A = this.evaluateLineProgressFeatures(g ? g.dist(y) : 0), b = x ? x.sub(y)._unit()._perp() : v, v = v || b;
                    const r = g && x;
                    let o = r ? n : p || u ? "butt" : i;
                    const l = v.x * b.x + v.y * b.y;
                    if (u) {
                        const t1 = function(t1) {
                            if (t1.patternJoinNone) {
                                const e = t1.segmentPoints.length / 2, r = t1.lineSoFar - t1.segmentStart;
                                for(let n = 0; n < e; ++n){
                                    const e = t1.segmentPoints[2 * n + 1], i = Math.round(t1.segmentPoints[2 * n]) + .5 + .25 * e;
                                    t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart), t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart);
                                }
                                t1.segmentPoints.length = 0;
                            }
                            t1.e1 = t1.e2 = -1;
                        };
                        if (r && l < Ky) {
                            this.updateDistance(g, y), this.addCurrentVertex(y, v, 1, 1, m, A), t1(this), this.addCurrentVertex(y, b, -1, -1, m, A);
                            continue;
                        }
                        if (g) {
                            if (!x) {
                                this.updateDistance(g, y), this.addCurrentVertex(y, v, 1, 1, m, A), t1(this);
                                continue;
                            }
                            o = "miter";
                        }
                    }
                    let I = v.add(b);
                    0 === I.x && 0 === I.y || I._unit();
                    const M = I.x * b.x + I.y * b.y, S = 0 !== M ? 1 / M : 1 / 0, P = 2 * Math.sqrt(2 - 2 * M), z = M < Jy && g && x, B = v.x * b.y - v.y * b.x > 0, k = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0;
                    if (r && "round" === o) {
                        if (S < a) o = "miter";
                        else if (S <= 2) {
                            const t1 = tg(y, -10, 8202);
                            o = "offset" === this.elevationType && (t1 || this.hasCrossSlope) ? "miter" : "fakeround";
                        }
                    }
                    if ("miter" === o && S > s && (o = "bevel"), "bevel" === o && (S > 2 && (o = "flipbevel"), S < s && (o = "miter")), g && !("miter" === o && z) && this.updateDistance(g, y), "miter" === o) if (z) {
                        const t1 = y.dist(g);
                        if (t1 > 2 * k) {
                            const e = y.sub(y.sub(g)._mult(k / t1)._round());
                            this.updateDistance(g, e), this.addCurrentVertex(e, v, 0, 0, m, A), g = e;
                        }
                        this.updateDistance(g, y), I._mult(S), this.addCurrentVertex(y, I, 0, 0, m, A);
                        const e = y.dist(x);
                        if (e > 2 * k) {
                            const t1 = y.add(x.sub(y)._mult(k / e)._round());
                            this.updateDistance(y, t1), this.addCurrentVertex(t1, b, 0, 0, m, A), y = t1;
                        }
                    } else I._mult(S), this.addCurrentVertex(y, I, 0, 0, m, A);
                    else if ("flipbevel" === o) {
                        if (S > 100) I = b.mult(-1);
                        else {
                            const t1 = S * v.add(b).mag() / v.sub(b).mag();
                            I._perp()._mult(t1 * (B ? -1 : 1));
                        }
                        this.addCurrentVertex(y, I, 0, 0, m, A), this.addCurrentVertex(y, I.mult(-1), 0, 0, m, A);
                    } else if ("bevel" === o || "fakeround" === o) {
                        null != A && g && this.addCurrentVertex(y, _ || v, -1, -1, m, A);
                        const t1 = y.dist(g) <= 2 * k && "bevel" !== o, e = I.mult(B ? 1 : -1);
                        e._mult(S);
                        const r = b.mult(B ? -1 : 1), n = v.mult(B ? -1 : 1), i = this.evaluateLineProgressFeatures(this.distance);
                        if (null == A && (this.addHalfVertex(y, e.x, e.y, !1, !B, 0, m, i), t1 || this.addHalfVertex(y, e.x + 2 * n.x, e.y + 2 * n.y, !1, B, 0, m, i)), "fakeround" === o) {
                            const t1 = Math.round(180 * P / Math.PI / 20);
                            this.addHalfVertex(y, n.x, n.y, !1, B, 0, m, i);
                            for(let e = 0; e < t1; e++){
                                let s = e / t1;
                                if (.5 !== s) {
                                    const t1 = s - .5;
                                    s += s * t1 * (s - 1) * ((1.0904 + l * (l * (3.55645 - 1.43519 * l) - 3.2452)) * t1 * t1 + (.848013 + l * (.215638 * l - 1.06021)));
                                }
                                const a = r.sub(n)._mult(s)._add(n)._unit();
                                this.addHalfVertex(y, a.x, a.y, !1, B, 0, m, i);
                            }
                            this.addHalfVertex(y, r.x, r.y, !1, B, 0, m, i);
                        }
                        t1 || null != A || this.addHalfVertex(y, e.x + 2 * r.x, e.y + 2 * r.y, !1, B, 0, m, i), null != A && x && this.addCurrentVertex(y, w || b, 1, 1, m, A);
                    } else if ("butt" === o) this.addCurrentVertex(y, I, 0, 0, m, A);
                    else if ("square" === o) {
                        if (!g) {
                            const t1 = c ? 0 : -1;
                            this.addCurrentVertex(y, I, t1, t1, m, A);
                        }
                        if (this.addCurrentVertex(y, I, 0, 0, m, A), g) {
                            const t1 = h ? 0 : 1;
                            this.addCurrentVertex(y, I, t1, t1, m, A);
                        }
                    } else if ("round" === o) {
                        if (g) {
                            const t1 = !r && _ ? _ : v;
                            this.addCurrentVertex(y, t1, 0, 0, m, A), !r && h || this.addCurrentVertex(y, t1, 1, 1, m, A, !0);
                        }
                        if (x) {
                            const t1 = !r && w ? w : b;
                            !r && c || this.addCurrentVertex(y, t1, -1, -1, m, A, !0), this.addCurrentVertex(y, t1, 0, 0, m, A);
                        }
                    }
                }
            }
            addVerticesTo(t1, e, r, n, i, s, a, o, l, u) {
                const c = (e.w - t1.w) / this.tessellationStep | 0;
                let h = 0;
                const p = this.scaledDistance;
                if (c > 1) {
                    this.lineSoFar = t1.w;
                    const p = (e.x - t1.x) / c, d = (e.y - t1.y) / c, f = (e.z - t1.z) / c, m = (e.w - t1.w) / c;
                    for(let e = 1; e < c; ++e){
                        t1.x += p, t1.y += d, t1.z += f, this.lineSoFar += m, h += m;
                        const e = this.evaluateLineProgressFeatures(this.prevDistance + h);
                        this.scaledDistance = (this.prevDistance + h) / this.totalDistance, this.addHalfVertex(t1, r, n, u, !1, a, l, e), this.addHalfVertex(t1, i, s, u, !0, -o, l, e);
                    }
                }
                this.lineSoFar = e.w, this.scaledDistance = p;
                const d = this.evaluateLineProgressFeatures(this.distance);
                this.addHalfVertex(e, r, n, u, !1, a, l, d), this.addHalfVertex(e, i, s, u, !0, -o, l, d);
            }
            evaluateLineProgressFeatures(t1) {
                if (!this.variableWidthValue && "offset" !== this.elevationType) return null;
                this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t1) / this.totalFeatureLength) : Zt(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
                let e = 0;
                return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), "offset" !== this.elevationType ? {
                    zOffset: 0,
                    variableWidth: e
                } : "constant" === this.zOffsetValue.kind ? {
                    zOffset: this.zOffsetValue.value,
                    variableWidth: e
                } : {
                    zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,
                    variableWidth: e
                };
            }
            addCurrentVertex(t1, e, r, n, i, s, a = !1) {
                const o = e.x + e.y * r, l = e.y - e.x * r, u = e.y * n - e.x, c = -e.y - e.x * n;
                if (null != s) {
                    const e = "offset" === this.elevationType, h = -10, p = 8202, d = s.zOffset, f = new kf(t1.x, t1.y, d, this.lineSoFar), m = !!e && tg(t1, h, p), y = this.lineSoFar, g = this.distance;
                    if (this.currentVertex) if (m) {
                        const e = this.currentVertexIsOutside, s = this.currentVertex, m = new kf(t1.x, t1.y, d, this.lineSoFar);
                        if (Vf(s, m, h, p), !tg(m, h, p)) {
                            if (e) {
                                this.e1 = this.e2 = -1, this.distance -= s.dist(f), this.lineSoFar = s.w;
                                const t1 = this.evaluateLineProgressFeatures(s.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                this.addHalfVertex(s, o, l, a, !1, r, i, t1), this.addHalfVertex(s, u, c, a, !0, -n, i, t1), this.prevDistance = this.distance;
                            }
                            this.distance = this.prevDistance + s.dist(m), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s, m, o, l, u, c, r, n, i, a), this.distance = g, this.scaledDistance = this.distance / this.totalDistance;
                        }
                    } else {
                        const t1 = this.currentVertex;
                        if (this.currentVertexIsOutside) {
                            Vf(t1, f, h, p), this.e1 = this.e2 = -1, this.distance -= t1.dist(f), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t1.w;
                            const e = this.evaluateLineProgressFeatures(t1.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                            this.addHalfVertex(t1, o, l, a, !1, r, i, e), this.addHalfVertex(t1, u, c, a, !0, -n, i, e), this.prevDistance = this.distance, this.distance = g, this.scaledDistance = this.distance / this.totalDistance;
                        }
                        this.addVerticesTo(t1, f, o, l, u, c, r, n, i, a);
                    }
                    else m || (this.addHalfVertex(t1, o, l, a, !1, r, i, s), this.addHalfVertex(t1, u, c, a, !0, -n, i, s));
                    this.currentVertex = f, this.currentVertexIsOutside = m, this.lineSoFar = y;
                } else this.addHalfVertex(t1, o, l, a, !1, r, i, s), this.addHalfVertex(t1, u, c, a, !0, -n, i, s);
            }
            addHalfVertex({ x: t1, y: e }, r, n, i, s, a, o, l) {
                if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s || this.segmentPoints.push(this.lineSoFar - this.segmentStart, a)), this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
                    const t1 = dr(this.lineClips.start, this.lineClips.end, this.scaledDistance);
                    this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t1);
                }
                const u = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), s ? this.e2 = u : this.e1 = u, null != l && this.zOffsetVertexArray.emplaceBack(l.zOffset, l.variableWidth, l.variableWidth);
            }
            updateScaledDistance() {
                this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
            }
            updateDistance(t1, e) {
                this.prevDistance = this.distance, this.distance += t1.dist(e), this.updateScaledDistance();
            }
        }
        function tg(t1, e, r) {
            return t1.x < e || t1.x > r || t1.y < e || t1.y > r;
        }
        let eg, rg;
        function ng(t1, e, r) {
            return e * (jn / (t1.tileSize * Math.pow(2, r - t1.tileID.overscaledZ)));
        }
        Qs(Qy, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures",
                "currentVertex",
                "currentVertexIsOutside"
            ]
        });
        const ig = (t1, e, r)=>(1 - r) * t1 + r * e;
        function sg(t1, e) {
            return 1 / ng(t1, 1, e.tileZoom);
        }
        function ag(t1, e, r, n) {
            return t1.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const og = (t1)=>{
            const e = [];
            lg(t1) && e.push("RENDER_LINE_DASH"), t1.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
            const r = t1.paint.get("line-trim-offset");
            0 === r[0] && 0 === r[1] || e.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t1.paint.get("line-border-width").constantOr(1) && e.push("RENDER_LINE_BORDER");
            const n = "none" === t1.layout.get("line-join").constantOr("miter"), i = !!t1.paint.get("line-pattern").constantOr(1);
            return n && i && e.push("LINE_JOIN_NONE"), e;
        };
        function lg(t1) {
            const e = t1.paint.get("line-dasharray").value;
            return "constant" !== e.kind || e.value;
        }
        let ug;
        const cg = ()=>ug || (ug = {
                layout: eg || (eg = new uo({
                    "line-cap": new oo(co.layout_line["line-cap"]),
                    "line-join": new oo(co.layout_line["line-join"]),
                    "line-miter-limit": new ao(co.layout_line["line-miter-limit"]),
                    "line-round-limit": new ao(co.layout_line["line-round-limit"]),
                    "line-sort-key": new oo(co.layout_line["line-sort-key"]),
                    "line-z-offset": new oo(co.layout_line["line-z-offset"]),
                    "line-elevation-reference": new ao(co.layout_line["line-elevation-reference"]),
                    "line-cross-slope": new ao(co.layout_line["line-cross-slope"]),
                    visibility: new ao(co.layout_line.visibility),
                    "line-width-unit": new ao(co.layout_line["line-width-unit"])
                })),
                paint: rg || (rg = new uo({
                    "line-opacity": new oo(co.paint_line["line-opacity"]),
                    "line-color": new oo(co.paint_line["line-color"]),
                    "line-translate": new ao(co.paint_line["line-translate"]),
                    "line-translate-anchor": new ao(co.paint_line["line-translate-anchor"]),
                    "line-width": new oo(co.paint_line["line-width"]),
                    "line-gap-width": new oo(co.paint_line["line-gap-width"]),
                    "line-offset": new oo(co.paint_line["line-offset"]),
                    "line-blur": new oo(co.paint_line["line-blur"]),
                    "line-dasharray": new oo(co.paint_line["line-dasharray"]),
                    "line-pattern": new oo(co.paint_line["line-pattern"]),
                    "line-pattern-cross-fade": new ao(co.paint_line["line-pattern-cross-fade"]),
                    "line-gradient": new lo(co.paint_line["line-gradient"]),
                    "line-trim-offset": new ao(co.paint_line["line-trim-offset"]),
                    "line-trim-fade-range": new ao(co.paint_line["line-trim-fade-range"]),
                    "line-trim-color": new ao(co.paint_line["line-trim-color"]),
                    "line-emissive-strength": new oo(co.paint_line["line-emissive-strength"]),
                    "line-border-width": new oo(co.paint_line["line-border-width"]),
                    "line-border-color": new oo(co.paint_line["line-border-color"]),
                    "line-occlusion-opacity": new ao(co.paint_line["line-occlusion-opacity"]),
                    "line-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-gradient-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-trim-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-border-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, ug);
        class hg extends oo {
            possiblyEvaluate(t1, e) {
                return e = new Ja(Math.floor(e.zoom), {
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    transition: e.transition,
                    worldview: e.worldview
                }), super.possiblyEvaluate(t1, e);
            }
            evaluate(t1, e, r, n) {
                return e = Object.assign({}, e, {
                    zoom: Math.floor(e.zoom)
                }), super.evaluate(t1, e, r, n);
            }
        }
        let pg;
        function dg(t1, e) {
            return e > 0 ? e + 2 * t1 : t1;
        }
        const fg = Oo([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), mg = Oo([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), yg = Oo([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        Oo([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const gg = Oo([
            {
                name: "a_auto_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), xg = Oo([
            {
                name: "a_x_axis",
                components: 3,
                type: "Float32"
            },
            {
                name: "a_y_axis",
                components: 3,
                type: "Float32"
            }
        ]), vg = Oo([
            {
                name: "a_texb",
                components: 2,
                type: "Uint16"
            }
        ]), bg = Oo([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_elevation_from_sea",
                components: 2,
                type: "Float32"
            }
        ]), wg = Oo([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_auto_z_offset",
                components: 1,
                type: "Float32"
            }
        ]);
        Oo([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const _g = Oo([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), Ag = Oo([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        Oo([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), Oo([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), Oo([
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            },
            {
                type: "Float32",
                name: "zOffset"
            },
            {
                type: "Uint8",
                name: "hasIconTextFit"
            },
            {
                type: "Uint16",
                name: "elevationFeatureIndex"
            }
        ]), Oo([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), Oo([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        var Ig = 24;
        function Mg(t1, e, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e, r) {
                    const n = e.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), Ya.applyArabicShaping && (t1 = Ya.applyArabicShaping(t1)), t1;
                }(t1.text, e, r);
            }), t1;
        }
        const Sg = {
            "!": "ï¸",
            "#": "ï¼",
            $: "ï¼",
            "%": "ï¼",
            "&": "ï¼",
            "(": "ï¸µ",
            ")": "ï¸¶",
            "*": "ï¼",
            "+": "ï¼",
            ",": "ï¸",
            "-": "ï¸²",
            ".": "ã»",
            "/": "ï¼",
            ":": "ï¸",
            ";": "ï¸",
            "<": "ï¸¿",
            "=": "ï¼",
            ">": "ï¹",
            "?": "ï¸",
            "@": "ï¼ ",
            "[": "ï¹",
            "\\": "ï¼¼",
            "]": "ï¹",
            "^": "ï¼¾",
            _: "ï¸³",
            "`": "ï½",
            "{": "ï¸·",
            "|": "â",
            "}": "ï¸¸",
            "~": "ï½",
            "Â¢": "ï¿ ",
            "Â£": "ï¿¡",
            "Â¥": "ï¿¥",
            "Â¦": "ï¿¤",
            "Â¬": "ï¿¢",
            "Â¯": "ï¿£",
            "â": "ï¸²",
            "â": "ï¸±",
            "â": "ï¹",
            "â": "ï¹",
            "â": "ï¹",
            "â": "ï¹",
            "â¦": "ï¸",
            "â§": "ã»",
            "â©": "ï¿¦",
            "ã": "ï¸",
            "ã": "ï¸",
            "ã": "ï¸¿",
            "ã": "ï¹",
            "ã": "ï¸½",
            "ã": "ï¸¾",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¸»",
            "ã": "ï¸¼",
            "ã": "ï¸¹",
            "ã": "ï¸º",
            "ã": "ï¸",
            "ã": "ï¸",
            "ï¼": "ï¸",
            "ï¼": "ï¸µ",
            "ï¼": "ï¸¶",
            "ï¼": "ï¸",
            "ï¼": "ï¸²",
            "ï¼": "ã»",
            "ï¼": "ï¸",
            "ï¼": "ï¸",
            "ï¼": "ï¸¿",
            "ï¼": "ï¹",
            "ï¼": "ï¸",
            "ï¼»": "ï¹",
            "ï¼½": "ï¹",
            "ï¼¿": "ï¸³",
            "ï½": "ï¸·",
            "ï½": "â",
            "ï½": "ï¸¸",
            "ï½": "ï¸µ",
            "ï½ ": "ï¸¶",
            "ï½¡": "ï¸",
            "ï½¢": "ï¹",
            "ï½£": "ï¹",
            "â": "â",
            "â": "â"
        };
        function Pg(t1) {
            return "ï¸¶" === t1 || "ï¹" === t1 || "ï¸¸" === t1 || "ï¹" === t1 || "ï¹" === t1 || "ï¸¾" === t1 || "ï¸¼" === t1 || "ï¸º" === t1 || "ï¸" === t1 || "ï¹" === t1 || "ï¸" === t1 || "ï¸" === t1 || "ï¸" === t1 || "ï½" === t1 || "ï¿£" === t1 || "ï¸" === t1 || "ï¸" === t1;
        }
        function zg(t1) {
            return "ï¸µ" === t1 || "ï¹" === t1 || "ï¸·" === t1 || "ï¹" === t1 || "ï¹" === t1 || "ï¸½" === t1 || "ï¸»" === t1 || "ï¸¹" === t1 || "ï¸" === t1 || "ï¸¿" === t1;
        }
        const Bg = 4294967296, kg = 1 / Bg, Tg = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
        let Vg = class {
            constructor(t1 = new Uint8Array(16)){
                this.buf = ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            readFields(t1, e, r = this.length) {
                for(; this.pos < r;){
                    const r = this.readVarint(), n = r >> 3, i = this.pos;
                    this.type = 7 & r, t1(n, e, this), this.pos === i && this.skip(r);
                }
                return e;
            }
            readMessage(t1, e) {
                return this.readFields(t1, e, this.readVarint() + this.pos);
            }
            readFixed32() {
                const t1 = this.dataView.getUint32(this.pos, !0);
                return this.pos += 4, t1;
            }
            readSFixed32() {
                const t1 = this.dataView.getInt32(this.pos, !0);
                return this.pos += 4, t1;
            }
            readFixed64() {
                const t1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Bg;
                return this.pos += 8, t1;
            }
            readSFixed64() {
                const t1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Bg;
                return this.pos += 8, t1;
            }
            readFloat() {
                const t1 = this.dataView.getFloat32(this.pos, !0);
                return this.pos += 4, t1;
            }
            readDouble() {
                const t1 = this.dataView.getFloat64(this.pos, !0);
                return this.pos += 8, t1;
            }
            readVarint(t1) {
                const e = this.buf;
                let r, n;
                return n = e[this.pos++], r = 127 & n, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 7, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 14, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 21, n < 128 ? r : (n = e[this.pos], r |= (15 & n) << 28, function(t1, e, r) {
                    const n = r.buf;
                    let i, s;
                    if (s = n[r.pos++], i = (112 & s) >> 4, s < 128) return Eg(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 3, s < 128) return Eg(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 10, s < 128) return Eg(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 17, s < 128) return Eg(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 24, s < 128) return Eg(t1, i, e);
                    if (s = n[r.pos++], i |= (1 & s) << 31, s < 128) return Eg(t1, i, e);
                    throw new Error("Expected varint not more than 10 bytes");
                }(r, t1, this)))));
            }
            readVarint64() {
                return this.readVarint(!0);
            }
            readSVarint() {
                const t1 = this.readVarint();
                return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
            }
            readBoolean() {
                return Boolean(this.readVarint());
            }
            readString() {
                const t1 = this.readVarint() + this.pos, e = this.pos;
                return this.pos = t1, t1 - e >= 12 && Tg ? Tg.decode(this.buf.subarray(e, t1)) : function(t1, e, r) {
                    let n = "", i = e;
                    for(; i < r;){
                        const e = t1[i];
                        let s, a, o, l = null, u = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                        if (i + u > r) break;
                        1 === u ? e < 128 && (l = e) : 2 === u ? (s = t1[i + 1], 128 == (192 & s) && (l = (31 & e) << 6 | 63 & s, l <= 127 && (l = null))) : 3 === u ? (s = t1[i + 1], a = t1[i + 2], 128 == (192 & s) && 128 == (192 & a) && (l = (15 & e) << 12 | (63 & s) << 6 | 63 & a, (l <= 2047 || l >= 55296 && l <= 57343) && (l = null))) : 4 === u && (s = t1[i + 1], a = t1[i + 2], o = t1[i + 3], 128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (l = (15 & e) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o, (l <= 65535 || l >= 1114112) && (l = null))), null === l ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += u;
                    }
                    return n;
                }(this.buf, e, t1);
            }
            readBytes() {
                const t1 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t1);
                return this.pos = t1, e;
            }
            readPackedVarint(t1 = [], e) {
                const r = this.readPackedEnd();
                for(; this.pos < r;)t1.push(this.readVarint(e));
                return t1;
            }
            readPackedSVarint(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readSVarint());
                return t1;
            }
            readPackedBoolean(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readBoolean());
                return t1;
            }
            readPackedFloat(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readFloat());
                return t1;
            }
            readPackedDouble(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readDouble());
                return t1;
            }
            readPackedFixed32(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readFixed32());
                return t1;
            }
            readPackedSFixed32(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readSFixed32());
                return t1;
            }
            readPackedFixed64(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readFixed64());
                return t1;
            }
            readPackedSFixed64(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readSFixed64());
                return t1;
            }
            readPackedEnd() {
                return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
            }
            skip(t1) {
                const e = 7 & t1;
                if (0 === e) for(; this.buf[this.pos++] > 127;);
                else if (2 === e) this.pos = this.readVarint() + this.pos;
                else if (5 === e) this.pos += 4;
                else {
                    if (1 !== e) throw new Error(`Unimplemented type: ${e}`);
                    this.pos += 8;
                }
            }
            writeTag(t1, e) {
                this.writeVarint(t1 << 3 | e);
            }
            realloc(t1) {
                let e = this.length || 16;
                for(; e < this.pos + t1;)e *= 2;
                if (e !== this.length) {
                    const t1 = new Uint8Array(e);
                    t1.set(this.buf), this.buf = t1, this.dataView = new DataView(t1.buffer), this.length = e;
                }
            }
            finish() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }
            writeFixed32(t1) {
                this.realloc(4), this.dataView.setInt32(this.pos, t1, !0), this.pos += 4;
            }
            writeSFixed32(t1) {
                this.realloc(4), this.dataView.setInt32(this.pos, t1, !0), this.pos += 4;
            }
            writeFixed64(t1) {
                this.realloc(8), this.dataView.setInt32(this.pos, -1 & t1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t1 * kg), !0), this.pos += 8;
            }
            writeSFixed64(t1) {
                this.realloc(8), this.dataView.setInt32(this.pos, -1 & t1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t1 * kg), !0), this.pos += 8;
            }
            writeVarint(t1) {
                (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e) {
                    let r, n;
                    if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (r = ~(-t1 % 4294967296), n = ~(-t1 / 4294967296), 4294967295 ^ r ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e.realloc(10), function(t1, e, r) {
                        r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                    }(r, 0, e), function(t1, e) {
                        const r = (7 & t1) << 4;
                        e.buf[e.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1)))));
                    }(n, e);
                }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
            }
            writeSVarint(t1) {
                this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
            }
            writeBoolean(t1) {
                this.writeVarint(+t1);
            }
            writeString(t1) {
                t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                const e = this.pos;
                this.pos = function(t1, e, r) {
                    for(let n, i, s = 0; s < e.length; s++){
                        if (n = e.charCodeAt(s), n > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                continue;
                            }
                            if (n < 56320) {
                                t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                continue;
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                        n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                    }
                    return r;
                }(this.buf, t1, this.pos);
                const r = this.pos - e;
                r >= 128 && Fg(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
            }
            writeFloat(t1) {
                this.realloc(4), this.dataView.setFloat32(this.pos, t1, !0), this.pos += 4;
            }
            writeDouble(t1) {
                this.realloc(8), this.dataView.setFloat64(this.pos, t1, !0), this.pos += 8;
            }
            writeBytes(t1) {
                const e = t1.length;
                this.writeVarint(e), this.realloc(e);
                for(let r = 0; r < e; r++)this.buf[this.pos++] = t1[r];
            }
            writeRawMessage(t1, e) {
                this.pos++;
                const r = this.pos;
                t1(e, this);
                const n = this.pos - r;
                n >= 128 && Fg(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            }
            writeMessage(t1, e, r) {
                this.writeTag(t1, 2), this.writeRawMessage(e, r);
            }
            writePackedVarint(t1, e) {
                e.length && this.writeMessage(t1, Dg, e);
            }
            writePackedSVarint(t1, e) {
                e.length && this.writeMessage(t1, Cg, e);
            }
            writePackedBoolean(t1, e) {
                e.length && this.writeMessage(t1, Og, e);
            }
            writePackedFloat(t1, e) {
                e.length && this.writeMessage(t1, Rg, e);
            }
            writePackedDouble(t1, e) {
                e.length && this.writeMessage(t1, Lg, e);
            }
            writePackedFixed32(t1, e) {
                e.length && this.writeMessage(t1, Ug, e);
            }
            writePackedSFixed32(t1, e) {
                e.length && this.writeMessage(t1, Ng, e);
            }
            writePackedFixed64(t1, e) {
                e.length && this.writeMessage(t1, jg, e);
            }
            writePackedSFixed64(t1, e) {
                e.length && this.writeMessage(t1, Gg, e);
            }
            writeBytesField(t1, e) {
                this.writeTag(t1, 2), this.writeBytes(e);
            }
            writeFixed32Field(t1, e) {
                this.writeTag(t1, 5), this.writeFixed32(e);
            }
            writeSFixed32Field(t1, e) {
                this.writeTag(t1, 5), this.writeSFixed32(e);
            }
            writeFixed64Field(t1, e) {
                this.writeTag(t1, 1), this.writeFixed64(e);
            }
            writeSFixed64Field(t1, e) {
                this.writeTag(t1, 1), this.writeSFixed64(e);
            }
            writeVarintField(t1, e) {
                this.writeTag(t1, 0), this.writeVarint(e);
            }
            writeSVarintField(t1, e) {
                this.writeTag(t1, 0), this.writeSVarint(e);
            }
            writeStringField(t1, e) {
                this.writeTag(t1, 2), this.writeString(e);
            }
            writeFloatField(t1, e) {
                this.writeTag(t1, 5), this.writeFloat(e);
            }
            writeDoubleField(t1, e) {
                this.writeTag(t1, 1), this.writeDouble(e);
            }
            writeBooleanField(t1, e) {
                this.writeVarintField(t1, +e);
            }
        };
        function Eg(t1, e, r) {
            return r ? 4294967296 * e + (t1 >>> 0) : 4294967296 * (e >>> 0) + (t1 >>> 0);
        }
        function Fg(t1, e, r) {
            const n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
            r.realloc(n);
            for(let e = r.pos - 1; e >= t1; e--)r.buf[e + n] = r.buf[e];
        }
        function Dg(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeVarint(t1[r]);
        }
        function Cg(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeSVarint(t1[r]);
        }
        function Rg(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeFloat(t1[r]);
        }
        function Lg(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeDouble(t1[r]);
        }
        function Og(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeBoolean(t1[r]);
        }
        function Ug(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeFixed32(t1[r]);
        }
        function Ng(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeSFixed32(t1[r]);
        }
        function jg(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeFixed64(t1[r]);
        }
        function Gg(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeSFixed64(t1[r]);
        }
        function $g(t1, e, r) {
            e.glyphs = [], 1 === t1 && r.readMessage(qg, e);
        }
        function qg(t1, e, r) {
            if (3 === t1) {
                const { id: t1, bitmap: n, width: i, height: s, left: a, top: o, advance: l } = r.readMessage(Xg, {});
                e.glyphs.push({
                    id: t1,
                    bitmap: new qh({
                        width: i + 6,
                        height: s + 6
                    }, n),
                    metrics: {
                        width: i,
                        height: s,
                        left: a,
                        top: o,
                        advance: l
                    }
                });
            } else 4 === t1 ? e.ascender = r.readSVarint() : 5 === t1 && (e.descender = r.readSVarint());
        }
        function Xg(t1, e, r) {
            1 === t1 ? e.id = r.readVarint() : 2 === t1 ? e.bitmap = r.readBytes() : 3 === t1 ? e.width = r.readVarint() : 4 === t1 ? e.height = r.readVarint() : 5 === t1 ? e.left = r.readSVarint() : 6 === t1 ? e.top = r.readSVarint() : 7 === t1 && (e.advance = r.readVarint());
        }
        const Hg = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class Zg {
            constructor(){
                this.scale = 1, this.fontStack = "", this.image = null;
            }
            static forText(t1, e) {
                const r = new Zg;
                return r.scale = t1 || 1, r.fontStack = e, r;
            }
            static forImage(t1) {
                const e = new Zg;
                return e.image = t1, e;
            }
        }
        class Wg {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e, r) {
                const n = new Wg;
                for(let i = 0; i < t1.sections.length; i++){
                    const s = t1.sections[i];
                    s.image ? n.addImageSection(s, r) : n.addTextSection(s, e);
                }
                return n;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCodePoint(t1) {
                return this.text.codePointAt(t1);
            }
            verticalizePunctuation(t1) {
                this.text = function(t1, e) {
                    let r = "";
                    for(let n = 0; n < t1.length; n++){
                        const i = t1.charCodeAt(n + 1) || null, s = t1.charCodeAt(n - 1) || null;
                        r += !e && (i && Ca(i) && !Sg[t1[n + 1]] || s && Ca(s) && !Sg[t1[n - 1]]) || !Sg[t1[n]] ? t1[n] : Sg[t1[n]];
                    }
                    return r;
                }(this.text, t1);
            }
            trim() {
                let t1 = 0;
                for(let e = 0; e < this.text.length && Jg[this.text.charCodeAt(e)]; e++)t1++;
                let e = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && Jg[this.text.charCodeAt(r)]; r--)e--;
                this.text = this.text.substring(t1, e), this.sectionIndex = this.sectionIndex.slice(t1, e);
            }
            substring(t1, e) {
                const r = new Wg;
                return r.text = this.text.substring(t1, e), r.sectionIndex = this.sectionIndex.slice(t1, e), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e)=>Math.max(t1, this.sections[e].scale), 0);
            }
            addTextSection(t1, e) {
                this.text += t1.text, this.sections.push(Zg.forText(t1.scale, t1.fontStack || e));
                const r = this.sections.length - 1;
                for(let e = 0; e < t1.text.length; ++e)this.sectionIndex.push(r);
            }
            addImageSection(t1, e) {
                const r = t1.image ? t1.image.getPrimary() : null;
                if (!r) return void Zt("Can't add FormattedSection with an empty image.");
                r.scaleSelf(e);
                const n = this.getNextImageSectionCharCode();
                n ? (this.text += String.fromCodePoint(n), this.sections.push(Zg.forImage(r)), this.sectionIndex.push(this.sections.length - 1)) : Zt("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function Yg(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m = 1) {
            const y = Wg.fromFeature(t1, i, m);
            h === Hg.vertical && y.verticalizePunctuation(p);
            let g = [];
            const x = function(t1, e, r, n, i, s) {
                if (!t1) return [];
                const a = [], o = function(t1, e, r, n, i, s) {
                    let a = 0;
                    for(let r = 0; r < t1.length(); r++){
                        const o = t1.getSection(r);
                        a += Qg(t1.getCodePoint(r), o, n, i, e, s);
                    }
                    return a / Math.max(1, Math.ceil(a / r));
                }(t1, e, r, n, i, s), l = t1.text.indexOf("â") >= 0;
                let u = 0;
                for(let r = 0; r < t1.length(); r++){
                    const c = t1.getSection(r), h = t1.getCodePoint(r);
                    if (Jg[h] || (u += Qg(h, c, n, i, e, s)), r < t1.length() - 1) {
                        const e = Ea(h);
                        (Kg[h] || e || c.image) && a.push(rx(r + 1, u, o, a, ex(h, t1.getCodePoint(r + 1), e && l), !1));
                    }
                }
                return nx(rx(t1.length(), u, o, a, 0, !0));
            }(y, u, s, e, n, d), { processBidirectionalText: v, processStyledBidirectionalText: b } = Ya;
            if (v && 1 === y.sections.length) {
                const t1 = v(y.toString(), x);
                for (const e of t1){
                    const t1 = new Wg;
                    t1.text = e, t1.sections = y.sections;
                    for(let r = 0; r < e.length; r++)t1.sectionIndex.push(0);
                    g.push(t1);
                }
            } else if (b) {
                const t1 = b(y.text, y.sectionIndex, x);
                for (const e of t1){
                    const t1 = new Wg;
                    t1.text = e[0], t1.sectionIndex = e[1], t1.sections = y.sections, g.push(t1);
                }
            } else g = function(t1, e) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(y, x);
            const w = [], _ = {
                positionedLines: w,
                text: y.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            if (function(t1, e, r, n, i, s, a, o, l, u, c, h) {
                let p = 0, d = 0, f = 0;
                const m = "right" === o ? 1 : "left" === o ? 0 : .5;
                let y = !1;
                for (const t1 of i){
                    const r = t1.getSections();
                    for (const t1 of r){
                        if (t1.image) continue;
                        const r = e[t1.fontStack];
                        if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;
                    }
                    if (!y) break;
                }
                let g = 0;
                for (const a of i){
                    a.trim();
                    const i = a.getMaxScale(), o = (i - 1) * Ig, x = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t1.positionedLines[g] = x;
                    const v = x.positionedGlyphs;
                    let b = 0;
                    if (!a.length()) {
                        d += s, ++g;
                        continue;
                    }
                    let w = 0, _ = 0;
                    for(let s = 0; s < a.length(); s++){
                        const o = a.getSection(s), f = a.getSectionIndex(s), m = a.getCodePoint(s);
                        let g = o.scale, x = null, A = null, I = null, M = Ig, S = 0, P = l;
                        P === Hg.vertical && Da(m) && (P = Hg.horizontal);
                        const z = !(P === Hg.horizontal || !c && !Fa(m) || c && (Jg[m] || Ra(m)));
                        if (o.image) {
                            const e = n.get(o.image.toString());
                            if (!e) continue;
                            I = o.image, t1.iconsInText = t1.iconsInText || !0, A = e.paddedRect;
                            const r = e.displaySize;
                            g = g * Ig / h, x = {
                                width: r[0],
                                height: r[1],
                                left: 0,
                                top: -3,
                                advance: z ? r[1] : r[0],
                                localGlyph: !1
                            }, S = y ? -x.height * g : i * Ig - 17 - r[1] * g, M = x.advance;
                            const s = (z ? r[0] : r[1]) * g - Ig * i;
                            s > 0 && s > b && (b = s);
                        } else {
                            const t1 = r[o.fontStack];
                            if (!t1) continue;
                            t1[m] && (A = t1[m]);
                            const n = e[o.fontStack];
                            if (!n) continue;
                            const s = n.glyphs[m];
                            if (!s) continue;
                            if (x = s.metrics, M = 8203 !== m ? Ig : 0, y) {
                                const t1 = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, e = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (t1 + e) * g;
                                w < r && (w = r, _ = (t1 - e) / 2 * g), S = -t1 * g;
                            } else S = (i - g) * Ig - 17;
                        }
                        z ? (t1.verticalizable = !0, v.push({
                            glyph: m,
                            image: I,
                            x: p,
                            y: d + S,
                            vertical: z,
                            scale: g,
                            localGlyph: x.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: f,
                            metrics: x,
                            rect: A
                        }), p += M * g + u) : (v.push({
                            glyph: m,
                            image: I,
                            x: p,
                            y: d + S,
                            vertical: z,
                            scale: g,
                            localGlyph: x.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: f,
                            metrics: x,
                            rect: A
                        }), p += x.advance * g + u);
                    }
                    0 !== v.length && (f = Math.max(p - u, f), y ? sx(v, m, b, _, s * i / 2) : sx(v, m, b, 0, s / 2)), p = 0;
                    const A = s * i + b;
                    x.lineOffset = Math.max(b, o), d += A, ++g;
                }
                const x = d, { horizontalAlign: v, verticalAlign: b } = ix(a);
                (function(t1, e, r, n, i, s) {
                    const a = (e - r) * i, o = -s * n;
                    for (const e of t1)for (const t1 of e.positionedGlyphs)t1.x += a, t1.y += o;
                })(t1.positionedLines, m, v, b, f, x), t1.top += -b * x, t1.bottom = t1.top + x, t1.left += -v * f, t1.right = t1.left + f, t1.hasBaseline = y;
            }(_, e, r, n, g, a, o, l, h, u, p, f), !function(t1) {
                for (const e of t1)if (0 !== e.positionedGlyphs.length) return !1;
                return !0;
            }(w)) return _;
        }
        const Jg = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, Kg = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function Qg(t1, e, r, n, i, s) {
            if (e.image) {
                const t1 = n.get(e.image.toString());
                return t1 ? t1.displaySize[0] * e.scale * Ig / s + i : 0;
            }
            {
                const n = r[e.fontStack], s = n && n.glyphs[t1];
                return s ? s.metrics.advance * e.scale + i : 0;
            }
        }
        function tx(t1, e, r, n) {
            const i = Math.pow(t1 - e, 2);
            return n ? t1 < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function ex(t1, e, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
        }
        function rx(t1, e, r, n, i, s) {
            let a = null, o = tx(e, r, i, s);
            for (const t1 of n){
                const n = tx(e - t1.x, r, i, s) + t1.badness;
                n <= o && (a = t1, o = n);
            }
            return {
                index: t1,
                x: e,
                priorBreak: a,
                badness: o
            };
        }
        function nx(t1) {
            return t1 ? nx(t1.priorBreak).concat(t1.index) : [];
        }
        function ix(t1) {
            let e = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e,
                verticalAlign: r
            };
        }
        function sx(t1, e, r, n, i) {
            if (!(e || r || n || i)) return;
            const s = t1.length - 1, a = t1[s], o = (a.x + a.metrics.advance * a.scale) * e;
            for(let e = 0; e <= s; e++)t1[e].x -= o, t1[e].y += r + n + i;
        }
        function ax(t1) {
            return void 0 !== t1.imagePrimary && void 0 !== t1.top && void 0 !== t1.bottom && void 0 !== t1.left && void 0 !== t1.right;
        }
        function ox(t1, e, r, n) {
            const { horizontalAlign: i, verticalAlign: s } = ix(n), a = r[0] - t1.displaySize[0] * i, o = r[1] - t1.displaySize[1] * s;
            return {
                imagePrimary: t1,
                imageSecondary: e,
                top: o,
                bottom: o + t1.displaySize[1],
                left: a,
                right: a + t1.displaySize[0]
            };
        }
        function lx(t1, e, r, n, i, s) {
            const a = t1.imagePrimary;
            let o;
            if (a.content) {
                const t1 = a.content, e = a.pixelRatio || 1;
                o = [
                    t1[0] / e,
                    t1[1] / e,
                    a.displaySize[0] - t1[2] / e,
                    a.displaySize[1] - t1[3] / e
                ];
            }
            const l = e.left * s, u = e.right * s;
            let c, h, p, d;
            "width" === r || "both" === r ? (d = i[0] + l - n[3], h = i[0] + u + n[1]) : (d = i[0] + (l + u - a.displaySize[0]) / 2, h = d + a.displaySize[0]);
            const f = e.top * s, m = e.bottom * s;
            return "height" === r || "both" === r ? (c = i[1] + f - n[0], p = i[1] + m + n[2]) : (c = i[1] + (f + m - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {
                imagePrimary: a,
                imageSecondary: void 0,
                top: c,
                right: h,
                bottom: p,
                left: d,
                collisionPadding: o
            };
        }
        function ux(t1) {
            return !t1.imagePrimary.stretchX;
        }
        function cx(t1) {
            return !t1.imagePrimary.stretchY;
        }
        function hx(t1) {
            return {
                width: t1.right - t1.left,
                height: t1.bottom - t1.top
            };
        }
        const px = 128;
        function dx(t1, e, r, n) {
            const { expression: i } = e;
            if ("constant" === i.kind) return {
                kind: "constant",
                layoutSize: i.evaluate(new Ja(t1 + 1, {
                    worldview: r
                }), void 0, void 0, void 0, n)
            };
            if ("source" === i.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e, interpolationType: s } = i;
                let a = 0;
                for(; a < e.length && e[a] <= t1;)a++;
                a = Math.max(0, a - 1);
                let o = a;
                for(; o < e.length && e[o] < t1 + 1;)o++;
                o = Math.min(e.length - 1, o);
                const l = e[a], u = e[o];
                return "composite" === i.kind ? {
                    kind: "composite",
                    minZoom: l,
                    maxZoom: u,
                    interpolationType: s
                } : {
                    kind: "camera",
                    minZoom: l,
                    maxZoom: u,
                    minSize: i.evaluate(new Ja(l, {
                        worldview: r
                    }), void 0, void 0, void 0, n),
                    maxSize: i.evaluate(new Ja(u, {
                        worldview: r
                    }), void 0, void 0, void 0, n),
                    interpolationType: s
                };
            }
        }
        function fx(t1, { uSize: e, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t1.kind ? n / px : "composite" === t1.kind ? dr(n / px, i / px, r) : e;
        }
        function mx(t1, e, r = 1) {
            let n = 0, i = 0;
            if ("constant" === t1.kind) i = t1.layoutSize * r;
            else if ("source" !== t1.kind) {
                const { interpolationType: s, minZoom: a, maxZoom: o } = t1, l = s ? Dt(Hi.interpolationFactor(s, e, a, o), 0, 1) : 0;
                "camera" === t1.kind ? i = dr(t1.minSize, t1.maxSize, l) * r : n = l * r;
            }
            return {
                uSizeT: n,
                uSize: i
            };
        }
        class yx extends Mt {
            constructor(t1, e, r, n, i){
                super(t1, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }
            clone() {
                return new yx(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function gx(t1, e, r, n, i) {
            if (void 0 === e.segment) return !0;
            let s = e, a = e.segment + 1, o = 0;
            for(; o > -r / 2;){
                if (a--, a < 0) return !1;
                o -= t1[a].dist(s), s = t1[a];
            }
            o += t1[a].dist(t1[a + 1]), a++;
            const l = [];
            let u = 0;
            for(; o < r / 2;){
                const e = t1[a], r = t1[a + 1];
                if (!r) return !1;
                let s = t1[a - 1].angleTo(e) - e.angleTo(r);
                for(s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: o,
                    angleDelta: s
                }), u += s; o - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                a++, o += e.dist(r);
            }
            return !0;
        }
        function xx(t1) {
            let e = 0;
            for(let r = 0; r < t1.length - 1; r++)e += t1[r].dist(t1[r + 1]);
            return e;
        }
        function vx(t1, e, r) {
            return t1 ? .6 * e * r : 0;
        }
        function bx(t1, e) {
            return Math.max(t1 ? t1.right - t1.left : 0, e ? e.right - e.left : 0);
        }
        function wx(t1, e, r, n, i, s) {
            const a = vx(r, i, s), o = bx(r, n) * s;
            let l = 0;
            const u = xx(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], s = n.dist(i);
                if (l + s > u) {
                    const c = (u - l) / s, h = dr(n.x, i.x, c), p = dr(n.y, i.y, c), d = new yx(h, p, 0, i.angleTo(n), r);
                    return !a || gx(t1, d, o, a, e) ? d : void 0;
                }
                l += s;
            }
        }
        function _x(t1, e, r, n, i, s, a, o, l) {
            const u = vx(n, s, a), c = bx(n, i), h = c * a, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e - h < e / 4 && (e = h + e / 4), Ax(t1, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);
        }
        function Ax(t1, e, r, n, i, s, a, o, l) {
            const u = s / 2, c = xx(t1);
            let h = 0, p = e - r, d = [];
            for(let e = 0; e < t1.length - 1; e++){
                const a = t1[e], o = t1[e + 1], f = a.dist(o), m = o.angleTo(a);
                for(; p + r < h + f;){
                    p += r;
                    const y = (p - h) / f, g = dr(a.x, o.x, y), x = dr(a.y, o.y, y);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new yx(g, x, 0, m, e);
                        n && !gx(t1, r, s, n, i) || d.push(r);
                    }
                }
                h += f;
            }
            return o || d.length || a || (d = Ax(t1, h / 2, r, n, i, s, a, !0, l)), d;
        }
        function Ix(t1) {
            let e = 0, r = 0;
            for (const n of t1)e += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e)=>e.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, s = 0;
            for (const e of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e.w > r.w || e.h > r.h)) {
                    if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
                        const e = n.pop();
                        e && t1 < n.length && (n[t1] = e);
                    } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({
                        x: r.x + e.w,
                        y: r.y,
                        w: r.w - e.w,
                        h: e.h
                    }), r.y += e.h, r.h -= e.h);
                    break;
                }
            }
            return {
                w: i,
                h: s,
                fill: e / (i * s) || 0
            };
        }
        Qs(yx, "Anchor");
        class Mx {
            static getImagePositionScale(t1, e, r) {
                if (e && t1) {
                    const { sx: e, sy: r } = t1;
                    return {
                        x: e,
                        y: r
                    };
                }
                return {
                    x: r,
                    y: r
                };
            }
            constructor(t1, e, r, n){
                this.paddedRect = t1;
                const { pixelRatio: i, version: s, stretchX: a, stretchY: o, content: l, sdf: u, usvg: c } = e;
                this.pixelRatio = i, this.stretchX = a, this.stretchY = o, this.content = l, this.version = s, this.padding = r, this.sdf = u, this.usvg = c, this.scale = Mx.getImagePositionScale(n, c, i);
            }
            get tl() {
                return [
                    this.paddedRect.x + this.padding,
                    this.paddedRect.y + this.padding
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - this.padding,
                    this.paddedRect.y + this.paddedRect.h - this.padding
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2 * this.padding) / this.scale.x,
                    (this.paddedRect.h - 2 * this.padding) / this.scale.y
                ];
            }
        }
        function Sx(t1, e, r) {
            const n = Lr.parse(t1), i = function(t1, e, r = [
                1,
                1
            ]) {
                return {
                    x: 0,
                    y: 0,
                    w: (t1.data ? t1.data.width : t1.width * r[0]) + 2 * e,
                    h: (t1.data ? t1.data.height : t1.height * r[1]) + 2 * e
                };
            }(e, r, [
                n.sx,
                n.sy
            ]);
            return {
                bin: i,
                imagePosition: new Mx(i, e, r, n),
                imageVariant: n
            };
        }
        class Px {
            constructor(t1, e, r){
                const n = new Map, i = new Map;
                this.haveRenderCallbacks = [];
                const s = [];
                this.addImages(t1, n, 1, s), this.addImages(e, i, 2, s);
                const { w: a, h: o } = Ix(s), l = new Xh({
                    width: a || 1,
                    height: o || 1
                });
                for (const [e, r] of t1.entries()){
                    const t1 = n.get(e).paddedRect;
                    Xh.copy(r.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: t1.x + 1,
                        y: t1.y + 1
                    }, r.data, null, r.sdf);
                }
                for (const [t1, n] of e.entries()){
                    const e = i.get(t1), s = e.paddedRect;
                    let a = e.padding;
                    const o = s.x + a, u = s.y + a, c = n.data.width, h = n.data.height;
                    a = a > 1 ? a - 1 : a, Xh.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: u
                    }, n.data, r), Xh.copy(n.data, l, {
                        x: 0,
                        y: h - a
                    }, {
                        x: o,
                        y: u - a
                    }, {
                        width: c,
                        height: a
                    }, r), Xh.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: u + h
                    }, {
                        width: c,
                        height: a
                    }, r), Xh.copy(n.data, l, {
                        x: c - a,
                        y: 0
                    }, {
                        x: o - a,
                        y: u
                    }, {
                        width: a,
                        height: h
                    }, r), Xh.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + c,
                        y: u
                    }, {
                        width: a,
                        height: h
                    }, r), Xh.copy(n.data, l, {
                        x: c - a,
                        y: h - a
                    }, {
                        x: o - a,
                        y: u - a
                    }, {
                        width: a,
                        height: a
                    }, r), Xh.copy(n.data, l, {
                        x: 0,
                        y: h - a
                    }, {
                        x: o + c,
                        y: u - a
                    }, {
                        width: a,
                        height: a
                    }, r), Xh.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + c,
                        y: u + h
                    }, {
                        width: a,
                        height: a
                    }, r), Xh.copy(n.data, l, {
                        x: c - a,
                        y: 0
                    }, {
                        x: o - a,
                        y: u + h
                    }, {
                        width: a,
                        height: a
                    }, r);
                }
                this.lut = r, this.image = l, this.iconPositions = n, this.patternPositions = i;
            }
            addImages(t1, e, r, n) {
                for (const [i, s] of t1.entries()){
                    const { bin: t1, imagePosition: a, imageVariant: o } = Sx(i, s, r);
                    e.set(i, a), n.push(t1), s.hasRenderCallback && this.haveRenderCallbacks.push(o.id);
                }
            }
            patchUpdatedImages(t1, e, r) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e)=>t1.hasImage(e, r)), t1.dispatchRenderCallbacks(this.haveRenderCallbacks, r);
                for (const n of t1.getUpdatedImages(r)){
                    for (const i of this.iconPositions.keys()){
                        const s = Lr.parse(i);
                        if (sr.isEqual(s.id, n)) {
                            const s = t1.getImage(n, r);
                            this.patchUpdatedImage(this.iconPositions.get(i), s, e, null);
                        }
                    }
                    for (const i of this.patternPositions.keys()){
                        const s = Lr.parse(i);
                        if (sr.isEqual(s.id, n)) {
                            const s = t1.getImage(n, r);
                            this.patchUpdatedImage(this.patternPositions.get(i), s, e, this.lut);
                        }
                    }
                }
            }
            patchUpdatedImage(t1, e, r, n = null) {
                if (!t1 || !e) return;
                if (t1.version === e.version) return;
                t1.version = e.version;
                const [i, s] = t1.tl, a = t1.sdf;
                if (this.lut || a) {
                    const t1 = {
                        width: e.data.width,
                        height: e.data.height
                    }, o = new Xh(t1);
                    Xh.copy(e.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, t1, n, a), r.update(o, {
                        position: {
                            x: i,
                            y: s
                        }
                    });
                } else r.update(e.data, {
                    position: {
                        x: i,
                        y: s
                    }
                });
            }
        }
        Qs(Mx, "ImagePosition"), Qs(Px, "ImageAtlas");
        const zx = 1e20;
        function Bx(t1, e, r, n, i, s, a, o, l) {
            for(let u = e; u < e + n; u++)kx(t1, r * s + u, s, i, a, o, l);
            for(let u = r; u < r + i; u++)kx(t1, u * s + e, 1, n, a, o, l);
        }
        function kx(t1, e, r, n, i, s, a) {
            s[0] = 0, a[0] = -zx, a[1] = zx, i[0] = t1[e];
            for(let o = 1, l = 0, u = 0; o < n; o++){
                i[o] = t1[e + o * r];
                const n = o * o;
                do {
                    const t1 = s[l];
                    u = (i[o] - i[t1] + n - t1 * t1) / (o - t1) / 2;
                }while (u <= a[l] && --l > -1)
                l++, s[l] = o, a[l] = u, a[l + 1] = zx;
            }
            for(let o = 0, l = 0; o < n; o++){
                for(; a[l + 1] < o;)l++;
                const n = s[l], u = o - n;
                t1[e + o * r] = i[n] + u * u;
            }
        }
        const Tx = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class Vx {
            constructor(t1, e, r){
                this.requestManager = t1, this.localGlyphMode = e, this.localFontFamily = r, this.url = "", this.entries = {}, this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t1) {
                this.url = t1;
            }
            getGlyphs(t1, e) {
                const r = [], n = this.url || oe.GLYPHS_URL;
                for(const e in t1)for (const n of t1[e])r.push({
                    stack: e,
                    id: n
                });
                Lt(r, ({ stack: t1, id: e }, r)=>{
                    let i = this.entries[t1];
                    i || (i = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let s = i.glyphs[e];
                    if (void 0 !== s) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    if (s = this._tinySDF(i, t1, e), s) return i.glyphs[e] = s, void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    const a = Math.floor(e / 256);
                    if (256 * a > 65535) return Zt("glyphs > 65535 not supported"), void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    if (i.ranges[a]) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    let o = i.requests[a];
                    o || (o = i.requests[a] = [], Vx.loadGlyphRange(t1, a, n, this.requestManager, (t1, e)=>{
                        if (e) {
                            i.ascender = e.ascender, i.descender = e.descender;
                            for(const t1 in e.glyphs)this._doesCharSupportLocalGlyph(+t1) || (i.glyphs[+t1] = e.glyphs[+t1]);
                            i.ranges[a] = !0;
                        }
                        for (const r of o)r(t1, e);
                        delete i.requests[a];
                    })), o.push((n, i)=>{
                        n ? r(n) : i && r(null, {
                            stack: t1,
                            id: e,
                            glyph: i.glyphs[e] || null
                        });
                    });
                }, (t1, r)=>{
                    if (t1) e(t1);
                    else if (r) {
                        const t1 = {};
                        for (const { stack: e, id: n, glyph: i } of r)void 0 === t1[e] && (t1[e] = {}), void 0 === t1[e].glyphs && (t1[e].glyphs = {}), t1[e].glyphs[n] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics
                        }, t1[e].ascender = this.entries[e].ascender, t1[e].descender = this.entries[e].descender;
                        e(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t1) {
                return this.localGlyphMode !== Tx.none && (this.localGlyphMode === Tx.all ? !!this.localFontFamily : !!this.localFontFamily && (va(t1) || _a(t1) || ca(t1) || ha(t1) || ua(t1) || xa(t1) || (e = t1) >= 131072 && e <= 173791 || ((t1)=>t1 >= 66736 && t1 <= 66815)(t1)));
                //TURBOPACK unreachable
                ;
                var e;
            }
            _tinySDF(t1, e, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r)) return;
                let i = t1.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t1.tinySDF = new Vx.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16
                    }), i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
                const s = String.fromCodePoint(r), { data: a, width: o, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: d } = i.draw(s);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new qh({
                        width: o,
                        height: l
                    }, a),
                    metrics: {
                        width: u / 2,
                        height: c / 2,
                        left: h / 2,
                        top: p / 2 - 27,
                        advance: d / 2,
                        localGlyph: !0
                    }
                };
            }
        }
        function Ex(t1, e) {
            return t1 + e[1] - e[0];
        }
        function Fx(t1, e, r, n, i = 1) {
            const s = [], a = t1.imagePrimary, o = a.pixelRatio, l = a.paddedRect.w - 2, u = a.paddedRect.h - 2, c = (t1.right - t1.left) * i, h = (t1.bottom - t1.top) * i, p = a.stretchX || [
                [
                    0,
                    l
                ]
            ], d = a.stretchY || [
                [
                    0,
                    u
                ]
            ], f = p.reduce(Ex, 0), m = d.reduce(Ex, 0), y = l - f, g = u - m;
            let x = 0, v = f, b = 0, w = m, _ = 0, A = y, I = 0, M = g;
            if (a.content && n) {
                const t1 = a.content;
                x = Cx(p, 0, t1[0]), b = Cx(d, 0, t1[1]), v = Cx(p, t1[0], t1[2]), w = Cx(d, t1[1], t1[3]), _ = t1[0] - x, I = t1[1] - b, A = t1[2] - t1[0] - v, M = t1[3] - t1[1] - w;
            }
            const S = (n, s, l, u)=>{
                const p = Ox(n.stretch - x, v, c, t1.left * i), d = Ux(n.fixed - _, A, n.stretch, f), y = Ox(s.stretch - b, w, h, t1.top * i), g = Ux(s.fixed - I, M, s.stretch, m), S = Ox(l.stretch - x, v, c, t1.left * i), P = Ux(l.fixed - _, A, l.stretch, f), z = Ox(u.stretch - b, w, h, t1.top * i), B = Ux(u.fixed - I, M, u.stretch, m), k = new Mt(p, y), T = new Mt(S, y), V = new Mt(S, z), E = new Mt(p, z), F = new Mt(d / o, g / o), D = new Mt(P / o, B / o), C = e * Math.PI / 180;
                if (C) {
                    const t1 = Math.sin(C), e = Math.cos(C), r = [
                        e,
                        -t1,
                        t1,
                        e
                    ];
                    k._matMult(r), T._matMult(r), E._matMult(r), V._matMult(r);
                }
                const R = n.stretch + n.fixed, L = l.stretch + l.fixed, O = s.stretch + s.fixed, U = u.stretch + u.fixed, N = t1.imageSecondary;
                return {
                    tl: k,
                    tr: T,
                    bl: E,
                    br: V,
                    texPrimary: {
                        x: a.paddedRect.x + 1 + R,
                        y: a.paddedRect.y + 1 + O,
                        w: L - R,
                        h: U - O
                    },
                    texSecondary: N ? {
                        x: N.paddedRect.x + 1 + R,
                        y: N.paddedRect.y + 1 + O,
                        w: L - R,
                        h: U - O
                    } : void 0,
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: F,
                    pixelOffsetBR: D,
                    minFontScaleX: A / o / c,
                    minFontScaleY: M / o / h,
                    isSDF: r
                };
            };
            if (a.stretchX || a.stretchY) {
                const t1 = Rx(p, y, f), e = Rx(d, g, m);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], i = t1[r + 1];
                    for(let t1 = 0; t1 < e.length - 1; t1++)s.push(S(n, e[t1], i, e[t1 + 1]));
                }
            } else s.push(S({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: l + 1
            }, {
                fixed: 0,
                stretch: u + 1
            }));
            return s;
        }
        function Dx(t1, e) {
            const r = t1.stretchY || [
                [
                    0,
                    t1.paddedRect.h - 2
                ]
            ];
            return t1.stretchX || t1.stretchY ? Lx(t1.stretchX || [
                [
                    0,
                    t1.paddedRect.w - 2
                ]
            ]) * Lx(r) : 1;
        }
        function Cx(t1, e, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));
            return n;
        }
        function Rx(t1, e, r) {
            const n = [
                {
                    fixed: -1,
                    stretch: 0
                }
            ];
            for (const [e, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch + (r - e)
                });
            }
            return n.push({
                fixed: e + 1,
                stretch: r
            }), n;
        }
        function Lx(t1) {
            return 2 * t1.length + 1;
        }
        function Ox(t1, e, r, n) {
            return t1 / e * r + n;
        }
        function Ux(t1, e, r, n) {
            return t1 - e * r / n;
        }
        function Nx(t1, e, r, n) {
            const i = e + t1.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e + t1.positionedLines[n - 1].lineOffset)) / 2;
        }
        function jx(t1, e, r, n, i, s, a, o, l) {
            const u = [];
            if (0 === e.positionedLines.length) return u;
            const c = (void 0 !== l ? l : n.layout.get("text-rotate").evaluate(s, {})) * Math.PI / 180, h = function(t1) {
                const e = t1[0], r = t1[1], n = e * r;
                return n > 0 ? [
                    e,
                    -r
                ] : n < 0 ? [
                    -e,
                    r
                ] : 0 === e ? [
                    r,
                    e
                ] : [
                    r,
                    -e
                ];
            }(r);
            let p = Math.abs(e.top - e.bottom);
            for (const t1 of e.positionedLines)p -= t1.lineOffset;
            const d = e.positionedLines.length, f = p / d;
            let m = e.top - r[1];
            for(let t1 = 0; t1 < d; ++t1){
                const n = e.positionedLines[t1];
                m = Nx(e, f, m, t1);
                for (const t1 of n.positionedGlyphs){
                    if (!t1.rect) continue;
                    const n = t1.rect || {};
                    let s = 4, l = !0, p = 1, d = 0;
                    if (t1.image) {
                        const e = a.get(t1.image.toString());
                        if (!e) continue;
                        if (e.sdf) {
                            Zt("SDF images are not supported in formatted text and will be ignored.");
                            continue;
                        }
                        l = !1, p = e.pixelRatio, s = 1 / p;
                    }
                    const f = (i || o) && t1.vertical, y = t1.metrics.advance * t1.scale / 2, g = t1.metrics, x = t1.rect;
                    if (null === x) continue;
                    o && e.verticalizable && (d = t1.image ? y - t1.metrics.width * t1.scale / 2 : 0);
                    const v = i ? [
                        t1.x + y,
                        t1.y
                    ] : [
                        0,
                        0
                    ];
                    let b = [
                        0,
                        0
                    ], w = [
                        0,
                        0
                    ], _ = !1;
                    i || (f ? (w = [
                        t1.x + y + h[0],
                        t1.y + h[1] - d
                    ], _ = !0) : b = [
                        t1.x + y + r[0],
                        t1.y + r[1] - d
                    ]);
                    const A = x.w * t1.scale / (p * (t1.localGlyph ? 2 : 1)), I = x.h * t1.scale / (p * (t1.localGlyph ? 2 : 1));
                    let M, S, P, z;
                    if (f) {
                        const e = t1.y - m, r = new Mt(-y, y - e), n = -Math.PI / 2, i = new Mt(...w);
                        M = new Mt(-y + b[0], b[1]), M._rotateAround(n, r)._add(i), M.x += -e + y, M.y -= (g.left - s) * t1.scale;
                        const a = t1.image ? g.advance * t1.scale : Ig * t1.scale, o = String.fromCodePoint(t1.glyph);
                        Pg(o) ? M.x += (1 - s) * t1.scale : zg(o) ? M.x += a - g.height * t1.scale + (-s - 1) * t1.scale : M.x += t1.image || g.width + 2 * s === x.w && g.height + 2 * s === x.h ? (a - I) / 2 : (a - (g.height + 2 * s) * t1.scale) / 2, S = new Mt(M.x, M.y - A), P = new Mt(M.x + I, M.y), z = new Mt(M.x + I, M.y - A);
                    } else {
                        const e = (g.left - s) * t1.scale - y + b[0], r = (-g.top - s) * t1.scale + b[1], n = e + A, i = r + I;
                        M = new Mt(e, r), S = new Mt(n, r), P = new Mt(e, i), z = new Mt(n, i);
                    }
                    if (c) {
                        let t1;
                        t1 = i ? new Mt(0, 0) : _ ? new Mt(h[0], h[1]) : new Mt(r[0], r[1]), M._rotateAround(c, t1), S._rotateAround(c, t1), P._rotateAround(c, t1), z._rotateAround(c, t1);
                    }
                    const B = new Mt(0, 0), k = new Mt(0, 0);
                    u.push({
                        tl: M,
                        tr: S,
                        bl: P,
                        br: z,
                        texPrimary: n,
                        texSecondary: void 0,
                        writingMode: e.writingMode,
                        glyphOffset: v,
                        sectionIndex: t1.sectionIndex,
                        isSDF: l,
                        pixelOffsetTL: B,
                        pixelOffsetBR: k,
                        minFontScaleX: 0,
                        minFontScaleY: 0
                    });
                }
            }
            return u;
        }
        function Gx(t1, e = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0;
            const o = t1[0];
            for(let t1 = 0; t1 < o.length; t1++){
                const e = o[t1];
                (!t1 || e.x < n) && (n = e.x), (!t1 || e.y < i) && (i = e.y), (!t1 || e.x > s) && (s = e.x), (!t1 || e.y > a) && (a = e.y);
            }
            const l = Math.min(s - n, a - i);
            let u = l / 2;
            const c = new Nn([], $x);
            if (0 === l) return new Mt(n, i);
            for(let e = n; e < s; e += l)for(let r = i; r < a; r += l)c.push(new qx(e + u, r + u, u, t1));
            let h = function(t1) {
                let e = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, s = i.length, a = s - 1; t1 < s; a = t1++){
                    const s = i[t1], o = i[a], l = s.x * o.y - o.x * s.y;
                    r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;
                }
                return new qx(r / e, n / e, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new qx(n.p.x - u, n.p.y - u, u, t1)), c.push(new qx(n.p.x + u, n.p.y - u, u, t1)), c.push(new qx(n.p.x - u, n.p.y + u, u, t1)), c.push(new qx(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function $x(t1, e) {
            return e.max - t1.max;
        }
        Vx.loadGlyphRange = function(t1, e, r, n, i) {
            const s = 256 * e, a = s + 255, o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t1).replace("{range}", `${s}-${a}`), Ce.Glyphs);
            Ue(o, (t1, e)=>{
                if (t1) i(t1);
                else if (e) {
                    const t1 = {}, r = function(t1) {
                        return new Vg(t1).readFields($g, {});
                    }(e);
                    for (const e of r.glyphs)t1[e.id] = e;
                    i(null, {
                        glyphs: t1,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            });
        }, Vx.TinySDF = class {
            constructor({ fontSize: t1 = 24, buffer: e = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: s = "normal", fontStyle: a = "normal", lang: o = null } = {}){
                this.buffer = e, this.cutoff = n, this.radius = r, this.lang = o;
                const l = this.size = t1 + 4 * e, u = this._createCanvas(l), c = this.ctx = u.getContext("2d", {
                    willReadFrequently: !0
                });
                c.font = `${a} ${s} ${t1}px ${i}`, c.textBaseline = "alphabetic", c.textAlign = "left", c.fillStyle = "black", this.gridOuter = new Float64Array(l * l), this.gridInner = new Float64Array(l * l), this.f = new Float64Array(l), this.z = new Float64Array(l + 1), this.v = new Uint16Array(l);
            }
            _createCanvas(t1) {
                const e = document.createElement("canvas");
                return e.width = e.height = t1, e;
            }
            draw(t1) {
                const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: s } = this.ctx.measureText(t1), a = Math.ceil(r), o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))), l = Math.min(this.size - this.buffer, a + Math.ceil(n)), u = o + 2 * this.buffer, c = l + 2 * this.buffer, h = Math.max(u * c, 0), p = new Uint8ClampedArray(h), d = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: o,
                    glyphHeight: l,
                    glyphTop: a,
                    glyphLeft: 0,
                    glyphAdvance: e
                };
                if (0 === o || 0 === l) return d;
                const { ctx: f, buffer: m, gridInner: y, gridOuter: g } = this;
                this.lang && (f.lang = this.lang), f.clearRect(m, m, o, l), f.fillText(t1, m, m + a);
                const x = f.getImageData(m, m, o, l);
                g.fill(zx, 0, h), y.fill(0, 0, h);
                for(let t1 = 0; t1 < l; t1++)for(let e = 0; e < o; e++){
                    const r = x.data[4 * (t1 * o + e) + 3] / 255;
                    if (0 === r) continue;
                    const n = (t1 + m) * u + e + m;
                    if (1 === r) g[n] = 0, y[n] = zx;
                    else {
                        const t1 = .5 - r;
                        g[n] = t1 > 0 ? t1 * t1 : 0, y[n] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                Bx(g, 0, 0, u, c, u, this.f, this.v, this.z), Bx(y, m, m, o, l, u, this.f, this.v, this.z);
                for(let t1 = 0; t1 < h; t1++){
                    const e = Math.sqrt(g[t1]) - Math.sqrt(y[t1]);
                    p[t1] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
                }
                return d;
            }
        };
        class qx {
            constructor(t1, e, r, n){
                this.p = new Mt(t1, e), this.h = r, this.d = function(t1, e) {
                    let r = !1, n = 1 / 0;
                    for(let i = 0; i < e.length; i++){
                        const s = e[i];
                        for(let e = 0, i = s.length, a = i - 1; e < i; a = e++){
                            const i = s[e], o = s[a];
                            i.y > t1.y != o.y > t1.y && t1.x < (o.x - i.x) * (t1.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Cc(t1, i, o));
                        }
                    }
                    return (r ? 1 : -1) * Math.sqrt(n);
                }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
            }
        }
        const Xx = Object.keys, Hx = Number.POSITIVE_INFINITY, Zx = Math.sqrt(2);
        function Wx(t1, e, r, n, i) {
            const s = ax(t1) && t1.collisionPadding ? t1.collisionPadding : [
                0,
                0,
                0,
                0
            ], a = {
                top: t1.top - s[1],
                bottom: t1.bottom + s[3],
                left: t1.left - s[0],
                right: t1.right + s[2],
                scaled: !1
            };
            return void 0 !== n && function(t1, e) {
                t1.top *= e, t1.bottom *= e, t1.left *= e, t1.right *= e, t1.scaled = !0;
            }(a, n), r && function(t1, e) {
                if (!e) return;
                const r = Bt(e), n = new Mt(t1.left, t1.top), i = new Mt(t1.right, t1.top), s = new Mt(t1.left, t1.bottom), a = new Mt(t1.right, t1.bottom), o = new Mt(0, 0);
                n._rotateAround(r, o), i._rotateAround(r, o), s._rotateAround(r, o), a._rotateAround(r, o), t1.left = Math.min(n.x, i.x, s.x, a.x), t1.right = Math.max(n.x, i.x, s.x, a.x), t1.top = Math.min(n.y, i.y, s.y, a.y), t1.bottom = Math.max(n.y, i.y, s.y, a.y);
            }(a, r), i && (a.left += i[0], a.right += i[0], a.top += i[1], a.bottom += i[1]), e ? {
                top: Math.min(e.top, a.top),
                bottom: Math.max(e.bottom, a.bottom),
                left: Math.min(e.left, a.left),
                right: Math.max(e.right, a.right),
                scaled: e.scaled || a.scaled
            } : a;
        }
        function Yx(t1, [e, r]) {
            let n = 0, i = 0;
            if (r === Hx) {
                e < 0 && (e = 0);
                const r = e / Zx;
                switch(t1){
                    case "top-right":
                    case "top-left":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i = 7 - r;
                        break;
                    case "bottom":
                        i = 7 - e;
                        break;
                    case "top":
                        i = e - 7;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        n = -r;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n = r;
                        break;
                    case "left":
                        n = e;
                        break;
                    case "right":
                        n = -e;
                }
            } else {
                switch(e = Math.abs(e), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = 7 - r;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e;
                }
            }
            return [
                n,
                i
            ];
        }
        function Jx(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f) {
            const m = t1.layers[0], y = m.appearances;
            if (0 === y.length) return {
                iconBBox: null,
                iconVerticalBBox: null,
                textBBox: null,
                textVerticalBBox: null
            };
            const g = {
                iconBBox: null,
                iconVerticalBBox: null
            }, x = {
                textBBox: null,
                textVerticalBBox: null
            }, { baseIconRotate: v, baseTextRotate: b, iconScaleFactor: w } = function(t1, e, r) {
                const n = t1.get("icon-rotate").evaluate(e, {}, r), i = t1.get("text-rotate").evaluate(e, {}, r), [s, a] = t1.get("icon-size-scale-range");
                return {
                    baseIconRotate: n,
                    baseTextRotate: i,
                    iconScaleFactor: Dt(1, s, a)
                };
            }(n, i, s);
            e && (g.iconBBox = Wx(e, g.iconBBox, v, a), r) && (g.iconVerticalBBox = Wx(r, g.iconVerticalBBox, v + 90, a));
            const _ = gv(h.horizontal);
            _ && (x.textBBox = Wx(_, x.textBBox, b, 1, d)), h.vertical && (x.textVerticalBBox = Wx(h.vertical, x.textVerticalBBox, b + 90, 1, d));
            for (const r of y)r.hasIconProperties() && Kx(g, t1, m, r, i, s, o, v, a, l, e, u, w, c, f), r.hasTextProperties() && tv(x, m, r, i, s, d, b, p, _, h.vertical);
            return {
                iconBBox: g.iconBBox,
                iconVerticalBBox: g.iconVerticalBBox,
                textBBox: x.textBBox,
                textVerticalBBox: x.textVerticalBBox
            };
        }
        function Kx(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f) {
            const { appearanceIconOffset: m, appearanceIconRotate: y, appearanceIconSize: g } = Qx(n, r, i, s, a, o, l, u.iconScaleFactor);
            let x = null, v = null, b = null;
            n.hasProperty("icon-image") ? b = function(t1, e, r, n, i, s, a, o) {
                let l = null;
                const u = e.getAppearanceValueAndResolveTokens(r, "icon-image", n, i, o);
                if (u) {
                    const e = t1.getResolvedImageFromTokens(u), c = r.getUnevaluatedProperty("icon-size"), h = iv(e, dx(t1.zoom, c, t1.worldview, o), c, i, t1.zoom, n, t1.pixelRatio, a, t1.worldview, o);
                    l = s.get(h.iconPrimary.toString());
                }
                return l;
            }(e, r, n, i, s, h, p, f) : c && (b = c.imagePrimary), b && (x = ox(b, null, m, d), e.allowVerticalPlacement && (v = ox(b, null, m, d))), x && (t1.iconBBox = Wx(x, t1.iconBBox, y, g)), v && (t1.iconVerticalBBox = Wx(v, t1.iconVerticalBBox, y + 90, g));
        }
        function Qx(t1, e, r, n, i, s, a, o) {
            const l = t1.hasProperty("icon-offset") ? e.getAppearanceValueAndResolveTokens(t1, "icon-offset", r, n, []) : null, u = l && Array.isArray(l) ? l : i, c = t1.hasProperty("icon-rotate") ? e.getAppearanceValueAndResolveTokens(t1, "icon-rotate", r, n, []) : null, h = "number" == typeof c ? c : s, p = t1.hasProperty("icon-size") ? e.getAppearanceValueAndResolveTokens(t1, "icon-size", r, n, []) : null;
            return {
                appearanceIconOffset: u,
                appearanceIconRotate: h,
                appearanceIconSize: "number" == typeof p ? p * o : a
            };
        }
        function tv(t1, e, r, n, i, s, a, o, l, u) {
            const { appearanceTextOffset: c, appearanceTextRotate: h, appearanceTextSize: p } = ev(r, e, n, i, s, a, o), d = p / o;
            l && (t1.textBBox = Wx(l, t1.textBBox, h, d, c)), u && (t1.textVerticalBBox = Wx(u, t1.textVerticalBBox, h + 90, d, c));
        }
        function ev(t1, e, r, n, i, s, a) {
            const o = t1.hasProperty("text-offset") ? e.getAppearanceValueAndResolveTokens(t1, "text-offset", r, n, []) : null, l = o && Array.isArray(o) ? [
                o[0] * Ig,
                o[1] * Ig
            ] : i, u = t1.hasProperty("text-rotate") ? e.getAppearanceValueAndResolveTokens(t1, "text-rotate", r, n, []) : null, c = "number" == typeof u ? u : s, h = t1.hasProperty("text-size") ? e.getAppearanceValueAndResolveTokens(t1, "text-size", r, n, []) : null;
            return {
                appearanceTextOffset: l,
                appearanceTextRotate: c,
                appearanceTextSize: "number" == typeof h ? h : a
            };
        }
        function rv(t1, e, r, n, i, s, a, o, l) {
            if (!e || !e.usvg) return;
            const u = hx(n), c = hx(i), h = "both" !== s && "width" !== s || !ux(n) ? 1 : c.width / u.width, p = "both" !== s && "height" !== s || !cx(n) ? 1 : c.height / u.height;
            r.scaleSelf(h, p);
            const d = r.toString();
            a.set(d, r), o.set(d, e);
            const { imagePosition: f } = Sx(d, e, 1);
            l.set(d, f);
        }
        function nv(t1, e, r, n, i, s, a, o, l, u) {
            if (!t1) return;
            const c = function(t1, e, r, n, i, s, a) {
                if ("camera" === t1.kind) return t1.maxSize;
                if ("composite" === t1.kind) {
                    const n = e.possiblyEvaluate(new Ja(t1.maxZoom, {
                        worldview: s
                    }), r, a).evaluate(i, {}, r, a), o = e.possiblyEvaluate(new Ja(t1.minZoom, {
                        worldview: s
                    }), r, a).evaluate(i, {}, r, a);
                    return Math.max(n, o);
                }
                return e.possiblyEvaluate(new Ja(n, {
                    worldview: s
                }), r, a).evaluate(i, {}, r, a);
            }(e, r, n, i, s, l, u);
            return t1.scaleSelf(c * o * a);
        }
        function iv(t1, e, r, n, i, s, a, o, l, u) {
            return {
                iconPrimary: nv(t1.getPrimary(), e, r, n, i, s, a, o, l, u),
                iconSecondary: nv(t1.getSecondary(), e, r, n, i, s, a, o, l, u)
            };
        }
        function sv(t1, e, r) {
            if (!e) return;
            const n = r.get(t1.toString()), i = r.get(e.toString());
            n && i && (n.paddedRect.w === i.paddedRect.w && n.paddedRect.h === i.paddedRect.h || Zt(`Mismatch in icon variant sizes: ${t1.toString()} and ${e.toString()}`), n.usvg !== i.usvg && Zt(`Mismatch in icon variant image types: ${t1.id} and ${e.id}`));
        }
        function av(t1, e, r, n) {
            if (!t1) return;
            const i = e.get(r.toString());
            if (t1.imagePrimary = i, n) {
                const r = e.get(n.toString());
                t1.imageSecondary = r;
            }
        }
        function ov(t1, e) {
            for(const r in t1.horizontal)lv(t1.horizontal[r], e);
            lv(t1.vertical, e);
        }
        function lv(t1, e) {
            if (t1) {
                for (const r of t1.positionedLines)for (const t1 of r.positionedGlyphs)if (null !== t1.image) {
                    const r = t1.image.toString();
                    t1.rect = e.get(r).paddedRect;
                }
            }
        }
        function uv(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function cv(t1, e, r, n, i, s, a, o, l) {
            const u = gv(s.horizontal) || s.vertical, c = r.get("icon-text-fit-padding").evaluate(n, {}, i);
            let h, p = e;
            return e && "none" !== l && (t1.allowVerticalPlacement && s.vertical && (h = lx(e, s.vertical, l, c, o, a)), u && (p = lx(e, u, l, c, o, a))), {
                defaultShapedIcon: p,
                verticallyShapedIcon: h
            };
        }
        function hv(t1, e) {
            return t1 * e / 24;
        }
        function pv(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A) {
            let I = a.textMaxSize.evaluate(e, {}, p);
            void 0 === I ? I = o * a.textScaleFactor : I *= a.textScaleFactor;
            const M = t1.layers[0].layout, S = hv(o, a.textScaleFactor), P = gv(r.horizontal) || r.vertical, z = t1.hasAnyAppearanceProperty([
                "text-size",
                "text-offset",
                "text-rotate"
            ]);
            if (("none" !== y || z) && t1.appearanceFeatureData && t1.featureToAppearanceIndex[e.index] < t1.appearanceFeatureData.length) {
                const r = t1.appearanceFeatureData[t1.featureToAppearanceIndex[e.index]];
                r && (r.textShaping = P, r.iconTextFitPadding = M.get("icon-text-fit-padding").evaluate(e, {}, p), r.fontScale = S, r.textScaleFactor = a.textScaleFactor);
            }
            const B = "globe" === d.name, k = t1.tilePixelRatio * I / 24, T = (R = t1.overscaling, t1.zoom > 18 && R > 2 && (R >>= 1), Math.max(jn / (512 * R), 1) * M.get("symbol-spacing")), V = M.get("text-padding") * t1.tilePixelRatio, E = M.get("icon-padding") * t1.tilePixelRatio, F = Bt(M.get("text-max-angle")), D = "map" === M.get("icon-rotation-alignment") && "point" !== v, C = T / 2;
            var R;
            !1 === t1.hasAnyIconTextFit && "none" !== y && (t1.hasAnyIconTextFit = !0);
            const L = e.properties ? +e.properties[ac] : null, O = L && t1.elevationFeatureIdToIndex ? t1.elevationFeatureIdToIndex.get(L) : 65535, U = (o, l, v)=>{
                if (l.x < 0 || l.x >= jn || l.y < 0 || l.y >= jn) return;
                let A = null;
                if (B) {
                    const { x: t1, y: e, z: r } = d.projectTilePoint(l.x, l.y, v);
                    A = {
                        anchor: new yx(t1, e, r, 0, void 0),
                        up: d.upVector(v, l.x, l.y)
                    };
                }
                !function(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, I, M, S, P, z, B, k, T) {
                    const V = t1.addToLineVertexArray(e, n);
                    let E, F, D, C, R, L, O, U = 0, N = 0, j = 0, G = 0, $ = -1, q = -1;
                    const X = {};
                    let H = Qe("");
                    const Z = r ? r.anchor : e, W = "none" !== P;
                    let Y = 0, J = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset")) {
                        const t1 = l.layout.get("text-offset").evaluate(b, {}, I);
                        Y = t1[0] * Ig, J = t1[1] * Ig;
                    } else Y = l.layout.get("text-radial-offset").evaluate(b, {}, I) * Ig, J = Hx;
                    if (t1.allowVerticalPlacement && i.vertical) {
                        const t1 = i.vertical;
                        if (f) L = vv(t1), o && (O = vv(o));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, I) + 90;
                            D = xv(u, Z, e, c, h, p, t1, d, r, m, T), o && (C = xv(u, Z, e, c, h, p, o, g, r, null, k));
                        }
                    }
                    if (s) {
                        const n = l.layout.get("icon-rotate").evaluate(b, {}, I), i = Fx(s, n, _, W, w.iconScaleFactor), a = o ? Fx(o, n, _, W, w.iconScaleFactor) : void 0;
                        F = xv(u, Z, e, c, h, p, s, g, n, null, B);
                        const d = function(t1, e, r, n, i, s, a, o, l) {
                            const u = t1.layers[0], c = u.appearances;
                            let h = e.length;
                            if (r && (h = Math.max(h, r.length)), 0 === c.length) return h;
                            const [p, d] = n.get("icon-size-scale-range"), f = Dt(1, p, d);
                            for (const e of c){
                                const r = e.getUnevaluatedProperties();
                                if (void 0 !== r._values["icon-image"].value) {
                                    const n = u.getAppearanceValueAndResolveTokens(e, "icon-image", i, s, l);
                                    if (n) {
                                        const e = t1.getResolvedImageFromTokens(n);
                                        if (e) {
                                            const n = r._values["icon-size"], o = iv(e, dx(t1.zoom, n, t1.worldview, l), n, s, t1.zoom, i, t1.pixelRatio, f, t1.worldview, l), u = a.get(o.iconPrimary.toString());
                                            h = Math.max(h, Dx(u));
                                        }
                                    }
                                }
                            }
                            return h;
                        }(t1, i, a, l.layout, b, I, t1.iconAtlasPositions, 0, A);
                        U = 4 * d;
                        const f = l.layout.get("icon-size").evaluate(b, {}, I, A), m = w.compositeIconSizes ? w.compositeIconSizes[0].evaluate(b, {}, I, A) : 0, y = w.compositeIconSizes ? w.compositeIconSizes[1].evaluate(b, {}, I, A) : 0, P = yv(t1.layerIds[0], t1.iconSizeData, f, w.iconScaleFactor, m, y);
                        t1.addSymbols(t1.icon, i, P, v, x, b, void 0, r, e, V.lineStartIndex, V.lineLength, -1, A, I, M, S, t1.symbolInstances.length, d), $ = t1.icon.placedSymbolArray.length - 1, a && (N = 4 * d, t1.addSymbols(t1.icon, a, P, v, x, b, Hg.vertical, r, e, V.lineStartIndex, V.lineLength, -1, A, I, M, S, t1.symbolInstances.length, d), q = t1.icon.placedSymbolArray.length - 1);
                    }
                    for(const n in i.horizontal){
                        const s = n, o = i.horizontal[s];
                        E || (H = Qe(o.text), f ? R = vv(o) : E = xv(u, Z, e, c, h, p, o, d, l.layout.get("text-rotate").evaluate(b, {}, I), m, T));
                        const y = 1 === o.positionedLines.length;
                        if (j += mv(t1, r, e, o, a, l, f, b, m, V, i.vertical ? Hg.horizontal : Hg.horizontalOnly, y ? Xx(i.horizontal) : [
                            s
                        ], X, $, w, A, I, t1.symbolInstances.length, M), y) break;
                    }
                    i.vertical && (G += mv(t1, r, e, i.vertical, a, l, f, b, m, V, Hg.vertical, [
                        "vertical"
                    ], X, q, w, A, I, t1.symbolInstances.length, M));
                    let K = -1;
                    const Q = (t1, e)=>t1 ? Math.max(t1, e) : e;
                    K = Q(R, K), K = Q(L, K), K = Q(O, K);
                    const tt = K > -1 ? 1 : 0;
                    t1.glyphOffsetArray.length >= 65535 && Zt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t1.addToSortKeyRanges(t1.symbolInstances.length, b.sortKey), t1.symbolInstances.emplaceBack(e.x, e.y, Z.x, Z.y, Z.z, X.right >= 0 ? X.right : -1, X.center >= 0 ? X.center : -1, X.left >= 0 ? X.left : -1, X.vertical >= 0 ? X.vertical : -1, $, q, H, void 0 !== E ? E : t1.collisionBoxArray.length, void 0 !== E ? E + 1 : t1.collisionBoxArray.length, void 0 !== D ? D : t1.collisionBoxArray.length, void 0 !== D ? D + 1 : t1.collisionBoxArray.length, void 0 !== F ? F : t1.collisionBoxArray.length, void 0 !== F ? F + 1 : t1.collisionBoxArray.length, C || t1.collisionBoxArray.length, C ? C + 1 : t1.collisionBoxArray.length, c, j, G, U, N, tt, 0, Y, J, K, 0, W ? 1 : 0, z);
                }(t1, l, A, o, r, n, s, i, t1.layers[0], t1.collisionBoxArray, e.index, e.sourceLayerIndex, t1.index, V, x, u, 0, E, D, g, e, a, c, h, p, f, m, y, O, b, w, _);
            };
            if ("line" === v) for (const i of Ef(e.geometry, 0, 0, jn, jn)){
                const e = _x(i, T, F, r.vertical || P, n, 24, k, t1.overscaling, jn);
                for (const r of e)P && bv(t1, P.text, C, r) || U(i, r, p);
            }
            else if ("line-center" === v) {
                for (const t1 of e.geometry)if (t1.length > 1) {
                    const e = wx(t1, F, r.vertical || P, n, 24, k);
                    e && U(t1, e, p);
                }
            } else if ("Polygon" === e.type) for (const t1 of Mp(e.geometry, 0)){
                const e = Gx(t1, 16);
                U(t1[0], new yx(e.x, e.y, 0, 0, void 0), p);
            }
            else if ("LineString" === e.type) for (const t1 of e.geometry)U(t1, new yx(t1[0].x, t1[0].y, 0, 0, void 0), p);
            else if ("Point" === e.type) for (const t1 of e.geometry)for (const e of t1)U([
                e
            ], new yx(e.x, e.y, 0, 0, void 0), p);
        }
        const dv = 255, fv = dv * px;
        function mv(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g, x) {
            const v = jx(0, n, l, s, a, o, i, t1.allowVerticalPlacement, void 0), b = s.layout.get("text-size").evaluate(o, {}, y), w = f.compositeTextSizes ? f.compositeTextSizes[0].evaluate(o, {}, y) : 0, _ = f.compositeTextSizes ? f.compositeTextSizes[1].evaluate(o, {}, y) : 0, A = yv(t1.layerIds[0], t1.textSizeData, b, f.textScaleFactor, w, _);
            t1.addSymbols(t1.text, v, A, l, a, o, c, e, r, u.lineStartIndex, u.lineLength, d, m, y, x, !1, g, v.length);
            for (const e of h)p[e] = t1.text.placedSymbolArray.length - 1;
            return 4 * v.length;
        }
        function yv(t1, e, r, n, i, s) {
            const a = e;
            let o = null;
            return "source" === a.kind ? (o = [
                px * r * n
            ], o[0] > fv && Zt(`${t1}: Value for "text-size" is >= ${dv}. Reduce your "text-size".`)) : "composite" === a.kind && (o = [
                px * i * n,
                px * s * n
            ], (o[0] > fv || o[1] > fv) && Zt(`${t1}: Value for "text-size" is >= ${dv}. Reduce your "text-size".`)), o;
        }
        function gv(t1) {
            for(const e in t1)return t1[e];
            return null;
        }
        function xv(t1, e, r, n, i, s, a, o, l, u, c) {
            let h, p, d, f;
            if (h = c ? c.top : a.top, p = c ? c.bottom : a.bottom, d = c ? c.left : a.left, f = c ? c.right : a.right, ax(a) && a.collisionPadding) {
                const t1 = a.collisionPadding;
                d -= t1[0], h -= t1[1], f += t1[2], p += t1[3];
            }
            if (l) {
                const t1 = new Mt(d, h), e = new Mt(f, h), r = new Mt(d, p), n = new Mt(f, p), i = Bt(l);
                let s = new Mt(0, 0);
                u && (s = new Mt(u[0], u[1])), t1._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), d = Math.min(t1.x, e.x, r.x, n.x), f = Math.max(t1.x, e.x, r.x, n.x), h = Math.min(t1.y, e.y, r.y, n.y), p = Math.max(t1.y, e.y, r.y, n.y);
            }
            return t1.emplaceBack(e.x, e.y, e.z, r.x, r.y, d, h, f, p, o, n, i, s), t1.length - 1;
        }
        function vv(t1) {
            ax(t1) && t1.collisionPadding && (t1.top -= t1.collisionPadding[1], t1.bottom += t1.collisionPadding[3]);
            const e = t1.bottom - t1.top;
            return e > 0 ? Math.max(10, e) : null;
        }
        function bv(t1, e, r, n) {
            const i = t1.compareText;
            if (e in i) {
                const t1 = i[e];
                for(let e = t1.length - 1; e >= 0; e--)if (n.dist(t1[e]) < r) return !0;
            } else i[e] = [];
            return i[e].push(n), !1;
        }
        function wv(t1, e) {
            const r = t1.fovAboveCenter, n = t1.elevation ? t1.elevation.getMinElevationBelowMSL() * e : 0, i = (t1._camera.position[2] * t1.worldSize - n) / Math.cos(t1._pitch), s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t1._pitch - r, .01));
            let a = Math.sin(t1._pitch) * s + i;
            const o = i * (1 / t1._horizonShift);
            if (!t1.elevation || 0 === t1.elevation.exaggeration()) {
                let e = Math.max(t1.zoom - 17, 0);
                t1.isOrthographic && (e /= 10), a *= 1 + e;
            }
            return Math.min(1.01 * a, o);
        }
        function _v(t1, e) {
            if (!e.isReprojectedInTileSpace) return {
                scale: 1 << t1.z,
                x: t1.x,
                y: t1.y,
                x2: t1.x + 1,
                y2: t1.y + 1,
                projection: e
            };
            const r = Math.pow(2, -t1.z), n = t1.x * r, i = (t1.x + 1) * r, s = t1.y * r, a = (t1.y + 1) * r, o = Du(n), l = Du(i), u = Cu(s), c = Cu(a), h = e.project(o, u), p = e.project(l, u), d = e.project(l, c), f = e.project(o, c);
            let m = Math.min(h.x, p.x, d.x, f.x), y = Math.min(h.y, p.y, d.y, f.y), g = Math.max(h.x, p.x, d.x, f.x), x = Math.max(h.y, p.y, d.y, f.y);
            const v = r / 16;
            function b(t1, r, n, i, s, a) {
                const o = (n + s) / 2, l = (i + a) / 2, u = e.project(Du(o), Cu(l)), c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);
                m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > v && (b(t1, u, n, i, o, l), b(u, r, o, l, s, a));
            }
            b(h, p, n, s, i, s), b(p, d, i, s, i, a), b(d, f, i, a, n, a), b(f, h, n, a, n, s), m -= v, y -= v, g += v, x += v;
            const w = 1 / Math.max(g - m, x - y);
            return {
                scale: w,
                x: m * w,
                y: y * w,
                x2: g * w,
                y2: x * w,
                projection: e
            };
        }
        function Av(t1, { x: e, y: r }, n = 0) {
            return new Mt(((e - n) * t1.scale - t1.x) * jn, (r * t1.scale - t1.y) * jn);
        }
        const Iv = u(new Float32Array(16));
        class Mv {
            constructor(t1){
                this.spec = t1, this.name = t1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t1, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t1, e) {
                return new Bu(0, 0);
            }
            projectTilePoint(t1, e, r) {
                return {
                    x: t1,
                    y: e,
                    z: 0
                };
            }
            locationPoint(t1, e, r, n = !0) {
                return t1._coordinatePoint(t1.locationCoordinate(e, r), n);
            }
            pixelsPerMeter(t1, e) {
                return Fu(1, t1) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                return 1;
            }
            farthestPixelDistance(t1) {
                return wv(t1, t1.pixelsPerMeter);
            }
            pointCoordinate(t1, e, r, n) {
                const i = t1.horizonLineFromTop(!1), s = new Mt(e, Math.max(i, r));
                return t1.rayIntersectionCoordinate(t1.pointRayIntersection(s, n));
            }
            pointCoordinate3D(t1, e, r) {
                const n = new Mt(e, r);
                if (t1.elevation) return t1.elevation.pointCoordinate(n);
                {
                    const e = this.pointCoordinate(t1, n.x, n.y, 0);
                    return [
                        e.x,
                        e.y,
                        e.z
                    ];
                }
            }
            isPointAboveHorizon(t1, e) {
                if (t1.elevation && t1.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t1, e.x, e.y);
                const r = t1.horizonLineFromTop();
                return e.y < r;
            }
            createInversionMatrix(t1, e) {
                return Iv;
            }
            createTileMatrix(t1, e, r) {
                let n, i, s;
                const a = r.canonical, o = u(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l = _v(a, this);
                    n = 1, i = l.x + r.wrap * l.scale, s = l.y, d(o, o, [
                        n / l.scale,
                        n / l.scale,
                        t1.pixelsPerMeter / e
                    ]);
                } else n = e / t1.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;
                return p(o, o, [
                    i,
                    s,
                    0
                ]), d(o, o, [
                    n / jn,
                    n / jn,
                    1
                ]), o;
            }
            upVector(t1, e, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t1, e, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class Sv extends Mv {
            constructor(t1){
                super(t1), this.range = [
                    4,
                    7
                ], this.center = t1.center || [
                    -96,
                    37.5
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    29.5,
                    45.5
                ], n = Math.sin(Bt(e));
                this.n = (n + Math.sin(Bt(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t1, e) {
                const { n: r, c: n, r0: i } = this, s = Bt(t1 - this.center[0]), a = Bt(e), o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
                return {
                    x: o * Math.sin(s * r),
                    y: o * Math.cos(s * r) - i,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { n: r, c: n, r0: i } = this, s = i + e;
                let a = Math.atan2(t1, Math.abs(s)) * Math.sign(s);
                s * r < 0 && (a -= Math.PI * Math.sign(t1) * Math.sign(s));
                const o = Bt(this.center[0]) * r;
                a = Rt(a, -Math.PI - o, Math.PI - o);
                const l = Dt(kt(a / r) + this.center[0], -180, 180), u = Math.asin(Dt((n - (t1 * t1 + s * s) * r * r) / (2 * r), -1, 1)), c = Dt(kt(u), -85.051129, Lu);
                return new Bu(l, c);
            }
        }
        const Pv = 1.340264, zv = -.081106, Bv = 893e-6, kv = .003796, Tv = Math.sqrt(3) / 2;
        class Vv extends Mv {
            project(t1, e) {
                e = e / 180 * Math.PI, t1 = t1 / 180 * Math.PI;
                const r = Math.asin(Tv * Math.sin(e)), n = r * r, i = n * n * n;
                return {
                    x: .5 * (t1 * Math.cos(r) / (Tv * (Pv + 3 * zv * n + i * (7 * Bv + 9 * kv * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (Pv + zv * n + i * (Bv + kv * n)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = r * r, i = n * n * n;
                for(let t1, s, a, o = 0; o < 12 && (s = r * (Pv + zv * n + i * (Bv + kv * n)) - e, a = Pv + 3 * zv * n + i * (7 * Bv + 9 * kv * n), t1 = s / a, r = Dt(r - t1, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t1) < 1e-12)); ++o);
                const s = Tv * t1 * (Pv + 3 * zv * n + i * (7 * Bv + 9 * kv * n)) / Math.cos(r), a = Math.asin(Math.sin(r) / Tv), o = Dt(180 * s / Math.PI, -180, 180), l = Dt(180 * a / Math.PI, -85.051129, Lu);
                return new Bu(o, l);
            }
        }
        class Ev extends Mv {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                return {
                    x: .5 + t1 / 360,
                    y: .5 - e / 360,
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = 360 * (t1 - .5), n = Dt(360 * (.5 - e), -85.051129, Lu);
                return new Bu(r, n);
            }
        }
        const Fv = Math.PI / 2;
        function Dv(t1) {
            return Math.tan((Fv + t1) / 2);
        }
        class Cv extends Mv {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    30
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    30,
                    30
                ];
                let n = Bt(e), i = Bt(r);
                this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
                const s = Math.cos(n), a = Dv(n);
                this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Dv(i) / a), this.f = s * Math.pow(Dv(n), this.n) / this.n;
            }
            project(t1, e) {
                e = Bt(e), this.southernCenter && (e = -e), t1 = Bt(t1 - this.center[0]);
                const r = 1e-6, { n, f: i } = this;
                i > 0 ? e < -Fv + r && (e = -Fv + r) : e > Fv - r && (e = Fv - r);
                const s = i / Math.pow(Dv(e), n);
                let a = s * Math.sin(n * t1), o = i - s * Math.cos(n * t1);
                return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {
                    x: a,
                    y: this.southernCenter ? o : 1 - o,
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;
                const { n: r, f: n } = this, i = n - e, s = Math.sign(i), a = Math.sign(r) * Math.sqrt(t1 * t1 + i * i);
                let o = Math.atan2(t1, Math.abs(i)) * s;
                i * r < 0 && (o -= Math.PI * Math.sign(t1) * s);
                const l = Dt(kt(o / r) + this.center[0], -180, 180), u = Dt(kt(2 * Math.atan(Math.pow(n / a, 1 / r)) - Fv), -85.051129, Lu);
                return new Bu(l, this.southernCenter ? -u : u);
            }
        }
        class Rv extends Mv {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t1, e) {
                return {
                    x: Vu(t1),
                    y: Eu(e),
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = Du(t1), n = Cu(e);
                return new Bu(r, n);
            }
        }
        const Lv = Bt(Lu);
        class Ov extends Mv {
            project(t1, e) {
                const r = (e = Bt(e)) * e, n = r * r;
                return {
                    x: .5 * ((t1 = Bt(t1)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = 25, i = 0, s = r * r;
                do {
                    s = r * r;
                    const t1 = s * s;
                    i = (r * (1.007226 + s * (.015085 + t1 * (.028874 * s - .044475 - .005916 * t1))) - e) / (1.007226 + s * (.045255 + t1 * (.259866 * s - .311325 - .005916 * 11 * t1))), r = Dt(r - i, -Lv, Lv);
                }while (Math.abs(i) > 1e-6 && --n > 0)
                s = r * r;
                const a = Dt(kt(t1 / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180), o = kt(r);
                return new Bu(a, o);
            }
        }
        const Uv = Bt(Lu);
        class Nv extends Mv {
            project(t1, e) {
                e = Bt(e), t1 = Bt(t1);
                const r = Math.cos(e), n = 2 / Math.PI, i = Math.acos(r * Math.cos(t1 / 2)), s = Math.sin(i) / i, a = .5 * (t1 * n + 2 * r * Math.sin(t1 / 2) / s) || 0, o = .5 * (e + Math.sin(e) / s) || 0;
                return {
                    x: .5 * (a / Math.PI + .5),
                    y: 1 - .5 * (o / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                let r = t1 = (2 * t1 - .5) * Math.PI, n = e = (2 * (1 - e) - 1) * Math.PI, i = 25;
                const s = 1e-6;
                let a = 0, o = 0;
                do {
                    const i = Math.cos(n), s = Math.sin(n), l = 2 * s * i, u = s * s, c = i * i, h = Math.cos(r / 2), p = Math.sin(r / 2), d = 2 * h * p, f = p * p, m = 1 - c * h * h, y = m ? 1 / m : 0, g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0, x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t1, v = .5 * (g * s + n) - e, b = .5 * y * (c * f + g * i * h * u) + 1 / Math.PI, w = y * (d * l / 4 - g * s * p), _ = .125 * y * (l * p - g * s * c * d), A = .5 * y * (u * h + g * f * i) + .5, I = w * _ - A * b;
                    a = (v * w - x * A) / I, o = (x * _ - v * b) / I, r = Dt(r - a, -Math.PI, Math.PI), n = Dt(n - o, -Uv, Uv);
                }while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0)
                return new Bu(kt(r), kt(n));
            }
        }
        class jv extends Mv {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    0
                ], this.parallels = t1.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(.01, Math.cos(Bt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                const { scale: r, cosPhi: n } = this;
                return {
                    x: Bt(t1) * n * r + .5,
                    y: -Math.sin(Bt(e)) / n * r + .5,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { scale: r, cosPhi: n } = this, i = -(e - .5) / r, s = Dt(kt((t1 - .5) / r) / n, -180, 180), a = Math.asin(Dt(i * n, -1, 1)), o = Dt(kt(a), -85.051129, Lu);
                return new Bu(s, o);
            }
        }
        class Gv extends Rv {
            constructor(t1){
                super(t1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(t1, e, r) {
                const n = yh(t1, e, r);
                return j(n, n, vh(ch(r))), {
                    x: n[0],
                    y: n[1],
                    z: n[2]
                };
            }
            locationPoint(t1, e, r) {
                const n = Su(e.lat, e.lng), i = L([], n), s = r ? t1._centerAltitude + r : t1.elevation ? t1.elevation.getAtPointOrZero(t1.locationCoordinate(e), t1._centerAltitude) : t1._centerAltitude;
                E(n, n, i, Fu(1, 0) * jn * s);
                const a = u(new Float64Array(16));
                return h(a, t1.pixelMatrix, t1.globeMatrix), j(n, n, a), new Mt(n[0], n[1]);
            }
            pixelsPerMeter(t1, e) {
                return Fu(1, 0) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                const n = Fu(1, t1) * e, i = dr(Fu(1, 45) * e, n, r);
                return this.pixelsPerMeter(t1, e) / i;
            }
            createTileMatrix(t1, e, r) {
                const n = bh(ch(r.canonical));
                return h(new Float64Array(16), t1.globeMatrix, n);
            }
            createInversionMatrix(t1, e) {
                const { center: r } = t1, n = vh(ch(e));
                return m(n, n, Bt(r.lng)), f(n, n, Bt(r.lat)), d(n, n, [
                    t1._pixelsPerMercatorPixel,
                    t1._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(n);
            }
            pointCoordinate(t1, e, r, n) {
                return oh(t1, e, r, !0) || new Gu(0, 0);
            }
            pointCoordinate3D(t1, e, r) {
                const n = this.pointCoordinate(t1, e, r, 0);
                return [
                    n.x,
                    n.y,
                    n.z
                ];
            }
            isPointAboveHorizon(t1, e) {
                return !oh(t1, e.x, e.y, !1);
            }
            farthestPixelDistance(t1) {
                const e = function(t1, e) {
                    const r = t1.cameraToCenterDistance, n = t1._centerAltitude * e, i = t1._camera, s = t1._camera.forward(), a = P([], V([], s, -r), [
                        0,
                        0,
                        n
                    ]), o = t1.worldSize / (2 * Math.PI), l = [
                        0,
                        0,
                        -o
                    ], u = t1.width / t1.height, c = Math.tan(t1.fovAboveCenter), h = V([], i.up(), c), p = V([], i.right(), c * u), d = L([], P([], P([], s, h), p)), f = [];
                    let m;
                    if (new fc(a, d).closestPointOnSphere(l, o, f)) {
                        const e = P([], f, l), r = H([], e, a);
                        m = Math.cos(t1.fovAboveCenter) * I(r);
                    } else {
                        const t1 = H([], a, l), e = H([], l, a);
                        L(e, e);
                        const r = I(t1) - o;
                        m = Math.sqrt(r * (r + 2 * o));
                        const n = Math.acos(m / (o + r)) - Math.acos(O(s, e));
                        m *= Math.cos(n);
                    }
                    return 1.01 * m;
                }(t1, this.pixelsPerMeter(t1.center.lat, t1.worldSize)), r = Ih(t1.zoom);
                if (r > 0) {
                    const n = wv(t1, Fu(1, t1.center.lat) * t1.worldSize), i = t1.worldSize / (2 * Math.PI), s = Math.max(t1.width, t1.height) / t1.worldSize * Math.PI;
                    return dr(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));
                }
                return e;
            }
            upVector(t1, e, r) {
                return yh(e, r, t1, 1);
            }
            upVectorScale(t1) {
                return {
                    metersToTile: sh(gh(ch(t1)))
                };
            }
        }
        function $v(t1) {
            const e = t1.parallels, r = !!e && Math.abs(e[0] + e[1]) < .01;
            switch(t1.name){
                case "mercator":
                    return new Rv(t1);
                case "equirectangular":
                    return new Ev(t1);
                case "naturalEarth":
                    return new Ov(t1);
                case "equalEarth":
                    return new Vv(t1);
                case "winkelTripel":
                    return new Nv(t1);
                case "albers":
                    return r ? new jv(t1) : new Sv(t1);
                case "lambertConformalConic":
                    return r ? new jv(t1) : new Cv(t1);
                case "globe":
                    return new Gv(t1);
            }
            throw new Error(`Invalid projection name: ${t1.name}`);
        }
        const qv = Qu.types, Xv = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function Hv(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
            const d = o ? Math.min(fv, Math.round(o[0])) : 0, f = o ? Math.min(fv, Math.round(o[1])) : 0;
            t1.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (d << 1) + (l ? 1 : 0), 0 + (f << 1), 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function Zv(t1, e, r) {
            t1.emplaceBack(e, r);
        }
        function Wv(t1, e, r, n, i, s, a) {
            t1.emplaceBack(e, r, n, i, s, a);
        }
        const Yv = (t1, e, r, n)=>{
            for(let i = 0; i < e; i++)t1.emplaceBack(r[0], r[1], r[2], n[0], n[1], n[2]);
        };
        function Jv(t1, e, r, n, i) {
            t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i);
        }
        function Kv(t1) {
            for (const e of t1.sections)if (Ua(e.text)) return !0;
            return !1;
        }
        class Qv {
            constructor(t1){
                this.layoutVertexArray = new Qo, this.indexArray = new ll, this.programConfigurations = t1, this.segments = new Ol, this.dynamicLayoutVertexArray = new el, this.opacityVertexArray = new rl, this.placedSymbolArray = new Sl, this.iconTransitioningVertexArray = new nl, this.globeExtVertexArray = new tl, this.zOffsetVertexArray = new $o, this.orientationVertexArray = new hl, this.symbolInstanceIndices = [];
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
            }
            getSymbolVertexData(t1, e) {
                const r = [], n = this.layoutVertexArray.uint16;
                for(let i = 0; i < e; ++i){
                    const e = 12 * (t1 + i);
                    r.push(...n.slice(e, e + 12));
                }
                return r;
            }
            updateSymbolVertexData(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
                const d = this.layoutVertexArray.uint16, f = 12 * t1;
                d[f] = e, d[f + 1] = r, d[f + 2] = n, d[f + 3] = i, d[f + 4] = s, d[f + 5] = a, d[f + 6] = o, d[f + 7] = l, d[f + 8] = u, d[f + 9] = c, d[f + 10] = h, d[f + 11] = p;
            }
            upload(t1, e, r, n, i, s) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, fg.members, !!s), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, yg.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, Xv, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t1.createVertexBuffer(this.iconTransitioningVertexArray, vg.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, mg.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, gg.members, !0)), !this.orientationVertexBuffer && this.orientationVertexArray && this.orientationVertexArray.length > 0 && (this.orientationVertexBuffer = t1.createVertexBuffer(this.orientationVertexArray, xg.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.orientationVertexBuffer && this.orientationVertexBuffer.destroy());
            }
        }
        Qs(Qv, "SymbolBuffers");
        class tb {
            constructor(t1, e, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e, this.indexArray = new r, this.segments = new Ol, this.collisionVertexArray = new ol, this.collisionVertexArrayExt = new el;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, bg.members, !0), this.collisionVertexBufferExt = t1.createVertexBuffer(this.collisionVertexArrayExt, wg.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        Qs(tb, "CollisionBuffers");
        class eb {
            constructor(t1){
                this.collisionBoxArray = t1.collisionBoxArray, this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.pixelRatio = t1.pixelRatio, this.sourceLayerIndex = t1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = u([]), this.placementViewportMatrix = u([]);
                const e = this.layers[0]._unevaluatedLayout._values;
                this.worldview = t1.worldview, this.localizable = t1.localizable, this.textSizeData = dx(this.zoom, e["text-size"], this.worldview, t1.availableImages), this.iconSizeData = dx(this.zoom, e["icon-size"], this.worldview, t1.availableImages);
                const r = this.layers[0].layout, n = r.get("symbol-sort-key"), i = r.get("symbol-z-order");
                this.lut = t1.lut, this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map((t1)=>Hg[t1]), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = t1.sourceID, this.projection = t1.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = "none", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.hasAnySecondaryIcon = !1, this.hasAppearances = null, this.lastActiveApperance = null, this.featureToAppearanceIndex = {};
            }
            hasAnyAppearanceProperty(t1) {
                const e = this.layers[0].getAppearances();
                if (!e || 0 === e.length) return !1;
                const r = Array.isArray(t1) ? t1 : [
                    t1
                ];
                return e.some((t1)=>r.some((e)=>null != t1.getProperty(e)));
            }
            createArrays() {
                this.text = new Qv(new fu(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>t1.startsWith("text") || t1.startsWith("symbol"))), this.icon = new Qv(new fu(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>t1.startsWith("icon") || t1.startsWith("symbol"))), this.glyphOffsetArray = new Bl, this.lineVertexArray = new kl, this.symbolInstances = new zl;
            }
            calculateGlyphDependencies(t1, e, r, n, i) {
                for (const r of t1){
                    const t1 = r.codePointAt(0);
                    if (void 0 === t1) break;
                    if (e[t1] = !0, n && i && t1 <= 65535) {
                        const t1 = Sg[r];
                        t1 && (e[t1.charCodeAt(0)] = !0);
                    }
                }
            }
            calculateEffectiveAppearanceIconSize(t1, e, r, n, i, s, a) {
                if (!t1.hasProperty("icon-size")) return a * s;
                let o = 1;
                const l = t1.getUnevaluatedProperties()._values["icon-size"], u = dx(this.zoom, l, this.worldview, i), c = mx(u, e);
                if ("constant" !== u.kind && "camera" !== u.kind || (o = c.uSize), "composite" === u.kind) {
                    const { minZoom: t1, maxZoom: e } = u, s = l.possiblyEvaluate(new Ja(t1, {
                        worldview: this.worldview
                    }), n), a = l.possiblyEvaluate(new Ja(e, {
                        worldview: this.worldview
                    }), n), h = s.evaluate(r, {}, n, i);
                    o = h + (a.evaluate(r, {}, n, i) - h) * c.uSizeT;
                }
                return "source" === u.kind && (o = l.possiblyEvaluate(new Ja(this.zoom, {
                    worldview: this.worldview
                }), n).evaluate(r, {}, n, i)), o * s;
            }
            updateFootprints(t1, e) {}
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                return !Nd(this.activeReplacements, r) && (this.activeReplacements = r, !0);
            }
            getResolvedImageFromTokens(t1) {
                return "string" == typeof t1 ? Or.build(t1) : t1;
            }
            populate(t1, e, r, n) {
                const i = this.layers[0], s = i.layout, a = "globe" === this.projection.name, o = s.get("text-font"), l = s.get("text-field"), u = s.get("icon-image"), [c, h] = s.get("icon-size-scale-range"), p = Dt(e.scaleFactor || 1, c, h), d = ("constant" !== l.value.kind || l.value.value instanceof Rr && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0), f = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0, m = this.hasAnyAppearanceProperty("icon-image"), y = s.get("symbol-sort-key");
                if (this.features = [], this.appearanceFeatureData = [], !d && !f && !m) return;
                const g = e.iconDependencies, x = e.glyphDependencies, v = e.availableImages, b = new Ja(this.zoom, {
                    worldview: this.worldview,
                    activeFloors: e.activeFloors
                }), w = (t1)=>{
                    const e = t1.id.toString();
                    g.has(e) ? g.get(e).push(t1) : g.set(e, [
                        t1
                    ]);
                };
                for (const e of t1){
                    const { feature: t1, id: l, index: u, sourceLayerIndex: c } = e, h = i._featureFilter.needGeometry, _ = Ku(t1, h);
                    if (!i._featureFilter.filter(b, _, r)) continue;
                    if (h || (_.geometry = Ju(t1, r, n)), a && 1 !== t1.type && r.z <= 5) {
                        const t1 = _.geometry, e = .98078528056, n = (t1, n)=>O(yh(t1.x, t1.y, r, 1), yh(n.x, n.y, r, 1)) < e;
                        for(let e = 0; e < t1.length; e++)t1[e] = Hu(t1[e], n);
                    }
                    let A, I;
                    if (d) {
                        const t1 = i.getValueAndResolveTokens("text-field", _, r, v), e = Rr.factory(t1);
                        Kv(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Za() || this.hasRTLText && Ya.isParsed()) && (A = Mg(e, i, _));
                    }
                    if (f) {
                        const t1 = i.getValueAndResolveTokens("icon-image", _, r, v);
                        I = this.getResolvedImageFromTokens(t1);
                    }
                    const M = this.layers[0];
                    let S = !1;
                    if (!I && m) {
                        const t1 = M.getAppearances();
                        for (const e of t1)if (e.getProperty("icon-image")) {
                            const t1 = M.getAppearanceValueAndResolveTokens(e, "icon-image", _, r, v);
                            if (t1) {
                                I = this.getResolvedImageFromTokens(t1), S = !0;
                                break;
                            }
                        }
                    }
                    if (!A && !I) continue;
                    const P = this.sortFeaturesByKey ? y.evaluate(_, {}, r) : void 0, z = {
                        id: l,
                        text: A,
                        icon: I,
                        index: u,
                        sourceLayerIndex: c,
                        geometry: _.geometry,
                        properties: t1.properties,
                        type: qv[t1.type],
                        sortKey: P
                    };
                    if (this.features.push(z), this.featureToAppearanceIndex[u] = this.appearanceFeatureData.length, this.appearanceFeatureData.push({
                        id: l,
                        properties: t1.properties,
                        usesAppearanceIconAsPlaceholder: S,
                        isUsingAppearanceIconVertexData: !1,
                        isUsingAppearanceTextVertexData: !1,
                        layoutBasedIconVertexData: [],
                        layoutBasedTextVertexData: [],
                        activeAppearance: null
                    }), I) {
                        const t1 = M._unevaluatedLayout._values, { iconPrimary: e, iconSecondary: n } = iv(I, this.iconSizeData, t1["icon-size"], r, this.zoom, z, this.pixelRatio, p, this.worldview, v);
                        w(e), n && (this.hasAnySecondaryIcon = !0, w(n));
                    }
                    const B = M.getAppearances();
                    if (0 !== B.length && B.forEach((t1)=>{
                        if (!t1.getProperty("icon-image")) return;
                        const e = this.getCombinedIconPrimary(t1, M, _, r, v, z, p);
                        e && w(e);
                    }), A) {
                        const t1 = o.evaluate(_, {}, r).join(","), e = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Hg.vertical) >= 0;
                        for (const r of A.sections)if (r.image) {
                            const t1 = r.image.getPrimary().scaleSelf(this.pixelRatio), e = t1.id.toString(), n = g.get(e) || [];
                            n.push(t1), g.set(e, n);
                        } else {
                            const n = ka(A.toString()), i = r.fontStack || t1, s = x[i] = x[i] || {};
                            this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
                        }
                    }
                }
                if ("line" === s.get("symbol-placement") && (this.features = function(t1) {
                    const e = {}, r = {}, n = [];
                    let i = 0;
                    function s(e) {
                        n.push(t1[e]), i++;
                    }
                    function a(t1, e, i) {
                        const s = r[t1];
                        return delete r[t1], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
                    }
                    function o(t1, r, i) {
                        const s = e[r];
                        return delete e[r], e[t1] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
                    }
                    function l(t1, e, r) {
                        const n = r ? e[0][e[0].length - 1] : e[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            s(u);
                            continue;
                        }
                        const d = l(p, h), f = l(p, h, !0);
                        if (d in r && f in e && r[d] !== e[f]) {
                            const t1 = o(d, f, h), i = a(d, f, n[t1].geometry);
                            delete e[d], delete r[f], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else d in r ? a(d, f, h) : f in e ? o(d, f, h) : (s(u), e[d] = i - 1, r[f] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), "hd-road-markup" === s.get("symbol-elevation-reference")) {
                    if (this.elevationType = "road", e.elevationFeatures) {
                        !this.elevationFeatures && e.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = new Map);
                        for (const t1 of e.elevationFeatures)this.elevationFeatureIdToIndex.set(t1.id, this.elevationFeatures.length), this.elevationFeatures.push(t1);
                    }
                } else s.get("symbol-z-elevate") && (this.elevationType = "offset");
                "none" !== this.elevationType && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort((t1, e)=>t1.sortKey - e.sortKey);
            }
            getCombinedIconPrimary(t1, e, r, n, i, s, a) {
                let o, l;
                const u = t1.getUnevaluatedProperties();
                if (void 0 !== u._values["icon-image"].value) {
                    const s = e.getAppearanceValueAndResolveTokens(t1, "icon-image", r, n, i);
                    o = this.getResolvedImageFromTokens(s);
                } else {
                    const t1 = e.getValueAndResolveTokens("icon-image", r, n, i);
                    o = this.getResolvedImageFromTokens(t1);
                }
                if (o) {
                    const r = t1.hasProperty("icon-size") ? u._values["icon-size"] : e._unevaluatedLayout._values["icon-size"];
                    l = iv(o, dx(this.zoom, r, this.worldview, i), r, n, this.zoom, s, this.pixelRatio, a, this.worldview, i).iconPrimary;
                }
                return l;
            }
            updateSymbolInstanceIconVertices(t1, e, r, n, i, s, a, o, l, u, c, h, p, d) {
                if (t1.placedIconSymbolIndex < 0) return {
                    vertexOffsetDelta: 0,
                    hasChanges: !1
                };
                if (e.activeAppearance === r) return {
                    vertexOffsetDelta: t1.numIconVertices,
                    hasChanges: !1
                };
                if (r) {
                    const f = this.getCombinedIconPrimary(r, l, n, s, a, {
                        sortKey: void 0,
                        text: void 0,
                        icon: null,
                        index: t1.featureIndex,
                        sourceLayerIndex: t1.featureIndex,
                        geometry: [],
                        properties: e.properties,
                        type: "Point",
                        id: e.id
                    }, u);
                    if (!f) return {
                        vertexOffsetDelta: 0,
                        hasChanges: !1
                    };
                    const m = f.toString(), y = this.iconAtlasPositions && this.iconAtlasPositions.get(m);
                    if (y) {
                        const { appearanceIconOffset: f, appearanceIconRotate: m } = Qx(r, l, n, s, h, d, p, u);
                        let g = ox(y, void 0, f, l.layout.get("icon-anchor").evaluate(n, c, s));
                        const x = y.sdf, v = l.layout.get("icon-text-fit").constantOr("none");
                        "none" !== v && e.textShaping && e.iconTextFitPadding && e.fontScale && (g = lx(g, e.textShaping, v, e.iconTextFitPadding, f, e.fontScale));
                        const b = this.calculateEffectiveAppearanceIconSize(r, o.zoom, n, s, a, u, p), w = 0, _ = 1 + (Math.min(fv, Math.round(b * px)) << 1), A = Fx(g, m, x, "none" !== v, u);
                        e.isUsingAppearanceIconVertexData || (e.isUsingAppearanceIconVertexData = !0, e.layoutBasedIconVertexData = this.icon.getSymbolVertexData(i, t1.numIconVertices));
                        let I = i;
                        for(let r = 0; r < A.length; ++r){
                            const n = A[r], i = e.layoutBasedIconVertexData[0] || t1.tileAnchorX, s = e.layoutBasedIconVertexData[1] || t1.tileAnchorY, a = 16 * n.pixelOffsetTL.x, o = 16 * n.pixelOffsetTL.y, l = 16 * n.pixelOffsetBR.x, u = 16 * n.pixelOffsetBR.y, c = 16 * n.minFontScaleX, h = 16 * n.minFontScaleY;
                            this.icon.updateSymbolVertexData(I, i, s, Math.round(32 * n.tl.x), Math.round(32 * n.tl.y), n.texPrimary.x, n.texPrimary.y, w, _, a, o, c, h), this.icon.updateSymbolVertexData(I + 1, i, s, Math.round(32 * n.tr.x), Math.round(32 * n.tr.y), n.texPrimary.x + n.texPrimary.w, n.texPrimary.y, w, _, l, o, c, h), this.icon.updateSymbolVertexData(I + 2, i, s, Math.round(32 * n.bl.x), Math.round(32 * n.bl.y), n.texPrimary.x, n.texPrimary.y + n.texPrimary.h, w, _, a, u, c, h), this.icon.updateSymbolVertexData(I + 3, i, s, Math.round(32 * n.br.x), Math.round(32 * n.br.y), n.texPrimary.x + n.texPrimary.w, n.texPrimary.y + n.texPrimary.h, w, _, l, u, c, h), I += 4;
                        }
                        const M = t1.numIconVertices - 4 * A.length;
                        for(let t1 = 0; t1 < M; ++t1)this.icon.updateSymbolVertexData(I + t1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        return {
                            vertexOffsetDelta: t1.numIconVertices,
                            hasChanges: !0
                        };
                    }
                } else if (e.usesAppearanceIconAsPlaceholder) {
                    if (this.layers[0].appearances && this.layers[0].appearances.length > 0) return this.icon.updateSymbolVertexData(i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateSymbolVertexData(i + 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateSymbolVertexData(i + 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateSymbolVertexData(i + 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), {
                        vertexOffsetDelta: t1.numIconVertices,
                        hasChanges: !0
                    };
                } else if (e.isUsingAppearanceIconVertexData) {
                    const t1 = 12, r = e.layoutBasedIconVertexData.length / t1;
                    for(let n = 0; n < r; ++n){
                        const r = n * t1;
                        this.icon.updateSymbolVertexData(i + n, e.layoutBasedIconVertexData[r + 0], e.layoutBasedIconVertexData[r + 1], e.layoutBasedIconVertexData[r + 2], e.layoutBasedIconVertexData[r + 3], e.layoutBasedIconVertexData[r + 4], e.layoutBasedIconVertexData[r + 5], e.layoutBasedIconVertexData[r + 6], e.layoutBasedIconVertexData[r + 7], e.layoutBasedIconVertexData[r + 8], e.layoutBasedIconVertexData[r + 9], e.layoutBasedIconVertexData[r + 10], e.layoutBasedIconVertexData[r + 11]);
                    }
                    return e.isUsingAppearanceIconVertexData = !1, {
                        vertexOffsetDelta: r,
                        hasChanges: !0
                    };
                }
                return {
                    vertexOffsetDelta: t1.numIconVertices,
                    hasChanges: !1
                };
            }
            updateSymbolInstanceTextVertices(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g) {
                const x = t1.numHorizontalGlyphVertices > 0 || t1.numVerticalGlyphVertices > 0;
                if (!x) return {
                    vertexOffsetDelta: x ? t1.numHorizontalGlyphVertices + t1.numVerticalGlyphVertices : 0,
                    hasChanges: !1
                };
                if (e.activeAppearance === r) return {
                    vertexOffsetDelta: t1.numHorizontalGlyphVertices + t1.numVerticalGlyphVertices,
                    hasChanges: !1
                };
                if (r && e.textShaping) {
                    const { appearanceTextOffset: x, appearanceTextRotate: v, appearanceTextSize: b } = ev(r, a, n, s, c, p, h);
                    e.fontScale = hv(b, e.textScaleFactor);
                    const w = r.getUnevaluatedProperty("text-size");
                    let _ = this.textSizeData, A = m, I = y;
                    r.hasProperty("text-size") && (_ = dx(this.zoom, w, this.worldview, g), A = "composite" === this.textSizeData.kind ? this.textSizeData.minZoom : 0, I = "composite" === this.textSizeData.kind ? this.textSizeData.maxZoom : 0);
                    const M = e.textShaping.bottom - c[1], S = e.textShaping.left - c[0], P = e.textShaping.right - c[0];
                    e.textShaping.top = x[1] + (e.textShaping.top - c[1]), e.textShaping.bottom = x[1] + M, e.textShaping.left = x[0] + S, e.textShaping.right = x[0] + P;
                    const z = jx(0, e.textShaping, x, a, !1, n, l, this.allowVerticalPlacement, v), B = b && "composite" === _.kind ? w.possiblyEvaluate(new Ja(A, {}), s).evaluate(n, u, s) : d, k = b && "composite" === _.kind ? w.possiblyEvaluate(new Ja(I, {}), s).evaluate(n, u, s) : f, T = yv(r.name, _, b, o, B, k), V = Array.isArray(T) ? T[1] : b, E = 0, F = 1 + (Math.min(fv, Math.round(V * px)) << 1);
                    e.isUsingAppearanceTextVertexData || (e.isUsingAppearanceTextVertexData = !0, e.layoutBasedTextVertexData = this.text.getSymbolVertexData(i, t1.numHorizontalGlyphVertices + t1.numVerticalGlyphVertices));
                    for(let e = 0; e < z.length && e < (t1.numHorizontalGlyphVertices + t1.numVerticalGlyphVertices) / 4; ++e){
                        const r = z[e], n = r.glyphOffset[1], s = t1.tileAnchorX, a = t1.tileAnchorY, o = i + 4 * e;
                        this.text.updateSymbolVertexData(o, s, a, Math.round(32 * r.tl.x), Math.round(32 * (n + r.tl.y)), r.texPrimary.x, r.texPrimary.y, E, F, r.pixelOffsetTL.x, r.pixelOffsetTL.y, r.minFontScaleX, r.minFontScaleY), this.text.updateSymbolVertexData(o + 1, s, a, Math.round(32 * r.tr.x), Math.round(32 * (n + r.tr.y)), r.texPrimary.x + r.texPrimary.w, r.texPrimary.y, E, F, r.pixelOffsetBR.x, r.pixelOffsetTL.y, r.minFontScaleX, r.minFontScaleY), this.text.updateSymbolVertexData(o + 2, s, a, Math.round(32 * r.bl.x), Math.round(32 * (n + r.bl.y)), r.texPrimary.x, r.texPrimary.y + r.texPrimary.h, E, F, r.pixelOffsetTL.x, r.pixelOffsetBR.y, r.minFontScaleX, r.minFontScaleY), this.text.updateSymbolVertexData(o + 3, s, a, Math.round(32 * r.br.x), Math.round(32 * (n + r.br.y)), r.texPrimary.x + r.texPrimary.w, r.texPrimary.y + r.texPrimary.h, E, F, r.pixelOffsetBR.x, r.pixelOffsetBR.y, r.minFontScaleX, r.minFontScaleY);
                    }
                    return {
                        vertexOffsetDelta: t1.numHorizontalGlyphVertices + t1.numVerticalGlyphVertices,
                        hasChanges: !0
                    };
                }
                if (e.isUsingAppearanceTextVertexData) {
                    const t1 = 12, r = e.layoutBasedTextVertexData.length / t1;
                    for(let n = 0; n < r; ++n){
                        const r = n * t1;
                        this.text.updateSymbolVertexData(i + n, e.layoutBasedTextVertexData[r + 0], e.layoutBasedTextVertexData[r + 1], e.layoutBasedTextVertexData[r + 2], e.layoutBasedTextVertexData[r + 3], e.layoutBasedTextVertexData[r + 4], e.layoutBasedTextVertexData[r + 5], e.layoutBasedTextVertexData[r + 6], e.layoutBasedTextVertexData[r + 7], e.layoutBasedTextVertexData[r + 8], e.layoutBasedTextVertexData[r + 9], e.layoutBasedTextVertexData[r + 10], e.layoutBasedTextVertexData[r + 11]);
                    }
                    return e.isUsingAppearanceTextVertexData = !1, {
                        vertexOffsetDelta: r,
                        hasChanges: !0
                    };
                }
                return {
                    vertexOffsetDelta: t1.numHorizontalGlyphVertices + t1.numVerticalGlyphVertices,
                    hasChanges: !1
                };
            }
            update(t1, e, r, n, i, s, a) {
                this.text.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, this.worldview), this.icon.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, a, this.worldview);
            }
            updateRoadElevation(t1) {
                if ("road" !== this.elevationType || !this.elevationFeatures) return;
                if (this.elevationStateComplete) return;
                this.elevationStateComplete = !0, this.hasAnyZOffset = !1;
                let e = !1;
                const r = ju(t1), n = 1 / r;
                let i = !1, s = !1;
                for(let t1 = 0; t1 < this.symbolInstances.length; t1++){
                    const a = this.symbolInstances.get(t1), o = M(1, 0, 0), l = M(0, 1, 0), { numHorizontalGlyphVertices: u, numVerticalGlyphVertices: c, numIconVertices: h, numVerticalIconVertices: p } = a, d = u > 0 || c > 0, f = h > 0, m = this.elevationFeatures[a.elevationFeatureIndex];
                    if (m) {
                        const t1 = new Mt(a.tileAnchorX, a.tileAnchorY), u = .075 + m.pointElevation(t1);
                        a.zOffset !== u && (e = !0, a.zOffset = u), 0 !== u && (this.hasAnyZOffset = !0);
                        const c = m.computeSlopeNormal(t1, n), h = ut(et(), M(0, 0, 1), c);
                        $(o, o, h), $(l, l, h), o[2] *= r, l[2] *= r, 1 === o[0] && 0 === o[1] && 0 === o[2] && 0 === l[0] && 1 === l[1] && 0 === l[2] || (i = i || d, s = s || f);
                    }
                    if (d && (Yv(this.text.orientationVertexArray, u, o, l), Yv(this.text.orientationVertexArray, c, o, l)), f) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: e } = a;
                        t1 >= 0 && Yv(this.icon.orientationVertexArray, h, o, l), e >= 0 && Yv(this.icon.orientationVertexArray, p, o, l);
                    }
                }
                i || (this.text.orientationVertexArray = void 0), s || (this.icon.orientationVertexArray = void 0), e && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0);
            }
            updateZOffset() {
                const t1 = (t1, e, n)=>{
                    r += e, r > t1.length && t1.resize(r);
                    for(let i = -e; i < 0; i++)t1.emplace(i + r, n);
                }, e = (t1, e, r)=>{
                    n += e, n > t1.length && t1.resize(n);
                    for(let i = -e; i < 0; i++)t1.emplace(i + n, r);
                };
                if (!this.zOffsetBuffersNeedUpload) return;
                this.zOffsetBuffersNeedUpload = !1;
                let r = 0, n = 0;
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const n = this.symbolInstances.get(r), { numHorizontalGlyphVertices: i, numVerticalGlyphVertices: s, numIconVertices: a } = n, o = n.zOffset, l = a > 0;
                    if ((i > 0 || s > 0) && (t1(this.text.zOffsetVertexArray, i, o), t1(this.text.zOffsetVertexArray, s, o)), l) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: r } = n;
                        t1 >= 0 && e(this.icon.zOffsetVertexArray, a, o), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, o);
                    }
                }
                this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1, e, r, n, i) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload, this.hasAppearances), null === this.hasAppearances && (this.hasAppearances = this.layers.some((t1)=>t1.appearances && t1.appearances.length > 0)), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload, this.hasAppearances), this.uploaded = !0;
            }
            updateAppearances(t1, e, r, n, i) {
                if (!(t1 && e && r && this.appearanceFeatureData)) return !1;
                const s = this.icon.layoutVertexArray && this.icon.layoutVertexArray.length > 0 && this.icon.layoutVertexArray.arrayBuffer, a = this.text.layoutVertexArray && this.text.layoutVertexArray.length > 0 && this.text.layoutVertexArray.arrayBuffer;
                if (!s && !a) return !1;
                const o = this.layers[0], l = o.layout;
                let u = 1, c = 0, h = !1;
                if (s) {
                    const [t1, e] = l.get("icon-size-scale-range");
                    u = Dt(1, t1, e);
                }
                let p = 1, d = 0, f = !1;
                if (a) {
                    const [t1, e] = l.get("text-size-scale-range");
                    p = Dt(1, t1, e);
                }
                const m = new Map;
                if (i && r) for (const t1 of r){
                    const e = i.getImage(t1, o.scope);
                    if (e) {
                        const r = new Lr(t1.toString());
                        m.set(r.toString(), e);
                    }
                }
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const y = this.symbolInstances.get(i), g = this.featureToAppearanceIndex[y.featureIndex], x = void 0 !== g ? this.appearanceFeatureData[g] : void 0;
                    if (!x) continue;
                    const v = x.id, b = e && void 0 !== v ? e[String(v)] : void 0, w = {
                        type: "Point",
                        id: x.id,
                        properties: x.properties,
                        geometry: []
                    }, _ = o.appearances && o.appearances.find((e)=>e.isActive({
                            globals: n,
                            feature: w,
                            canonical: t1,
                            featureState: b
                        }));
                    if (a) {
                        const e = l.get("text-size"), n = l.get("text-offset").evaluate(w, b, t1), i = e.evaluate(w, b, t1), s = l.get("text-rotate").evaluate(w, b, t1), a = "composite" === this.textSizeData.kind ? this.textSizeData.minZoom : 0, u = "composite" === this.textSizeData.kind ? this.textSizeData.maxZoom : 0, c = e.evaluate(w, {
                            zoom: a
                        }, t1), h = e.evaluate(w, {
                            zoom: u
                        }, t1), g = this.updateSymbolInstanceTextVertices(y, x, _, w, d, t1, o, p, m, b, n, i, s, c, h, a, u, r);
                        d += g.vertexOffsetDelta, f = f || g.hasChanges;
                    }
                    if (s) {
                        const e = l.get("icon-offset").evaluate(w, b, t1), i = l.get("icon-size").evaluate(w, b, t1, r), s = l.get("icon-rotate").evaluate(w, b, t1), a = this.updateSymbolInstanceIconVertices(y, x, _, w, c, t1, r, n, o, u, b, e, i, s);
                        c += a.vertexOffsetDelta, h = h || a.hasChanges;
                    }
                    x.activeAppearance = _;
                }
                return h && this.icon.layoutVertexBuffer && null !== this.icon.layoutVertexArray.arrayBuffer && this.icon.layoutVertexArray.length === this.icon.layoutVertexBuffer.length && this.icon.layoutVertexBuffer.updateData(this.icon.layoutVertexArray), f && this.text.layoutVertexBuffer && null !== this.text.layoutVertexArray.arrayBuffer && this.text.layoutVertexArray.length === this.text.layoutVertexBuffer.length && this.text.layoutVertexBuffer.updateData(this.text.layoutVertexArray), h || f;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = $v(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t1, e) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) for (const { x: t1, y: r } of e)this.lineVertexArray.emplaceBack(t1, r);
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(t1, e, r, n, i, s, a, o, l, u, c, h, p, d, f, m, y, g) {
                const x = t1.indexArray, v = t1.layoutVertexArray, b = t1.globeExtVertexArray, w = t1.segments.prepareSegment(4 * g, v, x, this.canOverlap ? s.sortKey : void 0), _ = this.glyphOffsetArray.length, A = w.vertexLength, I = this.allowVerticalPlacement && a === Hg.vertical ? Math.PI / 2 : 0, M = s.text && s.text.sections;
                for(let n = 0; n < e.length; n++){
                    const { tl: i, tr: a, bl: u, br: c, texPrimary: h, texSecondary: y, pixelOffsetTL: g, pixelOffsetBR: _, minFontScaleX: A, minFontScaleY: S, glyphOffset: P, isSDF: z, sectionIndex: B } = e[n], k = w.vertexLength, T = P[1];
                    if (Hv(v, l.x, l.y, i.x, T + i.y, h.x, h.y, r, z, g.x, g.y, A, S), Hv(v, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, z, _.x, g.y, A, S), Hv(v, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, z, g.x, _.y, A, S), Hv(v, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, z, _.x, _.y, A, S), o) {
                        const { x: e, y: r, z: n } = o.anchor, [i, s, a] = o.up;
                        Wv(b, e, r, n, i, s, a), Wv(b, e, r, n, i, s, a), Wv(b, e, r, n, i, s, a), Wv(b, e, r, n, i, s, a), Jv(t1.dynamicLayoutVertexArray, e, r, n, I);
                    } else Jv(t1.dynamicLayoutVertexArray, l.x, l.y, l.z, I);
                    if (m) {
                        const e = y || h;
                        Zv(t1.iconTransitioningVertexArray, e.x, e.y), Zv(t1.iconTransitioningVertexArray, e.x + e.w, e.y), Zv(t1.iconTransitioningVertexArray, e.x, e.y + e.h), Zv(t1.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);
                    }
                    x.emplaceBack(k, k + 1, k + 2), x.emplaceBack(k + 1, k + 2, k + 3), w.vertexLength += 4, w.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), n !== e.length - 1 && B === e[n + 1].sectionIndex || t1.programConfigurations.populatePaintArrays(v.length, s, s.index, {}, p, d, f, M && M[B], this.worldview);
                }
                const S = g - e.length;
                0 !== S && this._addNullVertices(S, v, r, o, b, t1, m, w, x);
                const P = o ? o.anchor : l;
                t1.placedSymbolArray.emplaceBack(P.x, P.y, P.z, l.x, l.y, _, this.glyphOffsetArray.length - _, A, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, 0, 0, h, 0), t1.symbolInstanceIndices.push(y);
            }
            _addNullVertices(t1, e, r, n, i, s, a, o, l) {
                for(let u = 0; u < t1; u++){
                    for(let t1 = 0; t1 < 4; t1++)Hv(e, 0, 0, 0, 0, 0, 0, r, !1, 0, 0, 0, 0), n ? (Wv(i, 0, 0, 0, 0, 0, 0), Jv(s.dynamicLayoutVertexArray, 0, 0, 0, 0)) : Jv(s.dynamicLayoutVertexArray, 0, 0, 0, 0), a && Zv(s.iconTransitioningVertexArray, 0, 0);
                    const t1 = o.vertexLength;
                    l.emplaceBack(t1, t1 + 1, t1 + 2), l.emplaceBack(t1 + 1, t1 + 2, t1 + 3), o.vertexLength += 4, o.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(0);
                }
            }
            _commitLayoutVertex(t1, e, r, n, i, s, a) {
                t1.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }
            _addCollisionDebugVertices(t1, e, r, n, i, s, a) {
                const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l = o.vertexLength, u = a.tileAnchorX, c = a.tileAnchorY;
                for(let t1 = 0; t1 < 4; t1++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
                this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t1.padding, a.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Mt(t1.x1, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Mt(t1.x2, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Mt(t1.x2, t1.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Mt(t1.x1, t1.y2)), o.vertexLength += 4;
                const h = r.indexArray;
                h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e, a);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e, s.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t1, e, r) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new tb(sl, _g.members, nl), this.iconCollisionBox = new tb(sl, _g.members, nl);
                const n = mx(this.iconSizeData, t1), i = mx(this.textSizeData, t1, r);
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const s = this.symbolInstances.get(r);
                    this._addTextDebugCollisionBoxes(i, t1, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(i, t1, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t1, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t1, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }
            getSymbolInstanceTextSize(t1, e, r, n) {
                const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n), s = fx(this.textSizeData, t1, i) / Ig;
                return this.tilePixelRatio * s;
            }
            getSymbolInstanceIconSize(t1, e, r) {
                const n = this.icon.placedSymbolArray.get(r), i = fx(this.iconSizeData, t1, n);
                return this.tilePixelRatio * i;
            }
            _commitDebugCollisionVertexUpdate(t1, e, r, n) {
                t1.emplaceBack(e, -r, -r, n), t1.emplaceBack(e, r, -r, n), t1.emplaceBack(e, r, r, n), t1.emplaceBack(e, -r, r, n);
            }
            _updateTextDebugCollisionBoxes(t1, e, r, n, i, s, a) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e, a);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);
                }
            }
            _updateIconDebugCollisionBoxes(t1, e, r, n, i, s, a) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e, s.placedIconSymbolIndex);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);
                }
            }
            updateCollisionDebugBuffers(t1, e, r, n) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const i = mx(this.iconSizeData, t1, n), s = mx(this.textSizeData, t1, r);
                for(let a = 0; a < this.symbolInstances.length; a++){
                    const o = this.symbolInstances.get(a);
                    this._updateTextDebugCollisionBoxes(s, t1, e, o.textBoxStartIndex, o.textBoxEndIndex, o, r), this._updateTextDebugCollisionBoxes(s, t1, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o, r), this._updateIconDebugCollisionBoxes(i, t1, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o, n), this._updateIconDebugCollisionBoxes(i, t1, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o, n);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t1, e, r, n, i, s, a, o, l) {
                const u = {};
                if (e < r) {
                    const { x1: r, y1: n, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(e);
                    u.textBox = {
                        x1: r,
                        y1: n,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.textFeatureIndex = d;
                }
                if (n < i) {
                    const { x1: e, y1: r, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(n);
                    u.verticalTextBox = {
                        x1: e,
                        y1: r,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalTextFeatureIndex = d;
                }
                if (s < a) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(s);
                    u.iconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.iconFeatureIndex = d;
                }
                if (o < l) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(o);
                    u.verticalIconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalIconFeatureIndex = d;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e = 0; e < this.symbolInstances.length; e++){
                    const r = this.symbolInstances.get(e);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            hasIconTextFit() {
                return this.hasAnyIconTextFit;
            }
            addIndicesForPlacedSymbol(t1, e) {
                const r = t1.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e = r.vertexStartIndex; e < n; e += 4)t1.indexArray.emplaceBack(e, e + 1, e + 2), t1.indexArray.emplaceBack(e + 1, e + 2, e + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e = Math.sin(t1), r = Math.cos(t1), n = [], i = [], s = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    s.push(t1);
                    const a = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
                }
                return s.sort((t1, e)=>n[t1] - n[e] || i[e] - i[t1]), s;
            }
            getSortedIndexesByZOffset() {
                if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
                if (!this.symbolInstanceIndexesSortedZOffset) {
                    this.symbolInstanceIndexesSortedZOffset = [];
                    for(let t1 = 0; t1 < this.symbolInstances.length; ++t1)this.symbolInstanceIndexesSortedZOffset.push(t1);
                }
                return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t1, e)=>this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t1).zOffset);
            }
            addToSortKeyRanges(t1, e) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: s, placedIconSymbolIndex: a, verticalPlacedIconSymbolIndex: o } = e;
                        r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
            getElevationFeatureForText(t1) {
                const e = this.symbolInstances.get(this.text.symbolInstanceIndices[t1]).elevationFeatureIndex;
                let r;
                return this.elevationFeatures && e < this.elevationFeatures.length && (r = this.elevationFeatures[e]), r;
            }
        }
        function rb(t1, e) {
            return e.replace(/{([^{}]+)}/g, (e, r)=>r in t1 ? String(t1[r]) : "");
        }
        let nb, ib, sb;
        Qs(eb, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "compareText",
                "features"
            ]
        }), eb.addDynamicAttributes = Jv;
        class ab {
            constructor(t1){
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : xr, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e = this.defaultValue.property.overrides;
                    if (e && e.hasOverride(t1.formattedSection)) return e.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        Qs(ab, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        const ob = ()=>sb || (sb = {
                layout: nb || (nb = new uo({
                    "symbol-placement": new ao(co.layout_symbol["symbol-placement"]),
                    "symbol-spacing": new ao(co.layout_symbol["symbol-spacing"]),
                    "symbol-avoid-edges": new ao(co.layout_symbol["symbol-avoid-edges"]),
                    "symbol-sort-key": new oo(co.layout_symbol["symbol-sort-key"]),
                    "symbol-z-order": new ao(co.layout_symbol["symbol-z-order"]),
                    "symbol-z-elevate": new ao(co.layout_symbol["symbol-z-elevate"]),
                    "symbol-elevation-reference": new ao(co.layout_symbol["symbol-elevation-reference"]),
                    "icon-allow-overlap": new ao(co.layout_symbol["icon-allow-overlap"]),
                    "icon-ignore-placement": new ao(co.layout_symbol["icon-ignore-placement"]),
                    "icon-optional": new ao(co.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new ao(co.layout_symbol["icon-rotation-alignment"]),
                    "icon-size": new oo(co.layout_symbol["icon-size"]),
                    "icon-size-scale-range": new ao(co.layout_symbol["icon-size-scale-range"]),
                    "icon-text-fit": new oo(co.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new oo(co.layout_symbol["icon-text-fit-padding"]),
                    "icon-image": new oo(co.layout_symbol["icon-image"]),
                    "icon-image-use-theme": new ao({
                        type: "string",
                        default: "default",
                        "property-type": "data-constant"
                    }),
                    "icon-rotate": new oo(co.layout_symbol["icon-rotate"]),
                    "icon-padding": new ao(co.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new ao(co.layout_symbol["icon-keep-upright"]),
                    "icon-offset": new oo(co.layout_symbol["icon-offset"]),
                    "icon-anchor": new oo(co.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new ao(co.layout_symbol["icon-pitch-alignment"]),
                    "text-pitch-alignment": new ao(co.layout_symbol["text-pitch-alignment"]),
                    "text-rotation-alignment": new ao(co.layout_symbol["text-rotation-alignment"]),
                    "text-field": new oo(co.layout_symbol["text-field"]),
                    "text-font": new oo(co.layout_symbol["text-font"]),
                    "text-size": new oo(co.layout_symbol["text-size"]),
                    "text-size-scale-range": new ao(co.layout_symbol["text-size-scale-range"]),
                    "text-max-width": new oo(co.layout_symbol["text-max-width"]),
                    "text-line-height": new oo(co.layout_symbol["text-line-height"]),
                    "text-letter-spacing": new oo(co.layout_symbol["text-letter-spacing"]),
                    "text-justify": new oo(co.layout_symbol["text-justify"]),
                    "text-radial-offset": new oo(co.layout_symbol["text-radial-offset"]),
                    "text-variable-anchor": new ao(co.layout_symbol["text-variable-anchor"]),
                    "text-anchor": new oo(co.layout_symbol["text-anchor"]),
                    "text-max-angle": new ao(co.layout_symbol["text-max-angle"]),
                    "text-writing-mode": new ao(co.layout_symbol["text-writing-mode"]),
                    "text-rotate": new oo(co.layout_symbol["text-rotate"]),
                    "text-padding": new ao(co.layout_symbol["text-padding"]),
                    "text-keep-upright": new ao(co.layout_symbol["text-keep-upright"]),
                    "text-transform": new oo(co.layout_symbol["text-transform"]),
                    "text-offset": new oo(co.layout_symbol["text-offset"]),
                    "text-allow-overlap": new ao(co.layout_symbol["text-allow-overlap"]),
                    "text-ignore-placement": new ao(co.layout_symbol["text-ignore-placement"]),
                    "text-optional": new ao(co.layout_symbol["text-optional"]),
                    visibility: new ao(co.layout_symbol.visibility)
                })),
                paint: ib || (ib = new uo({
                    "icon-opacity": new oo(co.paint_symbol["icon-opacity"]),
                    "icon-occlusion-opacity": new oo(co.paint_symbol["icon-occlusion-opacity"]),
                    "icon-emissive-strength": new oo(co.paint_symbol["icon-emissive-strength"]),
                    "text-emissive-strength": new oo(co.paint_symbol["text-emissive-strength"]),
                    "icon-color": new oo(co.paint_symbol["icon-color"]),
                    "icon-halo-color": new oo(co.paint_symbol["icon-halo-color"]),
                    "icon-halo-width": new oo(co.paint_symbol["icon-halo-width"]),
                    "icon-halo-blur": new oo(co.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new ao(co.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new ao(co.paint_symbol["icon-translate-anchor"]),
                    "icon-image-cross-fade": new ao(co.paint_symbol["icon-image-cross-fade"]),
                    "text-opacity": new oo(co.paint_symbol["text-opacity"]),
                    "text-occlusion-opacity": new oo(co.paint_symbol["text-occlusion-opacity"]),
                    "text-color": new oo(co.paint_symbol["text-color"], {
                        runtimeType: _r,
                        getOverride: (t1)=>t1.textColor,
                        hasOverride: (t1)=>!!t1.textColor
                    }),
                    "text-halo-color": new oo(co.paint_symbol["text-halo-color"]),
                    "text-halo-width": new oo(co.paint_symbol["text-halo-width"]),
                    "text-halo-blur": new oo(co.paint_symbol["text-halo-blur"]),
                    "text-translate": new ao(co.paint_symbol["text-translate"]),
                    "text-translate-anchor": new ao(co.paint_symbol["text-translate-anchor"]),
                    "icon-color-saturation": new ao(co.paint_symbol["icon-color-saturation"]),
                    "icon-color-contrast": new ao(co.paint_symbol["icon-color-contrast"]),
                    "icon-color-brightness-min": new ao(co.paint_symbol["icon-color-brightness-min"]),
                    "icon-color-brightness-max": new ao(co.paint_symbol["icon-color-brightness-max"]),
                    "symbol-z-offset": new oo(co.paint_symbol["symbol-z-offset"]),
                    "icon-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "icon-halo-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-halo-color-use-theme": new oo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, sb);
        class lb extends Fo {
            constructor(t1, e, r, n){
                super(t1, ob(), e, r, n, t1.layout ? t1.layout["icon-image-use-theme"] : null), this._colorAdjustmentMatrix = u([]), this.hasOcclusionOpacityProperties = void 0 !== t1.paint && ("icon-occlusion-opacity" in t1.paint || "text-occlusion-opacity" in t1.paint);
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "icon-occlusion-opacity" !== t1 && "text-occlusion-opacity" !== t1 || (this.hasOcclusionOpacityProperties = !0);
            }
            recalculate(t1, e) {
                super.recalculate(t1, e), this.appearances && this.appearances.forEach((r)=>{
                    r.recalculate(t1, e, this.iconImageUseTheme);
                }), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t1 = [];
                    for (const e of r)t1.indexOf(e) < 0 && t1.push(e);
                    this.layout._values["text-writing-mode"] = t1;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getColorAdjustmentMatrix(t1, e, r, n) {
                return this._saturation === t1 && this._contrast === e && this._brightnessMin === r && this._brightnessMax === n || (this._colorAdjustmentMatrix = function(t1, e, r, n) {
                    t1 = se(t1), e = ie(e);
                    const i = o(), s = t1 / 3, a = 1 - 2 * s, l = [
                        a,
                        s,
                        s,
                        0,
                        s,
                        a,
                        s,
                        0,
                        s,
                        s,
                        a,
                        0,
                        0,
                        0,
                        0,
                        1
                    ], u = .5 - .5 * e, c = n - r;
                    return h(i, [
                        c,
                        0,
                        0,
                        0,
                        0,
                        c,
                        0,
                        0,
                        0,
                        0,
                        c,
                        0,
                        r,
                        r,
                        r,
                        1
                    ], [
                        e,
                        0,
                        0,
                        0,
                        0,
                        e,
                        0,
                        0,
                        0,
                        0,
                        e,
                        0,
                        u,
                        u,
                        u,
                        1
                    ]), h(i, i, l), i;
                }(t1, e, r, n), this._saturation = t1, this._contrast = e, this._brightnessMin = r, this._brightnessMax = n), this._colorAdjustmentMatrix;
            }
            getValueAndResolveTokens(t1, e, r, n) {
                const i = this.layout.get(t1).evaluate(e, {}, r, n), s = this._unevaluatedLayout._values[t1];
                return s.isDataDriven() || Ns(s.value) || !i ? i : rb(e.properties, i);
            }
            getAppearanceValueAndResolveTokens(t1, e, r, n, i) {
                const s = t1.getProperty(e);
                if (!s) return;
                const a = s.evaluate(r, {}, n, i), o = t1.getUnevaluatedProperties()._values[e];
                return o.isDataDriven() || Ns(o.value) || !a || "string" != typeof a ? a : rb(r.properties, a);
            }
            createBucket(t1) {
                return new eb(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t1 of ob().paint.overridableProperties){
                    if (!lb.hasPaintOverride(this.layout, t1)) continue;
                    const e = this.paint.get(t1), r = new ab(e), n = new Us(r, e.property.specification, this.scope, this.options, this.layout.get("icon-image-use-theme"));
                    let i = null;
                    i = "constant" === e.value.kind || "source" === e.value.kind ? new Gs("source", n) : new $s("composite", n, e.value.zoomStops, e.value.interpolationType), this.paint._values[t1] = new io(e.property, i, e.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && lb.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e) {
                const r = t1.get("text-field"), n = ob().paint.properties[e];
                let i = !1;
                const s = (t1)=>{
                    for (const e of t1)if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof Rr) s(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e)=>{
                        i || (e instanceof $r && jr(e.value) === Sr ? s(e.value.sections) : e instanceof Zr ? s(e.sections) : e.eachChild(t1));
                    }, e = r.value;
                    e._styleExpression && t1(e._styleExpression.expression);
                }
                return i;
            }
            getProgramIds() {
                return [
                    "symbol"
                ];
            }
            getDefaultProgramParams(t1, e, r) {
                return {
                    config: new du(this, {
                        zoom: e,
                        lut: r
                    }),
                    overrideFog: !1
                };
            }
            hasElevation() {
                return this.layout && "hd-road-markup" === this.layout.get("symbol-elevation-reference");
            }
        }
        let ub, cb, hb, pb;
        var db = Oo([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        function fb(t1, e, r, n, i, o, l, u) {
            const c = [
                t1,
                e,
                1,
                r,
                n,
                1,
                i,
                o,
                1
            ], h = [
                l,
                u,
                1
            ], p = s([], c), [d, f, m] = G(h, h, p);
            return a(c, c, [
                d,
                0,
                0,
                0,
                f,
                0,
                0,
                0,
                m
            ]);
        }
        function mb(t1, e, r, n, i, o, l, u) {
            const c = function(t1, e, r, n, i, o, l, u) {
                const c = fb(0, 0, 1, 0, 1, 1, 0, 1), h = fb(t1, e, r, n, i, o, l, u);
                return a(h, h, s([], c));
            }(t1, e, r, n, i, o, l, u);
            return [
                c[2] / c[8] / jn,
                c[5] / c[8] / jn
            ];
        }
        function yb(t1) {
            return [
                t1[0],
                Math.min(Math.max(t1[1], -85.051129), Lu)
            ];
        }
        class gb extends ir {
            constructor(t1, e, r, n){
                super(), this.id = t1, this.dispatcher = r, this.coordinates = e.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;
            }
            load(t1, e) {
                if (this._loaded = e || !1, this.fire(new tr("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, !this.url) return t1 && (this.coordinates = t1), this._loaded = !0, void this._finishLoading();
                this._imageRequest = qe(this.map._requestManager.transformRequest(this.url, Ce.Image), (e, r)=>{
                    this._imageRequest = null, this._loaded = !0, e ? this.fire(new er(e)) : r && (this.image = r instanceof HTMLImageElement ? ge.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t1 && (this.coordinates = t1), this._finishLoading());
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(t1) {
                return t1.url ? (this._imageRequest && t1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t1.url, this.load(t1.coordinates, this._loaded), this) : this;
            }
            setTexture(t1) {
                if (!(t1.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
                return this.texture = new Rm(this.map.painter.context, t1.handle), this.width = t1.dimensions[0], this.height = t1.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new tr("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            onRemove(t1) {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Rm || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
            }
            setCoordinates(t1) {
                if (this.coordinates = t1, this._boundsArray = void 0, this._unsupportedCoords = !1, !t1.length) return this;
                this.onNorthPole = !1, this.onSouthPole = !1;
                let e = t1[0][1], r = t1[0][1];
                for (const n of t1)n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);
                const n = (r + e) / 2;
                if (n > Lu ? this.onNorthPole = !0 : n < -85.051129 && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
                    const e = t1.map(Gu.fromLngLat);
                    this.tileID = function(t1) {
                        let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
                        for (const s of t1)e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
                        const s = Math.max(n - e, i - r), a = Math.max(0, Math.floor(-Math.log2(s))), o = Math.pow(2, a);
                        let l = Math.floor((e + n) / 2 * o);
                        return l > 1 && (l -= 1), new Yc(a, l, Math.floor((r + i) / 2 * o));
                    }(e), this.minzoom = this.maxzoom = this.tileID.z;
                }
                return this.fire(new tr("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                !this.texture || this.texture instanceof Rm || (this.texture.destroy(), this._dirty = !0), this.texture = null, this._boundsArray = void 0, this._unsupportedCoords = !1;
            }
            _prepareData(t1) {
                for(const t1 in this.tiles){
                    const e = this.tiles[t1];
                    "loaded" !== e.state && (e.state = "loaded", e.texture = this.texture);
                }
                if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
                const e = _v(new Yc(0, 0, 0), this.map.transform.projection), r = [
                    e.projection.project(this.coordinates[0][0], this.coordinates[0][1]),
                    e.projection.project(this.coordinates[1][0], this.coordinates[1][1]),
                    e.projection.project(this.coordinates[2][0], this.coordinates[2][1]),
                    e.projection.project(this.coordinates[3][0], this.coordinates[3][1])
                ];
                if (!function(t1) {
                    const e = t1[1].x - t1[0].x, r = t1[1].y - t1[0].y, n = t1[2].x - t1[1].x, i = t1[2].y - t1[1].y, s = t1[3].x - t1[2].x, a = t1[3].y - t1[2].y, o = t1[0].x - t1[3].x, l = t1[0].y - t1[3].y, u = e * i - n * r, c = n * a - s * i, h = s * l - o * a, p = o * r - e * l;
                    return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;
                }(r)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
                const n = _v(this.tileID, this.map.transform.projection), [i, o, l, u] = this.coordinates.map((t1)=>{
                    const e = n.projection.project(t1[0], t1[1]);
                    return Av(n, e)._round();
                });
                this.perspectiveTransform = mb(i.x, i.y, o.x, o.y, l.x, l.y, u.x, u.y);
                const c = this._boundsArray = new Go;
                c.emplaceBack(i.x, i.y, 0, 0), c.emplaceBack(o.x, o.y, jn, 0), c.emplaceBack(u.x, u.y, 0, jn), c.emplaceBack(l.x, l.y, jn, jn), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t1.createVertexBuffer(c, db.members), this.boundsSegments = Ol.simpleSegment(0, 0, 4, 2);
                const h = [], p = [
                    yb((d = this.coordinates)[0]),
                    yb(d[1]),
                    yb(d[2]),
                    yb(d[3])
                ];
                var d;
                const [f, m, y, g] = function(t1) {
                    let e = t1[0][0], r = e, n = t1[0][1], i = n;
                    for(let s = 1; s < t1.length; s++)t1[s][0] < e ? e = t1[s][0] : t1[s][0] > r && (r = t1[s][0]), t1[s][1] < n ? n = t1[s][1] : t1[s][1] > i && (i = t1[s][1]);
                    return [
                        e,
                        n,
                        r - e,
                        i - n
                    ];
                }(p);
                {
                    const n = new Go, [i, o, l, u] = function(t1) {
                        let e = t1[0].x, r = e, n = t1[0].y, i = n;
                        for(let s = 1; s < t1.length; s++)t1[s].x < e ? e = t1[s].x : t1[s].x > r && (r = t1[s].x), t1[s].y < n ? n = t1[s].y : t1[s].y > i && (i = t1[s].y);
                        return [
                            e,
                            n,
                            r - e,
                            i - n
                        ];
                    }(r), c = (t1)=>[
                            (t1.x - i) / l,
                            (t1.y - o) / u
                        ], [p, d, x, v] = r.map(c), b = function(t1, e, r, n, i, o, l, u) {
                        const c = fb(0, 0, 1, 0, 1, 1, 0, 1);
                        return a(c, c, s([], fb(t1, e, r, n, i, o, l, u)));
                    }(p[0], p[1], d[0], d[1], x[0], x[1], v[0], v[1]);
                    this.elevatedGlobePerspectiveTransform = mb(p[0], p[1], d[0], d[1], x[0], x[1], v[0], v[1]);
                    const w = (t1, e)=>{
                        h.push(t1.lng);
                        const r = Math.round((t1.lng - f) / y * jn), i = Math.round((t1.lat - m) / g * jn), s = c(e), a = G([], [
                            s[0],
                            s[1],
                            1
                        ], b), o = Math.round(a[0] / a[2] * jn), l = Math.round(a[1] / a[2] * jn);
                        n.emplaceBack(r, i, o, l);
                    }, _ = r[3].x - r[0].x, A = r[3].y - r[0].y, I = r[2].x - r[1].x, M = r[2].y - r[1].y;
                    for(let t1 = 0; t1 < 65; t1++){
                        const n = t1 / 64, i = [
                            r[0].x + n * _,
                            r[0].y + n * A
                        ], s = [
                            r[1].x + n * I,
                            r[1].y + n * M
                        ], a = s[0] - i[0], o = s[1] - i[1];
                        for(let t1 = 0; t1 < 65; t1++){
                            const r = t1 / 64, n = {
                                x: i[0] + a * r,
                                y: i[1] + o * r
                            };
                            w(e.projection.unproject(n.x, n.y), n);
                        }
                    }
                    this.elevatedGlobeVertexBuffer = t1.createVertexBuffer(n, db.members);
                }
                {
                    this.maxLongitudeTriangleSize = 0;
                    let e = [], r = new ll;
                    const n = (t1, n, i)=>{
                        r.emplaceBack(t1, n, i);
                        const s = h[t1], a = h[n], o = h[i], l = Math.min(Math.min(s, a), o), u = Math.max(Math.max(s, a), o) - l;
                        u > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u), e.push(l + u / 2);
                    };
                    for(let t1 = 0; t1 < 64; t1++)for(let e = 0; e < 64; e++){
                        const r = 65 * t1 + e, i = r + 1, s = r + 65, a = s + 1;
                        n(r, s, i), n(i, s, a);
                    }
                    [e, r] = function(t1, e) {
                        const r = Array.from({
                            length: t1.length
                        }, (t1, e)=>e);
                        r.sort((e, r)=>t1[e] - t1[r]);
                        const n = [], i = new ll;
                        for(let s = 0; s < r.length; s++){
                            const a = r[s];
                            n.push(t1[a]);
                            const o = 3 * a, l = o + 1;
                            i.emplaceBack(e.uint16[o], e.uint16[l], e.uint16[l + 1]);
                        }
                        return [
                            n,
                            i
                        ];
                    }(e, r), this.elevatedGlobeTrianglesCenterLongitudes = e, this.elevatedGlobeIndexBuffer = t1.createIndexBuffer(r);
                }
                this.elevatedGlobeSegments = Ol.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([
                    0,
                    y / jn,
                    0,
                    g / jn,
                    0,
                    0,
                    m,
                    f,
                    0
                ]);
            }
            prepare() {
                const t1 = 0 !== Object.keys(this.tiles).length;
                if (this.tileID && !t1) return;
                const e = this.map.painter.context, r = e.gl;
                !this._dirty || this.texture instanceof Rm || (this.texture ? this.texture.update(this.image) : (this.texture = new Cm(e, this.image, r.RGBA8), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t1 && this._prepareData(e);
            }
            loadTile(t1, e) {
                this.tileID && this.tileID.equals(t1.tileID.canonical) ? (this.tiles[String(t1.tileID.wrap)] = t1, t1.buckets = {}, e(null)) : (t1.state = "errored", e(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
            getSegmentsForLongitude(t1) {
                const e = this.elevatedGlobeSegments;
                if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;
                const r = this.elevatedGlobeTrianglesCenterLongitudes;
                let n = (i = t1 + 180) + 360 * Math.round((r[0] - i) / 360);
                var i;
                const s = new Ol, a = (t1, r)=>{
                    s.segments.push({
                        vertexOffset: 0,
                        primitiveOffset: t1,
                        vertexLength: e.segments[0].vertexLength,
                        primitiveLength: r,
                        sortKey: void 0,
                        vaos: {}
                    });
                }, o = .51 * this.maxLongitudeTriangleSize;
                if (Math.abs(r[0] - n) <= o) {
                    const t1 = ne(r, 0, r.length, n + o);
                    return t1 === r.length || a(t1, re(r, t1 + 1, r.length, n + 360 - o) - t1), s;
                }
                n < r[0] && (n += 360);
                const l = re(r, 0, r.length, n - o);
                if (l === r.length) return a(0, r.length), s;
                a(0, l - 0);
                const u = ne(r, l + 1, r.length, n + o);
                return u !== r.length && a(u, r.length - u), s;
            }
        }
        const xb = (Math.pow(256, 2) - 1) / 16907520;
        class vb extends Fo {
            constructor(t1, e, r, n){
                super(t1, {
                    layout: hb || (hb = new uo({
                        visibility: new ao(co.layout_raster.visibility)
                    })),
                    paint: pb || (pb = new uo({
                        "raster-opacity": new ao(co.paint_raster["raster-opacity"]),
                        "raster-color": new lo(co.paint_raster["raster-color"]),
                        "raster-color-mix": new ao(co.paint_raster["raster-color-mix"]),
                        "raster-color-range": new ao(co.paint_raster["raster-color-range"]),
                        "raster-hue-rotate": new ao(co.paint_raster["raster-hue-rotate"]),
                        "raster-brightness-min": new ao(co.paint_raster["raster-brightness-min"]),
                        "raster-brightness-max": new ao(co.paint_raster["raster-brightness-max"]),
                        "raster-saturation": new ao(co.paint_raster["raster-saturation"]),
                        "raster-contrast": new ao(co.paint_raster["raster-contrast"]),
                        "raster-resampling": new ao(co.paint_raster["raster-resampling"]),
                        "raster-fade-duration": new ao(co.paint_raster["raster-fade-duration"]),
                        "raster-emissive-strength": new ao(co.paint_raster["raster-emissive-strength"]),
                        "raster-array-band": new ao(co.paint_raster["raster-array-band"]),
                        "raster-elevation": new ao(co.paint_raster["raster-elevation"]),
                        "raster-color-use-theme": new oo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                }, e, r, n), this.updateColorRamp(), this._curRampRange = [
                    NaN,
                    NaN
                ];
            }
            getProgramIds() {
                return [
                    "raster"
                ];
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-color"].value.value;
            }
            tileCoverLift() {
                return this.paint.get("raster-elevation");
            }
            isDraped(t1) {
                return !(t1 && t1._source instanceof gb && (t1._source.onNorthPole || t1._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-color" !== t1 && "raster-color-range" !== t1 || (this._curRampRange = [
                    NaN,
                    NaN
                ], this.updateColorRamp());
            }
            _clear() {
                this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
            }
            updateColorRamp(t1) {
                if (!this.hasColorMap()) return;
                if (!this._curRampRange) return;
                const e = this._transitionablePaint._values["raster-color"].value.expression, [r, n] = t1 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({
                    zoom: 0
                }) || [
                    NaN,
                    NaN
                ];
                isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = Zh({
                    expression: e,
                    evaluationKey: "rasterValue",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: r,
                            end: n
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null, this._curRampRange = [
                    r,
                    n
                ]);
            }
        }
        let bb, wb, _b, Ab, Ib;
        class Mb extends Fo {
            constructor(t1, e, r, n){
                super(t1, {
                    layout: bb || (bb = new uo({
                        visibility: new ao(co["layout_raster-particle"].visibility)
                    })),
                    paint: wb || (wb = new uo({
                        "raster-particle-array-band": new ao(co["paint_raster-particle"]["raster-particle-array-band"]),
                        "raster-particle-count": new ao(co["paint_raster-particle"]["raster-particle-count"]),
                        "raster-particle-color": new lo(co["paint_raster-particle"]["raster-particle-color"]),
                        "raster-particle-max-speed": new ao(co["paint_raster-particle"]["raster-particle-max-speed"]),
                        "raster-particle-speed-factor": new ao(co["paint_raster-particle"]["raster-particle-speed-factor"]),
                        "raster-particle-fade-opacity-factor": new ao(co["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
                        "raster-particle-reset-rate-factor": new ao(co["paint_raster-particle"]["raster-particle-reset-rate-factor"]),
                        "raster-particle-elevation": new ao(co["paint_raster-particle"]["raster-particle-elevation"]),
                        "raster-particle-color-use-theme": new oo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                }, e, r, n), this._updateColorRamp(), this.lastInvalidatedAt = ge.now();
            }
            _clear() {
                this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this.tileFramebuffer && (this.tileFramebuffer.destroy(), this.tileFramebuffer = null), this.particleFramebuffer && (this.particleFramebuffer.destroy(), this.particleFramebuffer = null);
            }
            onRemove(t1) {
                this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-particle-color"].value.value;
            }
            getProgramIds() {
                return [
                    "rasterParticle"
                ];
            }
            hasOffscreenPass() {
                return "none" !== this.visibility;
            }
            isDraped(t1) {
                return !1;
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-particle-color" !== t1 && "raster-particle-max-speed" !== t1 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t1 && this._invalidateAnimationState();
            }
            _updateColorRamp() {
                if (!this.hasColorMap()) return;
                const t1 = this._transitionablePaint._values["raster-particle-color"].value.expression, e = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({
                    zoom: 0
                });
                this.colorRamp = Zh({
                    expression: t1,
                    evaluationKey: "rasterParticleSpeed",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: 0,
                            end: e
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null;
            }
            _invalidateAnimationState() {
                this.lastInvalidatedAt = ge.now();
            }
            tileCoverLift() {
                return this.paint.get("raster-particle-elevation");
            }
        }
        class Sb extends Fo {
            constructor(t1, e){
                super(t1, {}, e, null), this.implementation = t1, t1.slot && (this.slot = t1.slot);
            }
            is3D(t1) {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            isDraped(t1) {
                return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {}
            onAdd(t1) {
                this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
            }
            onRemove(t1) {
                this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
            }
        }
        function Pb(t1, e, r) {
            const n = [
                0,
                0,
                1
            ], i = rt([]);
            return it(i, i, r ? -Bt(t1) + Math.PI : Bt(t1)), nt(i, i, -Bt(e)), $(n, n, i), L(n, n);
        }
        const zb = {
            None: 0,
            Model: 1,
            Symbol: 2,
            FillExtrusion: 4
        };
        class Bb {
            constructor(t1, e, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
            }
        }
        function kb(t1, e) {
            const r = -1 === t1.indexOf("://");
            try {
                return new URL(t1, r && e ? "http://example.com" : void 0), !0;
            } catch (t1) {
                return !1;
            }
        }
        class Tb {
            constructor(t1, e){
                this.feature = t1, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [
                    0,
                    0,
                    0
                ], this.scale = [
                    1,
                    1,
                    1
                ], this.translation = [
                    0,
                    0,
                    0
                ];
            }
        }
        class Vb {
            constructor(){
                this.maxScale = 1, this.maxXYTranslationDistance = 0, this.instancedDataArray = new vl, this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
            }
            colorForInstance(t1) {
                const e = 16 * t1, r = this.instancedDataArray.float32;
                let n = Math.floor(r[e + 2]);
                const i = 1.05 * (r[e + 2] - n);
                return n /= 100, [
                    r[e] % 1 * 1.05,
                    r[e + 1] % 1 * 1.05,
                    i,
                    n
                ];
            }
            tileCoordinatesForInstance(t1) {
                const e = 16 * t1, r = this.instancedDataArray.float32;
                let n = r[e + 0];
                return n = n > jn ? n - jn : n, new Mt(Math.trunc(n), Math.trunc(r[e + 1]));
            }
            translationForInstance(t1) {
                const e = 16 * t1, r = this.instancedDataArray.float32;
                return [
                    r[e + 4],
                    r[e + 5],
                    r[e + 6]
                ];
            }
            rotationScaleForInstance(t1) {
                const e = 16 * t1, r = this.instancedDataArray.float32;
                return [
                    r[e + 7],
                    r[e + 8],
                    r[e + 9],
                    r[e + 10],
                    r[e + 11],
                    r[e + 12],
                    r[e + 13],
                    r[e + 14],
                    r[e + 15]
                ];
            }
            transformForInstance(t1) {
                const e = 16 * t1, r = this.instancedDataArray.float32;
                return [
                    r[e + 7],
                    r[e + 8],
                    r[e + 9],
                    r[e + 4],
                    r[e + 10],
                    r[e + 11],
                    r[e + 12],
                    r[e + 5],
                    r[e + 13],
                    r[e + 14],
                    r[e + 15],
                    r[e + 6],
                    0,
                    0,
                    0,
                    1
                ];
            }
        }
        class Eb {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaledZ = this.canonical.z + Math.log2(t1.overscaling), this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.projection = t1.projection, this.index = t1.index, this.worldview = t1.worldview, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z + 1 ? 0 : this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {
                    id: null,
                    timestamp: 0
                }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t1.styleDefinedModelURLs, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {}
            updateAppearances(t1, e, r, n) {}
            populate(t1, e, r, n) {
                this.tileToMeter = ju(r);
                const i = this.layers[0]._featureFilter.needGeometry;
                this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                for (const { feature: s, id: a, index: o, sourceLayerIndex: l } of t1){
                    const t1 = null != a ? a : s.properties && s.properties.hasOwnProperty("id") ? s.properties.id : void 0, u = Ku(s, i);
                    if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, {
                        worldview: this.worldview,
                        activeFloors: e.activeFloors
                    }), u, r)) continue;
                    const c = {
                        id: t1,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: i ? u.geometry : Ju(s, r, n),
                        properties: s.properties,
                        type: s.type,
                        patterns: {}
                    }, h = this.addFeature(c, c.geometry, u);
                    h && e.featureIndex.insert(s, c.geometry, o, l, this.index, this.instancesPerModel[h].instancedDataArray.length, 256);
                }
                this.lookup = null;
            }
            evaluateQueryRenderedFeaturePadding() {
                const t1 = this.layers[0].modelManager, e = this.layers[0].scope;
                let r = 0;
                for (const n of this.modelUris){
                    const i = t1.getModel(n, e);
                    if (!i) continue;
                    const s = this.instancesPerModel[n];
                    if (s) {
                        const t1 = .5 * F(i.aabb.max, i.aabb.min) * s.maxScale + s.maxXYTranslationDistance, e = Math.min(jn, Math.max(t1 / this.tileToMeter, 256));
                        r = Math.max(e, r);
                    }
                }
                return r;
            }
            update(t1, e, r, n) {
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for(const e in t1)r.idToFeaturesIndex.hasOwnProperty(e) && (this.evaluate(r.features[r.idToFeaturesIndex[e]], t1[e], r, !0), this.uploaded = !1);
                }
                this.maxHeight = 0;
            }
            updateZoomBasedPaintProperties() {
                if (!this.hasZoomDependentProperties) return !1;
                let t1 = !1;
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for (const e of r.features){
                        const n = this.layers[0], i = e.feature, s = this.canonical, a = n.paint.get("model-rotation").evaluate(i, {}, s), o = n.paint.get("model-scale").evaluate(i, {}, s), l = n.paint.get("model-translation").evaluate(i, {}, s);
                        X(e.rotation, a) && X(e.scale, o) && X(e.translation, l) || (this.evaluate(e, e.featureStates, r, !0), t1 = !0);
                    }
                }
                return t1;
            }
            updateReplacement(t1, e, r, n) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const i = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                if (Nd(this.activeReplacements, i)) return !1;
                this.activeReplacements = i;
                let s = !1;
                for(const e in this.instancesPerModel){
                    const i = this.instancesPerModel[e], a = i.instancedDataArray;
                    for (const e of i.features){
                        const i = e.instancedDataOffset, o = e.instancedDataCount;
                        for(let e = 0; e < o; e++){
                            const o = 16 * (e + i);
                            let l = a.float32[o + 0];
                            const u = l > jn;
                            l = u ? l - jn : l;
                            const c = Math.floor(l), h = Math.floor(a.float32[o + 1]);
                            let p = !1;
                            for (const e of this.activeReplacements)if (!Rd(e, r, zb.Model, n) && !(e.min.x > c || c > e.max.x || e.min.y > h || h > e.max.y) && (p = Hd(Xd(c, h, t1.canonical, e.footprintTileId.canonical), e.footprint), p)) break;
                            a.float32[o] = p ? l + jn : l, s = s || p !== u;
                        }
                    }
                }
                return s;
            }
            isEmpty() {
                for(const t1 in this.instancesPerModel)if (0 !== this.instancesPerModel[t1].instancedDataArray.length) return !1;
                return !0;
            }
            uploadPending() {
                return !this.uploaded;
            }
            upload(t1) {
                if (!this.uploaded) for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t1.createVertexBuffer(r.instancedDataArray, Gm.members, !0, void 0, this.instanceCount));
                }
                this.uploaded = !0;
            }
            destroy(t1) {
                for(const t1 in this.instancesPerModel){
                    const e = this.instancesPerModel[t1];
                    0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();
                }
                const e = this.layers[0].modelManager;
                if (t1 && e && this.modelUris && this.modelsRequested) for (const t1 of this.modelUris)e.removeModel(t1, "", !0);
            }
            addFeature(t1, e, r) {
                const n = this.layers[0], i = n.layout.get("model-id"), s = n.layout.get("model-allow-density-reduction"), a = i.evaluate(r, {}, this.canonical);
                if (!a) return Zt(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), a;
                (kb(a, !1) || void 0 !== this.styleDefinedModelURLs[a]) && (this.modelUris.includes(a) || this.modelUris.push(a)), this.instancesPerModel[a] || (this.instancesPerModel[a] = new Vb);
                const o = this.instancesPerModel[a], l = o.instancedDataArray, u = new Tb(r, l.length);
                for (const t1 of e)for (const e of t1){
                    if (e.x < 0 || e.x >= jn || e.y < 0 || e.y >= jn) continue;
                    if (0 !== this.lookupDim && s) {
                        const t1 = (this.lookupDim - 1) / jn, r = this.lookupDim * (e.y * t1 | 0) + e.x * t1 | 0;
                        if (this.lookup) {
                            if (0 !== this.lookup[r]) continue;
                            this.lookup[r] = 1;
                        }
                    }
                    this.instanceCount++;
                    const t1 = l.length;
                    l.resize(t1 + 1), o.instancesEvaluatedElevation.push(0), l.float32[16 * t1] = e.x, l.float32[16 * t1 + 1] = e.y;
                }
                return u.instancedDataCount = o.instancedDataArray.length - u.instancedDataOffset, u.instancedDataCount > 0 && (t1.id && (o.idToFeaturesIndex[t1.id] = o.features.length), o.features.push(u), this.evaluate(u, {}, o, !1)), a;
            }
            getModelUris() {
                return this.modelUris;
            }
            evaluate(t1, e, r, n) {
                const i = this.layers[0], s = t1.feature, a = this.canonical, o = t1.rotation = i.paint.get("model-rotation").evaluate(s, e, a), l = t1.scale = i.paint.get("model-scale").evaluate(s, e, a), u = t1.translation = i.paint.get("model-translation").evaluate(s, e, a), c = Object.assign({}, i.paint.get("model-color").evaluate(s, e, a));
                c.a = i.paint.get("model-color-mix-intensity").evaluate(s, e, a);
                const h = [];
                this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]);
                const p = u[0] * u[0] + u[1] * u[1], d = p > 0 ? Math.sqrt(p) : 0;
                r.maxScale = Math.max(Math.max(r.maxScale, l[0]), Math.max(l[1], l[2])), r.maxXYTranslationDistance = Math.max(r.maxXYTranslationDistance, d), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), Jm(h, o, l);
                const f = Math.round(100 * c.a) + c.b / 1.05;
                for(let e = 0; e < t1.instancedDataCount; ++e){
                    const i = t1.instancedDataOffset + e, s = 16 * i, o = r.instancedDataArray.float32;
                    let l = 0;
                    n && (l = o[s + 6] - r.instancesEvaluatedElevation[i]);
                    const p = 0 | o[s + 1];
                    o[s] = (0 | o[s]) + c.r / 1.05, o[s + 1] = p + c.g / 1.05, o[s + 2] = f, o[s + 3] = 1 / (a.z > 10 ? this.tileToMeter : ju(a, p)), o[s + 4] = u[0], o[s + 5] = u[1], o[s + 6] = u[2] + l, o[s + 7] = h[0], o[s + 8] = h[1], o[s + 9] = h[2], o[s + 10] = h[4], o[s + 11] = h[5], o[s + 12] = h[6], o[s + 13] = h[8], o[s + 14] = h[9], o[s + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];
                }
            }
        }
        let Fb, Db;
        Qs(Eb, "ModelBucket", {
            omit: [
                "layers"
            ]
        }), Qs(Vb, "PerModelAttributes"), Qs(Tb, "ModelFeature");
        class Cb {
            constructor(t1, e, r){
                this._demTile = t1, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
            }
            static create(t1, e, r) {
                const n = r || t1.findDEMTileFor(e);
                if (!n || !n.dem) return;
                const i = n.dem, s = n.tileID, a = 1 << e.canonical.z - s.canonical.z;
                return new Cb(n, i.dim / jn / a, [
                    (e.canonical.x / a - s.canonical.x) * i.dim,
                    (e.canonical.y / a - s.canonical.y) * i.dim
                ]);
            }
            tileCoordToPixel(t1, e) {
                const r = e * this._scale + this._offset[1];
                return new Mt(Math.floor(t1 * this._scale + this._offset[0]), Math.floor(r));
            }
            getElevationAt(t1, e, r, n) {
                const i = t1 * this._scale + this._offset[0], s = e * this._scale + this._offset[1], a = Math.floor(i), o = Math.floor(s), l = this._dem;
                return n = !!n, r ? dr(dr(l.get(a, o, n), l.get(a, o + 1, n), s - o), dr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
            }
            getElevationAtPixel(t1, e, r) {
                return this._dem.get(t1, e, !!r);
            }
            getMeterToDEM(t1) {
                return (1 << this._demTile.tileID.canonical.z) * Fu(1, t1) * this._dem.stride;
            }
        }
        const Rb = new Float32Array(262144), Lb = new Uint8Array(262144);
        function Ob(t1) {
            let e = 0;
            if (t1.meshes) for (const r of t1.meshes)e = Math.max(e, r.aabb.max[2]);
            if (t1.children) for (const r of t1.children)e = Math.max(e, Ob(r));
            return e;
        }
        function Ub(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes){
                if (n.aabb.min[0] === 1 / 0) continue;
                const i = wc.applyTransform(n.aabb, t1.globalMatrix);
                r.insert(e, i.min[0], i.min[1], i.max[0], i.max[1]);
            }
            if (t1.children) for (const n of t1.children)Ub(n, e, r);
        }
        const Nb = [
            "",
            "wall",
            "door",
            "roof",
            "window",
            "lamp",
            "logo"
        ];
        class jb {
            constructor(t1){
                this.node = t1, this.evaluatedRMEA = [
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        .4,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ]
                ], this.hiddenByReplacement = !1, this.evaluatedTranslation = [
                    0,
                    0,
                    0
                ], this.evaluatedScale = [
                    1,
                    1,
                    1
                ], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {
                    type: "Point",
                    id: t1.id,
                    geometry: [],
                    properties: {
                        height: Ob(t1)
                    }
                }, this.aabb = this._getLocalBounds(), this.state = null;
            }
            _getLocalBounds() {
                if (!this.node.meshes) return new wc([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]);
                if (!this.aabb) {
                    let t1 = 0;
                    const e = new wc([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]);
                    for (const r of this.node.meshes)this.node.lightMeshIndex !== t1 && (r.transformedAabb = wc.applyTransformFast(r.aabb, this.node.globalMatrix), e.encapsulate(r.transformedAabb)), t1++;
                    this.aabb = e;
                }
                return this.aabb;
            }
        }
        class Gb {
            constructor(t1, e, r, n, i, s, a, o){
                this.id = r, this.layers = t1, this.layerIds = this.layers.map((t1)=>t1.fqid), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.modelTraits |= ry.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, n && (this.modelTraits |= ry.HasMapboxMeshFeatures), i && (this.modelTraits |= ry.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {
                    name: "mercator"
                }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s, this.worldview = o, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = [];
                for (const t1 of e)this.nodesInfo.push(new jb(t1)), Ub(t1, a.featureIndexArray.length, a.grid), a.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, a.bucketLayerIDs.length - 1, 0);
                this.states = {}, this.hasAppearances = null;
            }
            updateFootprints(t1, e) {
                for (const r of this.getNodesInfo()){
                    const n = r.node;
                    n.footprint && e.push({
                        footprint: n.footprint,
                        id: t1
                    });
                }
            }
            updateAppearances(t1, e, r, n) {}
            update(t1) {
                const e = 0 !== Object.keys(t1).length;
                if (e && !this.stateDependentLayers.length) return;
                const r = e ? this.stateDependentLayers : this.layers;
                if (!St(t1, this.states)) for (const e of r)this.evaluate(e, t1);
                this.states = structuredClone(t1);
            }
            populate() {
                console.log("populate 3D model bucket");
            }
            uploadPending() {
                return !this.uploaded || this.needsUpload;
            }
            upload(t1) {
                if (!this.needsUpload) return;
                const e = this.getNodesInfo();
                for (const r of e){
                    const e = r.node;
                    this.uploaded ? this.updatePbrBuffer(e) : oy(e, t1, !0);
                }
                for (const t1 of e)ly(t1.node);
                this.uploaded = !0, this.needsUpload = !1;
            }
            updatePbrBuffer(t1) {
                let e = !1;
                if (!t1.meshes) return e;
                for (const r of t1.meshes)r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);
                return e;
            }
            needsReEvaluation(t1, e, r) {
                const n = t1.transform.projectionOptions, i = t1.style.getBrightness(), s = this.brightness !== i;
                if (!this.uploaded || this.dirty || n.name !== this.projection.name || $b(r.paint.get("model-color").value, s) || $b(r.paint.get("model-color-mix-intensity").value, s) || $b(r.paint.get("model-roughness").value, s) || $b(r.paint.get("model-emissive-strength").value, s) || $b(r.paint.get("model-height-based-emissive-strength-multiplier").value, s)) {
                    this.projection = n, this.brightness = i;
                    const t1 = this.getNodesInfo();
                    for (const e of t1)e.state = null;
                    return !0;
                }
                return !1;
            }
            evaluateTransform(t1, e) {
                if (t1.transform.zoom === this.zoom) return;
                this.zoom = t1.transform.zoom;
                const r = this.getNodesInfo(), n = this.id.canonical;
                for (const t1 of r){
                    const r = t1.feature;
                    t1.evaluatedTranslation = e.paint.get("model-translation").evaluate(r, {}, n), t1.evaluatedScale = e.paint.get("model-scale").evaluate(r, {}, n);
                }
            }
            evaluate(t1, e) {
                const r = this.getNodesInfo();
                for (const n of r){
                    if (!n.node.meshes) continue;
                    const r = n.feature, i = e && e[r.id];
                    if (St(i, n.state)) continue;
                    n.state = structuredClone(i);
                    const s = n.node.meshes && n.node.meshes[0].featureData, a = n.evaluatedColor[2], o = n.evaluatedRMEA[2], l = this.id.canonical;
                    if (n.hasTranslucentParts = !1, s) {
                        for(let e = 0; e < Nb.length; e++){
                            const s = Nb[e];
                            s.length && (r.properties.part = s);
                            const a = t1.paint.get("model-color").evaluate(r, i, l).toPremultipliedRenderColor(null), o = t1.paint.get("model-color-mix-intensity").evaluate(r, i, l);
                            n.evaluatedColor[e] = [
                                a.r,
                                a.g,
                                a.b,
                                o
                            ], n.evaluatedRMEA[e][0] = t1.paint.get("model-roughness").evaluate(r, i, l), n.evaluatedRMEA[e][2] = t1.paint.get("model-emissive-strength").evaluate(r, i, l), n.evaluatedRMEA[e][3] = a.a, n.emissionHeightBasedParams[e] = t1.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r, i, l), !n.hasTranslucentParts && a.a < 1 && (n.hasTranslucentParts = !0);
                        }
                        delete r.properties.part, Xb(n, a !== n.evaluatedColor[2] || o !== n.evaluatedRMEA[2], this.modelTraits);
                    } else n.evaluatedRMEA[0][2] = t1.paint.get("model-emissive-strength").evaluate(r, i, l);
                    n.evaluatedTranslation = t1.paint.get("model-translation").evaluate(r, i, l), n.evaluatedScale = t1.paint.get("model-scale").evaluate(r, i, l), this.updatePbrBuffer(n.node) || (this.needsUpload = !0);
                }
                this.dirty = !1;
            }
            elevationUpdate(t1, e, r, n) {
                const i = t1.findDEMTileFor(r);
                if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {
                    if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {
                        this.elevationReadFromZ = i.tileID.overscaledZ;
                        const e = Cb.create(t1, r, i);
                        if (!e) return;
                        this.modelTraits & ry.HasMapboxMeshFeatures && this.updateDEM(t1, e, r, n);
                        for (const t1 of this.getNodesInfo()){
                            const r = t1.node;
                            if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;
                            const n = r.footprint.vertices;
                            let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);
                            for(let t1 = 1; t1 < n.length; t1++)i = Math.min(i, e.getElevationAt(n[t1].x, n[t1].y, !0, !0));
                            r.elevation = i;
                        }
                    }
                    this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;
                }
            }
            updateDEM(t1, e, r, n) {
                let i = e._dem._modifiedForSources[n];
                if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;
                const s = e._dem.dim;
                i.push(r.canonical);
                let a = !1;
                for (const t1 of this.getNodesInfo()){
                    const r = t1.node;
                    if (!r.footprint || !r.footprint.grid) continue;
                    const n = r.footprint.grid, i = e.tileCoordToPixel(n.min.x, n.min.y), o = e.tileCoordToPixel(n.max.x, n.max.y), l = Math.min(Math.min(s - o.y, i.x), Math.min(i.y, s - o.x));
                    if (l < 0) continue;
                    const u = Dt(l, 2, 5);
                    let c = Math.max(0, i.x - u), h = Math.max(0, i.y - u), p = Math.min(o.x + u, s - 1), d = Math.min(o.y + u, s - 1);
                    for(let t1 = h; t1 <= d; ++t1)for(let e = c; e <= p; ++e)Lb[t1 * s + e] = 255;
                    let f = 0, m = 0;
                    for(let t1 = 0; t1 < n.cellsY; ++t1)for(let r = 0; r < n.cellsX; ++r){
                        if (!n.cells[t1 * n.cellsX + r]) continue;
                        const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t1 / n.yScale), a = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t1 + 1) / n.yScale);
                        for(let t1 = i.y; t1 <= Math.min(a.y + 1, s - 1); ++t1)for(let r = i.x; r <= Math.min(a.x + 1, s - 1); ++r)255 === Lb[t1 * s + r] && (Lb[t1 * s + r] = 0, f += e.getElevationAtPixel(r, t1), m++);
                    }
                    const y = f / m;
                    c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(o.x + u, s - 2), d = Math.min(o.y + u, s - 2), a = !0;
                    for(let t1 = h; t1 <= d; ++t1)for(let r = c; r <= p; ++r)0 === Lb[t1 * s + r] && (Rb[t1 * s + r] = e._dem.set(r, t1, y));
                    for(let t1 = 1; t1 < u; ++t1){
                        c = Math.max(1, i.x - t1), h = Math.max(1, i.y - t1), p = Math.min(o.x + t1, s - 2), d = Math.min(o.y + t1, s - 2);
                        for(let r = h; r <= d; ++r)for(let n = c; n <= p; ++n){
                            const i = r * s + n;
                            if (255 === Lb[i]) {
                                let a = 0, o = 0, l = -1, c = -1;
                                for(let e = -1; e <= 1; ++e)for(let i = -1; i <= 1; ++i){
                                    const u = (r + e) * s + n + i;
                                    if (Lb[u] >= t1) continue;
                                    const h = Rb[u], p = Math.abs(h);
                                    p > o && (a = h, o = p, l = i, c = e);
                                }
                                if (o > .1) {
                                    const s = 1 - (t1 + .5 * Math.abs(l * c)) / u;
                                    let o = e._dem.get(n, r) + a * s;
                                    const h = e._dem.get(n + l, r + c), p = e._dem.get(n - l, r - c, !0);
                                    (o - h) * (o - p) > 0 && (o = (h + p) / 2), Rb[i] = e._dem.set(n, r, o), Lb[i] = t1;
                                }
                            }
                        }
                    }
                }
                a && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = ge.now());
            }
            setFilter(t1) {
                this.filter = t1 ? mo(t1) : null;
            }
            getNodesInfo() {
                return this.filter ? this.nodesInfo.filter((t1)=>this.filter.filter(new Ja(this.id.overscaledZ, {
                        worldview: this.worldview
                    }), t1.feature, this.id.canonical)) : this.nodesInfo;
            }
            destroy() {
                const t1 = this.getNodesInfo();
                for (const e of t1)ly(e.node), cy(e.node);
            }
            isEmpty() {
                return !this.nodesInfo.length;
            }
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped());
                for (const t1 of this.getNodesInfo()){
                    const e = t1.node.footprint;
                    t1.hiddenByReplacement = !!e && !r.find((t1)=>t1.footprint === e);
                }
            }
            getHeightAtTileCoord(t1, e) {
                const r = [], n = [
                    0,
                    0,
                    0
                ], i = u([]);
                for (const s of this.getNodesInfo()){
                    const a = s.node.meshes[0], o = a.transformedAabb;
                    if (t1 < o.min[0] || e < o.min[1] || t1 > o.max[0] || e > o.max[1]) continue;
                    if (!0 === s.node.hidden) return {
                        height: 1 / 0,
                        maxHeight: s.feature.properties.height,
                        hidden: !1,
                        verticalScale: s.evaluatedScale[2]
                    };
                    c(i, s.node.globalMatrix), n[0] = t1, n[1] = e, j(n, n, i);
                    const l = (n[0] - a.aabb.min[0]) / (a.aabb.max[0] - a.aabb.min[0]) * ey | 0, u = Math.min(63, (n[1] - a.aabb.min[1]) / (a.aabb.max[1] - a.aabb.min[1]) * ey | 0) * ey + Math.min(63, l), h = a.heightmap[u];
                    if (!(h < 0 && s.node.footprint)) {
                        if (s.hiddenByReplacement) return;
                        return {
                            height: h,
                            maxHeight: s.feature.properties.height,
                            hidden: !1,
                            verticalScale: s.evaluatedScale[2]
                        };
                    }
                    if (s.node.footprint.grid.query(new Mt(t1, e), new Mt(t1, e), r), r.length > 0) return {
                        height: void 0,
                        maxHeight: s.feature.properties.height,
                        hidden: s.hiddenByReplacement,
                        verticalScale: s.evaluatedScale[2]
                    };
                }
            }
        }
        function $b(t1, e) {
            return t1 instanceof Gs && !t1.isLightConstant && e;
        }
        function qb(t1, e, r, n, i, s, a, o) {
            let l = (61440 & e | (61440 & e) >> 4) >> 8, u = (3840 & e | (3840 & e) >> 4) >> 4, c = 240 & e | (240 & e) >> 4;
            r[3] > 0 && (l = dr(l, 255 * r[0], r[3]), u = dr(u, 255 * r[1], r[3]), c = dr(c, 255 * r[2], r[3]));
            const h = l << 8 | u, p = c << 8 | Math.floor(255 * n[3]), d = function(t1) {
                const e = Dt(t1, 0, 2);
                return Math.min(Math.round(.5 * e * 255), 255);
            }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1], f = Dt(i[0], 0, 1), m = Dt(i[1], 0, 1), y = Dt(i[2], 0, 1), g = Dt(i[3], 0, 1);
            let x, v, b, w;
            if (f !== m && a !== s && m !== f) {
                const t1 = a - s;
                v = 1 / (t1 * (m - f)), b = -(s + t1 * f) / (t1 * (m - f));
                const e = Dt(i[4], -1, 1);
                w = Math.pow(10, e), x = 255 * y << 8 | 255 * g;
            } else x = 65535, v = 0, b = 1, w = 1;
            if (t1.emplaceBack(h, p, d, x, v, b, w), o) {
                const t1 = o.length;
                o.clear();
                for(let e = 0; e < t1; e++)o.emplaceBack(h, p, d, x, v, b, w);
            }
        }
        function Xb(t1, e, r) {
            const n = t1.node;
            let i = 0;
            const s = r & ry.HasMeshoptCompression;
            for (const r of n.meshes){
                if (n.lights && n.lightMeshIndex === i) continue;
                if (!r.featureData) continue;
                r.featureArray = new bl, r.featureArray.reserve(r.featureData.length);
                let a = e;
                for (const e of r.featureData){
                    const i = s ? 65535 & e : e >> 16 & 65535, o = s ? e >> 16 & 65535 : 65535 & e, l = (15 & o) < 8 ? 15 & o : 0, u = t1.evaluatedRMEA[l], c = t1.evaluatedColor[l], h = t1.emissionHeightBasedParams[l];
                    let p;
                    if (a && 2 === l && n.lights && (p = new bl, p.resize(10 * n.lights.length)), qb(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && a) {
                        a = !1;
                        const t1 = n.meshes[n.lightMeshIndex];
                        t1.featureArray = p, t1.featureArray._trim();
                    }
                }
                r.featureArray._trim(), i++;
            }
        }
        Qs(Gb, "Tiled3dModelBucket", {
            omit: [
                "layers"
            ]
        }), Qs(jb, "Tiled3dModelFeature");
        const Hb = [
            "id",
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class Zb {
            constructor(t1, e, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, this._z = e, this._x = r, this._y = n, this.properties = t1 ? t1.properties : {}, this.id = i;
            }
            clone() {
                const t1 = new Zb(this._vectorTileFeature, this._z, this._x, this._y, this.id);
                return this.state && (t1.state = Object.assign({}, this.state)), this.layer && (t1.layer = Object.assign({}, this.layer)), this.source && (t1.source = this.source), this.sourceLayer && (t1.sourceLayer = this.sourceLayer), t1;
            }
            get geometry() {
                return void 0 === this._geometry && this._vectorTileFeature && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    type: "Feature",
                    state: void 0,
                    geometry: this.geometry,
                    properties: this.properties
                };
                for (const e of Hb)void 0 !== this[e] && (t1[e] = this[e]);
                return t1;
            }
        }
        class Wb extends ir {
            constructor(t1, e, r, n){
                super(), this.id = t1, this.type = "model", this.models = [], this._options = e, this._modelsInfo = new Map;
            }
            loadGLTFFromURI(t1) {
                return Em(this.map._requestManager.transformRequest(t1, Ce.Model).url);
            }
            load() {
                for(const t1 in this._options.models){
                    const e = this._options.models[t1], r = this._modelsInfo.get(t1);
                    if (r) {
                        r.modelSpec = e;
                        const t1 = r.model;
                        t1 && (t1.position = null != e.position ? new Bu(e.position[0], e.position[1]) : new Bu(0, 0), t1.orientation = null != e.orientation ? e.orientation : [
                            0,
                            0,
                            0
                        ], Wb.applyModelSpecification(t1, e), t1.computeBoundsAndApplyParent(), this.models.push(t1));
                    } else this._modelsInfo.set(t1, {
                        modelSpec: e,
                        model: null
                    }), this.loadGLTFFromURI(e.uri).then((e)=>{
                        if (!e) return;
                        const r = this._modelsInfo.get(t1);
                        if (!r) return;
                        const n = xy(e), i = r.modelSpec, s = new iy(t1, i.uri, i.position, i.orientation, n);
                        Wb.applyModelSpecification(s, i), s.computeBoundsAndApplyParent(), this.models.push(s), r.model = s, this.loaded() && this.fire(new tr("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        }));
                    }).catch((r)=>{
                        this.fire(new er(new Error(`Could not load model ${t1} from ${e.uri}: ${r.message}`)));
                    });
                }
                this.loaded() && this.fire(new tr("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                }));
            }
            static applyModelSpecification(t1, e) {
                e.nodeOverrides && Wb.convertNodeOverrides(t1, e.nodeOverrides), e.materialOverrides && Wb.convertMaterialOverrides(t1, e.materialOverrides), e.nodeOverrideNames && (t1.nodeOverrideNames = [
                    ...e.nodeOverrideNames
                ]), e.materialOverrideNames && (t1.materialOverrideNames = [
                    ...e.materialOverrideNames
                ]), e.featureProperties && (t1.featureProperties = e.featureProperties);
            }
            static convertNodeOverrides(t1, e) {
                if (Array.isArray(e) && e.every((t1)=>"string" == typeof t1)) {
                    t1.nodeOverrideNames = [];
                    for (const r of e)t1.nodeOverrideNames.push(r);
                } else Object.entries(e).forEach(([e, r])=>{
                    const n = {
                        orientation: [
                            0,
                            0,
                            0
                        ]
                    };
                    if (r.hasOwnProperty("orientation")) {
                        const t1 = r.orientation;
                        t1 && (n.orientation = t1);
                    }
                    t1.nodeOverrides.set(e, n);
                });
            }
            static convertMaterialOverrides(t1, e) {
                if (Array.isArray(e) && e.every((t1)=>"string" == typeof t1)) {
                    t1.materialOverrideNames = [];
                    for (const r of e)t1.materialOverrideNames.push(r);
                } else Object.entries(e).forEach(([e, r])=>{
                    const n = {
                        color: new ur(1, 1, 1),
                        colorMix: 0,
                        emissionStrength: 0,
                        opacity: 1
                    }, i = r["model-color"];
                    void 0 !== i && (n.color.r = i[0], n.color.g = i[1], n.color.b = i[2]);
                    const s = r["model-color-mix-intensity"];
                    void 0 !== s && (n.colorMix = s);
                    const a = r["model-emissive-strength"];
                    void 0 !== a && (n.emissionStrength = a);
                    const o = r["model-opacity"];
                    void 0 !== o && (n.opacity = o), t1.materialOverrides.set(e, n);
                });
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            hasTransition() {
                return !1;
            }
            loaded() {
                if (0 === this._modelsInfo.size) return !0;
                for (const t1 of this._modelsInfo.values())if (null == t1.model) return !1;
                return !0;
            }
            getModels() {
                return this.models;
            }
            loadTile(t1, e) {}
            serialize() {
                return this._options;
            }
            setProperty(t1, e) {
                return !1;
            }
            reload() {
                const t1 = zo(this.id, this.scope);
                this.map.style.clearSource(t1), this.models = [], this._modelsInfo.clear(), this.load();
            }
            setModels(t1) {
                this.models = [];
                const e = new Map;
                for(const r in t1){
                    const n = t1[r];
                    if (this._modelsInfo.has(r)) {
                        const t1 = this._modelsInfo.get(r);
                        t1 && t1.modelSpec.uri === n.uri && e.set(r, t1);
                    }
                }
                this._modelsInfo = e, this._options.models = t1, this.load();
            }
        }
        function Yb(t1, e, r, n) {
            const i = 1 << t1.z;
            e.lat = Cu((n / jn + t1.y) / i), e.lng = Du((r / jn + t1.x) / i);
        }
        function Jb(t1, e, r, n) {
            const i = t1.getNodesInfo()[e];
            if (!i || i.hiddenByReplacement || !i.node.meshes) return;
            let s = Number.MAX_VALUE;
            const a = i.node, o = r.tile, l = n.calculatePosMatrix(o.tileID.toUnwrapped(), n.worldSize), u = i.evaluatedScale;
            let c = 0;
            n.elevation && a.elevation && (c = a.elevation * n.elevation.exaggeration()), p(l, l, [
                (a.anchor ? a.anchor[0] : 0) * (u[0] - 1),
                (a.anchor ? a.anchor[1] : 0) * (u[1] - 1),
                c
            ]), d(l, l, u);
            const f = r.queryGeometry, m = f.isPointQuery() ? f.screenBounds : f.screenGeometry, y = function(t1) {
                const e = h([], l, t1.globalMatrix);
                h(e, n.expandedFarZProjMatrix, e);
                for(let r = 0; r < t1.meshes.length; ++r){
                    const i = t1.meshes[r];
                    if (r === t1.lightMeshIndex) continue;
                    const a = ty(m, n, e, i.aabb);
                    null != a && (s = Math.min(a, s));
                }
                if (t1.children) for (const e of t1.children)y(e);
            };
            if (y(a), s === Number.MAX_VALUE) return;
            const g = new Bu(0, 0);
            return Yb(o.tileID.canonical, g, i.node.anchor[0], i.node.anchor[1]), {
                intersectionZ: s,
                position: g,
                feature: i.feature
            };
        }
        const Kb = {
            circle: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Hc || (Hc = new uo({
                            "circle-sort-key": new oo(co.layout_circle["circle-sort-key"]),
                            "circle-elevation-reference": new ao(co.layout_circle["circle-elevation-reference"]),
                            visibility: new ao(co.layout_circle.visibility)
                        })),
                        paint: Zc || (Zc = new uo({
                            "circle-radius": new oo(co.paint_circle["circle-radius"]),
                            "circle-color": new oo(co.paint_circle["circle-color"]),
                            "circle-blur": new oo(co.paint_circle["circle-blur"]),
                            "circle-opacity": new oo(co.paint_circle["circle-opacity"]),
                            "circle-translate": new ao(co.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new ao(co.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new ao(co.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new ao(co.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new oo(co.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new oo(co.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new oo(co.paint_circle["circle-stroke-opacity"]),
                            "circle-emissive-strength": new ao(co.paint_circle["circle-emissive-strength"]),
                            "circle-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "circle-stroke-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                createBucket(t1) {
                    return new Sc(t1);
                }
                queryRadius(t1) {
                    const e = t1;
                    return Gc("circle-radius", this, e) + Gc("circle-stroke-width", this, e) + $c(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o) {
                    const l = Xc(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
                    return Vh(t1, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = Th(this);
                    return {
                        config: new du(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
                is3D(t1) {
                    return !t1 && !!this.layout && "none" !== this.layout.get("circle-elevation-reference");
                }
                hasElevation() {
                    return this.layout && "none" !== this.layout.get("circle-elevation-reference");
                }
            },
            heatmap: class extends Fo {
                createBucket(t1) {
                    return new Rh(t1);
                }
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Lh || (Lh = new uo({
                            visibility: new ao(co.layout_heatmap.visibility)
                        })),
                        paint: Oh || (Oh = new uo({
                            "heatmap-radius": new oo(co.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new oo(co.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new ao(co.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new lo(co.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new ao(co.paint_heatmap["heatmap-opacity"]),
                            "heatmap-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = Zh({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                _clear() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                queryRadius(t1) {
                    return Gc("heatmap-radius", this, t1);
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o) {
                    const l = this.paint.get("heatmap-radius").evaluate(e, r);
                    return Vh(t1, n, s, a, o, !0, !0, new Mt(0, 0), l);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return "heatmap" === t1 ? {
                        config: new du(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    } : {};
                }
            },
            hillshade: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Uh || (Uh = new uo({
                            visibility: new ao(co.layout_hillshade.visibility)
                        })),
                        paint: Nh || (Nh = new uo({
                            "hillshade-illumination-direction": new ao(co.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-anchor": new ao(co.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new ao(co.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new ao(co.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new ao(co.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new ao(co.paint_hillshade["hillshade-accent-color"]),
                            "hillshade-emissive-strength": new ao(co.paint_hillshade["hillshade-emissive-strength"]),
                            "hillshade-shadow-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "hillshade-highlight-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "hillshade-accent-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                shouldRedrape() {
                    return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
            },
            fill: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: bd || (bd = new uo({
                            "fill-sort-key": new oo(co.layout_fill["fill-sort-key"]),
                            visibility: new ao(co.layout_fill.visibility),
                            "fill-elevation-reference": new ao(co.layout_fill["fill-elevation-reference"]),
                            "fill-construct-bridge-guard-rail": new oo(co.layout_fill["fill-construct-bridge-guard-rail"])
                        })),
                        paint: wd || (wd = new uo({
                            "fill-antialias": new ao(co.paint_fill["fill-antialias"]),
                            "fill-opacity": new oo(co.paint_fill["fill-opacity"]),
                            "fill-color": new oo(co.paint_fill["fill-color"]),
                            "fill-outline-color": new oo(co.paint_fill["fill-outline-color"]),
                            "fill-translate": new ao(co.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new ao(co.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new oo(co.paint_fill["fill-pattern"]),
                            "fill-pattern-cross-fade": new ao(co.paint_fill["fill-pattern-cross-fade"]),
                            "fill-emissive-strength": new ao(co.paint_fill["fill-emissive-strength"]),
                            "fill-z-offset": new oo(co.paint_fill["fill-z-offset"]),
                            "fill-bridge-guard-rail-color": new oo(co.paint_fill["fill-bridge-guard-rail-color"]),
                            "fill-tunnel-structure-color": new oo(co.paint_fill["fill-tunnel-structure-color"]),
                            "fill-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-outline-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-bridge-guard-rail-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-tunnel-structure-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                getProgramIds() {
                    const t1 = this.paint.get("fill-pattern"), e = t1 && t1.constantOr(1), r = [
                        e ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        config: new du(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    };
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new vd(t1);
                }
                queryRadius() {
                    return $c(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    return !t1.queryGeometry.isAboveHorizon && Bc(qc(t1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return 0 === this.paint.get("fill-z-offset").constantOr(1);
                }
                is3D(t1) {
                    if (0 !== this.paint.get("fill-z-offset").constantOr(1)) return !0;
                    const e = this.layout && "none" !== this.layout.get("fill-elevation-reference");
                    return null != t1 ? e && !t1 : e;
                }
                hasElevation() {
                    return this.layout && "none" !== this.layout.get("fill-elevation-reference");
                }
                hasShadowPass() {
                    return this.layout && "none" !== this.layout.get("fill-elevation-reference");
                }
            },
            "fill-extrusion": class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Pf || (Pf = new uo({
                            visibility: new ao(co["layout_fill-extrusion"].visibility),
                            "fill-extrusion-edge-radius": new ao(co["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
                        })),
                        paint: zf || (zf = new uo({
                            "fill-extrusion-opacity": new ao(co["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new oo(co["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new ao(co["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new ao(co["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new oo(co["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-pattern-cross-fade": new ao(co["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]),
                            "fill-extrusion-height": new oo(co["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new oo(co["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-height-alignment": new ao(co["paint_fill-extrusion"]["fill-extrusion-height-alignment"]),
                            "fill-extrusion-base-alignment": new ao(co["paint_fill-extrusion"]["fill-extrusion-base-alignment"]),
                            "fill-extrusion-vertical-gradient": new ao(co["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                            "fill-extrusion-ambient-occlusion-intensity": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                            "fill-extrusion-ambient-occlusion-radius": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                            "fill-extrusion-ambient-occlusion-wall-radius": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
                            "fill-extrusion-ambient-occlusion-ground-radius": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
                            "fill-extrusion-ambient-occlusion-ground-attenuation": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
                            "fill-extrusion-flood-light-color": new ao(co["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
                            "fill-extrusion-flood-light-intensity": new ao(co["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
                            "fill-extrusion-flood-light-wall-radius": new oo(co["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
                            "fill-extrusion-flood-light-ground-radius": new oo(co["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
                            "fill-extrusion-flood-light-ground-attenuation": new ao(co["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
                            "fill-extrusion-vertical-scale": new ao(co["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
                            "fill-extrusion-rounded-roof": new ao(co["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
                            "fill-extrusion-cutoff-fade-range": new ao(co["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
                            "fill-extrusion-emissive-strength": new oo(co["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]),
                            "fill-extrusion-line-width": new oo(co["paint_fill-extrusion"]["fill-extrusion-line-width"]),
                            "fill-extrusion-cast-shadows": new ao(co["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]),
                            "fill-extrusion-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-extrusion-flood-light-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new mf(t1);
                }
                queryRadius() {
                    return $c(this.paint.get("fill-extrusion-translate"));
                }
                is3D(t1) {
                    return !0;
                }
                hasShadowPass() {
                    return this.paint.get("fill-extrusion-cast-shadows");
                }
                cutoffRange() {
                    return this.paint.get("fill-extrusion-cutoff-fade-range");
                }
                canCastShadows() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o, l) {
                    const u = Xc(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), c = this.paint.get("fill-extrusion-height").evaluate(e, r), h = this.paint.get("fill-extrusion-base").evaluate(e, r), p = [
                        0,
                        0
                    ], d = o && s.elevation, f = s.elevation ? s.elevation.exaggeration() : 1, m = t1.tile.getBucket(this);
                    if (d && m instanceof mf) {
                        const t1 = m.centroidVertexArray, e = l + 1;
                        e < t1.length && (p[0] = t1.geta_centroid_pos0(e), p[1] = t1.geta_centroid_pos1(e));
                    }
                    if (0 === p[0] && 1 === p[1]) return !1;
                    "globe" === s.projection.name && (n = Mf([
                        n
                    ], [
                        new Mt(0, 0),
                        new Mt(jn, jn)
                    ], t1.tileID.canonical).map((t1)=>t1.polygon).flat());
                    const y = d ? o : null, [g, x] = Of(s, n, h, c, u, a, y, p, f, s.center.lat, t1.tileID.canonical), v = t1.queryGeometry;
                    return Lf(g, x, v.isPointQuery() ? v.screenBounds : v.screenGeometry);
                }
            },
            building: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Uy || (Uy = new uo({
                            visibility: new ao(co.layout_building.visibility),
                            "building-facade": new oo(co.layout_building["building-facade"]),
                            "building-facade-floors": new oo(co.layout_building["building-facade-floors"]),
                            "building-facade-unit-width": new oo(co.layout_building["building-facade-unit-width"]),
                            "building-facade-window": new oo(co.layout_building["building-facade-window"]),
                            "building-roof-shape": new oo(co.layout_building["building-roof-shape"]),
                            "building-height": new oo(co.layout_building["building-height"]),
                            "building-base": new oo(co.layout_building["building-base"]),
                            "building-flood-light-wall-radius": new oo(co.layout_building["building-flood-light-wall-radius"]),
                            "building-flood-light-ground-radius": new oo(co.layout_building["building-flood-light-ground-radius"]),
                            "building-flip-roof-orientation": new oo(co.layout_building["building-flip-roof-orientation"])
                        })),
                        paint: Ny || (Ny = new uo({
                            "building-opacity": new ao(co.paint_building["building-opacity"]),
                            "building-ambient-occlusion-intensity": new ao(co.paint_building["building-ambient-occlusion-intensity"]),
                            "building-ambient-occlusion-ground-intensity": new ao(co.paint_building["building-ambient-occlusion-ground-intensity"]),
                            "building-ambient-occlusion-ground-radius": new ao(co.paint_building["building-ambient-occlusion-ground-radius"]),
                            "building-ambient-occlusion-ground-attenuation": new ao(co.paint_building["building-ambient-occlusion-ground-attenuation"]),
                            "building-vertical-scale": new ao(co.paint_building["building-vertical-scale"]),
                            "building-cast-shadows": new ao(co.paint_building["building-cast-shadows"]),
                            "building-color": new oo(co.paint_building["building-color"]),
                            "building-emissive-strength": new oo(co.paint_building["building-emissive-strength"]),
                            "building-facade-emissive-chance": new ao(co.paint_building["building-facade-emissive-chance"]),
                            "building-cutoff-fade-range": new ao(co.paint_building["building-cutoff-fade-range"]),
                            "building-flood-light-color": new ao(co.paint_building["building-flood-light-color"]),
                            "building-flood-light-intensity": new ao(co.paint_building["building-flood-light-intensity"]),
                            "building-flood-light-ground-attenuation": new ao(co.paint_building["building-flood-light-ground-attenuation"]),
                            "building-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "building-flood-light-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new Ry(t1);
                }
                cutoffRange() {
                    return this.paint.get("building-cutoff-fade-range");
                }
                hasShadowPass() {
                    return this.paint.get("building-cast-shadows");
                }
                hasLightBeamPass() {
                    return !0;
                }
                canCastShadows() {
                    return !0;
                }
                is3D(t1) {
                    return !0;
                }
                queryRadius(t1) {
                    return 0;
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o, l, u) {
                    let c = this.layout.get("building-height").evaluate(e, r);
                    const h = this.layout.get("building-base").evaluate(e, r), p = t1.tile.getBucket(this).getFootprint(e);
                    if (p) {
                        if (0 !== p.hiddenFlags) return !1;
                        c = p.height;
                    }
                    const [d, f] = Of(s, n, h, c, new Mt(0, 0), a, null, [
                        0,
                        0
                    ], 1, s.center.lat, t1.tileID.canonical), m = t1.queryGeometry;
                    return Lf(d, f, m.isPointQuery() ? m.screenBounds : m.screenGeometry);
                }
            },
            line: class extends Fo {
                constructor(t1, e, r, n){
                    const i = cg();
                    super(t1, i, e, r, n), i.layout && (this.layout = new so(i.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    if ("line-gradient" === t1) {
                        const t1 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t1._styleExpression && t1._styleExpression.expression instanceof zi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }
                emissiveStrengthExpression() {
                    return this._transitionablePaint._values["line-emissive-strength"].value.expression;
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e), this.paint._values["line-floorwidth"] = (()=>{
                        if (pg) return pg;
                        const t1 = cg();
                        return pg = new hg(t1.paint.properties["line-width"].specification), pg.useIntegerZoom = !0, pg;
                    })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new Qy(t1);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = og(this);
                    return {
                        config: new du(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
                queryRadius(t1) {
                    const e = t1, r = dg(Gc("line-width", this, e), Gc("line-gap-width", this, e)), n = Gc("line-offset", this, e);
                    return r / 2 + Math.abs(n) + $c(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    if (t1.queryGeometry.isAboveHorizon) return !1;
                    const a = qc(t1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), o = t1.pixelToTileUnitsFactor / 2 * dg(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), l = this.paint.get("line-offset").evaluate(e, r);
                    return l && (n = function(t1, e) {
                        const r = [], n = new Mt(0, 0);
                        for(let i = 0; i < t1.length; i++){
                            const s = t1[i], a = [];
                            for(let t1 = 0; t1 < s.length; t1++){
                                const r = s[t1], i = s[t1 + 1], o = 0 === t1 ? n : r.sub(s[t1 - 1])._unit()._perp(), l = t1 === s.length - 1 ? n : i.sub(r)._unit()._perp(), u = o._add(l)._unit();
                                u._mult(1 / (u.x * l.x + u.y * l.y)), a.push(u._mult(e)._add(r));
                            }
                            r.push(a);
                        }
                        return r;
                    }(n, l * t1.pixelToTileUnitsFactor)), function(t1, e, r) {
                        for(let n = 0; n < e.length; n++){
                            const i = e[n];
                            if (t1.length >= 3) {
                                for(let e = 0; e < i.length; e++)if (Lc(t1, i[e])) return !0;
                            }
                            if (kc(t1, i, r)) return !0;
                        }
                        return !1;
                    }(a, n, o);
                }
                isTileClipped() {
                    return this.hasNonElevatedBuckets;
                }
                isDraped(t1) {
                    return !this.hasElevatedBuckets || this.layout && "hd-road-markup" === this.layout.get("line-elevation-reference");
                }
                hasElevation() {
                    return this.layout && "none" !== this.layout.get("line-elevation-reference");
                }
            },
            symbol: lb,
            background: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: ub || (ub = new uo({
                            visibility: new ao(co.layout_background.visibility)
                        })),
                        paint: cb || (cb = new uo({
                            "background-pitch-alignment": new ao(co.paint_background["background-pitch-alignment"]),
                            "background-color": new ao(co.paint_background["background-color"]),
                            "background-pattern": new ao(co.paint_background["background-pattern"]),
                            "background-opacity": new ao(co.paint_background["background-opacity"]),
                            "background-emissive-strength": new ao(co.paint_background["background-emissive-strength"]),
                            "background-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
                is3D(t1) {
                    return "viewport" === this.paint.get("background-pitch-alignment");
                }
            },
            raster: vb,
            "raster-particle": Mb,
            sky: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: _b || (_b = new uo({
                            visibility: new ao(co.layout_sky.visibility)
                        })),
                        paint: Ab || (Ab = new uo({
                            "sky-type": new ao(co.paint_sky["sky-type"]),
                            "sky-atmosphere-sun": new ao(co.paint_sky["sky-atmosphere-sun"]),
                            "sky-atmosphere-sun-intensity": new ao(co.paint_sky["sky-atmosphere-sun-intensity"]),
                            "sky-gradient-center": new ao(co.paint_sky["sky-gradient-center"]),
                            "sky-gradient-radius": new ao(co.paint_sky["sky-gradient-radius"]),
                            "sky-gradient": new lo(co.paint_sky["sky-gradient"]),
                            "sky-atmosphere-halo-color": new ao(co.paint_sky["sky-atmosphere-halo-color"]),
                            "sky-atmosphere-color": new ao(co.paint_sky["sky-atmosphere-color"]),
                            "sky-opacity": new ao(co.paint_sky["sky-opacity"]),
                            "sky-gradient-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "sky-atmosphere-halo-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "sky-atmosphere-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._updateColorRamp();
                }
                _clear() {
                    this.skyboxFbo && (this.skyboxFbo.destroy(), this.skyboxFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this._skyboxInvalidated = !0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "sky-gradient" === t1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t1 && "sky-atmosphere-halo-color" !== t1 && "sky-atmosphere-color" !== t1 && "sky-atmosphere-sun-intensity" !== t1 || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = Zh({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t1) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t1.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
                    }
                    return !1;
                }
                getCenter(t1, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = t1.style.light, s = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && Zt("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? Pb(s.azimuthal, 90 - s.polar, e) : Pb(r[0], 90 - r[1], e);
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return Pb(r[0], 90 - r[1], e);
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t1) {
                    this._skyboxInvalidated = !1, this._lightPosition = t1.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t1 = this.paint.get("sky-type");
                    return "atmosphere" === t1 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t1 ? [
                        "skyboxGradient"
                    ] : null;
                }
            },
            slot: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        paint: Ib || (Ib = new uo({}))
                    }, e, null);
                }
            },
            model: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Fb || (Fb = new uo({
                            visibility: new ao(co.layout_model.visibility),
                            "model-id": new oo(co.layout_model["model-id"]),
                            "model-allow-density-reduction": new ao(co.layout_model["model-allow-density-reduction"])
                        })),
                        paint: Db || (Db = new uo({
                            "model-opacity": new oo(co.paint_model["model-opacity"]),
                            "model-rotation": new oo(co.paint_model["model-rotation"]),
                            "model-scale": new oo(co.paint_model["model-scale"]),
                            "model-translation": new oo(co.paint_model["model-translation"]),
                            "model-color": new oo(co.paint_model["model-color"]),
                            "model-color-mix-intensity": new oo(co.paint_model["model-color-mix-intensity"]),
                            "model-type": new ao(co.paint_model["model-type"]),
                            "model-cast-shadows": new ao(co.paint_model["model-cast-shadows"]),
                            "model-receive-shadows": new ao(co.paint_model["model-receive-shadows"]),
                            "model-ambient-occlusion-intensity": new ao(co.paint_model["model-ambient-occlusion-intensity"]),
                            "model-emissive-strength": new oo(co.paint_model["model-emissive-strength"]),
                            "model-roughness": new oo(co.paint_model["model-roughness"]),
                            "model-height-based-emissive-strength-multiplier": new oo(co.paint_model["model-height-based-emissive-strength-multiplier"]),
                            "model-cutoff-fade-range": new ao(co.paint_model["model-cutoff-fade-range"]),
                            "model-front-cutoff": new ao(co.paint_model["model-front-cutoff"]),
                            "model-elevation-reference": new ao(co.paint_model["model-elevation-reference"]),
                            "model-color-use-theme": new oo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this.layer = t1, this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new Eb(t1);
                }
                getProgramIds() {
                    return [
                        "model"
                    ];
                }
                is3D(t1) {
                    return !0;
                }
                hasShadowPass() {
                    return !0;
                }
                canCastShadows() {
                    return !0;
                }
                hasLightBeamPass() {
                    return !0;
                }
                cutoffRange() {
                    return this.paint.get("model-cutoff-fade-range");
                }
                queryRadius(t1) {
                    return t1 instanceof Gb ? 8191 : 0;
                }
                queryRenderedFeatures(t1, e, r) {
                    const n = e.getSource();
                    if (!(n && n instanceof Wb)) return {};
                    const i = n, s = {};
                    s[this.id] = [];
                    const a = s[this.id];
                    let o = 0;
                    for (const n of i.models){
                        const i = e.getFeatureState(this.sourceLayer, n.id), s = {
                            type: "Unknown",
                            id: n.id,
                            properties: n.featureProperties
                        }, l = this.paint.get("model-rotation").evaluate(s, i), u = this.paint.get("model-scale").evaluate(s, i), c = this.paint.get("model-translation").evaluate(s, i), p = this.paint.get("model-elevation-reference");
                        let d = [];
                        ny(d, n, r, n.position, l, u, c, "ground" === p, "ground" === p, !1), "globe" === r.projection.name && (d = Qm(d, r));
                        const f = h([], r.projMatrix, d), m = ty(t1.isPointQuery() ? t1.screenBounds : t1.screenGeometry, r, f, n.aabb);
                        if (null != m) {
                            const t1 = new Zb(void 0, 0, 0, 0, n.id);
                            t1.layer = this.layer, t1.properties = structuredClone(n.featureProperties), t1.properties.layer = this.id, t1.properties.uri = n.uri, t1.properties.orientation = n.orientation, t1.sourceLayer = this.sourceLayer, t1.geometry = {
                                type: "Point",
                                coordinates: [
                                    n.position.lng,
                                    n.position.lat
                                ]
                            }, t1.state = i, t1.source = this.source, a.push({
                                featureIndex: o,
                                feature: t1,
                                intersectionZ: m
                            });
                        }
                        ++o;
                    }
                    return s;
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o, l, u) {
                    if (!this.modelManager) return !1;
                    const c = this.modelManager, p = t1.tile.getBucket(this);
                    if (!(p && p instanceof Eb)) return !1;
                    for(const r in p.instancesPerModel){
                        const n = p.instancesPerModel[r], i = void 0 !== e.id ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
                        if (n.idToFeaturesIndex.hasOwnProperty(i)) {
                            const e = n.features[n.idToFeaturesIndex[i]], a = c.getModel(r, u || this.scope);
                            if (!a) return !1;
                            let o = [];
                            const l = new Bu(0, 0), d = p.canonical;
                            let f = Number.MAX_VALUE;
                            for(let r = 0; r < e.instancedDataCount; ++r){
                                const i = 16 * (e.instancedDataOffset + r), u = n.instancedDataArray.float32, c = [
                                    u[i + 4],
                                    u[i + 5],
                                    u[i + 6]
                                ];
                                Yb(d, l, Math.floor(u[i]), Math.floor(u[i + 1])), ny(o, a, s, l, e.rotation, e.scale, c, !1, !1, !1), "globe" === s.projection.name && (o = Qm(o, s));
                                const p = h([], s.projMatrix, o), m = t1.queryGeometry, y = ty(m.isPointQuery() ? m.screenBounds : m.screenGeometry, s, p, a.aabb);
                                null != y && (f = Math.min(y, f));
                            }
                            return f !== Number.MAX_VALUE && f;
                        }
                    }
                    return !1;
                }
                _handleOverridablePaintPropertyUpdate(t1, e, r) {
                    return !(!this.layout || e.isDataDriven() || r.isDataDriven() || "model-color" !== t1 && "model-color-mix-intensity" !== t1 && "model-rotation" !== t1 && "model-scale" !== t1 && "model-translation" !== t1 && "model-emissive-strength" !== t1);
                }
                _isPropertyZoomDependent(t1) {
                    const e = this._transitionablePaint._values[t1];
                    return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof $s;
                }
                isZoomDependent() {
                    return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
                }
            },
            clip: class extends Fo {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: _d || (_d = new uo({
                            "clip-layer-types": new ao(co.layout_clip["clip-layer-types"]),
                            "clip-layer-scope": new ao(co.layout_clip["clip-layer-scope"])
                        })),
                        paint: Ad || (Ad = new uo({}))
                    }, e, r, n);
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                }
                createBucket(t1) {
                    return new Sd(t1);
                }
                is3D(t1) {
                    return !0;
                }
            }
        }, Qb = new ur(0, 0, 0);
        function tw(t1, e, r) {
            1 === t1 && e.icons.push(function(t1, e) {
                return function(t1) {
                    if (t1.usvg_tree.height || (t1.usvg_tree.height = t1.usvg_tree.width), !t1.metadata) return t1;
                    const { metadata: e } = t1;
                    if (e.content_area) {
                        const { content_area: r } = e;
                        null == r.left && (r.left = 0), null == r.top && (r.top = r.left), null == r.width && (r.width = t1.usvg_tree.width), null == r.height && (r.height = r.width);
                    }
                    if (e.text_placeholder) {
                        const { text_placeholder: t1 } = e;
                        null == t1.top && (t1.top = t1.left), null == t1.height && (t1.height = t1.width);
                    }
                    return e.stretch_x && e.stretch_x.length && ew(e, "x"), e.stretch_y && e.stretch_y.length && ew(e, "y"), t1;
                }(t1.readFields(rw, {
                    name: void 0
                }, e));
            }(r, r.readVarint() + r.pos));
        }
        function ew(t1, e) {
            const r = [], n = t1[`stretch_${e}`];
            let i = null;
            for(let t1 = 0; t1 < n.length; t1++)null === i ? i = 0 === r.length ? n[0] : r[r.length - 1][1] + n[t1] : (r.push([
                i,
                i + n[t1]
            ]), i = null);
            t1[`stretch_${e}_areas`] = r;
        }
        function rw(t1, e, r) {
            1 === t1 ? e.name = r.readString() : 2 === t1 ? e.metadata = function(t1, e) {
                return t1.readFields(nw, {
                    stretch_x: null,
                    stretch_y: null,
                    stretch_x_areas: null,
                    stretch_y_areas: null,
                    variables: []
                }, e);
            }(r, r.readVarint() + r.pos) : 3 === t1 && (e.usvg_tree = function(t1, e) {
                return t1.readFields(ow, {
                    width: 20,
                    children: [],
                    linear_gradients: [],
                    radial_gradients: [],
                    clip_paths: [],
                    masks: []
                }, e);
            }(r, r.readVarint() + r.pos), e.data = "usvg_tree");
        }
        function nw(t1, e, r) {
            1 === t1 ? e.stretch_x = r.readPackedVarint() : 2 === t1 ? e.stretch_y = r.readPackedVarint() : 3 === t1 ? e.content_area = iw(r, r.readVarint() + r.pos) : 4 === t1 ? e.variables.push(function(t1, e) {
                return t1.readFields(aw, {
                    name: void 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 5 === t1 && (e.text_placeholder = iw(r, r.readVarint() + r.pos));
        }
        function iw(t1, e) {
            return t1.readFields(sw, {}, e);
        }
        function sw(t1, e, r) {
            1 === t1 ? e.left = r.readVarint() : 2 === t1 ? e.width = r.readVarint() : 3 === t1 ? e.top = r.readVarint() : 4 === t1 && (e.height = r.readVarint());
        }
        function aw(t1, e, r) {
            1 === t1 ? e.name = r.readString() : 2 === t1 && (e.rgb_color = mw(r.readVarint()), e.value = "rgb_color");
        }
        function ow(t1, e, r) {
            1 === t1 ? e.width = e.height = r.readVarint() : 2 === t1 ? e.height = r.readVarint() : 3 === t1 ? e.children.push(lw(r, r.readVarint() + r.pos)) : 4 === t1 ? e.linear_gradients.push(function(t1, e) {
                return t1.readFields(gw, {
                    spread_method: 1,
                    stops: [],
                    x1: 0,
                    y1: 0,
                    x2: 1,
                    y2: 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 5 === t1 ? e.radial_gradients.push(function(t1, e) {
                return t1.readFields(bw, {
                    spread_method: 1,
                    stops: [],
                    cx: .5,
                    cy: .5,
                    r: .5,
                    fx: .5,
                    fy: .5,
                    fr: 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 7 === t1 ? e.clip_paths.push(function(t1, e) {
                return t1.readFields(ww, {
                    children: []
                }, e);
            }(r, r.readVarint() + r.pos)) : 8 === t1 && e.masks.push(function(t1, e) {
                const r = t1.readFields(_w, {
                    left: 0,
                    width: 20,
                    mask_type: 1,
                    children: []
                }, e);
                return null == r.height && (r.height = r.width), null == r.top && (r.top = r.left), r;
            }(r, r.readVarint() + r.pos));
        }
        function lw(t1, e) {
            return t1.readFields(uw, {}, e);
        }
        function uw(t1, e, r) {
            1 === t1 ? (e.group = function(t1, e) {
                return t1.readFields(cw, {
                    opacity: 255,
                    children: []
                }, e);
            }(r, r.readVarint() + r.pos), e.node = "group") : 2 === t1 && (e.path = function(t1, e) {
                return t1.readFields(dw, {
                    paint_order: 1,
                    commands: [],
                    step: 1,
                    diffs: [],
                    rule: 1
                }, e);
            }(r, r.readVarint() + r.pos), e.node = "path");
        }
        function cw(t1, e, r) {
            1 === t1 ? e.transform = hw(r, r.readVarint() + r.pos) : 2 === t1 ? e.opacity = r.readVarint() : 5 === t1 ? e.clip_path_idx = r.readVarint() : 6 === t1 ? e.mask_idx = r.readVarint() : 7 === t1 && e.children.push(lw(r, r.readVarint() + r.pos));
        }
        function hw(t1, e) {
            return t1.readFields(pw, {
                sx: 1,
                ky: 0,
                kx: 0,
                sy: 1,
                tx: 0,
                ty: 0
            }, e);
        }
        function pw(t1, e, r) {
            1 === t1 ? e.sx = r.readFloat() : 2 === t1 ? e.ky = r.readFloat() : 3 === t1 ? e.kx = r.readFloat() : 4 === t1 ? e.sy = r.readFloat() : 5 === t1 ? e.tx = r.readFloat() : 6 === t1 && (e.ty = r.readFloat());
        }
        function dw(t1, e, r) {
            1 === t1 ? e.fill = function(t1, e) {
                return t1.readFields(fw, {
                    rgb_color: Qb,
                    paint: "rgb_color",
                    opacity: 255
                }, e);
            }(r, r.readVarint() + r.pos) : 2 === t1 ? e.stroke = function(t1, e) {
                return t1.readFields(yw, {
                    rgb_color: Qb,
                    paint: "rgb_color",
                    dasharray: [],
                    dashoffset: 0,
                    miterlimit: 4,
                    opacity: 255,
                    width: 1,
                    linecap: 1,
                    linejoin: 1
                }, e);
            }(r, r.readVarint() + r.pos) : 3 === t1 ? e.paint_order = r.readVarint() : 5 === t1 ? r.readPackedVarint(e.commands) : 6 === t1 ? e.step = r.readFloat() : 7 === t1 ? r.readPackedSVarint(e.diffs) : 8 === t1 && (e.rule = r.readVarint());
        }
        function fw(t1, e, r) {
            1 === t1 ? (e.rgb_color = mw(r.readVarint()), e.paint = "rgb_color") : 2 === t1 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : 3 === t1 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : 5 === t1 && (e.opacity = r.readVarint());
        }
        function mw(t1) {
            return new ur((t1 >> 16 & 255) / 255, (t1 >> 8 & 255) / 255, (255 & t1) / 255, 1);
        }
        function yw(t1, e, r) {
            1 === t1 ? (e.rgb_color = mw(r.readVarint()), e.paint = "rgb_color") : 2 === t1 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : 3 === t1 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : 5 === t1 ? r.readPackedFloat(e.dasharray) : 6 === t1 ? e.dashoffset = r.readFloat() : 7 === t1 ? e.miterlimit = r.readFloat() : 8 === t1 ? e.opacity = r.readVarint() : 9 === t1 ? e.width = r.readFloat() : 10 === t1 ? e.linecap = r.readVarint() : 11 === t1 && (e.linejoin = r.readVarint());
        }
        function gw(t1, e, r) {
            1 === t1 ? e.transform = hw(r, r.readVarint() + r.pos) : 2 === t1 ? e.spread_method = r.readVarint() : 3 === t1 ? e.stops.push(xw(r, r.readVarint() + r.pos)) : 4 === t1 ? e.x1 = r.readFloat() : 5 === t1 ? e.y1 = r.readFloat() : 6 === t1 ? e.x2 = r.readFloat() : 7 === t1 && (e.y2 = r.readFloat());
        }
        function xw(t1, e) {
            return t1.readFields(vw, {
                offset: 0,
                opacity: 255,
                rgb_color: Qb
            }, e);
        }
        function vw(t1, e, r) {
            1 === t1 ? e.offset = r.readFloat() : 2 === t1 ? e.opacity = r.readVarint() : 3 === t1 && (e.rgb_color = mw(r.readVarint()));
        }
        function bw(t1, e, r) {
            1 === t1 ? e.transform = hw(r, r.readVarint() + r.pos) : 2 === t1 ? e.spread_method = r.readVarint() : 3 === t1 ? e.stops.push(xw(r, r.readVarint() + r.pos)) : 4 === t1 ? e.cx = r.readFloat() : 5 === t1 ? e.cy = r.readFloat() : 6 === t1 ? e.r = r.readFloat() : 7 === t1 ? e.fx = r.readFloat() : 8 === t1 ? e.fy = r.readFloat() : 9 === t1 && (e.fr = r.readFloat());
        }
        function ww(t1, e, r) {
            1 === t1 ? e.transform = hw(r, r.readVarint() + r.pos) : 2 === t1 ? e.clip_path_idx = r.readVarint() : 3 === t1 && e.children.push(lw(r, r.readVarint() + r.pos));
        }
        function _w(t1, e, r) {
            1 === t1 ? e.left = e.top = r.readFloat() : 2 === t1 ? e.width = e.height = r.readFloat() : 3 === t1 ? e.top = r.readFloat() : 4 === t1 ? e.height = r.readFloat() : 5 === t1 ? e.mask_type = r.readVarint() : 6 === t1 ? e.mask_idx = r.readVarint() : 7 === t1 && e.children.push(lw(r, r.readVarint() + r.pos));
        }
        class Aw {
            static calculate(t1 = {}, e = []) {
                const r = new Map, n = new Map;
                if (0 === Object.keys(t1).length) return r;
                e.forEach((t1)=>{
                    n.set(t1.name, t1.rgb_color || new ur(0, 0, 0));
                });
                for (const [e, i] of Object.entries(t1))n.has(e) ? r.set(n.get(e).toString(), i) : console.warn(`Ignoring unknown image variable "${e}"`);
                return r;
            }
        }
        function Iw(t1, e = 255, r) {
            const n = e / 255, i = t1.toString(), s = r.has(i) ? r.get(i).clone() : t1.clone();
            return s.a *= n, s.toString();
        }
        function Mw(t1, e) {
            if (!ye()) {
                const r = document.createElement("canvas");
                return r.width = t1, r.height = e, r;
            }
            return new OffscreenCanvas(t1, e);
        }
        let Sw, Pw = null;
        function zw(t1, e, r, n, i) {
            for (const s of n.children)Bw(t1, e, r, s, i);
        }
        function Bw(t1, e, r, n, i) {
            n.group ? (t1.save(), function(t1, e, r, n, i) {
                const s = null != n.mask_idx ? r.masks[n.mask_idx] : null, a = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;
                if (n.transform && (e = Lw(n.transform).preMultiplySelf(e)), !function(t1, e, r) {
                    return 255 !== t1.opacity || e || r;
                }(n, null != a, null != s)) return void zw(t1, e, r, n, i);
                const o = Mw(t1.canvas.width, t1.canvas.height), l = o.getContext("2d");
                zw(l, e, r, n, i), a && Cw(l, e, r, a), s && Rw(l, e, r, s, i), t1.globalAlpha = n.opacity / 255, t1.drawImage(o, 0, 0);
            }(t1, e, r, n.group, i), t1.restore()) : n.path && (t1.save(), function(t1, e, r, n, i) {
                t1.setTransform(e), 1 === n.paint_order ? (kw(t1, r, n, i), Vw(t1, r, n, i)) : (Vw(t1, r, n, i), kw(t1, r, n, i));
            }(t1, e, r, n.path, i), t1.restore());
        }
        function kw(t1, e, r, n) {
            const i = r.fill;
            if (!i) return;
            const s = i.opacity / 255;
            switch(t1.save(), t1.beginPath(), Ow(r, t1), i.paint){
                case "rgb_color":
                    t1.fillStyle = Iw(i.rgb_color, i.opacity, n);
                    break;
                case "linear_gradient_idx":
                    {
                        const r = e.linear_gradients[i.linear_gradient_idx];
                        r.transform && t1.setTransform(Lw(r.transform).preMultiplySelf(t1.getTransform())), t1.fillStyle = Ew(t1, r, s, n);
                        break;
                    }
                case "radial_gradient_idx":
                    {
                        const r = e.radial_gradients[i.radial_gradient_idx];
                        r.transform && t1.setTransform(Lw(r.transform).preMultiplySelf(t1.getTransform())), t1.fillStyle = Fw(t1, r, s, n);
                    }
            }
            t1.fill(Tw(r)), t1.restore();
        }
        function Tw(t1) {
            return 1 === t1.rule ? "nonzero" : 2 === t1.rule ? "evenodd" : void 0;
        }
        function Vw(t1, e, r, n) {
            const i = r.stroke;
            if (!i) return;
            const s = Uw(r);
            t1.lineWidth = i.width, t1.miterLimit = i.miterlimit, t1.setLineDash(i.dasharray), t1.lineDashOffset = i.dashoffset;
            const a = i.opacity / 255;
            switch(i.paint){
                case "rgb_color":
                    t1.strokeStyle = Iw(i.rgb_color, i.opacity, n);
                    break;
                case "linear_gradient_idx":
                    t1.strokeStyle = Ew(t1, e.linear_gradients[i.linear_gradient_idx], a, n, !0);
                    break;
                case "radial_gradient_idx":
                    t1.strokeStyle = Fw(t1, e.radial_gradients[i.radial_gradient_idx], a, n, !0);
            }
            switch(i.linejoin){
                case 2:
                case 1:
                    t1.lineJoin = "miter";
                    break;
                case 3:
                    t1.lineJoin = "round";
                    break;
                case 4:
                    t1.lineJoin = "bevel";
            }
            switch(i.linecap){
                case 1:
                    t1.lineCap = "butt";
                    break;
                case 2:
                    t1.lineCap = "round";
                    break;
                case 3:
                    t1.lineCap = "square";
            }
            t1.stroke(s);
        }
        function Ew(t1, e, r, n, i = !1) {
            if (1 === e.stops.length) {
                const t1 = e.stops[0];
                return Iw(t1.rgb_color, t1.opacity * r, n);
            }
            const { x1: s, y1: a, x2: o, y2: l } = e;
            let u = new DOMPoint(s, a), c = new DOMPoint(o, l);
            if (i) {
                const t1 = Lw(e.transform);
                u = t1.transformPoint(u), c = t1.transformPoint(c);
            }
            const h = t1.createLinearGradient(u.x, u.y, c.x, c.y);
            for (const t1 of e.stops)h.addColorStop(t1.offset, Iw(t1.rgb_color, t1.opacity * r, n));
            return h;
        }
        function Fw(t1, e, r, n, i = !1) {
            if (1 === e.stops.length) {
                const t1 = e.stops[0];
                return Iw(t1.rgb_color, t1.opacity * r, n);
            }
            const s = Lw(e.transform), { fx: a, fy: o, fr: l, cx: u, cy: c, r: h } = e;
            let p = new DOMPoint(a, o), d = new DOMPoint(u, c), f = l, m = h;
            if (i) {
                p = s.transformPoint(p), d = s.transformPoint(d);
                const t1 = (s.a + s.d) / 2;
                f = l * t1, m = e.r * t1;
            }
            const y = t1.createRadialGradient(p.x, p.y, f, d.x, d.y, m);
            for (const t1 of e.stops)y.addColorStop(t1.offset, Iw(t1.rgb_color, t1.opacity * r, n));
            return y;
        }
        function Dw(t1, e, r, n) {
            const i = n.transform ? Lw(n.transform).preMultiplySelf(e) : e, s = Mw(t1.canvas.width, t1.canvas.height), a = s.getContext("2d");
            for (const t1 of n.children)if (t1.group) Dw(a, i, r, t1.group);
            else if (t1.path) {
                const e = t1.path, r = new Path2D;
                r.addPath(Uw(e), i), a.fill(r, Tw(e));
            }
            const o = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;
            o && Cw(a, i, r, o), t1.globalCompositeOperation = "source-over", t1.drawImage(s, 0, 0);
        }
        function Cw(t1, e, r, n) {
            const i = Mw(t1.canvas.width, t1.canvas.height);
            Dw(i.getContext("2d"), e, r, n), t1.globalCompositeOperation = "destination-in", t1.drawImage(i, 0, 0);
        }
        function Rw(t1, e, r, n, i) {
            if (0 === n.children.length) return;
            const s = null != n.mask_idx ? r.masks[n.mask_idx] : null;
            s && Rw(t1, e, r, s, i);
            const a = t1.canvas.width, o = t1.canvas.height, l = Mw(a, o), u = l.getContext("2d"), c = n.width, h = n.height, p = n.left, d = n.top, f = new Path2D, m = new Path2D;
            m.rect(p, d, c, h), f.addPath(m, e), u.clip(f);
            for (const t1 of n.children)Bw(u, e, r, t1, i);
            const y = u.getImageData(0, 0, a, o), g = y.data;
            if (1 === n.mask_type) for(let t1 = 0; t1 < g.length; t1 += 4)g[t1 + 3] = g[t1 + 3] / 255 * (.2126 * g[t1] + .7152 * g[t1 + 1] + .0722 * g[t1 + 2]);
            u.putImageData(y, 0, 0), t1.globalCompositeOperation = "destination-in", t1.drawImage(l, 0, 0);
        }
        function Lw(t1) {
            return t1 ? new DOMMatrix([
                t1.sx,
                t1.ky,
                t1.kx,
                t1.sy,
                t1.tx,
                t1.ty
            ]) : new DOMMatrix;
        }
        function Ow(t1, e) {
            const r = t1.step;
            let n = t1.diffs[0] * r, i = t1.diffs[1] * r;
            e.moveTo(n, i);
            for(let s = 0, a = 2; s < t1.commands.length; s++)switch(t1.commands[s]){
                case 1:
                    n += t1.diffs[a++] * r, i += t1.diffs[a++] * r, e.moveTo(n, i);
                    break;
                case 2:
                    n += t1.diffs[a++] * r, i += t1.diffs[a++] * r, e.lineTo(n, i);
                    break;
                case 3:
                    {
                        const s = n + t1.diffs[a++] * r, o = i + t1.diffs[a++] * r;
                        n = s + t1.diffs[a++] * r, i = o + t1.diffs[a++] * r, e.quadraticCurveTo(s, o, n, i);
                        break;
                    }
                case 4:
                    {
                        const s = n + t1.diffs[a++] * r, o = i + t1.diffs[a++] * r, l = s + t1.diffs[a++] * r, u = o + t1.diffs[a++] * r;
                        n = l + t1.diffs[a++] * r, i = u + t1.diffs[a++] * r, e.bezierCurveTo(s, o, l, u, n, i);
                        break;
                    }
                case 5:
                    e.closePath();
                    break;
                default:
                    Nw();
            }
            return e;
        }
        function Uw(t1) {
            return Ow(t1, new Path2D);
        }
        function Nw(t1, e) {}
        class jw {
            constructor(t1){
                this.capacity = t1, this.cache = new Map;
            }
            get(t1) {
                if (!this.cache.has(t1)) return;
                const e = this.cache.get(t1);
                return this.cache.delete(t1), this.cache.set(t1, e), e;
            }
            put(t1, e) {
                this.cache.has(t1) ? this.cache.delete(t1) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t1, e);
            }
            delete(t1) {
                this.cache.delete(t1);
            }
        }
        Qs(jw, "LRUCache");
        class Gw {
            constructor(){
                this.cacheMap = new Map, this.cacheDependenciesMap = new Map;
            }
            static _getImage(t1) {
                return new Xh(t1, t1.data);
            }
            getFromCache(t1, e, r) {
                return this.cacheMap.has(r) || this.cacheMap.set(r, new jw(150)), this.cacheMap.get(r).get(zo(t1.toString(), e));
            }
            setInCache(t1, e, r, n) {
                this.cacheDependenciesMap.has(n) || this.cacheDependenciesMap.set(n, new Map), this.cacheMap.has(n) || this.cacheMap.set(n, new jw(150));
                const i = this.cacheDependenciesMap.get(n), s = zo(t1.id.toString(), r);
                i.get(s) || i.set(s, new Set);
                const a = this.cacheMap.get(n), o = t1.toString();
                i.get(s).add(o), a.put(zo(t1.toString(), r), e);
            }
            removeImagesFromCacheByIds(t1, e, r = 0) {
                if (!this.cacheMap.has(r) || !this.cacheDependenciesMap.has(r)) return;
                const n = this.cacheMap.get(r), i = this.cacheDependenciesMap.get(r);
                for (const r of t1){
                    const t1 = zo(r.toString(), e);
                    if (i.has(t1)) {
                        for (const e of i.get(t1))n.delete(e);
                        i.delete(t1);
                    }
                }
            }
            rasterize(t1, e, r, n) {
                const i = this.getFromCache(t1, r, n);
                if (i) return i.clone();
                const s = function(t1, e) {
                    const r = Aw.calculate(e.params, t1.metadata ? t1.metadata.variables : []), n = t1.usvg_tree, i = n.width, s = n.height, a = Math.max(1, Math.round(i * e.sx)), o = Math.max(1, Math.round(s * e.sy)), l = new DOMMatrix([
                        a / i,
                        0,
                        0,
                        o / s,
                        0,
                        0
                    ]);
                    return null === Pw && (Pw = Mw(10, 10), Sw = Pw.getContext("2d", {
                        willReadFrequently: !0
                    })), Pw.width = a, Pw.height = o, zw(Sw, l, n, n, r), Sw.getImageData(0, 0, a, o);
                }(e.icon, t1), a = Gw._getImage(s);
                return this.setInCache(t1, a, r, n), a.clone();
            }
        }
        class $w {
            constructor(t1){
                this.size = t1, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t1, e) {
                const r = this.toIdx(t1, e);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                };
            }
            isLeaf(t1, e) {
                return this.leaves[this.toIdx(t1, e)];
            }
            toIdx(t1, e) {
                return e * this.size + t1;
            }
        }
        function qw(t1, e, r, n) {
            let i = 0, s = Number.MAX_VALUE;
            for(let a = 0; a < 3; a++)if (Math.abs(n[a]) < 1e-15) {
                if (r[a] < t1[a] || r[a] > e[a]) return null;
            } else {
                const o = 1 / n[a];
                let l = (t1[a] - r[a]) * o, u = (e[a] - r[a]) * o;
                if (l > u) {
                    const t1 = l;
                    l = u, u = t1;
                }
                if (l > i && (i = l), u < s && (s = u), i > s) return null;
            }
            return i;
        }
        function Xw(t1, e, r, n, i, s, a, o, l, u, c) {
            const h = n - t1, p = i - e, d = s - r, f = a - t1, m = o - e, y = l - r, g = c[1] * y - c[2] * m, x = c[2] * f - c[0] * y, v = c[0] * m - c[1] * f, b = h * g + p * x + d * v;
            if (Math.abs(b) < 1e-15) return null;
            const w = 1 / b, _ = u[0] - t1, A = u[1] - e, I = u[2] - r, M = (_ * g + A * x + I * v) * w;
            if (M < 0 || M > 1) return null;
            const S = A * d - I * p, P = I * h - _ * d, z = _ * p - A * h, B = (c[0] * S + c[1] * P + c[2] * z) * w;
            return B < 0 || M + B > 1 ? null : (f * S + m * P + y * z) * w;
        }
        function Hw(t1, e, r) {
            return (t1 - e) / (r - e);
        }
        function Zw(t1, e, r, n, i, s, a, o, l) {
            const u = 1 << r, c = s - n, h = a - i, p = (t1 + 1) / u * c + n, d = (e + 0) / u * h + i, f = (e + 1) / u * h + i;
            o[0] = (t1 + 0) / u * c + n, o[1] = d, l[0] = p, l[1] = f;
        }
        class Ww {
            constructor(t1){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t1, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e = function(t1) {
                    const e = Math.ceil(Math.log2(t1.dim / 8)), r = [];
                    let n = Math.ceil(Math.pow(2, e));
                    const i = 1 / n, s = (t1, e, r, n, i)=>{
                        const s = n ? 1 : 0, a = (t1 + 1) * r - s, o = e * r, l = (e + 1) * r - s;
                        i[0] = t1 * r, i[1] = o, i[2] = a, i[3] = l;
                    };
                    let a = new $w(n);
                    const o = [];
                    for(let e = 0; e < n * n; e++){
                        s(e % n, Math.floor(e / n), i, !1, o);
                        const r = Jw(o[0], o[1], t1), l = Jw(o[2], o[1], t1), u = Jw(o[2], o[3], t1), c = Jw(o[0], o[3], t1);
                        a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
                    }
                    for(r.push(a), n /= 2; n >= 1; n /= 2){
                        const t1 = r[r.length - 1];
                        a = new $w(n);
                        for(let e = 0; e < n * n; e++){
                            s(e % n, Math.floor(e / n), 2, !0, o);
                            const r = t1.getElevation(o[0], o[1]), i = t1.getElevation(o[2], o[1]), l = t1.getElevation(o[2], o[3]), u = t1.getElevation(o[0], o[3]), c = t1.isLeaf(o[0], o[1]), h = t1.isLeaf(o[2], o[1]), p = t1.isLeaf(o[2], o[3]), d = t1.isLeaf(o[0], o[3]), f = Math.min(r.min, i.min, l.min, u.min), m = Math.max(r.max, i.max, l.max, u.max), y = c && h && p && d;
                            a.maximums.push(m), a.minimums.push(f), a.leaves.push(m - f <= 5 && y ? 1 : 0);
                        }
                        r.push(a);
                    }
                    return r;
                }(this.dem), r = e.length - 1, n = e[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
            }
            raycastRoot(t1, e, r, n, i, s, a = 1) {
                return qw([
                    t1,
                    e,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * a
                ], i, s);
            }
            raycast(t1, e, r, n, i, s, a = 1) {
                if (!this.nodeCount) return null;
                const o = this.raycastRoot(t1, e, r, n, i, s, a);
                if (null == o) return null;
                const l = [], u = [], c = [], h = [], p = [
                    {
                        idx: 0,
                        t: o,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; p.length > 0;){
                    const { idx: o, t: d, nodex: f, nodey: m, depth: y } = p.pop();
                    if (this.leaves[o]) {
                        Zw(f, m, y, t1, e, r, n, c, h);
                        const o = 1 << y, l = (f + 0) / o, u = (f + 1) / o, p = (m + 0) / o, g = (m + 1) / o, x = Jw(l, p, this.dem) * a, v = Jw(u, p, this.dem) * a, b = Jw(u, g, this.dem) * a, w = Jw(l, g, this.dem) * a, _ = Xw(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s), A = Xw(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s), I = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
                        if (I !== Number.MAX_VALUE) return I;
                        {
                            const t1 = E([], i, s, d);
                            if (Yw(x, v, w, b, Hw(t1[0], c[0], h[0]), Hw(t1[1], c[1], h[1])) >= t1[2]) return d;
                        }
                        continue;
                    }
                    let g = 0;
                    for(let p = 0; p < this._siblingOffset.length; p++){
                        Zw((f << 1) + this._siblingOffset[p][0], (m << 1) + this._siblingOffset[p][1], y + 1, t1, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;
                        const d = qw(c, h, i, s);
                        if (null != d) {
                            const t1 = d;
                            l[p] = t1;
                            let e = !1;
                            for(let r = 0; r < g && !e; r++)t1 >= l[u[r]] && (u.splice(r, 0, p), e = !0);
                            e || (u[g] = p), g++;
                        }
                    }
                    for(let t1 = 0; t1 < g; t1++){
                        const e = u[t1];
                        p.push({
                            idx: this.childOffsets[o] + e,
                            t: l[e],
                            nodex: (f << 1) + this._siblingOffset[e][0],
                            nodey: (m << 1) + this._siblingOffset[e][1],
                            depth: y + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t1, e, r) {
                return this.minimums.push(t1), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t1, e, r, n, i) {
                if (1 === t1[n].isLeaf(e, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s = n - 1, a = t1[s];
                let o = 0, l = 0;
                for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                    const n = 2 * e + this._siblingOffset[t1][0], i = 2 * r + this._siblingOffset[t1][1], s = a.getElevation(n, i), u = a.isLeaf(n, i), c = this._addNode(s.min, s.max, u);
                    u && (o |= 1 << t1), l || (l = c);
                }
                for(let n = 0; n < this._siblingOffset.length; n++)o & 1 << n || this._construct(t1, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }
        function Yw(t1, e, r, n, i, s) {
            return dr(dr(t1, r, s), dr(e, n, s), i);
        }
        function Jw(t1, e, r) {
            const n = r.dim, i = Dt(t1 * n - .5, 0, n - 1), s = Dt(e * n - .5, 0, n - 1), a = Math.floor(i), o = Math.floor(s), l = Math.min(a + 1, n - 1), u = Math.min(o + 1, n - 1);
            return Yw(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
        }
        const Kw = {
            mapbox: [
                6553.6,
                25.6,
                .1,
                1e4
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        function Qw(t1, e, r) {
            return (256 * t1 * 256 + 256 * e + r) / 10 - 1e4;
        }
        function t_(t1, e, r) {
            return 256 * t1 + e + r / 256 - 32768;
        }
        class e_ {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t1, e, r, n = !1){
                if (this.uid = t1, e.height !== e.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return void Zt(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e.height;
                const i = this.dim = e.height - 2, s = new Uint32Array(e.data.buffer);
                if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {
                    for(let t1 = 0; t1 < i; t1++)s[this._idx(-1, t1)] = s[this._idx(0, t1)], s[this._idx(i, t1)] = s[this._idx(i - 1, t1)], s[this._idx(t1, -1)] = s[this._idx(t1, 0)], s[this._idx(t1, i)] = s[this._idx(t1, i - 1)];
                    s[this._idx(-1, -1)] = s[this._idx(0, 0)], s[this._idx(i, -1)] = s[this._idx(i - 1, 0)], s[this._idx(-1, i)] = s[this._idx(0, i - 1)], s[this._idx(i, i)] = s[this._idx(i - 1, i - 1)];
                }
                const a = "terrarium" === r ? t_ : Qw;
                for(let t1 = 0; t1 < s.length; ++t1){
                    const e = 4 * t1;
                    this.floatView[t1] = a(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);
                }
                this._timestamp = ge.now();
            }
            _buildQuadTree() {
                this._tree = new Ww(this);
            }
            get(t1, e, r = !1) {
                r && (t1 = Dt(t1, -1, this.dim), e = Dt(e, -1, this.dim));
                const n = this._idx(t1, e);
                return this.floatView[n];
            }
            set(t1, e, r) {
                const n = this._idx(t1, e), i = this.floatView[n];
                return this.floatView[n] = r, r - i;
            }
            static getUnpackVector(t1) {
                return Kw[t1];
            }
            _idx(t1, e) {
                if (t1 < -1 || t1 >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t1 + 1);
            }
            static pack(t1, e) {
                const r = [
                    0,
                    0,
                    0,
                    0
                ], n = e_.getUnpackVector(e);
                let i = Math.floor((t1 + n[3]) / n[2]);
                return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }
            getPixels() {
                return new Hh({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t1, e, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e * this.dim, i = e * this.dim + this.dim, s = r * this.dim, a = r * this.dim + this.dim;
                switch(e){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        s = a - 1;
                        break;
                    case 1:
                        a = s + 1;
                }
                const o = -e * this.dim, l = -r * this.dim;
                for(let e = s; e < a; e++)for(let r = n; r < i; r++){
                    const n = 4 * this._idx(r, e), i = 4 * this._idx(r + o, e + l);
                    this.pixels[n + 0] = t1.pixels[i + 0], this.pixels[n + 1] = t1.pixels[i + 1], this.pixels[n + 2] = t1.pixels[i + 2], this.pixels[n + 3] = t1.pixels[i + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        function r_(t1, e, r) {
            1 === t1 ? e.headerLength = r.readFixed32() : 2 === t1 ? e.x = r.readVarint() : 3 === t1 ? e.y = r.readVarint() : 4 === t1 ? e.z = r.readVarint() : 5 === t1 && e.layers.push(function(t1, e) {
                return t1.readFields(o_, {
                    version: 0,
                    name: "",
                    units: "",
                    tileSize: 0,
                    buffer: 0,
                    pixelFormat: 0,
                    dataIndex: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function n_(t1, e, r) {
            1 === t1 ? (e.delta_filter = function(t1, e) {
                return t1.readFields(i_, {
                    blockSize: 0
                }, e);
            }(r, r.readVarint() + r.pos), e.filter = "delta_filter") : 2 === t1 ? (r.readVarint(), e.filter = "zigzag_filter") : 3 === t1 ? (r.readVarint(), e.filter = "bitshuffle_filter") : 4 === t1 && (r.readVarint(), e.filter = "byteshuffle_filter");
        }
        function i_(t1, e, r) {
            1 === t1 && (e.blockSize = r.readVarint());
        }
        function s_(t1, e, r) {
            1 === t1 ? (r.readVarint(), e.codec = "gzip_data") : 2 === t1 ? (r.readVarint(), e.codec = "jpeg_image") : 3 === t1 ? (r.readVarint(), e.codec = "webp_image") : 4 === t1 && (r.readVarint(), e.codec = "png_image");
        }
        function a_(t1, e, r) {
            let n = 0, i = 0;
            1 === t1 ? e.firstByte = r.readFixed64() : 2 === t1 ? e.lastByte = r.readFixed64() : 3 === t1 ? e.filters.push(function(t1, e) {
                return t1.readFields(n_, {}, e);
            }(r, r.readVarint() + r.pos)) : 4 === t1 ? e.codec = function(t1, e) {
                return t1.readFields(s_, {}, e);
            }(r, r.readVarint() + r.pos) : 5 === t1 ? i = r.readFloat() : 6 === t1 ? n = r.readFloat() : 7 === t1 ? e.bands.push(r.readString()) : 8 === t1 ? e.offset = r.readDouble() : 9 === t1 && (e.scale = r.readDouble()), 0 === e.offset && (e.offset = i), 0 === e.scale && (e.scale = n);
        }
        function o_(t1, e, r) {
            1 === t1 ? e.version = r.readVarint() : 2 === t1 ? e.name = r.readString() : 3 === t1 ? e.units = r.readString() : 4 === t1 ? e.tileSize = r.readVarint() : 5 === t1 ? e.buffer = r.readVarint() : 6 === t1 ? e.pixelFormat = r.readVarint() : 7 === t1 && e.dataIndex.push(function(t1, e) {
                return t1.readFields(a_, {
                    firstByte: 0,
                    lastByte: 0,
                    filters: [],
                    codec: null,
                    offset: 0,
                    scale: 0,
                    bands: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function l_(t1, e, r) {
            if (2 === t1) !function(t1, e, r) {
                t1.readFields(u_, r, e);
            }(r, r.readVarint() + r.pos, e);
            else if (3 === t1) throw new Error("Not implemented");
        }
        function u_(t1, e, r) {
            if (1 === t1) {
                let t1 = 0;
                const n = r.readVarint() + r.pos;
                for(; r.pos < n;)e[t1++] = r.readVarint();
            }
        }
        function c_(t1, e) {
            if (4 !== e.length) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
            let r = e[3];
            for(let n = 2; n >= 1; n--){
                const i = 1 === n ? 1 : 0, s = 2 === n ? 1 : 0;
                for(let n = 0; n < e[0]; n++){
                    const a = e[1] * n;
                    for(let n = i; n < e[1]; n++){
                        const i = e[2] * (n + a);
                        for(let n = s; n < e[2]; n++){
                            const s = e[3] * (n + i);
                            for(let n = 0; n < e[3]; n++){
                                const e = s + n;
                                t1[e] += t1[e - r];
                            }
                        }
                    }
                }
                r *= e[n];
            }
            return t1;
        }
        function h_(t1) {
            for(let e = 0, r = t1.length; e < r; e++)t1[e] = t1[e] >>> 1 ^ -(1 & t1[e]);
            return t1;
        }
        function p_(t1, e) {
            switch(e){
                case "uint32":
                    return t1;
                case "uint16":
                    for(let e = 0; e < t1.length; e += 2){
                        const r = t1[e], n = t1[e + 1];
                        t1[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t1[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;
                    }
                    return t1;
                case "uint8":
                    for(let e = 0; e < t1.length; e += 4){
                        const r = t1[e], n = t1[e + 1], i = t1[e + 2], s = t1[e + 3];
                        t1[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & s, t1[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & s) << 2, t1[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & s) << 4, t1[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & s) << 6;
                    }
                    return t1;
                default:
                    throw new Error(`Invalid pixel format, "${e}"`);
            }
        }
        Qs(e_, "DEMData"), Qs(Ww, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        var d_ = Uint8Array, f_ = Uint16Array, m_ = Int32Array, y_ = new d_([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            5,
            5,
            5,
            5,
            0,
            0,
            0,
            0
        ]), g_ = new d_([
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            8,
            8,
            9,
            9,
            10,
            10,
            11,
            11,
            12,
            12,
            13,
            13,
            0,
            0
        ]), x_ = new d_([
            16,
            17,
            18,
            0,
            8,
            7,
            9,
            6,
            10,
            5,
            11,
            4,
            12,
            3,
            13,
            2,
            14,
            1,
            15
        ]), v_ = function(t1, e) {
            for(var r = new f_(31), n = 0; n < 31; ++n)r[n] = e += 1 << t1[n - 1];
            var i = new m_(r[30]);
            for(n = 1; n < 30; ++n)for(var s = r[n]; s < r[n + 1]; ++s)i[s] = s - r[n] << 5 | n;
            return {
                b: r,
                r: i
            };
        }, b_ = v_(y_, 2), w_ = b_.b, __ = b_.r;
        w_[28] = 258, __[258] = 28;
        for(var A_ = v_(g_, 0).b, I_ = new f_(32768), M_ = 0; M_ < 32768; ++M_){
            var S_ = (43690 & M_) >> 1 | (21845 & M_) << 1;
            I_[M_] = ((65280 & (S_ = (61680 & (S_ = (52428 & S_) >> 2 | (13107 & S_) << 2)) >> 4 | (3855 & S_) << 4)) >> 8 | (255 & S_) << 8) >> 1;
        }
        var P_ = function(t1, e, r) {
            for(var n = t1.length, i = 0, s = new f_(e); i < n; ++i)t1[i] && ++s[t1[i] - 1];
            var a, o = new f_(e);
            for(i = 1; i < e; ++i)o[i] = o[i - 1] + s[i - 1] << 1;
            a = new f_(1 << e);
            var l = 15 - e;
            for(i = 0; i < n; ++i)if (t1[i]) for(var u = i << 4 | t1[i], c = e - t1[i], h = o[t1[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h)a[I_[h] >> l] = u;
            return a;
        }, z_ = new d_(288);
        for(M_ = 0; M_ < 144; ++M_)z_[M_] = 8;
        for(M_ = 144; M_ < 256; ++M_)z_[M_] = 9;
        for(M_ = 256; M_ < 280; ++M_)z_[M_] = 7;
        for(M_ = 280; M_ < 288; ++M_)z_[M_] = 8;
        var B_ = new d_(32);
        for(M_ = 0; M_ < 32; ++M_)B_[M_] = 5;
        var k_ = P_(z_, 9), T_ = P_(B_, 5), V_ = function(t1) {
            for(var e = t1[0], r = 1; r < t1.length; ++r)t1[r] > e && (e = t1[r]);
            return e;
        }, E_ = function(t1, e, r) {
            var n = e / 8 | 0;
            return (t1[n] | t1[n + 1] << 8) >> (7 & e) & r;
        }, F_ = function(t1, e) {
            var r = e / 8 | 0;
            return (t1[r] | t1[r + 1] << 8 | t1[r + 2] << 16) >> (7 & e);
        }, D_ = function(t1) {
            return (t1 + 7) / 8 | 0;
        }, C_ = [
            "unexpected EOF",
            "invalid block type",
            "invalid length/literal",
            "invalid distance",
            "stream finished",
            "no stream handler",
            ,
            "no callback",
            "invalid UTF-8 data",
            "extra field too long",
            "date not in range 1980-2099",
            "filename too long",
            "stream finishing",
            "invalid zip data"
        ], R_ = function(t1, e, r) {
            var n = new Error(e || C_[t1]);
            if (n.code = t1, Error.captureStackTrace && Error.captureStackTrace(n, R_), !r) throw n;
            return n;
        }, L_ = new d_(0);
        var O_ = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            O_.decode(L_, {
                stream: !0
            });
        } catch (t1) {}
        const U_ = {
            gzip_data: "gzip"
        };
        class N_ extends Error {
            constructor(t1){
                super(t1), this.name = "MRTError";
            }
        }
        const j_ = {
            0: "uint32",
            1: "uint32",
            2: "uint16",
            3: "uint8"
        }, G_ = {
            uint32: 1,
            uint16: 2,
            uint8: 4
        }, $_ = {
            uint32: Uint32Array,
            uint16: Uint16Array,
            uint8: Uint8Array
        };
        let q_;
        class X_ {
            constructor(t1 = 5){
                this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t1;
            }
            getLayer(t1) {
                const e = this.layers[t1];
                if (!e) throw new N_(`Layer '${t1}' not found`);
                return e;
            }
            getHeaderLength(t1) {
                const e = new Uint8Array(t1), r = new DataView(t1);
                if (13 !== e[0]) throw new N_("File is not a valid MRT.");
                return r.getUint32(1, !0);
            }
            parseHeader(t1) {
                const e = new Uint8Array(t1), r = this.getHeaderLength(t1);
                if (e.length < r) throw new N_(`Expected header with length >= ${r} but got buffer of length ${e.length}`);
                const n = new q_(e.subarray(0, r)).readFields(r_, {
                    headerLength: 0,
                    x: 0,
                    y: 0,
                    z: 0,
                    layers: []
                }, void 0);
                if (!isNaN(this.x) && (this.x !== n.x || this.y !== n.y || this.z !== n.z)) throw new N_(`Invalid attempt to parse header ${n.z}/${n.x}/${n.y} for tile ${this.z}/${this.x}/${this.y}`);
                this.x = n.x, this.y = n.y, this.z = n.z;
                for (const t1 of n.layers)this.layers[t1.name] = new H_(t1, {
                    cacheSize: this._cacheSize
                });
                return this;
            }
            createDecodingTask(t1) {
                const e = [], r = this.getLayer(t1.layerName);
                for (let n of t1.blockIndices){
                    const i = r.dataIndex[n], s = i.firstByte - t1.firstByte, a = i.lastByte - t1.firstByte;
                    if (r._blocksInProgress.has(n)) continue;
                    const o = {
                        layerName: r.name,
                        firstByte: s,
                        lastByte: a,
                        pixelFormat: r.pixelFormat,
                        blockIndex: n,
                        blockShape: [
                            i.bands.length
                        ].concat(r.bandShape),
                        buffer: r.buffer,
                        codec: i.codec.codec,
                        filters: i.filters.map((t1)=>t1.filter)
                    };
                    r._blocksInProgress.add(n), e.push(o);
                }
                return new Z_(e, ()=>{
                    e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex));
                }, (t1, n)=>{
                    if (e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex)), t1) throw t1;
                    n.forEach((t1)=>{
                        this.getLayer(t1.layerName).processDecodedData(t1);
                    });
                });
            }
        }
        class H_ {
            constructor({ version: t1, name: e, units: r, tileSize: n, pixelFormat: i, buffer: s, dataIndex: a }, o){
                if (this.version = t1, 1 !== this.version) throw new N_(`Cannot parse raster layer encoded with MRT version ${t1}`);
                this.name = e, this.units = r, this.tileSize = n, this.buffer = s, this.pixelFormat = j_[i], this.dataIndex = a, this.bandShape = [
                    n + 2 * s,
                    n + 2 * s,
                    G_[this.pixelFormat]
                ], this._decodedBlocks = new jw(o ? o.cacheSize : 5), this._blocksInProgress = new Set;
            }
            get dimension() {
                return G_[this.pixelFormat];
            }
            get cacheSize() {
                return this._decodedBlocks.capacity;
            }
            getBandList() {
                return this.dataIndex.map(({ bands: t1 })=>t1).flat();
            }
            processDecodedData(t1) {
                const e = t1.blockIndex.toString();
                this._decodedBlocks.get(e) || this._decodedBlocks.put(e, t1.data);
            }
            getBlockForBand(t1) {
                let e = 0;
                switch(typeof t1){
                    case "string":
                        for (const [r, n] of this.dataIndex.entries()){
                            for (const [i, s] of n.bands.entries())if (s === t1) return {
                                bandIndex: e + i,
                                blockIndex: r,
                                blockBandIndex: i
                            };
                            e += n.bands.length;
                        }
                        break;
                    case "number":
                        for (const [r, n] of this.dataIndex.entries()){
                            if (t1 >= e && t1 < e + n.bands.length) return {
                                bandIndex: t1,
                                blockIndex: r,
                                blockBandIndex: t1 - e
                            };
                            e += n.bands.length;
                        }
                        break;
                    default:
                        throw new N_(`Invalid band \`${JSON.stringify(t1)}\`. Expected string or integer.`);
                }
                return {
                    blockIndex: -1,
                    blockBandIndex: -1
                };
            }
            getDataRange(t1) {
                let e = 1 / 0, r = -1 / 0;
                const n = [], i = new Set;
                for (const s of t1){
                    const { blockIndex: t1 } = this.getBlockForBand(s);
                    if (t1 < 0) throw new N_(`Invalid band: ${JSON.stringify(s)}`);
                    const a = this.dataIndex[t1];
                    n.includes(t1) || n.push(t1), i.add(t1), e = Math.min(e, a.firstByte), r = Math.max(r, a.lastByte);
                }
                if (i.size > this.cacheSize) throw new N_(`Number of blocks to decode (${i.size}) exceeds cache size (${this.cacheSize}).`);
                return {
                    layerName: this.name,
                    firstByte: e,
                    lastByte: r,
                    blockIndices: n
                };
            }
            hasBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0;
            }
            hasDataForBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0 && !!this._decodedBlocks.get(e.toString());
            }
            getBandView(t1) {
                const { blockIndex: e, blockBandIndex: r } = this.getBlockForBand(t1);
                if (e < 0) throw new N_(`Band not found: ${JSON.stringify(t1)}`);
                const n = this._decodedBlocks.get(e.toString());
                if (!n) throw new N_(`Data for band ${JSON.stringify(t1)} of layer "${this.name}" not decoded.`);
                const i = this.dataIndex[e], s = this.bandShape.reduce((t1, e)=>t1 * e, 1), a = r * s, o = n.subarray(a, a + s);
                return {
                    data: o,
                    bytes: new Uint8Array(o.buffer).subarray(o.byteOffset, o.byteOffset + o.byteLength),
                    tileSize: this.tileSize,
                    buffer: this.buffer,
                    pixelFormat: this.pixelFormat,
                    dimension: this.dimension,
                    offset: i.offset,
                    scale: i.scale
                };
            }
        }
        X_.setPbf = function(t1) {
            q_ = t1;
        };
        class Z_ {
            constructor(t1, e, r){
                this.tasks = t1, this._onCancel = e, this._onComplete = r, this._finalized = !1;
            }
            cancel() {
                this._finalized || (this._onCancel(), this._finalized = !0);
            }
            complete(t1, e) {
                this._finalized || (this._onComplete(t1, e), this._finalized = !0);
            }
        }
        X_.performDecoding = function(t1, e) {
            const r = new Uint8Array(t1);
            return Promise.all(e.tasks.map((t1)=>{
                const { layerName: e, firstByte: n, lastByte: i, pixelFormat: s, blockShape: a, blockIndex: o, filters: l, codec: u } = t1, c = r.subarray(n, i + 1), h = new Uint32Array(a[0] * a[1] * a[2]);
                let p;
                if ("gzip_data" !== u) throw new N_(`Unhandled codec: ${u}`);
                return p = (function(t1, e) {
                    if (!globalThis.DecompressionStream && "gzip_data" === e) return Promise.resolve((a = function(t1) {
                        31 == t1[0] && 139 == t1[1] && 8 == t1[2] || R_(6, "invalid gzip data");
                        var e = t1[3], r = 10;
                        4 & e && (r += 2 + (t1[10] | t1[11] << 8));
                        for(var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t1[r++]);
                        return r + (2 & e);
                    }(r = t1), a + 8 > r.length && R_(6, "invalid gzip data"), function(t1, e, r, n) {
                        var i = t1.length;
                        if (!i || e.f && !e.l) return r || new d_(0);
                        var s = !r, a = s || 2 != e.i, o = e.i;
                        s && (r = new d_(3 * i));
                        var l = function(t1) {
                            var e = r.length;
                            if (t1 > e) {
                                var n = new d_(Math.max(2 * e, t1));
                                n.set(r), r = n;
                            }
                        }, u = e.f || 0, c = e.p || 0, h = e.b || 0, p = e.l, d = e.d, f = e.m, m = e.n, y = 8 * i;
                        do {
                            if (!p) {
                                u = E_(t1, c, 1);
                                var g = E_(t1, c + 1, 3);
                                if (c += 3, !g) {
                                    var x = t1[(B = D_(c) + 4) - 4] | t1[B - 3] << 8, v = B + x;
                                    if (v > i) {
                                        o && R_(0);
                                        break;
                                    }
                                    a && l(h + x), r.set(t1.subarray(B, v), h), e.b = h += x, e.p = c = 8 * v, e.f = u;
                                    continue;
                                }
                                if (1 == g) p = k_, d = T_, f = 9, m = 5;
                                else if (2 == g) {
                                    var b = E_(t1, c, 31) + 257, w = E_(t1, c + 10, 15) + 4, _ = b + E_(t1, c + 5, 31) + 1;
                                    c += 14;
                                    for(var A = new d_(_), I = new d_(19), M = 0; M < w; ++M)I[x_[M]] = E_(t1, c + 3 * M, 7);
                                    c += 3 * w;
                                    var S = V_(I), P = (1 << S) - 1, z = P_(I, S);
                                    for(M = 0; M < _;){
                                        var B, k = z[E_(t1, c, P)];
                                        if (c += 15 & k, (B = k >> 4) < 16) A[M++] = B;
                                        else {
                                            var T = 0, V = 0;
                                            for(16 == B ? (V = 3 + E_(t1, c, 3), c += 2, T = A[M - 1]) : 17 == B ? (V = 3 + E_(t1, c, 7), c += 3) : 18 == B && (V = 11 + E_(t1, c, 127), c += 7); V--;)A[M++] = T;
                                        }
                                    }
                                    var E = A.subarray(0, b), F = A.subarray(b);
                                    f = V_(E), m = V_(F), p = P_(E, f), d = P_(F, m);
                                } else R_(1);
                                if (c > y) {
                                    o && R_(0);
                                    break;
                                }
                            }
                            a && l(h + 131072);
                            for(var D = (1 << f) - 1, C = (1 << m) - 1, R = c;; R = c){
                                var L = (T = p[F_(t1, c) & D]) >> 4;
                                if ((c += 15 & T) > y) {
                                    o && R_(0);
                                    break;
                                }
                                if (T || R_(2), L < 256) r[h++] = L;
                                else {
                                    if (256 == L) {
                                        R = c, p = null;
                                        break;
                                    }
                                    var O = L - 254;
                                    L > 264 && (O = E_(t1, c, (1 << (j = y_[M = L - 257])) - 1) + w_[M], c += j);
                                    var U = d[F_(t1, c) & C], N = U >> 4;
                                    if (U || R_(3), c += 15 & U, F = A_[N], N > 3) {
                                        var j = g_[N];
                                        F += F_(t1, c) & (1 << j) - 1, c += j;
                                    }
                                    if (c > y) {
                                        o && R_(0);
                                        break;
                                    }
                                    a && l(h + 131072);
                                    var G = h + O;
                                    if (h < F) {
                                        var $ = 0 - F, q = Math.min(F, G);
                                        for($ + h < 0 && R_(3); h < q; ++h)r[h] = n[$ + h];
                                    }
                                    for(; h < G; ++h)r[h] = r[h - F];
                                }
                            }
                            e.l = p, e.p = R, e.b = h, e.f = u, p && (u = 1, e.m = f, e.d = d, e.n = m);
                        }while (!u)
                        return h != r.length && s ? function(t1, e, r) {
                            return (null == r || r > t1.length) && (r = t1.length), new d_(t1.subarray(0, r));
                        }(r, 0, h) : r.subarray(0, h);
                    }(r.subarray(a, -8), {
                        i: 2
                    }, new d_(((i = r)[(s = i.length) - 4] | i[s - 3] << 8 | i[s - 2] << 16 | i[s - 1] << 24) >>> 0), n)));
                    var r, n, i, s, a;
                    const o = U_[e];
                    if (!o) throw new Error(`Unhandled codec: ${e}`);
                    const l = new globalThis.DecompressionStream(o);
                    return new Response(new Blob([
                        t1
                    ]).stream().pipeThrough(l)).arrayBuffer().then((t1)=>new Uint8Array(t1));
                })(c, u).then((t1)=>((function(t1, e) {
                        t1.readFields(l_, e);
                    })(new q_(t1), h), new (0, $_[s])(h.buffer))), p.then((t1)=>{
                    for(let e = l.length - 1; e >= 0; e--)switch(l[e]){
                        case "delta_filter":
                            c_(t1, a);
                            break;
                        case "zigzag_filter":
                            h_(t1);
                            break;
                        case "bitshuffle_filter":
                            p_(t1, s);
                            break;
                        default:
                            throw new N_(`Unhandled filter "${l[e]}"`);
                    }
                    return {
                        layerName: e,
                        blockIndex: o,
                        data: t1
                    };
                }).catch((t1)=>{
                    throw t1;
                });
            }));
        }, Qs(Z_, "MRTDecodingBatch", {
            omit: [
                "_onCancel",
                "_onComplete"
            ]
        }), Qs(X_, "MapboxRasterTile"), Qs(H_, "MapboxRasterLayer", {
            omit: [
                "_blocksInProgress"
            ]
        });
        class W_ {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e = 0; e < t1.length; e++){
                    const r = t1[e];
                    this._stringToNumber[r] = e, this._numberToString[e] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                return this._numberToString[t1];
            }
        }
        class Y_ {
            constructor(t1, e){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new Js(jn, 16, 0), this.featureIndexArray = new Vl, this.promoteId = e, this.is3DTile = !1, this.serializedLayersCache = new Map;
            }
            insert(t1, e, r, n, i, s = 0, a = 0) {
                const o = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const l = this.grid;
                for(let t1 = 0; t1 < e.length; t1++){
                    const r = e[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e = r[t1];
                        n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
                    }
                    0 !== a && (n[0] -= a, n[1] -= a, n[2] += a, n[3] += a), n[0] < jn && n[1] < jn && n[2] >= 0 && n[3] >= 0 && l.insert(o, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new ic(new Vg(this.rawTileData)).layers, this.sourceLayerCoder = new W_(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {};
                    for(const t1 in this.vtLayers)this.vtFeatures[t1] = [];
                }
                return this.vtLayers;
            }
            query(t1, e) {
                const { tilespaceGeometry: r, transform: n, tileTransform: i, pixelPosMatrix: s, availableImages: a, worldview: o } = e;
                this.loadVTLayers(), this.serializedLayersCache.clear();
                const l = e.queryRadius ? e.queryRadius : 0, u = r.bufferedTilespaceBounds, c = this.grid.query(u.min.x, u.min.y, u.max.x, u.max.y, (t1, e, n, i)=>Oc(r.bufferedTilespaceGeometry, t1 - l, e - l, n + l, i + l));
                c.sort(K_);
                let h = null;
                n.elevation && c.length > 0 && (h = Cb.create(n.elevation, this.tileID));
                const p = {};
                let d;
                for(let l = 0; l < c.length; l++){
                    const u = c[l];
                    if (u === d) continue;
                    d = u;
                    const f = this.featureIndexArray.get(u);
                    let m = null;
                    this.is3DTile ? this.loadMatchingModelFeature(p, f, t1, r, n, o) : this.loadMatchingFeature(p, f, t1, a, o, (t1, a, o, l = 0)=>(m || (m = Ju(t1, this.tileID.canonical, i)), a.queryIntersectsFeature(r, t1, o, m, this.z, n, s, h, l, e.scope)));
                }
                return p;
            }
            loadMatchingFeature(t1, e, r, n, i, s) {
                const { featureIndex: a, bucketIndex: o, sourceLayerIndex: l, layoutVertexArrayOffset: u } = e, c = this.bucketLayerIDs[o], h = r.layers, p = Object.keys(h);
                if (p.length && !Xt(p, c)) return;
                const d = r.sourceCache, f = this.sourceLayerCoder.decode(l), m = this.vtLayers[f].feature(a), y = this.getId(m, f);
                for(let e = 0; e < c.length; e++){
                    const r = c[e];
                    if (!h[r]) continue;
                    const { styleLayer: o, targets: l } = h[r];
                    let p = {};
                    void 0 !== y && (p = d.getFeatureState(o.sourceLayer, y));
                    const f = !s || s(m, o, p, u);
                    if (!f) continue;
                    const g = new Zb(m, this.z, this.x, this.y, y);
                    g.tile = this.tileID.canonical, g.state = p;
                    let x = this.serializedLayersCache.get(r);
                    x || (x = o.serialize(), x.id = r, this.serializedLayersCache.set(r, x)), g.source = x.source, g.sourceLayer = x["source-layer"], g.layer = Object.assign({}, x), g.layer.paint = J_(x.paint, o.paint, m, p, n), g.layer.layout = J_(x.layout, o.layout, m, p, n);
                    let v = !1;
                    for (const t1 of l){
                        this.updateFeatureProperties(g, t1);
                        const { filter: e } = t1;
                        if (e) {
                            if (m.properties = g.properties, e.needGeometry) {
                                const t1 = Ku(m, !0);
                                if (!e.filter(new Ja(this.tileID.overscaledZ, {
                                    worldview: i
                                }), t1, this.tileID.canonical)) continue;
                            } else if (!e.filter(new Ja(this.tileID.overscaledZ, {
                                worldview: i
                            }), m)) continue;
                        }
                        v = !0, t1.targetId && this.addFeatureVariant(g, t1);
                    }
                    v && this.appendToResult(t1, r, a, g, f);
                }
            }
            loadMatchingModelFeature(t1, e, r, n, i, s) {
                const { featureIndex: a, bucketIndex: o } = e, l = this.bucketLayerIDs[o], u = r.layers, c = Object.keys(u);
                if (!c.length || Xt(c, l)) for(let e = 0; e < l.length; e++){
                    const o = l[e], { styleLayer: c, targets: h } = u[o];
                    if ("model" !== c.type) continue;
                    const p = n.tile, d = p.getBucket(c);
                    if (!(d && d instanceof Gb)) continue;
                    const f = Jb(d, a, n, i);
                    if (!f) continue;
                    const { z: m, x: y, y: g } = p.tileID.canonical, { feature: x, intersectionZ: v, position: b } = f;
                    let w = {};
                    void 0 !== x.id && (w = r.sourceCache.getFeatureState(c.sourceLayer, x.id));
                    const _ = new Zb({}, m, y, g, x.id);
                    _.tile = this.tileID.canonical, _.state = w, _.properties = x.properties, _.geometry = {
                        type: "Point",
                        coordinates: [
                            b.lng,
                            b.lat
                        ]
                    };
                    let A = this.serializedLayersCache.get(o);
                    A || (A = c.serialize(), A.id = o, this.serializedLayersCache.set(o, A)), _.source = A.source, _.sourceLayer = A["source-layer"], _.layer = Object.assign({}, A);
                    let I = !1;
                    for (const t1 of h){
                        this.updateFeatureProperties(_, t1);
                        const { filter: e } = t1;
                        if (e) {
                            if (x.properties = _.properties, e.needGeometry) {
                                if (!e.filter(new Ja(this.tileID.overscaledZ, {
                                    worldview: s
                                }), x, this.tileID.canonical)) continue;
                            } else if (!e.filter(new Ja(this.tileID.overscaledZ, {
                                worldview: s
                            }), x)) continue;
                        }
                        I = !0, t1.targetId && this.addFeatureVariant(_, t1);
                    }
                    I && this.appendToResult(t1, o, a, _, v);
                }
            }
            updateFeatureProperties(t1, e, r) {
                if (e.properties) {
                    const n = {};
                    for(const i in e.properties){
                        const s = e.properties[i].evaluate({
                            zoom: this.z
                        }, t1._vectorTileFeature, t1.state, t1.tile, r);
                        null != s && (n[i] = s);
                    }
                    t1.properties = n;
                }
            }
            addFeatureVariant(t1, e, r) {
                const n = {
                    target: e.target,
                    namespace: e.namespace,
                    uniqueFeatureID: e.uniqueFeatureID
                };
                e.properties && (n.properties = t1.properties), t1.variants = t1.variants || {}, t1.variants[e.targetId] = t1.variants[e.targetId] || [], t1.variants[e.targetId].push(n);
            }
            appendToResult(t1, e, r, n, i) {
                let s = t1[e];
                void 0 === s && (s = t1[e] = []), s.push({
                    featureIndex: r,
                    feature: n,
                    intersectionZ: i
                });
            }
            lookupSymbolFeatures(t1, e, r, n, i, s) {
                const a = {};
                this.loadVTLayers();
                for (const o of t1)this.loadMatchingFeature(a, {
                    bucketIndex: e,
                    sourceLayerIndex: r,
                    featureIndex: o,
                    layoutVertexArrayOffset: 0
                }, n, i, s);
                return a;
            }
            loadFeature(t1) {
                const { featureIndex: e, sourceLayerIndex: r } = t1;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n];
                if (i[e]) return i[e];
                const s = this.vtLayers[n].feature(e);
                return i[e] = s, s;
            }
            hasLayer(t1) {
                for (const e of this.bucketLayerIDs)for (const r of e)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e) {
                let r = t1.id;
                if (this.promoteId) {
                    const n = Array.isArray(this.promoteId) || "object" != typeof this.promoteId ? this.promoteId : this.promoteId[e];
                    if (null != n) if (Array.isArray(n)) {
                        if (!this.promoteIdExpression) {
                            const t1 = js(n);
                            if ("success" !== t1.result) {
                                const e = t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", ");
                                return void Zt(`Failed to create expression for promoteId: ${e}`);
                            }
                            this.promoteIdExpression = t1.value;
                        }
                        r = this.promoteIdExpression.evaluate({
                            zoom: 0
                        }, t1);
                    } else r = t1.properties[n];
                    "boolean" == typeof r && (r = Number(r));
                }
                return r;
            }
        }
        function J_(t1, e, r, n, i) {
            return Gt(t1, (t1, s)=>{
                const a = e instanceof so ? e.get(s) : null;
                return a && a.evaluate ? a.evaluate(r, n, void 0, i) : a;
            });
        }
        function K_(t1, e) {
            return e - t1;
        }
        Qs(Y_, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        const Q_ = [
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        ];
        class tA {
            static from(t1) {
                if (!(t1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                const [e, r] = new Uint8Array(t1, 0, 2);
                if (219 !== e) throw new Error("Data does not appear to be in a KDBush format.");
                const n = r >> 4;
                if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);
                const i = Q_[15 & r];
                if (!i) throw new Error("Unrecognized array type.");
                const [s] = new Uint16Array(t1, 2, 1), [a] = new Uint32Array(t1, 4, 1);
                return new tA(a, s, i, t1);
            }
            constructor(t1, e = 64, r = Float64Array, n){
                if (isNaN(t1) || t1 < 0) throw new Error(`Unpexpected numItems value: ${t1}.`);
                this.numItems = +t1, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t1 < 65536 ? Uint16Array : Uint32Array;
                const i = Q_.indexOf(this.ArrayType), s = 2 * t1 * this.ArrayType.BYTES_PER_ELEMENT, a = t1 * this.IndexArrayType.BYTES_PER_ELEMENT, o = (8 - a % 8) % 8;
                if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);
                n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t1), this._pos = 2 * t1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + a + o), this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([
                    219,
                    16 + i
                ]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t1);
            }
            add(t1, e) {
                const r = this._pos >> 1;
                return this.ids[r] = r, this.coords[this._pos++] = t1, this.coords[this._pos++] = e, r;
            }
            finish() {
                const t1 = this._pos >> 1;
                if (t1 !== this.numItems) throw new Error(`Added ${t1} items when expected ${this.numItems}.`);
                return eA(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
            }
            range(t1, e, r, n) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: i, coords: s, nodeSize: a } = this, o = [
                    0,
                    i.length - 1,
                    0
                ], l = [];
                for(; o.length;){
                    const u = o.pop() || 0, c = o.pop() || 0, h = o.pop() || 0;
                    if (c - h <= a) {
                        for(let a = h; a <= c; a++){
                            const o = s[2 * a], u = s[2 * a + 1];
                            o >= t1 && o <= r && u >= e && u <= n && l.push(i[a]);
                        }
                        continue;
                    }
                    const p = h + c >> 1, d = s[2 * p], f = s[2 * p + 1];
                    d >= t1 && d <= r && f >= e && f <= n && l.push(i[p]), (0 === u ? t1 <= d : e <= f) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= d : n >= f) && (o.push(p + 1), o.push(c), o.push(1 - u));
                }
                return l;
            }
            within(t1, e, r) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: n, coords: i, nodeSize: s } = this, a = [
                    0,
                    n.length - 1,
                    0
                ], o = [], l = r * r;
                for(; a.length;){
                    const u = a.pop() || 0, c = a.pop() || 0, h = a.pop() || 0;
                    if (c - h <= s) {
                        for(let r = h; r <= c; r++)sA(i[2 * r], i[2 * r + 1], t1, e) <= l && o.push(n[r]);
                        continue;
                    }
                    const p = h + c >> 1, d = i[2 * p], f = i[2 * p + 1];
                    sA(d, f, t1, e) <= l && o.push(n[p]), (0 === u ? t1 - r <= d : e - r <= f) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? t1 + r >= d : e + r >= f) && (a.push(p + 1), a.push(c), a.push(1 - u));
                }
                return o;
            }
        }
        function eA(t1, e, r, n, i, s) {
            if (i - n <= r) return;
            const a = n + i >> 1;
            rA(t1, e, a, n, i, s), eA(t1, e, r, n, a - 1, 1 - s), eA(t1, e, r, a + 1, i, 1 - s);
        }
        function rA(t1, e, r, n, i, s) {
            for(; i > n;){
                if (i - n > 600) {
                    const a = i - n + 1, o = r - n + 1, l = Math.log(a), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1);
                    rA(t1, e, r, Math.max(n, Math.floor(r - o * u / a + c)), Math.min(i, Math.floor(r + (a - o) * u / a + c)), s);
                }
                const a = e[2 * r + s];
                let o = n, l = i;
                for(nA(t1, e, n, r), e[2 * i + s] > a && nA(t1, e, n, i); o < l;){
                    for(nA(t1, e, o, l), o++, l--; e[2 * o + s] < a;)o++;
                    for(; e[2 * l + s] > a;)l--;
                }
                e[2 * n + s] === a ? nA(t1, e, n, l) : (l++, nA(t1, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);
            }
        }
        function nA(t1, e, r, n) {
            iA(t1, r, n), iA(e, 2 * r, 2 * n), iA(e, 2 * r + 1, 2 * n + 1);
        }
        function iA(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function sA(t1, e, r, n) {
            const i = t1 - r, s = e - n;
            return i * i + s * s;
        }
        t1.$ = tn, t1.A = Lr, t1.B = zo, t1.C = 2, t1.D = Zf, t1.E = ir, t1.F = Mx, t1.G = Ix, t1.H = Jr, t1.I = sr, t1.J = ho, t1.K = Yr, t1.L = Qr, t1.M = Ts, t1.N = zs, t1.O = ks, t1.P = Mt, t1.Q = Ns, t1.R = Ce, t1.S = po, t1.T = Cm, t1.U = js, t1.V = Bb, t1.W = qs, t1.X = vi, t1.Y = gi, t1.Z = xi, t1._ = an, t1.a = function(t1) {
            return oe.API_CDN_URL_REGEX.test(t1);
        }, t1.a$ = Cu, t1.a0 = Kr, t1.a1 = lr, t1.a2 = fo, t1.a3 = class extends Bb {
        }, t1.a4 = Vs, t1.a5 = Bs, t1.a6 = co, t1.a7 = function(t1) {
            const e = t1.value;
            return e ? Kr(e) ? kb(e, !0) ? [] : [
                new Bb(t1.key, e, `invalid url "${e}"`)
            ] : [
                new Bb(t1.key, e, `string expected, "${Yr(e)}" found`)
            ] : [];
        }, t1.a8 = to, t1.a9 = uo, t1.aA = Dt, t1.aB = h, t1.aC = tt, t1.aD = bu, t1.aE = Lc, t1.aF = Vu, t1.aG = qu, t1.aH = function(t1, e) {
            const r = {};
            for(let n = 0; n < e.length; n++){
                const i = e[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.aI = ku, t1.aJ = Eu, t1.aK = class {
            constructor(t1){
                this.entries = {}, this.scheduler = t1;
            }
            request(t1, e, r, n) {
                const i = this.entries[t1] = this.entries[t1] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t1, r] = i.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t1, r);
                    }, e) : n(t1, r), ()=>{};
                }
                return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n)=>{
                    i.result = [
                        r,
                        n
                    ];
                    for (const t1 of i.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t1(r, n);
                    }, e) : t1(r, n);
                    setTimeout(()=>delete this.entries[t1], 3e3);
                })), ()=>{
                    i.result || (i.callbacks = i.callbacks.filter((t1)=>t1 !== n), i.callbacks.length || (i.cancel(), delete this.entries[t1]));
                };
            }
        }, t1.aL = function(t1, e, r) {
            const n = JSON.stringify(t1.request);
            return t1.data && (this.deduped.entries[n] = {
                result: [
                    null,
                    t1.data
                ]
            }), this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t1.isSymbolTile,
                zoom: t1.tileZoom
            }, (e)=>{
                const n = Ue(t1.request, (t1, n, i)=>{
                    t1 ? e(t1) : n && e(null, {
                        rawData: n,
                        vectorTile: r ? void 0 : new ic(new Vg(n)),
                        responseHeaders: new Map(i.entries())
                    });
                });
                return ()=>{
                    n.cancel(), e();
                };
            }, e);
        }, t1.aM = function(t1) {
            return t1 ? {
                cacheControl: t1.get("Cache-Control"),
                expires: t1.get("Expires")
            } : {
                cacheControl: void 0,
                expires: void 0
            };
        }, t1.aN = Re, t1.aO = function(t1) {
            ze++, ze > _e && (t1.getActor().send("enforceCacheSizeLimit", we), ze = 0);
        }, t1.aP = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log2(t1)));
        }, t1.aQ = Kc, t1.aR = vb, t1.aS = Mb, t1.aT = Bu, t1.aU = gb, t1.aV = function(t1, e) {
            const r = document.createElement("video");
            r.muted = !0, r.onloadstart = function() {
                e(null, r);
            };
            for(let e = 0; e < t1.length; e++){
                const n = document.createElement("source");
                Ne(t1[e]) || (r.crossOrigin = "Anonymous"), n.src = t1[e], r.appendChild(n);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.aW = Rm, t1.aX = Wb, t1.aY = jt, t1.aZ = _v, t1.a_ = Du, t1.aa = ao, t1.ab = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return Jt(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: dr(t1.x, e.x, r),
                    y: dr(t1.y, e.y, r),
                    z: dr(t1.z, e.z, r),
                    azimuthal: dr(t1.azimuthal, e.azimuthal, r),
                    polar: dr(t1.polar, e.polar, r)
                };
            }
        }, t1.ac = Ja, t1.ad = $s, t1.ae = Gu, t1.af = j, t1.ag = I, t1.ah = Ct, t1.ai = so, t1.aj = Ih, t1.ak = dr, t1.al = jn, t1.am = fr, t1.an = Bt, t1.ao = ur, t1.ap = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return function([t1, e]) {
                    const r = Jt([
                        1,
                        t1,
                        e
                    ]);
                    return {
                        x: r.x,
                        y: r.y,
                        z: r.z
                    };
                }(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: dr(t1.x, e.x, r),
                    y: dr(t1.y, e.y, r),
                    z: dr(t1.z, e.z, r)
                };
            }
        }, t1.aq = function(t1, e, r = 0, n = !0) {
            const i = new Mt(r, r), s = t1.sub(i), a = e.add(i), o = [
                s,
                new Mt(a.x, s.y),
                a,
                new Mt(s.x, a.y)
            ];
            return n && o.push(s.clone()), o;
        }, t1.ar = function(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; n++){
                const i = Rt(n - 1, -1, t1.length - 1), s = Rt(n + 1, -1, t1.length - 1), a = t1[n], o = t1[s], l = t1[i].sub(a).unit(), u = o.sub(a).unit(), c = u.angleWithSep(l.x, l.y), h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
                r.push(a.add(h));
            }
            return r;
        }, t1.as = Av, t1.at = Oc, t1.au = function(t1, e, r = 0) {
            return M(((e.x - r) * t1.scale - t1.x) * jn, (e.y * t1.scale - t1.y) * jn, Ru(e.z, e.y));
        }, t1.av = H, t1.aw = L, t1.ax = fc, t1.ay = ng, t1.az = function(t1) {
            let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const s of t1)e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
            return {
                min: new Mt(e, r),
                max: new Mt(n, i)
            };
        }, t1.b = function(t1) {
            return oe.API_FONTS_REGEX.test(t1);
        }, t1.b$ = Xd, t1.b0 = ll, t1.b1 = Go, t1.b2 = Ut, t1.b3 = Il, t1.b4 = eb, t1.b5 = function() {
            Ya.isLoading() || Ya.isLoaded() || "deferred" !== Za() || Wa();
        }, t1.b6 = mo, t1.b7 = Ku, t1.b8 = Zb, t1.b9 = Qt, t1.bA = u, t1.bB = y, t1.bC = o, t1.bD = function(t1, e) {
            const { x: r, y: n } = t1.point, i = Ah(r, n, t1.worldSize / t1._pixelsPerMercatorPixel, 0, 0);
            return h(i, i, bh(ch(e)));
        }, t1.bE = n, t1.bF = q, t1.bG = F, t1.bH = E, t1.bI = U, t1.bJ = O, t1.bK = mx, t1.bL = Hg, t1.bM = fx, t1.bN = function(t1, e, r, n, i) {
            const s = 5 * e + 2;
            t1.float32[s + 0] = r, t1.float32[s + 1] = n, t1.float32[s + 2] = i;
        }, t1.bO = Jv, t1.bP = ht, t1.bQ = mt, t1.bR = dt, t1.bS = wt, t1.bT = Rt, t1.bU = function(t1, e, n, i) {
            var s = new r(4);
            return s[0] = t1, s[1] = e, s[2] = n, s[3] = i, s;
        }, t1.bV = class {
            isDataAvailableAtPoint(t1) {
                const e = this._source();
                if (this.isUsingMockSource() || !e || t1.y < 0 || t1.y > 1) return !1;
                const r = e.getSource().maxzoom, n = 1 << r, i = Math.floor(t1.x), s = Math.floor((t1.x - i) * n), a = Math.floor(t1.y * n), o = this.findDEMTileFor(new Kc(r, i, r, s, a));
                return !(!o || !o.dem);
            }
            getAtPointOrZero(t1, e = 0) {
                return this.getAtPoint(t1, e) || 0;
            }
            getAtPoint(t1, e, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e && (e = null);
                const n = this._source();
                if (!n) return e;
                if (t1.y < 0 || t1.y > 1) return e;
                const i = n.getSource().maxzoom, s = 1 << i, a = Math.floor(t1.x), o = t1.x - a, l = new Kc(i, a, i, Math.floor(o * s), Math.floor(t1.y * s)), u = this.findDEMTileFor(l);
                if (!u || !u.dem) return e;
                const c = u.dem, h = 1 << u.tileID.canonical.z, p = (o * h - u.tileID.canonical.x) * c.dim, d = (t1.y * h - u.tileID.canonical.y) * c.dim, f = Math.floor(p), m = Math.floor(d);
                return (r ? this.exaggeration() : 1) * dr(dr(c.get(f, m), c.get(f, m + 1), d - m), dr(c.get(f + 1, m), c.get(f + 1, m + 1), d - m), p - f);
            }
            static getAtTileOffset(t1, e, r, n) {
                const i = 1 << t1.canonical.z;
                return n ? n.pointElevation(e) : r ? r.getAtPointOrZero(new Gu(t1.wrap + (t1.canonical.x + e.x / jn) / i, (t1.canonical.y + e.y / jn) / i)) : 0;
            }
            static getAtTileOffsetFunc(t1, e, r, n) {
                return (i, s, a)=>{
                    const o = this.getAtTileOffset(t1, i, s, a), l = n.upVector(t1.canonical, i.x, i.y);
                    return V(l, l, o * n.upVectorScale(t1.canonical, e, r).metersToTile), l;
                };
            }
            getForTilePoints(t1, e, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i = Cb.create(this, t1, n);
                return !!i && (e.forEach((t1)=>{
                    t1[2] = this.exaggeration() * i.getElevationAt(t1[0], t1[1], r);
                }), !0);
            }
            getMinMaxForTile(t1) {
                if (this.isUsingMockSource()) return null;
                const e = this.findDEMTileFor(t1);
                if (!e || !e.dem) return null;
                const r = e.dem.tree, n = e.tileID, i = 1 << t1.canonical.z - n.canonical.z;
                let s = t1.canonical.x / i - n.canonical.x, a = t1.canonical.y / i - n.canonical.y, o = 0;
                for(let e = 0; e < t1.canonical.z - n.canonical.z && !r.leaves[o]; e++){
                    s *= 2, a *= 2;
                    const t1 = 2 * Math.floor(a) + Math.floor(s);
                    o = r.childOffsets[o] + t1, s %= 1, a %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[o],
                    max: this.exaggeration() * r.maximums[o]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t1, e, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t1) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t1) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
            getMinMaxForVisibleTiles() {
                const t1 = this.visibleDemTiles;
                if (0 === t1.length) return null;
                let e = !1, r = Number.MAX_VALUE, n = Number.MIN_VALUE;
                for (const i of t1){
                    const t1 = this.getMinMaxForTile(i.tileID);
                    t1 && (r = Math.min(r, t1.min), n = Math.max(n, t1.max), e = !0);
                }
                return e ? {
                    min: r,
                    max: n
                } : null;
            }
        }, t1.bW = Ef, t1.bX = Pc, t1.bY = Ig, t1.bZ = Rd, t1.b_ = zb, t1.ba = Qy, t1.bb = vd, t1.bc = Ju, t1.bd = No, t1.be = xl, t1.bf = ih, t1.bg = Ol, t1.bh = Qh, t1.bi = db, t1.bj = function(t1, e) {
            const r = Ih(e.zoom);
            if (0 === r) return ch(t1);
            const n = fh(t1), i = mh(n), s = Vu(n.getWest()) * e.worldSize, a = Vu(n.getEast()) * e.worldSize, o = Eu(n.getNorth()) * e.worldSize, l = Eu(n.getSouth()) * e.worldSize, u = [
                s,
                o,
                0
            ], h = [
                a,
                o,
                0
            ], p = [
                s,
                l,
                0
            ], d = [
                a,
                l,
                0
            ], f = c([], e.globeMatrix);
            return j(u, u, f), j(h, h, f), j(p, p, f), j(d, d, f), i[0] = hh(i[0], p, r), i[1] = hh(i[1], d, r), i[2] = hh(i[2], h, r), i[3] = hh(i[3], u, r), wc.fromPoints(i);
        }, t1.bk = vh, t1.bl = c, t1.bm = yh, t1.bn = hh, t1.bo = jo, t1.bp = nh, t1.bq = g, t1.br = p, t1.bs = X_, t1.bt = Vg, t1.bu = Ue, t1.bv = function(t1, e) {
            const r = [];
            for(const n in t1)n in e || r.push(n);
            return r;
        }, t1.bw = Lt, t1.bx = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.by = St, t1.bz = l, t1.c = ue, t1.c$ = function(t1, e, r) {
            let n = 0;
            for(let r = 0; r < 2; ++r){
                const i = 0;
                t1[r] > i && (n += (t1[r] - i) * (t1[r] - i)), e[r] < i && (n += (i - e[r]) * (i - e[r]));
            }
            return n;
        }, t1.c0 = Hd, t1.c1 = ix, t1.c2 = Yx, t1.c3 = uv, t1.c4 = tA, t1.c5 = V, t1.c6 = W, t1.c7 = rt, t1.c8 = function(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + i * o, t1[1] = i * l - n * o, t1[2] = s * l + a * o, t1[3] = a * l - s * o, t1;
        }, t1.c9 = nt, t1.cA = _, t1.cB = bc, t1.cC = Xm, t1.cD = Yc, t1.cE = dh, t1.cF = function(t1, e, r, n, i, s, a, o, l) {
            if ("globe" === l.name) return dh(t1, e, new Yc(r, n, i), !1);
            const u = _v({
                z: r,
                x: n,
                y: i
            }, l);
            return new wc([
                (s + u.x / u.scale) * e,
                e * (u.y / u.scale),
                a
            ], [
                (s + u.x2 / u.scale) * e,
                e * (u.y2 / u.scale),
                o
            ]);
        }, t1.cG = function(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1[3] = Math.min(e[3], r[3]), t1;
        }, t1.cH = function(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1[3] = Math.max(e[3], r[3]), t1;
        }, t1.cI = function(t1) {
            const e = Math.round((t1 + 45 + 360) % 360 / 90) % 4;
            return Tt[e];
        }, t1.cJ = Lu, t1.cK = J, t1.cL = 6, t1.cM = function(t1) {
            const e = u(new Float64Array(16));
            h(e, t1.pixelMatrix, t1.globeMatrix);
            const r = [
                0,
                Au,
                0
            ], n = [
                0,
                Iu,
                0
            ];
            return j(r, r, e), j(n, n, e), [
                r[0] > 0 && r[0] <= t1.width && r[1] > 0 && r[1] <= t1.height && !Sh(t1, new Bu(t1.center.lat, 90)),
                n[0] > 0 && n[0] <= t1.width && n[1] > 0 && n[1] <= t1.height && !Sh(t1, new Bu(t1.center.lat, -90))
            ];
        }, t1.cN = function(t1, e) {
            const { scale: r } = t1.tileTransform, n = r * jn / (t1.tileSize * Math.pow(2, e.zoom - t1.tileID.overscaledZ + t1.tileID.canonical.z));
            return function(t1, e, r) {
                var n = e[1], i = e[2], s = e[3], a = r[0], o = r[1];
                return t1[0] = e[0] * a, t1[1] = n * a, t1[2] = i * o, t1[3] = s * o, t1;
            }(new Float32Array(4), e.inverseAdjustmentMatrix, [
                n,
                n
            ]);
        }, t1.cO = Hm, t1.cP = w, t1.cQ = qm, t1.cR = function(t1) {
            const e = qm(t1, !0);
            return n([], [
                e[0],
                e[1],
                e[4],
                e[5]
            ]);
        }, t1.cS = d, t1.cT = mc, t1.cU = f, t1.cV = function(t1) {
            const { x: e, y: r } = t1.point, { lng: n, lat: i } = t1._center;
            return Ah(e, r, t1.worldSize, n, i);
        }, t1.cW = B, t1.cX = kt, t1.cY = Qc, t1.cZ = Uc, t1.c_ = 5, t1.ca = ee, t1.cb = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = e[3], t1;
        }, t1.cc = b, t1.cd = function(t1, e, r, n, i) {
            var s = 1 / Math.tan(e / 2);
            if (t1[0] = s / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = s, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0) {
                var a = 1 / (n - i);
                t1[10] = (i + n) * a, t1[14] = 2 * i * n * a;
            } else t1[10] = -1, t1[14] = -2 * n;
            return t1;
        }, t1.ce = function(t1, e, r, n, i, s, a) {
            var o = 1 / (e - r), l = 1 / (n - i), u = 1 / (s - a);
            return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e + r) * o, t1[13] = (i + n) * l, t1[14] = (a + s) * u, t1[15] = 1, t1;
        }, t1.cf = Fu, t1.cg = function(t1, e, r) {
            t1[4 * e + 0] = r[0], t1[4 * e + 1] = r[1], t1[4 * e + 2] = r[2], t1[4 * e + 3] = r[3];
        }, t1.ch = Wl, t1.ci = Kl, t1.cj = Yl, t1.ck = Jl, t1.cl = ru, t1.cm = $v, t1.cn = function() {
            var t1 = new r(4);
            return r != Float32Array && (t1[1] = 0, t1[2] = 0), t1[0] = 1, t1[3] = 1, t1;
        }, t1.co = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + s * o, t1[1] = i * l + a * o, t1[2] = n * -o + s * l, t1[3] = i * -o + a * l, t1;
        }, t1.cp = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3];
        }, t1.cq = X, t1.cr = function(t1) {
            var e = t1[0], r = t1[1], n = t1[2], i = t1[3];
            return Math.sqrt(e * e + r * r + n * n + i * i);
        }, t1.cs = lt, t1.ct = $, t1.cu = Jc, t1.cv = 3, t1.cw = 2, t1.cx = 7, t1.cy = 6, t1.cz = N, t1.d = function(t1) {
            return oe.API_TILEJSON_REGEX.test(t1);
        }, t1.d$ = class {
            constructor(t1, e, r, n){
                this.context = t1, this.format = n, this.size = r, this.texture = t1.gl.createTexture();
                const [i, s, a] = this.size, { gl: o } = t1;
                o.bindTexture(o.TEXTURE_3D, this.texture), t1.pixelStoreUnpackFlipY.set(!1), t1.pixelStoreUnpack.set(1), t1.pixelStoreUnpackPremultiplyAlpha.set(!1), "data" in e && e.data && o.texImage3D(o.TEXTURE_3D, 0, this.format, i, s, a, 0, Fm(this.format), Dm(this.format), e.data);
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_3D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }, t1.d0 = function(t1) {
            return t1 * t1 * t1 * t1 * t1;
        }, t1.d1 = Tu, t1.d2 = 45, t1.d3 = Ql, t1.d4 = function(t1, e, r) {
            const n = Math.sqrt(t1 * t1 + e * e + r * r), i = n > 0 ? Math.acos(r / n) * zt : 0;
            let s = 0 !== t1 || 0 !== e ? Math.atan2(-e, -t1) * zt + 90 : 0;
            return s < 0 && (s += 360), [
                n,
                s,
                i
            ];
        }, t1.d5 = M, t1.d6 = Jt, t1.d7 = ju, t1.d8 = P, t1.d9 = wc, t1.dA = function(t1) {
            return t1({
                pluginStatus: Ga,
                pluginURL: $a
            }), Ha.on("pluginStateChange", t1), t1;
        }, t1.dB = tu, t1.dC = class extends Zl {
            constructor(t1){
                super(t1), this.current = nu;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 9; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.dD = Vt, t1.dE = function(t1, e, r) {
            const n = Ih(r.zoom), i = t1.style.map._antialias, s = t1.terrain && t1.terrain.exaggeration() > 0;
            return 0 === n && !i && !s;
        }, t1.dF = function(t1) {
            const e = t1.pixelsPerMeter, r = e / Fu(1, t1.center.lat), n = u(new Float64Array(16));
            return p(n, n, [
                t1.point.x,
                t1.point.y,
                0
            ]), d(n, n, [
                r,
                r,
                e
            ]), Float32Array.from(n);
        }, t1.dG = fh, t1.dH = function(t1) {
            const e = 80.051129;
            t1 = Dt(t1, -80.051129, e) / e * 90;
            const r = Math.pow(Math.abs(Math.sin(Bt(t1))), 3);
            return Math.round(r * (_u.length - 1));
        }, t1.dI = function(t1, e, r, n) {
            const i = e.getNorth(), s = e.getSouth(), o = e.getWest(), l = e.getEast(), u = 1 << t1.z, c = l - o, h = i - s, p = c / wu, d = -h / _u[r], f = [
                0,
                p,
                0,
                d,
                0,
                0,
                i,
                o,
                0
            ];
            if (t1.z > 0) {
                const t1 = 180 / n;
                a(f, f, [
                    t1 / c + 1,
                    0,
                    0,
                    0,
                    t1 / h + 1,
                    0,
                    -.5 * t1 / p,
                    .5 * t1 / d,
                    1
                ]);
            }
            return f[2] = u, f[5] = t1.x, f[8] = t1.y, f;
        }, t1.dJ = ch, t1.dK = function(t1, e, r) {
            const n = u(new Float64Array(16)), i = (e / (1 << t1) - .5) * Math.PI * 2;
            return m(n, r.globeMatrix, i), Float32Array.from(n);
        }, t1.dL = Hh, t1.dM = sh, t1.dN = function(t1, e) {
            return [
                Math.pow(t1[0], 2.2) * e,
                Math.pow(t1[1], 2.2) * e,
                Math.pow(t1[2], 2.2) * e
            ];
        }, t1.dO = i, t1.dP = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, t1.dQ = G, t1.dR = _h, t1.dS = ie, t1.dT = se, t1.dU = 256, t1.dV = function(t1, e) {
            const r = [
                0,
                0,
                0
            ];
            return j(r, r, vh(ch(e.canonical))), j(r, r, t1), r;
        }, t1.dW = (t1)=>({
                u_matrix: new ru(t1),
                u_texsize: new Jl(t1),
                u_pixels_to_tile_units: new su(t1),
                u_device_pixel_ratio: new Yl(t1),
                u_width_scale: new Yl(t1),
                u_floor_width_scale: new Yl(t1),
                u_image: new Wl(t1),
                u_units_to_pixels: new Jl(t1),
                u_tile_units_to_pixels: new Yl(t1),
                u_alpha_discard_threshold: new Yl(t1),
                u_trim_offset: new Jl(t1),
                u_trim_fade_range: new Jl(t1),
                u_trim_gradient_mix_range: new Jl(t1),
                u_trim_color: new Ql(t1),
                u_zbias_factor: new Yl(t1),
                u_tile_to_meter: new Yl(t1),
                u_ground_shadow_factor: new Kl(t1),
                u_pattern_transition: new Yl(t1)
            }), t1.dX = (t1)=>({
                u_matrix: new ru(t1),
                u_pixels_to_tile_units: new su(t1),
                u_device_pixel_ratio: new Yl(t1),
                u_width_scale: new Yl(t1),
                u_floor_width_scale: new Yl(t1),
                u_units_to_pixels: new Jl(t1),
                u_dash_image: new Wl(t1),
                u_gradient_image: new Wl(t1),
                u_image_height: new Yl(t1),
                u_texsize: new Jl(t1),
                u_tile_units_to_pixels: new Yl(t1),
                u_alpha_discard_threshold: new Yl(t1),
                u_trim_offset: new Jl(t1),
                u_trim_fade_range: new Jl(t1),
                u_trim_gradient_mix_range: new Jl(t1),
                u_trim_color: new Ql(t1),
                u_zbias_factor: new Yl(t1),
                u_tile_to_meter: new Yl(t1),
                u_ground_shadow_factor: new Kl(t1)
            }), t1.dY = (t1)=>({
                u_camera_to_center_distance: new Yl(t1),
                u_extrude_scale: new su(t1),
                u_device_pixel_ratio: new Yl(t1),
                u_matrix: new ru(t1),
                u_inv_rot_matrix: new ru(t1),
                u_merc_center: new Jl(t1),
                u_tile_id: new Kl(t1),
                u_zoom_transition: new Yl(t1),
                u_up_dir: new Kl(t1),
                u_emissive_strength: new Yl(t1)
            }), t1.dZ = al, t1.d_ = Ag, t1.da = z, t1.db = function(t1) {
            return [
                Math.pow(t1[0], 1 / 2.2),
                Math.pow(t1[1], 1 / 2.2),
                Math.pow(t1[2], 1 / 2.2)
            ];
        }, t1.dc = Em, t1.dd = xy, t1.de = iy, t1.df = kb, t1.dg = function(t1, e) {
            return t1.readFields(tw, {
                icons: []
            }, e);
        }, t1.dh = Jf, t1.di = Vx, t1.dj = Tx, t1.dk = Le, t1.dl = qa, t1.dm = ve, t1.dn = Qe, t1.dp = qt, t1.dq = function(t1) {
            const e = t1.indexOf(Po);
            return e >= 0 ? t1.slice(0, e) : t1;
        }, t1.dr = function(t1) {
            return t1.indexOf(Po) >= 0;
        }, t1.ds = function(t1) {
            const e = t1.lastIndexOf(Po);
            return e >= 0 ? t1.slice(e + 1) : "";
        }, t1.dt = function(t1) {
            const e = [], r = t1.id;
            return void 0 === r && e.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e;
        }, t1.du = function(t1, e, r, n) {
            return "custom" === t1.type ? new Sb(t1, e) : new Kb[t1.type](t1, e, r, n);
        }, t1.dv = $t, t1.dw = function(t1) {
            const e = t1.indexOf(Po);
            return e >= 0 ? t1.slice(e + 1) : "";
        }, t1.dx = class extends Zb {
            constructor(t1, e){
                super(t1._vectorTileFeature, t1._z, t1._x, t1._y, t1.id), t1.state && (this.state = Object.assign({}, t1.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t1.source, this.sourceLayer = t1.sourceLayer, this.layer = t1.layer);
            }
            toJSON() {
                const t1 = super.toJSON();
                return t1.target = this.target, t1.namespace = this.namespace, t1;
            }
        }, t1.dy = Ha, t1.dz = Oe, t1.e = oe, t1.e$ = S, t1.e0 = Th, t1.e1 = (t1, e, r, n, i, s)=>{
            const a = t1.transform, o = "globe" === a.projection.name;
            let l;
            if ("map" === s.paint.get("circle-pitch-alignment")) if (o) {
                const t1 = _h(a.zoom, e.canonical) * a._pixelsPerMercatorPixel;
                l = Float32Array.from([
                    t1,
                    0,
                    0,
                    t1
                ]);
            } else l = a.calculatePixelsToTileUnitsMatrix(r);
            else l = new Float32Array([
                a.pixelsToGLUnits[0],
                0,
                0,
                a.pixelsToGLUnits[1]
            ]);
            const u = {
                u_camera_to_center_distance: t1.transform.getCameraToCenterDistance(a.projection),
                u_matrix: t1.translatePosMatrix(e.projMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: ge.devicePixelRatio,
                u_extrude_scale: l,
                u_inv_rot_matrix: kh,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_emissive_strength: s.paint.get("circle-emissive-strength")
            };
            if (o) {
                u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [
                    e.canonical.x,
                    e.canonical.y,
                    1 << e.canonical.z
                ], u.u_zoom_transition = Ih(a.zoom);
                const t1 = i[0] * jn, r = i[1] * jn;
                u.u_up_dir = a.projection.upVector(new Yc(0, 0, 0), t1, r);
            }
            return u;
        }, t1.e2 = og, t1.e3 = Or, t1.e4 = (t1, e, r, n, i, s, a, o, l, u)=>{
            const c = t1.transform, h = c.pitch < 15 ? ig(.07, .7, Dt((14 - c.zoom) / 5, 0, 1)) : .07, p = "none" === r.paint.get("line-trim-color-use-theme").constantOr("default");
            return {
                u_matrix: ag(t1, e, r, n),
                u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_pixels_to_tile_units: c.calculatePixelsToTileUnitsMatrix(e),
                u_device_pixel_ratio: i,
                u_width_scale: s,
                u_floor_width_scale: a,
                u_image: 0,
                u_tile_units_to_pixels: sg(e, c),
                u_units_to_pixels: [
                    1 / c.pixelsToGLUnits[0],
                    1 / c.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0,
                u_trim_offset: o,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_gradient_mix_range: [
                    1,
                    1
                ],
                u_trim_color: r.paint.get("line-trim-color").toPremultipliedRenderColor(p ? null : r.lut).toArray01(),
                u_zbias_factor: h,
                u_tile_to_meter: ju(e.tileID.canonical, 0),
                u_ground_shadow_factor: l,
                u_pattern_transition: u
            };
        }, t1.e5 = (t1, e, r, n, i, s, a, o, l, u)=>{
            const c = t1.transform, h = c.calculatePixelsToTileUnitsMatrix(e), p = "none" === r.paint.get("line-trim-color-use-theme").constantOr("default"), d = c.pitch < 15 ? ig(.07, .7, Dt((14 - c.zoom) / 5, 0, 1)) : .07;
            return {
                u_matrix: ag(t1, e, r, n),
                u_pixels_to_tile_units: h,
                u_device_pixel_ratio: s,
                u_width_scale: a,
                u_floor_width_scale: o,
                u_units_to_pixels: [
                    1 / c.pixelsToGLUnits[0],
                    1 / c.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: i,
                u_texsize: lg(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: sg(e, t1.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: l,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_gradient_mix_range: [
                    1,
                    1
                ],
                u_trim_color: r.paint.get("line-trim-color").toPremultipliedRenderColor(p ? null : r.lut).toArray01(),
                u_zbias_factor: d,
                u_tile_to_meter: ju(e.tileID.canonical, 0),
                u_ground_shadow_factor: u
            };
        }, t1.e6 = Nt, t1.e7 = Zh, t1.e8 = Ru, t1.e9 = th, t1.eA = function(t1, r) {
            var n = 2 * Math.acos(r[3]), i = Math.sin(n / 2);
            return i > e ? (t1[0] = r[0] / i, t1[1] = r[1] / i, t1[2] = r[2] / i) : (t1[0] = 1, t1[1] = 0, t1[2] = 0), n;
        }, t1.eB = Yb, t1.eC = ny, t1.eD = Qm, t1.eE = [
            1,
            1,
            1
        ], t1.eF = Cb, t1.eG = Y, t1.eH = function(t1, e, r, n) {
            var i = e[0], s = e[1], a = e[2], o = e[3];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1[2] = a + n * (r[2] - a), t1[3] = o + n * (r[3] - o), t1;
        }, t1.eI = ry, t1.eJ = nl, t1.eK = yl, t1.eL = function(t1, e, n, i, s, a, o, l, u, c, h, p, d, f, m, y) {
            var g = new r(16);
            return g[0] = t1, g[1] = e, g[2] = n, g[3] = i, g[4] = s, g[5] = a, g[6] = o, g[7] = l, g[8] = u, g[9] = c, g[10] = h, g[11] = p, g[12] = d, g[13] = f, g[14] = m, g[15] = y, g;
        }, t1.eM = Pu, t1.eN = ml, t1.eO = fl, t1.eP = class {
            constructor(){
                this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {
                    min: new Mt(1 / 0, 1 / 0),
                    max: new Mt(-1 / 0, -1 / 0)
                };
            }
            clear() {
                this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
            }
            get updateTime() {
                return this._updateTime;
            }
            getReplacementRegionsForTile(t1, e = !1) {
                const r = jd(new Mt(0, 0), new Mt(jn, jn), t1), n = [];
                if (e && !Ud(r, this._globalClipBounds)) return n;
                for (const e of this._activeRegions){
                    if (e.hiddenByOverlap) continue;
                    if (!Ud(r, e)) continue;
                    const i = Gd(e.min, e.max, t1);
                    n.push({
                        min: i.min,
                        max: i.max,
                        sourceId: this._sourceIds[e.priority],
                        footprint: e.footprint,
                        footprintTileId: e.tileId,
                        order: e.order,
                        clipMask: e.clipMask,
                        clipScope: e.clipScope
                    });
                }
                return n;
            }
            setSources(t1) {
                this._setSources(t1.map((t1)=>({
                        getSourceId: ()=>t1.cache.id,
                        getFootprints: ()=>{
                            const e = [];
                            for (const r of t1.cache.getVisibleCoordinates()){
                                const n = t1.cache.getTile(r).buckets[t1.layer];
                                n && n.updateFootprints(r.toUnwrapped(), e);
                            }
                            return e;
                        },
                        getOrder: ()=>t1.order,
                        getClipMask: ()=>t1.clipMask,
                        getClipScope: ()=>t1.clipScope
                    })));
            }
            _addSource(t1) {
                const e = t1.getFootprints();
                if (0 === e.length) return;
                const r = t1.getOrder(), n = t1.getClipMask(), i = t1.getClipScope();
                for (const t1 of e){
                    if (!t1.footprint) continue;
                    const e = jd(t1.footprint.min, t1.footprint.max, t1.id);
                    this._activeRegions.push({
                        min: e.min,
                        max: e.max,
                        hiddenByOverlap: !1,
                        priority: this._sourceIds.length,
                        tileId: t1.id,
                        footprint: t1.footprint,
                        order: r,
                        clipMask: n,
                        clipScope: i
                    });
                }
                this._sourceIds.push(t1.getSourceId());
            }
            _computeReplacement() {
                this._activeRegions.sort((t1, e)=>t1.priority - e.priority || Ld(t1.min, e.min) || Ld(t1.max, e.max) || t1.order - e.order || t1.clipMask - e.clipMask || function(t1, e) {
                        const r = (t1, e)=>t1 + e;
                        return t1.length - e.length || t1.reduce(r, "").localeCompare(e.reduce(r, ""));
                    }(t1.clipScope, e.clipScope));
                let t1 = this._activeRegions.length !== this._prevRegions.length;
                if (!t1) {
                    let e = 0;
                    for(; !t1 && e !== this._activeRegions.length;){
                        const r = this._activeRegions[e], n = this._prevRegions[e];
                        t1 = r.priority !== n.priority || !Od(r, n) || r.order !== n.order || r.clipMask !== n.clipMask || !St(r.clipScope, n.clipScope), this._activeRegions[e].hiddenByOverlap = n.hiddenByOverlap, ++e;
                    }
                }
                if (t1) {
                    ++this._updateTime;
                    for (const t1 of this._activeRegions)t1.order !== Dd && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t1.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t1.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t1.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t1.max.y));
                    const t1 = (t1)=>{
                        const e = this._activeRegions;
                        if (t1 >= e.length) return t1;
                        const r = e[t1].priority;
                        for(; t1 < e.length && e[t1].priority === r;)++t1;
                        return t1;
                    };
                    if (this._sourceIds.length > 1) {
                        let e = 0, r = t1(e);
                        for(; e !== r;){
                            let n = e;
                            const i = e;
                            for(; n !== r;){
                                const t1 = this._activeRegions[n];
                                t1.hiddenByOverlap = !1;
                                for(let e = 0; e < i; e++){
                                    const r = this._activeRegions[e];
                                    if (!r.hiddenByOverlap && t1.order === Dd && Ud(t1, r) && (t1.hiddenByOverlap = qd(t1.footprint, t1.tileId, r.footprint, r.tileId), t1.hiddenByOverlap)) break;
                                }
                                ++n;
                            }
                            e = r, r = t1(e);
                        }
                    }
                }
            }
            _setSources(t1) {
                [this._prevRegions, this._activeRegions] = [
                    this._activeRegions,
                    []
                ], this._sourceIds = [];
                for(let e = t1.length - 1; e >= 0; e--)this._addSource(t1[e]);
                this._computeReplacement();
            }
        }, t1.eQ = Dd, t1.eR = class {
            constructor(t1){
                this._createGrid(t1), this._createPoles(t1);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t1 of this._poleSegments)t1.destroy();
                for (const t1 of this._gridSegments)t1.withSkirts.destroy(), t1.withoutSkirts.destroy();
            }
            _fillGridMeshWithLods(t1, e) {
                const r = new No, n = new ll, i = [], s = t1 + 1 + 2, a = e[0] + 1, o = e[0] + 1 + (1 + e.length), l = (t1, e, r)=>{
                    let n = t1 === s - 1 ? t1 - 2 : 0 === t1 ? t1 : t1 - 1;
                    return n += r ? 24575 : 0, [
                        n,
                        e
                    ];
                };
                for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, 0, !0));
                for(let t1 = 0; t1 < a; ++t1)for(let e = 0; e < s; ++e)r.emplaceBack(...l(e, t1, (0 === e || e === s - 1) && !0));
                for(let t1 = 0; t1 < e.length; ++t1){
                    const n = e[t1];
                    for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, n, !0));
                }
                for(let t1 = 0; t1 < e.length; ++t1){
                    const a = n.length, l = e[t1] + 1 + 2, u = new ll;
                    for(let r = 0; r < l - 1; r++){
                        const i = r === l - 2, a = i ? s * (o - e.length + t1 - r) : s;
                        for(let t1 = 0; t1 < s - 1; t1++){
                            const e = r * s + t1;
                            0 === r || i || 0 === t1 || t1 === s - 2 ? (u.emplaceBack(e + 1, e, e + a), u.emplaceBack(e + a, e + a + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + a), n.emplaceBack(e + a, e + a + 1, e + 1));
                        }
                    }
                    const c = Ol.simpleSegment(0, a, r.length, n.length - a);
                    for(let t1 = 0; t1 < u.uint16.length; t1 += 3)n.emplaceBack(u.uint16[t1], u.uint16[t1 + 1], u.uint16[t1 + 2]);
                    const h = Ol.simpleSegment(0, a, r.length, n.length - a);
                    i.push({
                        withoutSkirts: c,
                        withSkirts: h
                    });
                }
                return {
                    vertices: r,
                    indices: n,
                    segments: i
                };
            }
            _createGrid(t1) {
                const e = this._fillGridMeshWithLods(wu, _u);
                this._gridSegments = e.segments, this._gridBuffer = t1.createVertexBuffer(e.vertices, ih.members), this._gridIndexBuffer = t1.createIndexBuffer(e.indices, !0);
            }
            _createPoles(t1) {
                const e = new ll;
                for(let t1 = 0; t1 <= wu; t1++)e.emplaceBack(0, t1 + 1, t1 + 2);
                this._poleIndexBuffer = t1.createIndexBuffer(e, !0);
                const r = new pl, n = new pl, i = new pl, s = new pl;
                this._poleSegments = [];
                for(let t1 = 0, e = 0; t1 < 5; t1++){
                    const a = 360 / (1 << t1);
                    r.emplaceBack(0, -bu, 0, .5, 0), n.emplaceBack(0, -bu, 0, .5, 1), i.emplaceBack(0, -bu, 0, .5, .5), s.emplaceBack(0, -bu, 0, .5, .5);
                    for(let t1 = 0; t1 <= wu; t1++){
                        let e = t1 / wu, o = 0;
                        const l = dr(0, a, e), [u, c, h] = Mu(zh, Bh, l, bu);
                        r.emplaceBack(u, c, h, e, o), n.emplaceBack(u, c, h, e, 1 - o);
                        const p = Bt(l);
                        e = .5 + .5 * Math.sin(p), o = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, o), s.emplaceBack(u, c, h, e, 1 - o);
                    }
                    this._poleSegments.push(Ol.simpleSegment(e, 0, 66, 64)), e += 66;
                }
                this._poleNorthVertexBuffer = t1.createVertexBuffer(r, rh, !1), this._poleSouthVertexBuffer = t1.createVertexBuffer(n, rh, !1), this._texturedPoleNorthVertexBuffer = t1.createVertexBuffer(i, rh, !1), this._texturedPoleSouthVertexBuffer = t1.createVertexBuffer(s, rh, !1);
            }
            getGridBuffers(t1, e) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e ? this._gridSegments[t1].withSkirts : this._gridSegments[t1].withoutSkirts
                ];
            }
            getPoleBuffers(t1, e) {
                return [
                    e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer,
                    e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t1]
                ];
            }
        }, t1.eS = Cd, t1.eT = Et, t1.eU = function() {
            return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t1.eV = Ft, t1.eW = Nu, t1.eX = function(t1, e, r) {
            return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1[2] = e[2] / r[2], t1;
        }, t1.eY = Z, t1.eZ = Su, t1.e_ = C, t1.ea = mf, t1.eb = If, t1.ec = rf, t1.ed = 450, t1.ee = 7, t1.ef = Uu, t1.eg = function(t1, e) {
            if (t1 === e) {
                var r = e[1], n = e[2], i = e[3], s = e[6], a = e[7], o = e[11];
                t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = r, t1[6] = e[9], t1[7] = e[13], t1[8] = n, t1[9] = s, t1[11] = e[14], t1[12] = i, t1[13] = a, t1[14] = o;
            } else t1[0] = e[0], t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = e[1], t1[5] = e[5], t1[6] = e[9], t1[7] = e[13], t1[8] = e[2], t1[9] = e[6], t1[10] = e[10], t1[11] = e[14], t1[12] = e[3], t1[13] = e[7], t1[14] = e[11], t1[15] = e[15];
            return t1;
        }, t1.eh = xb, t1.ei = Oo, t1.ej = wl, t1.ek = 256, t1.el = bh, t1.em = Wo, t1.en = m, t1.eo = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[4], t1[4] = e[5], t1[5] = e[6], t1[6] = e[8], t1[7] = e[9], t1[8] = e[10], t1;
        }, t1.ep = pl, t1.eq = ys, t1.er = dl, t1.es = function(t1, e, r, n, i) {
            return Dt((t1 - e) / (r - e) * (i - n) + n, n, i);
        }, t1.et = it, t1.eu = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = c * a - o * u, p = -c * s + o * l, d = u * s - a * l, f = r * h + n * p + i * d;
            return f ? (t1[0] = h * (f = 1 / f), t1[1] = (-c * n + i * u) * f, t1[2] = (o * n - i * a) * f, t1[3] = p * f, t1[4] = (c * r - i * l) * f, t1[5] = (-o * r + i * s) * f, t1[6] = d * f, t1[7] = (-u * r + n * l) * f, t1[8] = (a * r - n * s) * f, t1) : null;
        }, t1.ev = 2, t1.ew = R, t1.ex = et, t1.ey = v, t1.ez = function(t1, e) {
            var n = new r(3);
            v(n, e);
            var i = 1 / n[0], s = 1 / n[1], a = 1 / n[2], o = e[0] * i, l = e[1] * s, u = e[2] * a, c = e[4] * i, h = e[5] * s, p = e[6] * a, d = e[8] * i, f = e[9] * s, m = e[10] * a, y = o + h + m, g = 0;
            return y > 0 ? (g = 2 * Math.sqrt(y + 1), t1[3] = .25 * g, t1[0] = (p - f) / g, t1[1] = (d - u) / g, t1[2] = (l - c) / g) : o > h && o > m ? (g = 2 * Math.sqrt(1 + o - h - m), t1[3] = (p - f) / g, t1[0] = .25 * g, t1[1] = (l + c) / g, t1[2] = (d + u) / g) : h > m ? (g = 2 * Math.sqrt(1 + h - o - m), t1[3] = (d - u) / g, t1[0] = (l + c) / g, t1[1] = .25 * g, t1[2] = (p + f) / g) : (g = 2 * Math.sqrt(1 + m - o - h), t1[3] = (l - c) / g, t1[0] = (d + u) / g, t1[1] = (p + f) / g, t1[2] = .25 * g), t1;
        }, t1.f = function(t1) {
            return btoa(encodeURIComponent(t1).replace(/%([0-9A-F]{2})/g, (t1, e)=>String.fromCharCode(Number("0x" + e))));
        }, t1.f0 = function([t1, e, r]) {
            const n = Math.hypot(t1, e, r), i = Math.atan2(t1, r), s = .5 * Math.PI - Math.acos(-e / n);
            return new Bu(kt(i), kt(s));
        }, t1.f1 = K, t1.f2 = Wm, t1.f3 = function(t1) {
            const e = t1.navigator ? t1.navigator.userAgent : null;
            return !!function(t1) {
                if (null == te) {
                    const e = t1.navigator ? t1.navigator.userAgent : null;
                    te = !!t1.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
                }
                return te;
            }(t1) && !(!e || !(e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));
        }, t1.f4 = function(t1, e) {
            we = t1, _e = e;
        }, t1.f5 = Sh, t1.f6 = Mh, t1.f7 = function(t1) {
            const e = [
                0,
                0,
                0
            ], r = u(new Float64Array(16));
            return h(r, t1.pixelMatrix, t1.globeMatrix), j(e, e, r), new Mt(e[0], e[1]);
        }, t1.f8 = function() {
            const t1 = Wf;
            t1 && (t1.isPreloaded() && 1 === t1.numActive() ? (t1.release(Xf), Wf = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t1.f9 = function() {
            Jf().acquire(Xf);
        }, t1.fA = e_, t1.fB = Qu, t1.fC = function(t1) {
            let e = 0;
            if (new Uint32Array(t1, 0, 1)[0] !== Sm) {
                const r = new Uint32Array(t1, 0, 7), [, , n, i, s, a] = r;
                e = r.byteLength + i + s + a + s, (n !== t1.byteLength || e >= t1.byteLength) && Zt("Invalid b3dm header information.");
            }
            return Vm(t1, e);
        }, t1.fD = function(t1, e) {
            const r = xy(t1);
            for (const t1 of r){
                for (const e of t1.meshes)vy(e);
                t1.lights && (t1.lightMeshIndex = t1.meshes.length, t1.meshes.push(wy(t1.lights, e)));
            }
            return r;
        }, t1.fE = Gb, t1.fF = Kt, t1.fG = Gf, t1.fH = Ya, t1.fI = Na, t1.fJ = function(t1) {
            Pe(), null != Ie && Ie.then((e)=>{
                e.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e.delete(r[n]).catch((t1)=>Zt(t1.message));
                }).catch((t1)=>Zt(t1.message));
            }).catch((t1)=>Zt(t1.message));
        }, t1.fa = Za, t1.fb = function(t1, e, r = !1) {
            if (Ga === Na.deferred || Ga === Na.loading || Ga === Na.loaded) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            $a = ge.resolveURL(t1), Ga = Na.deferred, ja = e, Xa(), r || Wa();
        }, t1.fc = function(t1) {
            nm = ge.resolveURL(t1), sm || (sm = new Zf(Jf(), new ir)), sm.broadcast("setMeshoptUrl", nm);
        }, t1.fd = cm, t1.fe = function(t1) {
            em = ge.resolveURL(t1), sm || (sm = new Zf(Jf(), new ir)), sm.broadcast("setDracoUrl", em);
        }, t1.ff = um, t1.fg = $f, t1.fh = function(t1) {
            const e = Se();
            if (!e) return;
            const r = e.delete(be);
            t1 && r.then(()=>t1()).catch(t1);
        }, t1.fi = Hf, t1.fj = Qs, t1.fk = qh, t1.fl = 2, t1.fm = W_, t1.fn = Y_, t1.fo = Wy, t1.fp = ac, t1.fq = "hd_road_elevation", t1.fr = Ic, t1.fs = Gt, t1.ft = kp, t1.fu = Sx, t1.fv = 1, t1.fw = function(t1, e, r, n, i, s, a, o = 1, l, u, c, h) {
            t1.createArrays(), t1.tilePixelRatio = jn / (512 * t1.overscaling), t1.compareText = {}, t1.iconsNeedLinear = !1;
            const p = t1.layers[0].layout, d = t1.layers[0]._unevaluatedLayout._values, f = {};
            f.scaleFactor = o, f.textSizeScaleRange = p.get("text-size-scale-range"), f.iconSizeScaleRange = p.get("icon-size-scale-range");
            const [m, y] = f.textSizeScaleRange, [g, x] = f.iconSizeScaleRange;
            f.textScaleFactor = Dt(f.scaleFactor, m, y), f.iconScaleFactor = Dt(f.scaleFactor, g, x);
            const v = d["text-size"], b = d["icon-size"];
            if ("composite" === t1.textSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.textSizeData;
                f.compositeTextSizes = [
                    v.possiblyEvaluate(new Ja(e, {
                        worldview: c
                    }), s),
                    v.possiblyEvaluate(new Ja(r, {
                        worldview: c
                    }), s)
                ];
            }
            if ("composite" === t1.iconSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.iconSizeData;
                f.compositeIconSizes = [
                    b.possiblyEvaluate(new Ja(e, {
                        worldview: c
                    }), s, h),
                    b.possiblyEvaluate(new Ja(r, {
                        worldview: c
                    }), s, h)
                ];
            }
            f.layoutTextSize = v.possiblyEvaluate(new Ja(a + 1, {
                worldview: c
            }), s), f.layoutIconSize = b.possiblyEvaluate(new Ja(a + 1, {
                worldview: c
            }), s, h), f.textMaxSize = v.possiblyEvaluate(new Ja(18, {
                worldview: c
            }), s);
            const w = p.get("symbol-placement"), _ = "map" === p.get("text-rotation-alignment") && "point" !== w, A = p.get("text-size");
            let I = !1;
            const M = [];
            for (const a of t1.features){
                const o = p.get("text-font").evaluate(a, {}, s).join(","), m = A.evaluate(a, {}, s) * f.textScaleFactor, y = f.layoutTextSize.evaluate(a, {}, s) * f.textScaleFactor, g = f.layoutIconSize.evaluate(a, {}, s, h) * f.iconScaleFactor, x = {
                    horizontal: {},
                    vertical: void 0
                }, v = a.text;
                let b, S = [
                    0,
                    0
                ];
                if (v) {
                    const n = v.toString(), u = p.get("text-letter-spacing").evaluate(a, {}, s) * Ig, c = p.get("text-line-height").evaluate(a, {}, s) * Ig, h = Ta(n) ? u : 0, d = p.get("text-anchor").evaluate(a, {}, s), f = p.get("text-variable-anchor");
                    if (!f) {
                        const t1 = p.get("text-radial-offset").evaluate(a, {}, s);
                        if (t1) S = Yx(d, [
                            t1 * Ig,
                            Hx
                        ]);
                        else {
                            const t1 = p.get("text-offset").evaluate(a, {}, s);
                            S = [
                                t1[0] * Ig,
                                t1[1] * Ig
                            ];
                        }
                    }
                    let g = _ ? "center" : p.get("text-justify").evaluate(a, {}, s);
                    const b = "point" === w, A = b ? p.get("text-max-width").evaluate(a, {}, s) * Ig : 1 / 0, I = (s)=>{
                        t1.allowVerticalPlacement && ka(n) && (x.vertical = Yg(v, e, r, i, o, A, c, d, s, h, S, Hg.vertical, !0, y, m, l));
                    };
                    if (!_ && f) {
                        const t1 = "auto" === g ? f.map((t1)=>uv(t1)) : [
                            g
                        ];
                        let n = !1;
                        for(let s = 0; s < t1.length; s++){
                            const a = t1[s];
                            if (!x.horizontal[a]) if (n) x.horizontal[a] = x.horizontal[0];
                            else {
                                const t1 = Yg(v, e, r, i, o, A, c, "center", a, h, S, Hg.horizontal, !1, y, m, l);
                                t1 && (x.horizontal[a] = t1, n = 1 === t1.positionedLines.length);
                            }
                        }
                        I("left");
                    } else {
                        if ("auto" === g && (g = uv(d)), b || p.get("text-writing-mode").indexOf("horizontal") >= 0 || !ka(n)) {
                            const t1 = Yg(v, e, r, i, o, A, c, d, g, h, S, Hg.horizontal, !1, y, m, l);
                            t1 && (x.horizontal[g] = t1);
                        }
                        I(b ? "left" : g);
                    }
                }
                let P, z, B, k, T, V, E = !1;
                const F = p.get("icon-text-fit").evaluate(a, {}, s);
                if (a.icon && a.icon.hasPrimary()) {
                    const e = iv(a.icon, t1.iconSizeData, d["icon-size"], s, t1.zoom, a, l, f.iconScaleFactor, c, h);
                    P = e.iconPrimary, B = e.iconSecondary;
                    const r = P.toString();
                    if (z = n.get(r), z && (T = p.get("icon-offset").evaluate(a, {}, s), V = p.get("icon-anchor").evaluate(a, {}, s), b = ox(i.get(r), B ? i.get(B.toString()) : void 0, T, V), E = z.sdf, void 0 === t1.sdfIcons ? t1.sdfIcons = z.sdf : t1.sdfIcons !== z.sdf && Zt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (z.pixelRatio !== t1.pixelRatio || 0 !== p.get("icon-rotate").constantOr(1)) && (t1.iconsNeedLinear = !0)), B) {
                        const t1 = B.toString();
                        k = n.get(t1);
                    }
                }
                I = I || !(!a.icon || !a.icon.hasSecondary());
                const D = gv(x.horizontal) || x.vertical;
                t1.iconsInText || (t1.iconsInText = !!D && D.iconsInText);
                const C = y * f.textScaleFactor / Ig, { defaultShapedIcon: R, verticallyShapedIcon: L } = cv(t1, b, p, a, s, x, C, T, F);
                "none" !== F && b && (ux(b) || cx(b)) && (rv(0, z, P, b, R, F, u, n, i), rv(0, k, B, b, R, F, u, n, i), L && (rv(0, z, P, b, L, F, u, n, i), rv(0, k, B, b, L, F, u, n, i))), b = R;
                const { iconBBox: O, iconVerticalBBox: U, textBBox: N, textVerticalBBox: j } = Jx(t1, b, L, p, a, s, g, T, f, i, V, x, y, S, h);
                M.push({
                    feature: a,
                    shapedTextOrientations: x,
                    shapedText: D,
                    shapedIcon: b,
                    iconPrimary: P,
                    iconSecondary: B,
                    iconOffset: T,
                    iconAnchor: V,
                    verticallyShapedIcon: L,
                    layoutTextSize: y,
                    layoutIconSize: g,
                    textOffset: S,
                    isSDFIcon: E,
                    iconTextFit: F,
                    iconCollisionBounds: O,
                    iconVerticalCollisionBounds: U,
                    textCollisionBounds: N,
                    textVerticalCollisionBounds: j
                });
            }
            return {
                featureData: M,
                sizes: f,
                hasAnySecondaryIcon: I,
                textAlongLine: _,
                symbolPlacement: w
            };
        }, t1.fx = Px, t1.fy = function(t1, e, r, n, i, s, a, o, l, u) {
            t1.iconAtlasPositions = u.iconPositions;
            const { featureData: c, hasAnySecondaryIcon: h, sizes: p, textAlongLine: d, symbolPlacement: f } = e;
            for (const e of c){
                const { shapedIcon: r, verticallyShapedIcon: s, feature: c, shapedTextOrientations: m, shapedText: y, layoutTextSize: g, textOffset: x, isSDFIcon: v, iconPrimary: b, iconSecondary: w, iconTextFit: _, iconOffset: A, iconCollisionBounds: I, iconVerticalCollisionBounds: M, textCollisionBounds: S } = e;
                av(r, u.iconPositions, b, w), av(s, u.iconPositions, b, w), ov(m, u.iconPositions), sv(b, w, u.iconPositions), (y || r) && pv(t1, c, m, r, s, l, p, g, 0, x, v, n, i, a, o, h, _, A, d, f, I, M, S);
            }
            r && t1.generateCollisionDebugBuffers(s, t1.collisionBoxArray, p.textScaleFactor);
        }, t1.fz = ic, t1.g = function(t1, e) {
            return Oe(Object.assign(t1, {
                method: "GET"
            }), e);
        }, t1.h = function(t1) {
            return 0 === t1.indexOf("mapbox:");
        }, t1.i = function(t1) {
            return oe.API_STYLE_REGEX.test(t1) && !ue(t1);
        }, t1.j = le, t1.k = Be, t1.l = function(t1) {
            return decodeURIComponent(atob(t1).split("").map((t1)=>"%" + ("00" + t1.charCodeAt(0).toString(16)).slice(-2)).join(""));
        }, t1.m = function(t1, e) {
            return Oe(Object.assign(t1, {
                type: "json"
            }), e);
        }, t1.n = qe, t1.o = ge, t1.p = function(t1, e) {
            return Oe(Object.assign(t1, {
                method: "POST"
            }), e);
        }, t1.q = Xh, t1.r = ye, t1.s = function(t1) {
            try {
                const e = self[t1];
                return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
            } catch (t1) {
                return !1;
            }
        }, t1.t = function() {
            return Yf || (Yf = new Hf("ImageRasterizer")), Yf;
        }, t1.u = function() {
            return function t1(e) {
                return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([
                    1e7
                ] + -[
                    1e3
                ] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t1);
            }();
        }, t1.v = function(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }, t1.w = Zt, t1.x = Gw, t1.y = er, t1.z = tr;
    });
    define([
        "./shared"
    ], function(e) {
        function t1(e) {
            const t1 = e ? e.url.toString() : void 0;
            return t1 ? performance.getEntriesByName(t1) : [];
        }
        function s(e) {
            if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);
            if (Array.isArray(e)) {
                let t1 = "[";
                for (const i of e)t1 += `${s(i)},`;
                return `${t1}]`;
            }
            let t1 = "{";
            for (const i of Object.keys(e).sort())t1 += `${i}:${s(e[i])},`;
            return `${t1}}`;
        }
        function i(t1) {
            let i = "";
            for (const o of e.bx)i += `/${s(t1[o])}`;
            return i;
        }
        function o(e, t1) {
            return function e(s) {
                return "string" == typeof s && s === t1 || (Array.isArray(s) ? s.some(e) : !(!s || "object" != typeof s) && Object.values(s).some(e));
            }(e);
        }
        class n {
            constructor(e){
                this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);
            }
            replace(e, t1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e, [], t1);
            }
            update(t1, n, r) {
                this._options = r;
                for (const s of t1)this._layerConfigs[s.id] = s, (this._layers[s.id] = e.du(s, this.scope, null, this._options)).compileFilter(r), this.keyCache[s.id] && delete this.keyCache[s.id];
                for (const e of n)delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
                this.familiesBySource = {};
                const a = function(e, t1) {
                    const n = {};
                    for(let r = 0; r < e.length; r++){
                        const a = e[r];
                        let l = t1 && t1[a.id];
                        l || ("symbol" === a.type ? l = a.id : (l = i(a), "line" === a.type && a.paint && o(a.paint["line-width"], "line-progress") && (l += `/${s(a.paint["line-width"])}`))), t1 && (t1[a.id] = l);
                        let c = n[l];
                        c || (c = n[l] = []), c.push(a);
                    }
                    const r = [];
                    for(const e in n)r.push(n[e]);
                    return r;
                }(Object.values(this._layerConfigs), this.keyCache);
                for (const e of a){
                    const t1 = e.map((e)=>this._layers[e.id]), s = t1[0];
                    if ("none" === s.visibility) continue;
                    const i = s.source || "";
                    let o = this.familiesBySource[i];
                    o || (o = this.familiesBySource[i] = {});
                    const n = s.sourceLayer || "_geojsonTileLayer";
                    let r = o[n];
                    r || (r = o[n] = []), r.push(t1);
                }
            }
        }
        const r = 1 * e.fl;
        class a {
            constructor(t1){
                const s = {}, i = [];
                for(const e in t1){
                    const o = t1[e], n = s[e] = {};
                    for(const e in o.glyphs){
                        const t1 = o.glyphs[+e];
                        if (!t1 || 0 === t1.bitmap.width || 0 === t1.bitmap.height) continue;
                        const s = t1.metrics.localGlyph ? r : 1, a = {
                            x: 0,
                            y: 0,
                            w: t1.bitmap.width + 2 * s,
                            h: t1.bitmap.height + 2 * s
                        };
                        i.push(a), n[e] = a;
                    }
                }
                const { w: o, h: n } = e.G(i), a = new e.fk({
                    width: o || 1,
                    height: n || 1
                });
                for(const i in t1){
                    const o = t1[i];
                    for(const t1 in o.glyphs){
                        const n = o.glyphs[+t1];
                        if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height) continue;
                        const l = s[i][t1], c = n.metrics.localGlyph ? r : 1;
                        e.fk.copy(n.bitmap, a, {
                            x: 0,
                            y: 0
                        }, {
                            x: l.x + c,
                            y: l.y + c
                        }, n.bitmap);
                    }
                }
                this.image = a, this.positions = s;
            }
        }
        function l(e, t1, s) {
            e[t1] ? s && (e[t1].center = s) : e[t1] = {
                floorIds: new Set,
                center: s || [
                    0,
                    0
                ],
                floors: {}
            };
        }
        function c(e, t1, s, i) {
            for (const o of t1)l(e, o), e[o].floors[s] = i, e[o].floorIds.add(s);
        }
        function h(e) {
            return {
                id: e.properties.id.toString(),
                center: e.properties.center.toString().split(";").map(Number)
            };
        }
        function u(e) {
            return {
                id: e.properties.id.toString(),
                isDefault: !!e.properties.is_default && e.properties.is_default,
                connections: e.properties.connected_floor_ids ? new Set(e.properties.connected_floor_ids.toString().split(";")) : new Set,
                conflicts: e.properties.conflicted_floor_ids ? new Set(e.properties.conflicted_floor_ids.toString().split(";")) : new Set,
                buildings: e.properties.building_ids ? new Set(e.properties.building_ids.toString().split(";")) : new Set,
                name: e.properties.name.toString(),
                zIndex: e.properties.z_index
            };
        }
        function d(e, t1) {
            return t1.every((t1)=>e.properties && null != e.properties[t1]);
        }
        function f(e) {
            return d(e, [
                "type",
                "id",
                "name"
            ]) && "building" === e.properties.type;
        }
        function p(e) {
            return d(e, [
                "type",
                "id",
                "name",
                "z_index"
            ]) && "floor" === e.properties.type;
        }
        e.fj(a, "GlyphAtlas");
        class g {
            constructor(t1){
                this.tileID = new e.aQ(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.lut = t1.lut, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.scope = t1.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.request && t1.request.collectResourceTiming, this.promoteId = t1.promoteId, this.isSymbolTile = t1.isSymbolTile, this.tileTransform = e.aZ(t1.tileID.canonical, t1.projection), this.projection = t1.projection, this.worldview = t1.worldview, this.localizableLayerIds = t1.localizableLayerIds, this.brightness = t1.brightness, this.extraShadowCaster = !!t1.extraShadowCaster, this.tessellationStep = t1.tessellationStep, this.scaleFactor = t1.scaleFactor, this.worldview = t1.worldview, this.indoor = t1.indoor;
            }
            parse(t1, s, i, o, n, r) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new e.b3;
                const d = new e.fm(Object.keys(t1.layers).sort()), g = new e.fn(this.tileID, this.promoteId);
                g.bucketLayerIDs = [];
                const y = {}, w = new e.fo(256, 256), b = {
                    featureIndex: g,
                    iconDependencies: new Map,
                    patternDependencies: new Map,
                    glyphDependencies: {},
                    lineAtlas: w,
                    availableImages: i,
                    brightness: this.brightness,
                    scaleFactor: this.scaleFactor,
                    elevationFeatures: void 0,
                    activeFloors: void 0
                };
                if (this.indoor) {
                    const s = this.indoor.indoorState.activeFloorsVisible, i = function(t1, s, i) {
                        const o = function(t1, s) {
                            if (!t1) return e.w("No source layers defined in indoor specification"), s;
                            if (0 === t1.size) return s;
                            const i = t1.difference(s);
                            for (const t1 of i)e.w(`Missing source layer required in indoor specification: ${t1}`);
                            return s.intersection(s);
                        }(s.sourceLayers, new Set(Object.keys(t1.layers))), n = s.indoorState, r = function(t1, s, i, o) {
                            const n = new Set, r = new Set, a = new Set, d = new Map, g = {}, m = (e)=>{
                                const t1 = d.get(e) || new Set;
                                for (const s of n)if ((d.get(s) || new Set).has(e) || t1.has(s)) return !0;
                                return !1;
                            };
                            for (const i of s){
                                const s = t1.layers[i];
                                if (s) for(let e = 0; e < s.length; e++){
                                    const t1 = s.feature(e);
                                    if (f(t1)) {
                                        const { id: e, center: s } = h(t1);
                                        l(g, e, s), n.add(e);
                                        continue;
                                    }
                                    if (p(t1)) {
                                        const { id: e, isDefault: s, connections: i, conflicts: l, buildings: h, name: f, zIndex: p } = u(t1);
                                        c(g, h, e, {
                                            name: f,
                                            zIndex: p
                                        }), d.set(e, l), (e === o || i.has(o)) && n.add(e), r.add(e), s && a.add(e);
                                    }
                                }
                                else e.w(`indoor source layer not found: ${i}`);
                            }
                            if (i) for (const e of i)r.has(e) && (m(e) || n.add(e));
                            for (const e of a)n.has(e) || m(e) || n.add(e);
                            return {
                                buildings: g,
                                activeFloors: n
                            };
                        }(t1, o, n.lastActiveFloors, n.selectedFloorId);
                        return i.send("setIndoorData", r), r;
                    }(t1, this.indoor, n);
                    b.activeFloors = s ? i.activeFloors : void 0;
                }
                const x = [], v = s.familiesBySource[this.source];
                for(const s in v){
                    const n = t1.layers[s];
                    if (!n) continue;
                    let r = !1, a = !1, l = !1;
                    for (const e of v[s])"symbol" === e[0].type ? r = !0 : a = !0, e[0].is3D() && "model" !== e[0].type && (l = !0);
                    if (this.extraShadowCaster && !l) continue;
                    if (!0 === this.isSymbolTile && !r) continue;
                    if (!1 === this.isSymbolTile && !a) continue;
                    1 === n.version && e.w(`Vector tile source "${this.source}" layer "${s}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const c = d.encode(s), h = [], u = this.localizableLayerIds && this.localizableLayerIds.has(s);
                    let f = !1;
                    for(let t1 = 0, i = 0; t1 < n.length; t1++){
                        const o = n.feature(t1), r = g.getId(o, s), a = o.properties ? o.properties.worldview : null;
                        if (u && this.worldview && "string" == typeof a) if ("all" === a) o.properties.$localized = !0;
                        else {
                            if (!a.split(",").includes(this.worldview)) continue;
                            o.properties.$localized = !0, o.properties.worldview = this.worldview;
                        }
                        !f && o.properties && o.properties.hasOwnProperty(e.fp) && (f = !0), h.push({
                            feature: o,
                            id: r,
                            index: i,
                            sourceLayerIndex: c
                        }), i++;
                    }
                    f && !b.elevationFeatures && t1.layers.hasOwnProperty(e.fq) && (b.elevationFeatures = e.fr.parseFrom(t1.layers[e.fq], this.canonical));
                    for (const t1 of v[s]){
                        const s = t1[0];
                        if (this.extraShadowCaster && (!s.is3D() || "model" === s.type)) continue;
                        if (void 0 !== this.isSymbolTile && "symbol" === s.type !== this.isSymbolTile) continue;
                        if (s.minzoom && this.zoom < Math.floor(s.minzoom)) continue;
                        if (s.maxzoom && this.zoom >= s.maxzoom) continue;
                        if ("none" === s.visibility) continue;
                        m(t1, this.zoom, b.brightness, i, this.worldview);
                        const n = y[s.id] = s.createBucket({
                            index: g.bucketLayerIDs.length,
                            layers: t1,
                            zoom: this.zoom,
                            lut: this.lut,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: c,
                            sourceID: this.source,
                            projection: this.projection.spec,
                            tessellationStep: this.tessellationStep,
                            styleDefinedModelURLs: o,
                            worldview: this.worldview,
                            localizable: u,
                            availableImages: i
                        });
                        g.bucketLayerIDs.push(t1.map((t1)=>e.B(t1.id, t1.scope)));
                        let r = n.prepare ? n.prepare() : null;
                        null != r ? (r = r.then(()=>n.populate(h, b, this.tileID.canonical, this.tileTransform)), x.push(r)) : n.populate(h, b, this.tileID.canonical, this.tileTransform);
                    }
                }
                const I = ()=>{
                    let s, o, l, c, h, u;
                    w.trim();
                    const f = {
                        type: "maybePrepare",
                        isSymbolTile: this.isSymbolTile,
                        zoom: this.zoom
                    }, p = ()=>{
                        if (s) return this.status = "done", r(s);
                        if (this.extraShadowCaster) this.status = "done", r(null, {
                            buckets: Object.values(y).filter((e)=>!e.isEmpty()),
                            featureIndex: g,
                            collisionBoxArray: null,
                            glyphAtlasImage: null,
                            lineAtlas: null,
                            imageAtlas: null,
                            brightness: b.brightness,
                            glyphMap: null,
                            iconMap: null,
                            glyphPositions: null
                        });
                        else if (o && l && c) {
                            const t1 = new a(o), s = new Map;
                            for (const [t1, i] of l.entries()){
                                const { imagePosition: o } = e.fu(t1, i, e.fv);
                                s.set(t1, o);
                            }
                            const r = {};
                            for(const n in y){
                                const a = y[n];
                                a instanceof e.b4 && (m(a.layers, this.zoom, b.brightness, i, this.worldview), r[n] = e.fw(a, o, t1.positions, l, s, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, h, this.worldview, i));
                            }
                            const d = {
                                iconsPending: !0,
                                patternsPending: !0
                            };
                            this.rasterizeIfNeeded(n, l, h, ()=>{
                                d.iconsPending = !1, x(r, t1, d);
                            }), this.rasterizeIfNeeded(n, c, u, ()=>{
                                d.patternsPending = !1, x(r, t1, d);
                            });
                        }
                    }, x = (t1, s, o, n)=>{
                        if (o.iconsPending || o.patternsPending) return;
                        const a = new e.fx(l, c, this.lut);
                        for(const s in y){
                            const o = y[s];
                            if (s in t1) e.fy(o, t1[s], this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, l, a);
                            else if (o.hasPattern && (o instanceof e.ba || o instanceof e.bb || o instanceof e.ea)) {
                                m(o.layers, this.zoom, b.brightness, i, this.worldview);
                                const e = Object.fromEntries(a.patternPositions);
                                o.addFeatures(b, this.tileID.canonical, e, i, this.tileTransform, this.brightness);
                            }
                        }
                        this.status = "done", r(null, {
                            buckets: Object.values(y).filter((e)=>!e.isEmpty()),
                            featureIndex: g,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: s.image,
                            lineAtlas: w,
                            imageAtlas: a,
                            brightness: b.brightness
                        });
                    };
                    if (!this.extraShadowCaster) {
                        const t1 = e.fs(b.glyphDependencies, (e)=>Object.keys(e).map(Number));
                        Object.keys(t1).length ? n.send("getGlyphs", {
                            uid: this.uid,
                            stacks: t1
                        }, (e, t1)=>{
                            s || (s = e, o = t1, p());
                        }, void 0, !1, f) : o = {};
                        const i = Array.from(b.iconDependencies.keys()).map((t1)=>e.I.parse(t1));
                        i.length ? n.send("getImages", {
                            images: i,
                            source: this.source,
                            scope: this.scope,
                            tileID: this.tileID,
                            type: "icons"
                        }, (e, t1)=>{
                            s || (s = e, l = new Map, h = this.updateImageMapAndGetImageTaskQueue(l, t1, b.iconDependencies), p());
                        }, void 0, !1, f) : (l = new Map, h = new Map);
                        const r = Array.from(b.patternDependencies.keys()).map((t1)=>e.I.parse(t1));
                        r.length ? n.send("getImages", {
                            images: r,
                            source: this.source,
                            scope: this.scope,
                            tileID: this.tileID,
                            type: "patterns"
                        }, (e, t1)=>{
                            s || (s = e, c = new Map, u = this.updateImageMapAndGetImageTaskQueue(c, t1, b.patternDependencies), p());
                        }, void 0, !1, f) : (c = new Map, u = new Map);
                    }
                    if (b.elevationFeatures && b.elevationFeatures.length > 0) {
                        const s = [];
                        for (const t1 of Object.values(y))if (t1 instanceof e.bb) {
                            const e = t1.getUnevaluatedPortalGraph();
                            e && s.push(e);
                        }
                        const i = e.ft.evaluate(s);
                        for (const s of Object.values(y))if (s instanceof e.bb) {
                            const e = t1.layers[d.decode(s.sourceLayerIndex)];
                            s.setEvaluatedPortalGraph(i, e, this.tileID.canonical, b.availableImages, b.brightness);
                        }
                    }
                    p();
                };
                x.length > 0 ? Promise.allSettled(x).then(I).catch(r) : I();
            }
            updateParameters(t1) {
                this.scaleFactor = t1.scaleFactor, this.showCollisionBoxes = t1.showCollisionBoxes, this.projection = t1.projection, this.brightness = t1.brightness, this.tileTransform = e.aZ(t1.tileID.canonical, t1.projection), this.extraShadowCaster = t1.extraShadowCaster, this.lut = t1.lut, this.worldview = t1.worldview, this.indoor = t1.indoor;
            }
            rasterizeIfNeeded(e, t1, s, i) {
                Array.from(t1.values()).some((e)=>e.usvg) ? this.rasterize(e, t1, s, i) : i();
            }
            updateImageMapAndGetImageTaskQueue(e, t1, s) {
                const i = new Map;
                for (const o of t1.keys()){
                    const n = s.get(o) || [];
                    for (const s of n){
                        const o = s.toString(), n = t1.get(s.id.toString());
                        n.usvg ? i.has(o) || (i.set(o, s), e.set(o, Object.assign({}, n))) : e.set(o, n);
                    }
                }
                return i;
            }
            rasterize(e, t1, s, i) {
                this.rasterizeTask = e.send("rasterizeImages", {
                    scope: this.scope,
                    tasks: s
                }, (e, s)=>{
                    if (!e) for (const [e, i] of s.entries()){
                        const s = Object.assign(t1.get(e), {
                            data: i
                        });
                        t1.set(e, s);
                    }
                    i();
                });
            }
            cancelRasterize() {
                this.rasterizeTask && this.rasterizeTask.cancel();
            }
        }
        function m(t1, s, i, o, n) {
            const r = new e.ac(s, {
                brightness: i,
                worldview: n
            });
            for (const e of t1)e.recalculate(r, o);
        }
        class y extends e.E {
            constructor(t1, s, i, o, n, r, a){
                super(), this.actor = t1, this.layerIndex = s, this.availableImages = i, this.availableModels = o, this.loadVectorData = r || e.aL, this.loading = {}, this.loaded = {}, this.deduped = new e.aK(t1.scheduler), this.isSpriteLoaded = n, this.scheduler = t1.scheduler, this.brightness = a;
            }
            loadTile(s, i) {
                const o = s.uid, n = s && s.request, r = n && n.collectResourceTiming, a = this.loading[o] = new g(s);
                a.abort = this.loadVectorData(s, (l, c)=>{
                    const h = !this.loading[o];
                    if (delete this.loading[o], a.cancelRasterize(), h || l || !c) return a.status = "done", h || (this.loaded[o] = a), i(l);
                    const u = c.rawData, d = {}, f = e.aM(c.responseHeaders);
                    f && f.expires && (d.expires = f.expires), f && f.cacheControl && (d.cacheControl = f.cacheControl), a.vectorTile = c.vectorTile || new e.fz(new e.bt(u));
                    const p = ()=>{
                        a.parse(a.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (e, s)=>{
                            if (e || !s) return i(e);
                            const o = {};
                            if (r) {
                                const e = t1(n);
                                e.length > 0 && (o.resourceTiming = JSON.parse(JSON.stringify(e)));
                            }
                            i(null, Object.assign({
                                rawTileData: u.slice(0),
                                responseHeaders: c.responseHeaders
                            }, s, d, o));
                        });
                    };
                    this.isSpriteLoaded ? p() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(p, {
                            type: "parseTile",
                            isSymbolTile: s.isSymbolTile,
                            zoom: s.tileZoom
                        }) : p();
                    }), this.loaded = this.loaded || {}, this.loaded[o] = a;
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded, i = e.uid;
                if (s && s[i]) {
                    const o = s[i];
                    o.updateParameters(e);
                    const n = (e, s)=>{
                        const i = o.reloadCallback;
                        i && (delete o.reloadCallback, o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i)), t1(e, s);
                    };
                    "parsing" === o.status ? o.reloadCallback = n : "done" === o.status && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, n) : n());
                } else t1(null, void 0);
            }
            abortTile(e, t1) {
                const s = e.uid, i = this.loading[s];
                i && (i.abort && i.abort(), delete this.loading[s]), t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, i = e.uid;
                s && s[i] && delete s[i], t1();
            }
        }
        class w {
            loadTile(t1, s) {
                const { uid: i, encoding: o, rawImageData: n, padding: r } = t1, a = ImageBitmap && n instanceof ImageBitmap ? this.getImageData(n, r) : n;
                s(null, new e.fA(i, a, o, r < 1));
            }
            reloadTile(e, t1) {
                t1(null, null);
            }
            abortTile(e, t1) {
                t1();
            }
            removeTile(e, t1) {
                t1();
            }
            getImageData(e, t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
                const s = this.offscreenCanvasContext.getImageData(-t1, -t1, e.width + 2 * t1, e.height + 2 * t1);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;
            }
        }
        e.bs.setPbf(e.bt);
        class b {
            constructor(t1){
                this._mrt = new e.bs(t1.partial ? 30 : 1 / 0), this._isHeaderLoaded = !1, this.uid = t1.uid, this.tileID = t1.tileID, this.source = t1.source;
            }
            parse(t1, s) {
                const i = this._mrt;
                this.status = "parsing", this._entireBuffer = t1;
                try {
                    i.parseHeader(t1), this._isHeaderLoaded = !0;
                    const o = [];
                    for(const s in i.layers){
                        const n = i.getLayer(s), r = n.getDataRange(n.getBandList()), a = i.createDecodingTask(r), l = t1.slice(r.firstByte, r.lastByte + 1), c = e.bs.performDecoding(l, a).then((e)=>a.complete(null, e)).catch((e)=>a.complete(e, null));
                        o.push(c);
                    }
                    Promise.allSettled(o).then(()=>s(null, i)).catch((e)=>s(e));
                } catch (e) {
                    s(e);
                }
            }
        }
        class x {
            constructor(e){
                this.actor = e, this.loading = {}, this.loaded = {};
            }
            loadTile(t1, s) {
                const i = t1.uid, o = t1.request, n = this.loading[i] = new b(t1), { cancel: r } = e.bu(o, (e, t1, o)=>{
                    const r = !this.loading[i];
                    if (delete this.loading[i], r || e || !t1) return n.status = "done", r || (this.loaded[i] = n), s(e);
                    n.parse(t1, (e, t1)=>{
                        if (e || !t1) return s(e);
                        s(null, t1, o);
                    }), this.loaded[i] = n;
                });
                n.abort = r;
            }
            reloadTile(e, t1) {
                t1(null, void 0);
            }
            abortTile(e, t1) {
                const s = e.uid, i = this.loading[s];
                i && (i.abort && i.abort(), delete this.loading[s]), t1();
            }
            removeTile(e, t1) {
                const s = e.uid;
                this.loaded[s] && delete this.loaded[s], t1();
            }
            decodeRasterArray(t1, s) {
                e.bs.performDecoding(t1.buffer, t1.task).then((e)=>s(null, e)).catch((e)=>s(e));
            }
        }
        const v = e.fB.prototype.toGeoJSON;
        class I {
            constructor(t1){
                this._feature = t1, this.extent = e.al, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t1 = [];
                    for (const s of this._feature.geometry)t1.push([
                        new e.P(s[0], s[1])
                    ]);
                    return t1;
                }
                {
                    const t1 = [];
                    for (const s of this._feature.geometry){
                        const i = [];
                        for (const t1 of s)i.push(new e.P(t1[0], t1[1]));
                        t1.push(i);
                    }
                    return t1;
                }
            }
            toGeoJSON(e, t1, s) {
                return v.call(this, e, t1, s);
            }
        }
        class S {
            constructor(t1, s){
                this.name = t1, this.extent = e.al, this.length = s.length, this._jsonFeatures = s;
            }
            feature(e) {
                return new I(this._jsonFeatures[e]);
            }
        }
        class M {
            constructor(t1){
                this.layers = {}, this.extent = e.al;
                for (const e of Object.keys(t1))this.layers[e] = new S(e, t1[e]);
            }
        }
        const P = 64 / 4096;
        class T {
            constructor(){
                this.features = new Map;
            }
            clear() {
                this.features.clear();
            }
            load(e = [], t1) {
                for (const s of e){
                    const e = s.id;
                    if (null == e) continue;
                    let i = this.features.get(e);
                    i && this.updateCache(i, t1), s.geometry ? (i = k(s), this.updateCache(i, t1), this.features.set(e, i)) : this.features.delete(e), this.updateCache(i, t1);
                }
            }
            updateCache(e, t1) {
                for (const { canonical: s, uid: i } of Object.values(t1)){
                    const { z: o, x: n, y: r } = s;
                    _(e, Math.pow(2, o), n, r) && delete t1[i];
                }
            }
            getTile(e, t1, s) {
                const i = Math.pow(2, e), o = [];
                for (const e of this.features.values())_(e, i, t1, s) && o.push(D(e, i, t1, s));
                return {
                    features: o
                };
            }
            getFeatures() {
                return [
                    ...this.features.values()
                ];
            }
        }
        function _({ minX: e, minY: t1, maxX: s, maxY: i }, o, n, r) {
            return e < (n + 1 + P) / o && t1 < (r + 1 + P) / o && s > (n - P) / o && i > (r - P) / o;
        }
        function k(e) {
            const { id: t1, geometry: s, properties: i } = e;
            if (!s) return;
            if ("GeometryCollection" === s.type) throw new Error("GeometryCollection not supported in dynamic mode.");
            const { type: o, coordinates: n } = s, r = {
                id: t1,
                type: 1,
                geometry: [],
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }, a = r.geometry;
            if ("Point" === o) L(n, a, r);
            else if ("MultiPoint" === o) for (const e of n)L(e, a, r);
            else if ("LineString" === o) r.type = 2, z(n, a, r);
            else if ("MultiLineString" === o) r.type = 2, C(n, a, r);
            else if ("Polygon" === o) r.type = 3, C(n, a, r, !0);
            else {
                if ("MultiPolygon" !== o) throw new Error("Input data is not a valid GeoJSON object.");
                r.type = 3;
                for (const e of n)C(e, a, r, !0);
            }
            return r;
        }
        function L([t1, s], i, o) {
            const n = e.aF(t1);
            let r = e.aJ(s);
            r = r < 0 ? 0 : r > 1 ? 1 : r, i.push(n, r), o.minX = Math.min(o.minX, n), o.minY = Math.min(o.minY, r), o.maxX = Math.max(o.maxX, n), o.maxY = Math.max(o.maxY, r);
        }
        function z(e, t1, s, i = !1, o = !1) {
            const n = [];
            for (const t1 of e)L(t1, n, s);
            t1.push(n), i && function(e, t1) {
                let s = 0;
                for(let t1 = 0, i = e.length, o = i - 2; t1 < i; o = t1, t1 += 2)s += (e[t1] - e[o]) * (e[t1 + 1] + e[o + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const i = e[t1], o = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = i, e[s - 1 - t1] = o;
                }
            }(n, o);
        }
        function C(e, t1, s, i = !1) {
            for(let o = 0; o < e.length; o++)z(e[o], t1, s, i, 0 === o);
        }
        function D(t1, s, i, o) {
            const { id: n, type: r, geometry: a, tags: l } = t1, c = [];
            if (1 === r) !function(t1, s, i, o, n) {
                for(let r = 0; r < t1.length; r += 2){
                    const a = Math.round(e.al * (t1[r + 0] * s - i)), l = Math.round(e.al * (t1[r + 1] * s - o));
                    n.push([
                        a,
                        l
                    ]);
                }
            }(a, s, i, o, c);
            else if (2 === r) for (const e of a)j(e, s, i, o, c);
            else if (3 === r) for (const e of a)O(e, s, i, o, c);
            return {
                id: n,
                type: r,
                geometry: c,
                tags: l
            };
        }
        function j(t1, s, i, o, n) {
            const r = -128, a = e.al + 128;
            let l;
            for(let c = 0; c < t1.length - 2; c += 2){
                let h = Math.round(e.al * (t1[c + 0] * s - i)), u = Math.round(e.al * (t1[c + 1] * s - o)), d = Math.round(e.al * (t1[c + 2] * s - i)), f = Math.round(e.al * (t1[c + 3] * s - o));
                const p = d - h, g = f - u;
                h < r && d < r || (h < r ? (u += Math.round(g * ((r - h) / p)), h = r) : d < r && (f = u + Math.round(g * ((r - h) / p)), d = r), u < r && f < r || (u < r ? (h += Math.round(p * ((r - u) / g)), u = r) : f < r && (d = h + Math.round(p * ((r - u) / g)), f = r), h >= a && d >= a || (h >= a ? (u += Math.round(g * ((a - h) / p)), h = a) : d >= a && (f = u + Math.round(g * ((a - h) / p)), d = a), u >= a && f >= a || (u >= a ? (h += Math.round(p * ((a - u) / g)), u = a) : f >= a && (d = h + Math.round(p * ((a - u) / g)), f = a), l && h === l[l.length - 1][0] && u === l[l.length - 1][1] || (l = [
                    [
                        h,
                        u
                    ]
                ], n.push(l)), l.push([
                    d,
                    f
                ])))));
            }
        }
        function O(t1, s, i, o, n) {
            const r = (i - P) / s, a = (o - P) / s, l = (i + 1 + P) / s, c = (o + 1 + P) / s;
            function h(e, t1) {
                let s = 0;
                return e < r ? s |= 1 : e > l && (s |= 2), t1 < a ? s |= 4 : t1 > c && (s |= 8), s;
            }
            let u = [];
            for(let e = 1; e <= 8; e *= 2){
                let s = t1[t1.length - 2], i = t1[t1.length - 1], o = !(h(s, i) & e);
                for(let n = 0; n < t1.length; n += 2){
                    const d = t1[n], f = t1[n + 1], p = !(h(d, f) & e);
                    p !== o && (8 & e ? u.push(s + (d - s) * (c - i) / (f - i), c) : 4 & e ? u.push(s + (d - s) * (a - i) / (f - i), a) : 2 & e ? u.push(l, i + (f - i) * (l - s) / (d - s)) : 1 & e && u.push(r, i + (f - i) * (r - s) / (d - s))), p && u.push(d, f), s = d, i = f, o = p;
                }
                if (!(t1 = u).length || 8 === e) break;
                u = [];
            }
            const d = [];
            for(let t1 = 0; t1 < u.length; t1 += 2)d.push([
                Math.round(e.al * (u[t1] * s - i)),
                Math.round(e.al * (u[t1 + 1] * s - o))
            ]);
            d.length && n.push(d);
        }
        function F({ name: t1, features: s }, i) {
            i.writeStringField(1, t1), i.writeVarintField(5, e.al);
            const o = new Map, n = new Map, r = {
                keys: o,
                values: n,
                feature: null
            };
            for (const e of s)r.feature = e, i.writeMessage(2, A, r);
            for (const e of o.keys())i.writeStringField(3, e);
            for (const e of n.keys())i.writeMessage(4, R, e);
        }
        function A(e, t1) {
            const s = e.feature;
            void 0 !== s.id && Number.isSafeInteger(+s.id) && t1.writeVarintField(1, +s.id), s.tags && t1.writeMessage(2, Z, e), t1.writeVarintField(3, s.type), t1.writeMessage(4, E, s);
        }
        function Z({ keys: e, values: t1, feature: s }, i) {
            for (const o of Object.keys(s.tags)){
                let n = s.tags[o];
                if (null === n) continue;
                let r = e.get(o);
                void 0 === r && (r = e.size, e.set(o, r)), i.writeVarint(r);
                const a = typeof n;
                "string" !== a && "boolean" !== a && "number" !== a && (n = JSON.stringify(n));
                let l = t1.get(n);
                void 0 === l && (l = t1.size, t1.set(n, l)), i.writeVarint(l);
            }
        }
        function B(e, t1) {
            return (t1 << 3) + (7 & e);
        }
        function N(e) {
            return e << 1 ^ e >> 31;
        }
        function E(e, t1) {
            const { geometry: s, type: i } = e;
            let o = 0, n = 0;
            if (1 === i) {
                t1.writeVarint(B(1, s.length));
                for (const e of s){
                    const s = e[0] - o, i = e[1] - n;
                    t1.writeVarint(N(s)), t1.writeVarint(N(i)), o += s, n += i;
                }
            } else for (const e of s){
                if (0 === e.length) continue;
                t1.writeVarint(B(1, 1));
                const s = e.length - (3 === i ? 1 : 0);
                for(let i = 0; i < s; i++){
                    1 === i && t1.writeVarint(B(2, s - 1));
                    const r = e[i][0] - o, a = e[i][1] - n;
                    t1.writeVarint(N(r)), t1.writeVarint(N(a)), o += r, n += a;
                }
                3 === i && t1.writeVarint(B(7, 1));
            }
        }
        function R(e, t1) {
            const s = typeof e;
            "string" === s ? t1.writeStringField(1, e) : "boolean" === s ? t1.writeBooleanField(7, e) : "number" === s && (e % 1 != 0 ? t1.writeDoubleField(3, e) : e < 0 ? t1.writeSVarintField(6, e) : t1.writeVarintField(5, e));
        }
        const Y = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e)=>e
        }, X = Math.fround || (J = new Float32Array(1), (e)=>(J[0] = +e, J[0]));
        var J;
        class G {
            constructor(e){
                this.options = Object.assign(Object.create(Y), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e) {
                const { log: t1, minZoom: s, maxZoom: i } = this.options;
                t1 && console.time("total time");
                const o = `prepare ${e.length} points`;
                t1 && console.time(o), this.points = e;
                const n = [];
                for(let t1 = 0; t1 < e.length; t1++){
                    const s = e[t1];
                    if (!s.geometry) continue;
                    const [i, o] = s.geometry.coordinates, r = X(V(i)), a = X(U(o));
                    n.push(r, a, 1 / 0, t1, -1, 1), this.options.reduce && n.push(0);
                }
                let r = this.trees[i + 1] = this._createTree(n);
                t1 && console.timeEnd(o);
                for(let e = i; e >= s; e--){
                    const s = +Date.now();
                    r = this.trees[e] = this._createTree(this._cluster(r, e)), t1 && console.log("z%d: %d clusters in %dms", e, r.numItems, +Date.now() - s);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e, t1) {
                let s = ((e[0] + 180) % 360 + 360) % 360 - 180;
                const i = Math.max(-90, Math.min(90, e[1]));
                let o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                const n = Math.max(-90, Math.min(90, e[3]));
                if (e[2] - e[0] >= 360) s = -180, o = 180;
                else if (s > o) {
                    const e = this.getClusters([
                        s,
                        i,
                        180,
                        n
                    ], t1), r = this.getClusters([
                        -180,
                        i,
                        o,
                        n
                    ], t1);
                    return e.concat(r);
                }
                const r = this.trees[this._limitZoom(t1)], a = r.range(V(s), U(n), V(o), U(i)), l = r.data, c = [];
                for (const e of a){
                    const t1 = this.stride * e;
                    c.push(l[t1 + 5] > 1 ? H(l, t1, this.clusterProps) : this.points[l[t1 + 3]]);
                }
                return c;
            }
            getChildren(e) {
                const t1 = this._getOriginId(e), s = this._getOriginZoom(e), i = "No cluster with the specified id.", o = this.trees[s];
                if (!o) throw new Error(i);
                const n = o.data;
                if (t1 * this.stride >= n.length) throw new Error(i);
                const r = this.options.radius / (this.options.extent * Math.pow(2, s - 1)), a = o.within(n[t1 * this.stride], n[t1 * this.stride + 1], r), l = [];
                for (const t1 of a){
                    const s = t1 * this.stride;
                    n[s + 4] === e && l.push(n[s + 5] > 1 ? H(n, s, this.clusterProps) : this.points[n[s + 3]]);
                }
                if (0 === l.length) throw new Error(i);
                return l;
            }
            getLeaves(e, t1, s) {
                const i = [];
                return this._appendLeaves(i, e, t1 = t1 || 10, s = s || 0, 0), i;
            }
            getTile(e, t1, s) {
                const i = this.trees[this._limitZoom(e)], o = Math.pow(2, e), { extent: n, radius: r } = this.options, a = r / n, l = (s - a) / o, c = (s + 1 + a) / o, h = {
                    features: []
                };
                return this._addTileFeatures(i.range((t1 - a) / o, l, (t1 + 1 + a) / o, c), i.data, t1, s, o, h), 0 === t1 && this._addTileFeatures(i.range(1 - a / o, l, 1, c), i.data, o, s, o, h), t1 === o - 1 && this._addTileFeatures(i.range(0, l, a / o, c), i.data, -1, s, o, h), h.features.length ? h : null;
            }
            getClusterExpansionZoom(e) {
                let t1 = this._getOriginZoom(e) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const s = this.getChildren(e);
                    if (t1++, 1 !== s.length) break;
                    e = s[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e, t1, s, i, o) {
                const n = this.getChildren(t1);
                for (const t1 of n){
                    const n = t1.properties;
                    if (n && n.cluster ? o + n.point_count <= i ? o += n.point_count : o = this._appendLeaves(e, n.cluster_id, s, i, o) : o < i ? o++ : e.push(t1), e.length === s) break;
                }
                return o;
            }
            _createTree(t1) {
                const s = new e.c4(t1.length / this.stride | 0, this.options.nodeSize, Float32Array);
                for(let e = 0; e < t1.length; e += this.stride)s.add(t1[e], t1[e + 1]);
                return s.finish(), s.data = t1, s;
            }
            _addTileFeatures(e, t1, s, i, o, n) {
                for (const r of e){
                    const e = r * this.stride, a = t1[e + 5] > 1;
                    let l, c, h;
                    if (a) l = $(t1, e, this.clusterProps), c = t1[e], h = t1[e + 1];
                    else {
                        const s = this.points[t1[e + 3]];
                        l = s.properties;
                        const [i, o] = s.geometry.coordinates;
                        c = V(i), h = U(o);
                    }
                    const u = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (c * o - s)),
                                Math.round(this.options.extent * (h * o - i))
                            ]
                        ],
                        tags: l
                    };
                    let d;
                    d = a || this.options.generateId ? t1[e + 3] : this.points[t1[e + 3]].id, void 0 !== d && (u.id = d), n.features.push(u);
                }
            }
            _limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
            }
            _cluster(e, t1) {
                const { radius: s, extent: i, reduce: o, minPoints: n } = this.options, r = s / (i * Math.pow(2, t1)), a = e.data, l = [], c = this.stride;
                for(let s = 0; s < a.length; s += c){
                    if (a[s + 2] <= t1) continue;
                    a[s + 2] = t1;
                    const i = a[s], h = a[s + 1], u = e.within(a[s], a[s + 1], r), d = a[s + 5];
                    let f = d;
                    for (const e of u){
                        const s = e * c;
                        a[s + 2] > t1 && (f += a[s + 5]);
                    }
                    if (f > d && f >= n) {
                        let e, n = i * d, r = h * d, p = -1;
                        const g = (s / c << 5) + (t1 + 1) + this.points.length;
                        for (const i of u){
                            const l = i * c;
                            if (a[l + 2] <= t1) continue;
                            a[l + 2] = t1;
                            const h = a[l + 5];
                            n += a[l] * h, r += a[l + 1] * h, a[l + 4] = g, o && (e || (e = this._map(a, s, !0), p = this.clusterProps.length, this.clusterProps.push(e)), o(e, this._map(a, l)));
                        }
                        a[s + 4] = g, l.push(n / f, r / f, 1 / 0, g, -1, f), o && l.push(p);
                    } else {
                        for(let e = 0; e < c; e++)l.push(a[s + e]);
                        if (f > 1) for (const e of u){
                            const s = e * c;
                            if (!(a[s + 2] <= t1)) {
                                a[s + 2] = t1;
                                for(let e = 0; e < c; e++)l.push(a[s + e]);
                            }
                        }
                    }
                }
                return l;
            }
            _getOriginId(e) {
                return e - this.points.length >> 5;
            }
            _getOriginZoom(e) {
                return (e - this.points.length) % 32;
            }
            _map(e, t1, s) {
                if (e[t1 + 5] > 1) {
                    const i = this.clusterProps[e[t1 + 6]];
                    return s ? Object.assign({}, i) : i;
                }
                const i = this.points[e[t1 + 3]].properties, o = this.options.map(i);
                return s && o === i ? Object.assign({}, o) : o;
            }
        }
        function H(e, t1, s) {
            return {
                type: "Feature",
                id: e[t1 + 3],
                properties: $(e, t1, s),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (i = e[t1], 360 * (i - .5)),
                        q(e[t1 + 1])
                    ]
                }
            };
            //TURBOPACK unreachable
            ;
            var i;
        }
        function $(e, t1, s) {
            const i = e[t1 + 5], o = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + "k" : i, n = e[t1 + 6], r = -1 === n ? {} : Object.assign({}, s[n]);
            return Object.assign(r, {
                cluster: !0,
                cluster_id: e[t1 + 3],
                point_count: i,
                point_count_abbreviated: o
            });
        }
        function V(e) {
            return e / 360 + .5;
        }
        function U(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function q(e) {
            const t1 = (180 - 360 * e) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function W(e, t1, s, i) {
            let o = i;
            const n = t1 + (s - t1 >> 1);
            let r, a = s - t1;
            const l = e[t1], c = e[t1 + 1], h = e[s], u = e[s + 1];
            for(let i = t1 + 3; i < s; i += 3){
                const t1 = Q(e[i], e[i + 1], l, c, h, u);
                if (t1 > o) r = i, o = t1;
                else if (t1 === o) {
                    const e = Math.abs(i - n);
                    e < a && (r = i, a = e);
                }
            }
            o > i && (r - t1 > 3 && W(e, t1, r, i), e[r + 2] = o, s - r > 3 && W(e, r, s, i));
        }
        function Q(e, t1, s, i, o, n) {
            let r = o - s, a = n - i;
            if (0 !== r || 0 !== a) {
                const l = ((e - s) * r + (t1 - i) * a) / (r * r + a * a);
                l > 1 ? (s = o, i = n) : l > 0 && (s += r * l, i += a * l);
            }
            return r = e - s, a = t1 - i, r * r + a * a;
        }
        function K(e, t1, s, i) {
            const o = {
                id: e ?? null,
                type: t1,
                geometry: s,
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            if ("Point" === t1 || "MultiPoint" === t1 || "LineString" === t1) ee(o, s);
            else if ("Polygon" === t1) ee(o, s[0]);
            else if ("MultiLineString" === t1) for (const e of s)ee(o, e);
            else if ("MultiPolygon" === t1) for (const e of s)ee(o, e[0]);
            return o;
        }
        function ee(e, t1) {
            for(let s = 0; s < t1.length; s += 3)e.minX = Math.min(e.minX, t1[s]), e.minY = Math.min(e.minY, t1[s + 1]), e.maxX = Math.max(e.maxX, t1[s]), e.maxY = Math.max(e.maxY, t1[s + 1]);
        }
        function te(e, t1, s, i) {
            if (!t1.geometry) return;
            const o = t1.geometry.coordinates;
            if (o && 0 === o.length) return;
            const n = t1.geometry.type, r = Math.pow(s.tolerance / ((1 << s.maxZoom) * s.extent), 2);
            let a = [], l = t1.id;
            if (s.promoteId ? l = t1.properties[s.promoteId] : s.generateId && (l = i || 0), "Point" === n) se(o, a);
            else if ("MultiPoint" === n) for (const e of o)se(e, a);
            else if ("LineString" === n) ie(o, a, r, !1);
            else if ("MultiLineString" === n) {
                if (s.lineMetrics) {
                    for (const s of o)a = [], ie(s, a, r, !1), e.push(K(l, "LineString", a, t1.properties));
                    return;
                }
                oe(o, a, r, !1);
            } else if ("Polygon" === n) oe(o, a, r, !0);
            else {
                if ("MultiPolygon" !== n) {
                    if ("GeometryCollection" === n) {
                        for (const o of t1.geometry.geometries)te(e, {
                            id: l,
                            geometry: o,
                            properties: t1.properties
                        }, s, i);
                        return;
                    }
                    throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (const e of o){
                    const t1 = [];
                    oe(e, t1, r, !0), a.push(t1);
                }
            }
            e.push(K(l, n, a, t1.properties));
        }
        function se(e, t1) {
            t1.push(ne(e[0]), re(e[1]), 0);
        }
        function ie(e, t1, s, i) {
            let o, n, r = 0;
            for(let s = 0; s < e.length; s++){
                const a = ne(e[s][0]), l = re(e[s][1]);
                t1.push(a, l, 0), s > 0 && (r += i ? (o * l - a * n) / 2 : Math.sqrt(Math.pow(a - o, 2) + Math.pow(l - n, 2))), o = a, n = l;
            }
            const a = t1.length - 3;
            t1[2] = 1, W(t1, 0, a, s), t1[a + 2] = 1, t1.size = Math.abs(r), t1.start = 0, t1.end = t1.size;
        }
        function oe(e, t1, s, i) {
            for(let o = 0; o < e.length; o++){
                const n = [];
                ie(e[o], n, s, i), t1.push(n);
            }
        }
        function ne(e) {
            return e / 360 + .5;
        }
        function re(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function ae(e, t1, s, i, o, n, r, a) {
            if (i /= t1, n >= (s /= t1) && r < i) return e;
            if (r < s || n >= i) return null;
            const l = [];
            for (const t1 of e){
                const e = t1.geometry;
                let n = t1.type;
                const r = 0 === o ? t1.minX : t1.minY, c = 0 === o ? t1.maxX : t1.maxY;
                if (r >= s && c < i) {
                    l.push(t1);
                    continue;
                }
                if (c < s || r >= i) continue;
                let h = [];
                if ("Point" === n || "MultiPoint" === n) le(e, h, s, i, o);
                else if ("LineString" === n) ce(e, h, s, i, o, !1, a.lineMetrics);
                else if ("MultiLineString" === n) ue(e, h, s, i, o, !1);
                else if ("Polygon" === n) ue(e, h, s, i, o, !0);
                else if ("MultiPolygon" === n) for (const t1 of e){
                    const e = [];
                    ue(t1, e, s, i, o, !0), e.length && h.push(e);
                }
                if (h.length) {
                    if (a.lineMetrics && "LineString" === n) {
                        for (const e of h)l.push(K(t1.id, n, e, t1.tags));
                        continue;
                    }
                    "LineString" !== n && "MultiLineString" !== n || (1 === h.length ? (n = "LineString", h = h[0]) : n = "MultiLineString"), "Point" !== n && "MultiPoint" !== n || (n = 3 === h.length ? "Point" : "MultiPoint"), l.push(K(t1.id, n, h, t1.tags));
                }
            }
            return l.length ? l : null;
        }
        function le(e, t1, s, i, o) {
            for(let n = 0; n < e.length; n += 3){
                const r = e[n + o];
                r >= s && r <= i && de(t1, e[n], e[n + 1], e[n + 2]);
            }
        }
        function ce(e, t1, s, i, o, n, r) {
            let a = he(e);
            const l = 0 === o ? fe : pe;
            let c, h, u = e.start;
            for(let d = 0; d < e.length - 3; d += 3){
                const f = e[d], p = e[d + 1], g = e[d + 2], m = e[d + 3], y = e[d + 4], w = 0 === o ? f : p, b = 0 === o ? m : y;
                let x = !1;
                r && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(p - y, 2))), w < s ? b > s && (h = l(a, f, p, m, y, s), r && (a.start = u + c * h)) : w > i ? b < i && (h = l(a, f, p, m, y, i), r && (a.start = u + c * h)) : de(a, f, p, g), b < s && w >= s && (h = l(a, f, p, m, y, s), x = !0), b > i && w <= i && (h = l(a, f, p, m, y, i), x = !0), !n && x && (r && (a.end = u + c * h), t1.push(a), a = he(e)), r && (u += c);
            }
            let d = e.length - 3;
            const f = e[d], p = e[d + 1], g = 0 === o ? f : p;
            g >= s && g <= i && de(a, f, p, e[d + 2]), d = a.length - 3, n && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && de(a, a[0], a[1], a[2]), a.length && t1.push(a);
        }
        function he(e) {
            const t1 = [];
            return t1.size = e.size, t1.start = e.start, t1.end = e.end, t1;
        }
        function ue(e, t1, s, i, o, n) {
            for (const r of e)ce(r, t1, s, i, o, n, !1);
        }
        function de(e, t1, s, i) {
            e.push(t1, s, i);
        }
        function fe(e, t1, s, i, o, n) {
            const r = (n - t1) / (i - t1);
            return de(e, n, s + (o - s) * r, 1), r;
        }
        function pe(e, t1, s, i, o, n) {
            const r = (n - s) / (o - s);
            return de(e, t1 + (i - t1) * r, n, 1), r;
        }
        function ge(e, t1) {
            const s = [];
            for(let i = 0; i < e.length; i++){
                const o = e[i], n = o.type;
                let r;
                if ("Point" === n || "MultiPoint" === n || "LineString" === n) r = me(o.geometry, t1);
                else if ("MultiLineString" === n || "Polygon" === n) {
                    r = [];
                    for (const e of o.geometry)r.push(me(e, t1));
                } else if ("MultiPolygon" === n) {
                    r = [];
                    for (const e of o.geometry){
                        const s = [];
                        for (const i of e)s.push(me(i, t1));
                        r.push(s);
                    }
                }
                s.push(K(o.id, n, r, o.tags));
            }
            return s;
        }
        function me(e, t1) {
            const s = [];
            s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);
            for(let i = 0; i < e.length; i += 3)s.push(e[i] + t1, e[i + 1], e[i + 2]);
            return s;
        }
        function ye(e, t1) {
            if (e.transformed) return e;
            const s = 1 << e.z, i = e.x, o = e.y;
            for (const n of e.features){
                const e = n.geometry, r = n.type;
                if (n.geometry = [], 1 === r) for(let r = 0; r < e.length; r += 2)n.geometry.push(we(e[r], e[r + 1], t1, s, i, o));
                else for(let r = 0; r < e.length; r++){
                    const a = [];
                    for(let n = 0; n < e[r].length; n += 2)a.push(we(e[r][n], e[r][n + 1], t1, s, i, o));
                    n.geometry.push(a);
                }
            }
            return e.transformed = !0, e;
        }
        function we(e, t1, s, i, o, n) {
            return [
                Math.round(s * (e * i - o)),
                Math.round(s * (t1 * i - n))
            ];
        }
        function be(e, t1, s, i, o) {
            const n = t1 === o.maxZoom ? 0 : o.tolerance / ((1 << t1) * o.extent), r = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: e.length,
                source: null,
                x: s,
                y: i,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            };
            for (const t1 of e)xe(r, t1, n, o);
            return r;
        }
        function xe(e, t1, s, i) {
            const o = t1.geometry, n = t1.type, r = [];
            if (e.minX = Math.min(e.minX, t1.minX), e.minY = Math.min(e.minY, t1.minY), e.maxX = Math.max(e.maxX, t1.maxX), e.maxY = Math.max(e.maxY, t1.maxY), "Point" === n || "MultiPoint" === n) for(let t1 = 0; t1 < o.length; t1 += 3)r.push(o[t1], o[t1 + 1]), e.numPoints++, e.numSimplified++;
            else if ("LineString" === n) ve(r, o, e, s, !1, !1);
            else if ("MultiLineString" === n || "Polygon" === n) for(let t1 = 0; t1 < o.length; t1++)ve(r, o[t1], e, s, "Polygon" === n, 0 === t1);
            else if ("MultiPolygon" === n) for(let t1 = 0; t1 < o.length; t1++){
                const i = o[t1];
                for(let t1 = 0; t1 < i.length; t1++)ve(r, i[t1], e, s, !0, 0 === t1);
            }
            if (r.length) {
                let s = t1.tags || null;
                if ("LineString" === n && i.lineMetrics) {
                    s = {};
                    for(const e in t1.tags)s[e] = t1.tags[e];
                    s.mapbox_clip_start = o.start / o.size, s.mapbox_clip_end = o.end / o.size;
                }
                const a = {
                    geometry: r,
                    type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,
                    tags: s
                };
                null !== t1.id && (a.id = t1.id), e.features.push(a);
            }
        }
        function ve(e, t1, s, i, o, n) {
            const r = i * i;
            if (i > 0 && t1.size < (o ? r : i)) return void (s.numPoints += t1.length / 3);
            const a = [];
            for(let e = 0; e < t1.length; e += 3)(0 === i || t1[e + 2] > r) && (s.numSimplified++, a.push(t1[e], t1[e + 1])), s.numPoints++;
            o && function(e, t1) {
                let s = 0;
                for(let t1 = 0, i = e.length, o = i - 2; t1 < i; o = t1, t1 += 2)s += (e[t1] - e[o]) * (e[t1 + 1] + e[o + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const i = e[t1], o = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = i, e[s - 1 - t1] = o;
                }
            }(a, n), e.push(a);
        }
        const Ie = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        };
        class Se {
            constructor(e, t1){
                const s = (t1 = this.options = function(e, t1) {
                    for(const s in t1)e[s] = t1[s];
                    return e;
                }(Object.create(Ie), t1)).debug;
                if (s && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
                let i = function(e, t1) {
                    const s = [];
                    if ("FeatureCollection" === e.type) for(let i = 0; i < e.features.length; i++)te(s, e.features[i], t1, i);
                    else te(s, "Feature" === e.type ? e : {
                        geometry: e
                    }, t1);
                    return s;
                }(e, t1);
                this.tiles = {}, this.tileCoords = [], s && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = function(e, t1) {
                    const s = t1.buffer / t1.extent;
                    let i = e;
                    const o = ae(e, 1, -1 - s, s, 0, -1, 2, t1), n = ae(e, 1, 1 - s, 2 + s, 0, -1, 2, t1);
                    return (o || n) && (i = ae(e, 1, -s, 1 + s, 0, -1, 2, t1) || [], o && (i = ge(o, 1).concat(i)), n && (i = i.concat(ge(n, -1)))), i;
                }(i, t1), i.length && this.splitTile(i, 0, 0, 0), s && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e, t1, s, i, o, n, r) {
                const a = [
                    e,
                    t1,
                    s,
                    i
                ], l = this.options, c = l.debug;
                for(; a.length;){
                    i = a.pop(), s = a.pop(), t1 = a.pop(), e = a.pop();
                    const h = 1 << t1, u = Me(t1, s, i);
                    let d = this.tiles[u];
                    if (!d && (c > 1 && console.time("creation"), d = this.tiles[u] = be(e, t1, s, i, l), this.tileCoords.push({
                        z: t1,
                        x: s,
                        y: i
                    }), c)) {
                        c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, s, i, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd("creation"));
                        const e = `z${t1}`;
                        this.stats[e] = (this.stats[e] || 0) + 1, this.total++;
                    }
                    if (d.source = e, null == o) {
                        if (t1 === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue;
                    } else {
                        if (t1 === l.maxZoom || t1 === o) continue;
                        if (null != o) {
                            const e = o - t1;
                            if (s !== n >> e || i !== r >> e) continue;
                        }
                    }
                    if (d.source = null, 0 === e.length) continue;
                    c > 1 && console.time("clipping");
                    const f = .5 * l.buffer / l.extent, p = .5 - f, g = .5 + f, m = 1 + f;
                    let y = null, w = null, b = null, x = null, v = ae(e, h, s - f, s + g, 0, d.minX, d.maxX, l), I = ae(e, h, s + p, s + m, 0, d.minX, d.maxX, l);
                    e = null, v && (y = ae(v, h, i - f, i + g, 1, d.minY, d.maxY, l), w = ae(v, h, i + p, i + m, 1, d.minY, d.maxY, l), v = null), I && (b = ae(I, h, i - f, i + g, 1, d.minY, d.maxY, l), x = ae(I, h, i + p, i + m, 1, d.minY, d.maxY, l), I = null), c > 1 && console.timeEnd("clipping"), a.push(y || [], t1 + 1, 2 * s, 2 * i), a.push(w || [], t1 + 1, 2 * s, 2 * i + 1), a.push(b || [], t1 + 1, 2 * s + 1, 2 * i), a.push(x || [], t1 + 1, 2 * s + 1, 2 * i + 1);
                }
            }
            getTile(e, t1, s) {
                e = +e, t1 = +t1, s = +s;
                const i = this.options, { extent: o, debug: n } = i;
                if (e < 0 || e > 24) return null;
                const r = 1 << e, a = Me(e, t1 = t1 + r & r - 1, s);
                if (this.tiles[a]) return ye(this.tiles[a], o);
                n > 1 && console.log("drilling down to z%d-%d-%d", e, t1, s);
                let l, c = e, h = t1, u = s;
                for(; !l && c > 0;)c--, h >>= 1, u >>= 1, l = this.tiles[Me(c, h, u)];
                return l && l.source ? (n > 1 && (console.log("found parent tile z%d-%d-%d", c, h, u), console.time("drilling down")), this.splitTile(l.source, c, h, u, e, t1, s), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? ye(this.tiles[a], o) : null) : null;
            }
        }
        function Me(e, t1, s) {
            return 32 * ((1 << e) * s + t1) + e;
        }
        function Pe(t1, s) {
            const i = t1.tileID.canonical;
            if (!this._geoJSONIndex) return void s(null, null);
            const o = this._geoJSONIndex.getTile(i.z, i.x, i.y);
            if (!o) return void s(null, null);
            const n = (e)=>e.tags && "3d_elevation_id" in e.tags && "source" in e.tags && "elevation" === e.tags.source, r = o.features.filter((e)=>n(e));
            let a = {
                _geojsonTileLayer: o.features
            };
            r.length > 0 && (a = {
                _geojsonTileLayer: o.features.filter((e)=>!n(e)),
                hd_road_elevation: r
            });
            const l = new M(a), c = function(t1) {
                const s = new e.bt;
                for (const e of Object.keys(t1))s.writeMessage(3, F, {
                    name: e,
                    features: t1[e]
                });
                return s.finish();
            }(a).buffer;
            s(null, {
                vectorTile: l,
                rawData: c
            });
        }
        class Te extends y {
            constructor(e, t1, s, i, o, n, r){
                super(e, t1, s, i, o, Pe, r), n && (this.loadGeoJSON = n), this._dynamicIndex = new T;
            }
            loadData(s, i) {
                const o = s && s.request, n = o && o.collectResourceTiming;
                this._geoJSONIndex = null, this.loadGeoJSON(s, (r, a)=>{
                    if (r || !a) return i(r);
                    if ("object" != typeof a) return i(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));
                    {
                        try {
                            if (s.filter) {
                                const t1 = e.U(s.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === t1.result) throw new Error(t1.value.map((e)=>`${e.key}: ${e.message}`).join(", "));
                                a.features = a.features.filter((e)=>t1.value.evaluate({
                                        zoom: 0
                                    }, e));
                            }
                            s.dynamic ? ("Feature" === a.type && (a = {
                                type: "FeatureCollection",
                                features: [
                                    a
                                ]
                            }), s.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a.features, this.loaded), s.cluster && (a.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s.cluster ? new G(function({ superclusterOptions: t1, clusterProperties: s }) {
                                if (!s || !t1) return t1;
                                const i = {}, o = {}, n = {
                                    accumulated: null,
                                    zoom: 0
                                }, r = {
                                    properties: null
                                }, a = Object.keys(s);
                                for (const t1 of a){
                                    const [n, r] = s[t1], a = e.U(r), l = e.U("string" == typeof n ? [
                                        n,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : n);
                                    i[t1] = a.value, o[t1] = l.value;
                                }
                                return t1.map = (e)=>{
                                    r.properties = e;
                                    const t1 = {};
                                    for (const e of a)t1[e] = i[e].evaluate(n, r);
                                    return t1;
                                }, t1.reduce = (e, t1)=>{
                                    r.properties = t1;
                                    for (const t1 of a)n.accumulated = e[t1], e[t1] = o[t1].evaluate(n, r);
                                }, t1;
                            }(s)).load(a.features) : s.dynamic ? this._dynamicIndex : function(e, t1) {
                                return new Se(e, t1);
                            }(a, s.geojsonVtOptions);
                        } catch (e) {
                            return i(e);
                        }
                        const r = {};
                        if (n) {
                            const e = t1(o);
                            e && (r.resourceTiming = {}, r.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));
                        }
                        i(null, r);
                    }
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded;
                return s && s[e.uid] ? e.partial ? t1(null, void 0) : super.reloadTile(e, t1) : this.loadTile(e, t1);
            }
            loadGeoJSON(t1, s) {
                if (t1.request) e.m(t1.request, s);
                else {
                    if ("string" != typeof t1.data) return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    setTimeout(()=>{
                        try {
                            return s(null, JSON.parse(t1.data));
                        } catch (e) {
                            return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                        }
                    }, 0);
                }
            }
            getClusterExpansionZoom(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterChildren(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterLeaves(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e) {
                    t1(e);
                }
            }
        }
        class _e {
            constructor(t1, s, i){
                this.tileID = new e.aQ(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t1.projection, this.brightness = s, this.worldview = i;
            }
            parse(t1, s, i, o) {
                this.status = "parsing";
                const n = new e.aQ(i.tileID.overscaledZ, i.tileID.wrap, i.tileID.canonical.z, i.tileID.canonical.x, i.tileID.canonical.y), r = [], a = s.familiesBySource[i.source], l = new e.fn(n, i.promoteId);
                l.bucketLayerIDs = [], l.is3DTile = !0, e.fC(t1).then((t1)=>{
                    if (!t1) return o(new Error("Could not parse tile"));
                    const s = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("MAPBOX_mesh_features") || t1.json.asset.extras && t1.json.asset.extras.MAPBOX_mesh_features, c = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("EXT_meshopt_compression"), h = new e.ac(this.zoom, {
                        brightness: this.brightness,
                        worldview: this.worldview
                    });
                    for(const o in a)for (const u of a[o]){
                        const o = u[0];
                        l.bucketLayerIDs.push(u.map((t1)=>e.B(t1.id, t1.scope))), o.recalculate(h, []);
                        const a = e.fD(t1, 1 / e.d7(i.tileID.canonical)), d = new e.fE(u, a, n, s, c, this.brightness, l, this.worldview);
                        s || (d.needsUpload = !0), r.push(d), d.evaluate(o);
                    }
                    this.status = "done", o(null, {
                        buckets: r,
                        featureIndex: l,
                        collisionBoxArray: null,
                        glyphAtlasImage: null,
                        lineAtlas: null,
                        imageAtlas: null,
                        brightness: null
                    });
                }).catch((e)=>o(new Error(e.message)));
            }
        }
        class ke {
            constructor(e, t1, s, i, o, n, r, a){
                this.actor = e, this.layerIndex = t1, this.availableImages = s, this.availableModels = i, this.brightness = r, this.loading = {}, this.loaded = {}, this.worldview = a;
            }
            loadTile(t1, s) {
                const i = t1.uid, o = this.loading[i] = new _e(t1, this.brightness, this.worldview);
                e.bu(t1.request, (e, n)=>{
                    const r = !this.loading[i];
                    return delete this.loading[i], r || e ? (o.status = "done", r || (this.loaded[i] = o), s(e)) : n && 0 !== n.byteLength ? void o.parse(n, this.layerIndex, t1, (e, t1)=>{
                        o.status = "done", this.loaded = this.loaded || {}, this.loaded[i] = o, e || !t1 ? s(e) : s(null, t1);
                    }) : (o.status = "done", this.loaded[i] = o, s());
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded, i = e.uid;
                if (s && s[i]) {
                    const o = s[i];
                    o.projection = e.projection, o.brightness = e.brightness;
                    const n = (s, i)=>{
                        o.reloadCallback && (delete o.reloadCallback, this.loadTile(e, t1)), t1(s, i);
                    };
                    "parsing" === o.status ? o.reloadCallback = n : "done" === o.status && this.loadTile(e, t1);
                }
            }
            abortTile(e, t1) {
                const s = e.uid;
                this.loading[s] && delete this.loading[s], t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, i = e.uid;
                s && s[i] && delete s[i], t1();
            }
        }
        class Le {
            constructor(t1){
                this.self = t1, this.actor = new e.fG(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.x, this.rtlPluginParsingListeners = [], this.projections = {}, this.defaultProjection = e.cm({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: y,
                    geojson: Te,
                    "raster-dem": w,
                    "raster-array": x,
                    "batched-model": ke
                }, this.workerSources = {}, this.self.registerWorkerSource = (e, t1)=>{
                    if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
                    this.workerSourceTypes[e] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e.fH.isParsed()) throw new Error("RTL text plugin already registered.");
                    e.fH.setState({
                        pluginStatus: e.fI.parsed,
                        pluginURL: e.fH.getPluginURL()
                    }), e.fH.applyArabicShaping = t1.applyArabicShaping, e.fH.processBidirectionalText = t1.processBidirectionalText, e.fH.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                    for (const e of this.rtlPluginParsingListeners)e(null, !0);
                    this.rtlPluginParsingListeners = [];
                };
            }
            clearCaches(e, t1, s) {
                delete this.layerIndexes[e], delete this.availableImages[e], delete this.availableModels[e], delete this.workerSources[e], s();
            }
            checkIfReady(e, t1, s) {
                s();
            }
            setReferrer(e, t1) {
                this.referrer = t1;
            }
            spriteLoaded(t1, s) {
                this.isSpriteLoaded[t1] || (this.isSpriteLoaded[t1] = {});
                const { scope: i, isLoaded: o } = s;
                if (this.isSpriteLoaded[t1][i] = o, this.workerSources[t1] && this.workerSources[t1][i]) for(const s in this.workerSources[t1][i]){
                    const n = this.workerSources[t1][i][s];
                    for(const t1 in n){
                        const s = n[t1];
                        s instanceof y && (s.isSpriteLoaded = o, s.fire(new e.z("isSpriteLoaded")));
                    }
                }
            }
            setImages(e, t1, s) {
                this.availableImages[e] || (this.availableImages[e] = {});
                const { scope: i, images: o } = t1;
                if (this.availableImages[e][i] = o, this.workerSources[e] && this.workerSources[e][i]) {
                    for(const t1 in this.workerSources[e][i]){
                        const s = this.workerSources[e][i][t1];
                        for(const e in s)s[e].availableImages = o;
                    }
                    s();
                } else s();
            }
            setModels(e, { scope: t1, models: s }, i) {
                if (this.availableModels[e] || (this.availableModels[e] = {}), this.availableModels[e][t1] = s, this.workerSources[e] && this.workerSources[e][t1]) {
                    for(const i in this.workerSources[e][t1]){
                        const o = this.workerSources[e][t1][i];
                        for(const e in o)o[e].availableModels = s;
                    }
                    i();
                } else i();
            }
            setProjection(t1, s) {
                this.projections[t1] = e.cm(s);
            }
            setBrightness(e, t1, s) {
                this.brightness = t1, s();
            }
            setWorldview(e, t1, s) {
                this.worldview = t1, s();
            }
            setLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).replace(t1.layers, t1.options), s();
            }
            updateLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).update(t1.layers, t1.removedIds, t1.options), s();
            }
            loadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).loadTile(t1, s);
            }
            decodeRasterArray(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).decodeRasterArray(t1, s);
            }
            reloadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).reloadTile(t1, s);
            }
            abortTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).abortTile(t1, s);
            }
            removeTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).removeTile(t1, s);
            }
            removeSource(e, t1, s) {
                if (!(this.workerSources[e] && this.workerSources[e][t1.scope] && this.workerSources[e][t1.scope][t1.type] && this.workerSources[e][t1.scope][t1.type][t1.source])) return;
                const i = this.workerSources[e][t1.scope][t1.type][t1.source];
                delete this.workerSources[e][t1.scope][t1.type][t1.source], void 0 !== i.removeSource ? i.removeSource(t1, s) : s();
            }
            loadWorkerSource(e, t1, s) {
                try {
                    this.self.importScripts(t1.url), s();
                } catch (e) {
                    s(e);
                }
            }
            syncRTLPluginState(t1, s, i) {
                if (e.fH.isParsed()) i(null, !0);
                else if (e.fH.isParsing()) this.rtlPluginParsingListeners.push(i);
                else try {
                    e.fH.setState(s);
                    const t1 = e.fH.getPluginURL();
                    !e.fH.isLoaded() || e.fH.isParsed() || e.fH.isParsing() || null == t1 || (e.fH.setState({
                        pluginStatus: e.fI.parsing,
                        pluginURL: e.fH.getPluginURL()
                    }), this.self.importScripts(t1), e.fH.isParsed() ? i(null, !0) : this.rtlPluginParsingListeners.push(i));
                } catch (e) {
                    i(e);
                }
            }
            setDracoUrl(e, t1) {
                this.dracoUrl = t1;
            }
            getAvailableImages(e, t1) {
                this.availableImages[e] || (this.availableImages[e] = {});
                let s = this.availableImages[e][t1];
                return s || (s = []), s;
            }
            getAvailableModels(e, t1) {
                this.availableModels[e] || (this.availableModels[e] = {});
                let s = this.availableModels[e][t1];
                return s || (s = {}), s;
            }
            getLayerIndex(e, t1) {
                this.layerIndexes[e] || (this.layerIndexes[e] = {});
                let s = this.layerIndexes[e][t1];
                return s || (s = this.layerIndexes[e][t1] = new n, s.scope = t1), s;
            }
            getWorkerSource(e, t1, s, i) {
                const o = this.workerSources;
                return o[e] || (o[e] = {}), o[e][i] || (o[e][i] = {}), o[e][i][t1] || (o[e][i][t1] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), o[e][i][t1][s] || (o[e][i][t1][s] = new this.workerSourceTypes[t1]({
                    send: (t1, s, i, o, n, r)=>this.actor.send(t1, s, i, e, n, r),
                    scheduler: this.actor.scheduler
                }, this.getLayerIndex(e, i), this.getAvailableImages(e, i), this.getAvailableModels(e, i), this.isSpriteLoaded[e][i], void 0, this.brightness, this.worldview)), o[e][i][t1][s];
            }
            rasterizeImagesWorker(e, t1, s) {
                const i = new Map;
                for (const [s, { image: o, imageVariant: n }] of t1.tasks.entries()){
                    const r = this.imageRasterizer.rasterize(n, o, t1.scope, e);
                    i.set(s, r);
                }
                s(void 0, i);
            }
            removeRasterizedImages(e, t1, s) {
                this.imageRasterizer.removeImagesFromCacheByIds(t1.imageIds, t1.scope, e), s();
            }
            enforceCacheSizeLimit(t1, s) {
                e.fJ(s);
            }
            getWorkerPerformanceMetrics(e, t1, s) {
                s(void 0, void 0);
            }
        }
        return e.fF(self) && (self.worker = new Le(self)), Le;
    });
    define([
        "./shared"
    ], function(e) {
        var t1 = "3.18.0";
        const i = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, o = {
            mark (e) {
                performance.mark(e);
            },
            measure (e, t1, i) {
                performance.measure(e, t1, i);
            }
        };
        function s(t1) {
            const i = t1.name.split("?")[0];
            return e.a(i) && i.includes("mapbox-gl.js") ? "javascript" : e.a(i) && i.includes("mapbox-gl.css") ? "css" : e.b(i) ? "fontRange" : e.c(i) ? "sprite" : e.i(i) ? "style" : e.d(i) ? "tilejson" : "other";
        }
        var r, n = {}, a = function() {
            if (r) return n;
            function e(e) {
                return !t1(e);
            }
            function t1(t1) {
                return ("TURBOPACK compile-time truthy", 1) ? "not a browser" : "TURBOPACK unreachable";
                //TURBOPACK unreachable
                ;
                var o;
            }
            r = 1, n.supported = e, n.notSupportedReason = t1;
            var i = {};
            return e.webGLContextAttributes = {
                antialias: !1,
                alpha: !0,
                stencil: !0,
                depth: !0
            }, n;
        }();
        function l(e, t1, i) {
            const o = document.createElement(e);
            return null != t1 && (o.className = t1), i && i.appendChild(o), o;
        }
        function c(e, t1, i) {
            const o = document.createElementNS("http://www.w3.org/2000/svg", e);
            for (const e of Object.keys(t1))o.setAttributeNS(null, e, String(t1[e]));
            return i && i.appendChild(o), o;
        }
        const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, d = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
        let u;
        function _() {
            h && d && (u = h[d], h[d] = "none");
        }
        function p() {
            h && d && (h[d] = u);
        }
        function f(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", f, !0);
        }
        function m() {
            window.addEventListener("click", f, !0), window.setTimeout(()=>{
                window.removeEventListener("click", f, !0);
            }, 0);
        }
        function g(e, t1) {
            const i = e.getBoundingClientRect();
            return x(e, i, t1);
        }
        function v(e, t1) {
            const i = e.getBoundingClientRect(), o = [];
            for(let s = 0; s < t1.length; s++)o.push(x(e, i, t1[s]));
            return o;
        }
        function y(e) {
            return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e.button && e.ctrlKey ? 0 : e.button;
        }
        function x(t1, i, o) {
            const s = t1.offsetWidth === i.width ? 1 : t1.offsetWidth / i.width;
            return new e.P((o.clientX - i.left) * s, (o.clientY - i.top) * s);
        }
        const b = "01", w = "NO_ACCESS_TOKEN";
        class T {
            constructor(e, t1, i){
                this._transformRequestFn = e, this._customAccessToken = t1, this._silenceAuthErrors = !!i, this._createSkuToken();
            }
            _createSkuToken() {
                const e = function() {
                    let e = "";
                    for(let t1 = 0; t1 < 10; t1++)e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            b,
                            e
                        ].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    };
                }();
                this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(e, t1) {
                return this._transformRequestFn && this._transformRequestFn(e, t1) || {
                    url: e
                };
            }
            normalizeStyleURL(i, o) {
                if (!e.h(i)) return i;
                const s = S(i);
                return s.params.push(`sdk=js-${t1}`), s.path = `/styles/v1${s.path}`, this._makeAPIURL(s, this._customAccessToken || o);
            }
            normalizeGlyphsURL(t1, i) {
                if (!e.h(t1)) return t1;
                const o = S(t1);
                return o.path = `/fonts/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);
            }
            normalizeModelURL(t1, i) {
                if (!e.h(t1)) return t1;
                const o = S(t1);
                return o.path = `/models/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);
            }
            normalizeSourceURL(t1, i, o, s) {
                if (!e.h(t1)) return t1;
                const r = S(t1);
                return r.path = `/v4/${r.authority}.json`, r.params.push("secure"), o && r.params.push(`language=${o}`), s && r.params.push(`worldview=${s}`), this._makeAPIURL(r, this._customAccessToken || i);
            }
            normalizeIconsetURL(t1, i) {
                const o = S(t1);
                return e.h(t1) ? (o.path = `/styles/v1${o.path}/iconset.pbf`, this._makeAPIURL(o, this._customAccessToken || i)) : I(o);
            }
            normalizeSpriteURL(t1, i, o, s) {
                const r = S(t1);
                return e.h(t1) ? (r.path = `/styles/v1${r.path}/sprite${i}${o}`, this._makeAPIURL(r, this._customAccessToken || s)) : (r.path += `${i}${o}`, I(r));
            }
            normalizeTileURL(t1, i, o) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t1 && !e.h(t1)) return t1;
                const s = S(t1);
                s.path = s.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i || o && "raster" !== s.authority && 512 === o ? "@2x" : ""}${e.k.supported ? ".webp" : "$1"}`), "raster" === s.authority ? s.path = `/${e.e.RASTER_URL_PREFIX}${s.path}` : "rasterarrays" === s.authority ? s.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${s.path}` : "3dtiles" === s.authority ? s.path = `/${e.e.TILES3D_URL_PREFIX}${s.path}` : (s.path = s.path.replace(/^.+\/v4\//, "/"), s.path = `/${e.e.TILE_URL_VERSION}${s.path}`);
                const r = this._customAccessToken || function(e) {
                    for (const t1 of e){
                        const e = t1.match(/^access_token=(.*)$/);
                        if (e) return e[1];
                    }
                    return null;
                }(s.params) || e.e.ACCESS_TOKEN;
                return e.e.REQUIRE_ACCESS_TOKEN && r && this._skuToken && s.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s, r);
            }
            canonicalizeTileURL(t1, i) {
                const o = S(t1);
                if (!o.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o.path.match(/\.[\w]+$/)) return t1;
                let s = "mapbox://";
                o.path.match(/^\/raster\/v1\//) ? s += `raster/${o.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o.path.match(/^\/rasterarrays\/v1\//) ? s += `rasterarrays/${o.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : s += `tiles/${o.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
                let r = o.params;
                return i && (r = r.filter((e)=>!e.match(/^access_token=/))), r.length && (s += `?${r.join("&")}`), s;
            }
            canonicalizeTileset(t1, i) {
                const o = !!i && e.h(i), s = [];
                for (const i of t1.tiles || [])e.j(i) ? s.push(this.canonicalizeTileURL(i, o)) : s.push(i);
                return s;
            }
            _makeAPIURL(t1, i) {
                const o = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", s = S(e.e.API_URL);
                if (t1.protocol = s.protocol, t1.authority = s.authority, "http" === t1.protocol) {
                    const e = t1.params.indexOf("secure");
                    e >= 0 && t1.params.splice(e, 1);
                }
                if ("/" !== s.path && (t1.path = `${s.path}${t1.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return I(t1);
                if (i = i || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!i) throw new Error(`An API access token is required to use Mapbox GL. ${o}`);
                    if ("s" === i[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o}`);
                }
                return t1.params = t1.params.filter((e)=>-1 === e.indexOf("access_token")), t1.params.push(`access_token=${i || ""}`), I(t1);
            }
        }
        const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function S(e) {
            const t1 = e.match(E);
            if (!t1) throw new Error("Unable to parse URL object");
            return {
                protocol: t1[1],
                authority: t1[2],
                path: t1[3] || "/",
                params: t1[4] ? t1[4].split("&") : []
            };
        }
        function I(e) {
            const t1 = e.params.length ? `?${e.params.join("&")}` : "";
            return `${e.protocol}://${e.authority}${e.path}${t1}`;
        }
        const C = "mapbox.eventData";
        function R(t1) {
            if (!t1) return null;
            const i = t1.split(".");
            if (!i || 3 !== i.length) return null;
            try {
                return JSON.parse(e.l(i[1]));
            } catch (e) {
                return null;
            }
        }
        class A {
            constructor(e){
                this.type = e, this.anonId = null, this.anonIdTimestamp = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t1) {
                const i = R(e.e.ACCESS_TOKEN);
                let o = "";
                return o = i && i.u ? e.f(i.u) : e.e.ACCESS_TOKEN || "", t1 ? `${C}.${t1}:${o}` : `${C}:${o}`;
            }
            fetchEventData() {
                const t1 = e.s("localStorage"), i = this.getStorageKey(), o = this.getStorageKey("uuid"), s = this.getStorageKey("uuidTimestamp");
                if (t1) try {
                    const e = localStorage.getItem(i);
                    e && (this.eventData = JSON.parse(e));
                    const t1 = localStorage.getItem(o);
                    t1 && (this.anonId = t1);
                    const r = localStorage.getItem(s);
                    r && (this.anonIdTimestamp = Number(r));
                    const n = Date.now() - 864e5;
                    (!this.anonIdTimestamp || this.anonIdTimestamp < n) && this.refreshUUID();
                } catch (t1) {
                    e.w("Unable to read from LocalStorage");
                }
            }
            refreshUUID() {
                this.anonId = e.u(), this.anonIdTimestamp = Date.now();
            }
            saveEventData() {
                const t1 = e.s("localStorage"), i = this.getStorageKey(), o = this.getStorageKey("uuid"), s = this.getStorageKey("uuidTimestamp"), r = this.anonId, n = this.anonIdTimestamp;
                if (t1 && r) try {
                    localStorage.setItem(o, r), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i, JSON.stringify(this.eventData)), n && localStorage.setItem(s, n.toString());
                } catch (t1) {
                    e.w("Unable to write to LocalStorage");
                }
            }
            processRequests(e) {}
            postEvent(t1, i, o, s) {
                if (!e.e.EVENTS_URL) return;
                const r = S(e.e.EVENTS_URL);
                r.params.push(`access_token=${s || e.e.ACCESS_TOKEN || ""}`);
                const n = {
                    event: this.type,
                    created: new Date(t1).toISOString()
                }, a = i ? Object.assign(n, i) : n, l = {
                    url: I(r),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        a
                    ])
                };
                this.pendingRequest = e.p(l, (e)=>{
                    this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);
                });
            }
            queueRequest(e, t1) {
                this.queue.push(e), this.processRequests(t1);
            }
        }
        class L extends A {
            constructor(e){
                super("metrics"), e && (this.data = e);
            }
            postMetricsEvent(t1) {
                if (!e.e.EVENTS_URL || !t1 && !e.e.ACCESS_TOKEN) return;
                this.anonId || this.fetchEventData(), e.v(this.anonId) || this.refreshUUID();
                const i = Object.assign({}, this.data, {
                    sessionId: this.anonId
                });
                this.queueRequest({
                    timestamp: Date.now(),
                    payload: i
                }, t1);
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: t1, payload: i } = this.queue.shift();
                this.postEvent(t1, i, ()=>{}, e);
            }
        }
        const D = new class extends A {
            constructor(e){
                super("appUserTurnstile"), this._customAccessToken = e;
            }
            postTurnstileEvent(t1, i) {
                e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t1) && t1.some((t1)=>e.h(t1) || e.j(t1)) && this.queueRequest(Date.now(), i);
            }
            processRequests(i) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.anonIdTimestamp && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const o = R(e.e.ACCESS_TOKEN), s = o ? o.u : e.e.ACCESS_TOKEN;
                let r = s !== this.eventData.tokenU;
                e.v(this.anonId) || (this.refreshUUID(), r = !0);
                const n = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const e = new Date(this.eventData.lastSuccess), t1 = new Date(n), i = (n - this.eventData.lastSuccess) / 864e5;
                    r = r || i >= 1 || i < -1 || e.getDate() !== t1.getDate();
                } else r = !0;
                r ? this.postEvent(n, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: t1,
                    skuId: b,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (e)=>{
                    e || (this.eventData.lastSuccess = n, this.eventData.tokenU = s);
                }, i) : this.processRequests();
            }
        }, P = D.postTurnstileEvent.bind(D), O = new class extends A {
            constructor(){
                super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t1, i, o, s) {
                this.skuToken = i, this.errorCb = s, e.e.EVENTS_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, o) : this.errorCb(new Error(w)));
            }
            processRequests(i) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: o, timestamp: s } = this.queue.shift();
                o && this.success[o] || (this.anonId && this.anonIdTimestamp || this.fetchEventData(), e.v(this.anonId) || this.refreshUUID(), this.postEvent(s, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: t1,
                    skuId: b,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (e)=>{
                    e ? this.errorCb(e) : o && (this.success[o] = !0);
                }, i));
            }
            remove() {
                this.errorCb = null;
            }
        }, z = O.postMapLoadEvent.bind(O), M = new class extends A {
            constructor(){
                super("style.load"), this.eventIdPerMapInstanceMap = new Map, this.mapInstanceIdMap = new WeakMap;
            }
            getMapInstanceId(t1) {
                let i = this.mapInstanceIdMap.get(t1);
                return i || (i = e.u(), this.mapInstanceIdMap.set(t1, i)), i;
            }
            getEventId(e) {
                const t1 = this.eventIdPerMapInstanceMap.get(e) || 0;
                return this.eventIdPerMapInstanceMap.set(e, t1 + 1), t1;
            }
            postStyleLoadEvent(t1, i) {
                const { map: o, style: s, importedStyles: r } = i;
                if (!e.e.EVENTS_URL || !t1 && !e.e.ACCESS_TOKEN) return;
                const n = this.getMapInstanceId(o), a = {
                    mapInstanceId: n,
                    eventId: this.getEventId(n),
                    style: s
                };
                r.length && (a.importedStyles = r), this.queueRequest({
                    timestamp: Date.now(),
                    payload: a
                }, t1);
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: t1, payload: i } = this.queue.shift();
                this.postEvent(t1, i, ()=>{}, e);
            }
        }, F = M.postStyleLoadEvent.bind(M), B = new L({
            attributes: [
                {
                    name: "maps/js/layer-animations/style-with-appearances"
                }
            ]
        }), k = B.postMetricsEvent.bind(B), N = new L({
            attributes: [
                {
                    name: "maps/js/layer-animations/runtime-appearances"
                }
            ]
        }), U = N.postMetricsEvent.bind(N), j = new class extends A {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t1, i) {
                e.e.EVENTS_URL && (t1 || e.e.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: i
                }, t1);
            }
            processRequests(o) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: r, performanceData: n } = this.queue.shift(), a = function(o) {
                    const r = performance.getEntriesByType("resource"), n = performance.getEntriesByType("mark"), a = function(e) {
                        const t1 = {};
                        if (e) {
                            for(const i in e)if ("other" !== i) for (const o of e[i]){
                                const e = `${i}ResolveRangeMin`, s = `${i}ResolveRangeMax`, r = `${i}RequestCount`, n = `${i}RequestCachedCount`;
                                t1[e] = Math.min(t1[e] || 1 / 0, o.startTime), t1[s] = Math.max(t1[s] || -1 / 0, o.responseEnd);
                                const a = (e)=>{
                                    void 0 === t1[e] && (t1[e] = 0), ++t1[e];
                                };
                                void 0 !== o.transferSize && 0 === o.transferSize && a(n), a(r);
                            }
                        }
                        return t1;
                    }(function(e, t1) {
                        const i = {};
                        if (e) for (const o of e){
                            const e = t1(o);
                            void 0 === i[e] && (i[e] = []), i[e].push(o);
                        }
                        return i;
                    }(r, s)), l = window.devicePixelRatio, c = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h = c ? c.effectiveType : void 0, d = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, u = (e, t1, i)=>{
                        null != i && e.push({
                            name: t1,
                            value: i.toString()
                        });
                    };
                    for(const e in a)u(d.counters, e, a[e]);
                    if (o.interactionRange[0] !== 1 / 0 && o.interactionRange[1] !== -1 / 0 && (u(d.counters, "interactionRangeMin", o.interactionRange[0]), u(d.counters, "interactionRangeMax", o.interactionRange[1])), n) for (const e of Object.values(i)){
                        const t1 = n.find((t1)=>t1.name === e);
                        t1 && u(d.counters, e, t1.startTime);
                    }
                    return u(d.counters, "visibilityHidden", o.visibilityHidden), u(d.attributes, "style", function(t1) {
                        if (t1) for (const i of t1){
                            const t1 = i.name.split("?")[0];
                            if (e.i(t1)) {
                                const e = t1.split("/").slice(-2);
                                if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;
                            }
                        }
                    }(r)), u(d.attributes, "terrainEnabled", o.terrainEnabled ? "true" : "false"), u(d.attributes, "fogEnabled", o.fogEnabled ? "true" : "false"), u(d.attributes, "projection", o.projection), u(d.attributes, "zoom", o.zoom), u(d.metadata, "devicePixelRatio", l), u(d.metadata, "connectionEffectiveType", h), u(d.metadata, "navigatorUserAgent", navigator.userAgent), u(d.metadata, "screenWidth", window.screen.width), u(d.metadata, "screenHeight", window.screen.height), u(d.metadata, "windowWidth", window.innerWidth), u(d.metadata, "windowHeight", window.innerHeight), u(d.metadata, "mapWidth", o.width / l), u(d.metadata, "mapHeight", o.height / l), u(d.metadata, "webglRenderer", o.renderer), u(d.metadata, "webglVendor", o.vendor), u(d.metadata, "sdkVersion", t1), u(d.metadata, "sdkIdentifier", "mapbox-gl-js"), d;
                }(n);
                for (const e of a.metadata);
                for (const e of a.counters);
                for (const e of a.attributes);
                this.postEvent(r, a, ()=>{}, o);
            }
        }, V = j.postPerformanceEvent.bind(j), G = new class extends A {
            constructor(){
                super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t1, i, o, s) {
                if (!e.e.API_URL || !e.e.SESSION_PATH) return;
                const r = S(e.e.API_URL + e.e.SESSION_PATH);
                r.params.push(`sku=${i || ""}`), r.params.push(`access_token=${s || e.e.ACCESS_TOKEN || ""}`);
                const n = {
                    url: I(r),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = e.g(n, (e)=>{
                    this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);
                });
            }
            getSessionAPI(t1, i, o, s) {
                this.skuToken = i, this.errorCb = s, e.e.SESSION_PATH && e.e.API_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, o) : this.errorCb(new Error(w)));
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: t1, timestamp: i } = this.queue.shift();
                t1 && this.success[t1] || this.getSession(i, this.skuToken, (e)=>{
                    e ? this.errorCb(e) : t1 && (this.success[t1] = !0);
                }, e);
            }
            remove() {
                this.errorCb = null;
            }
        }, H = G.getSessionAPI.bind(G), q = new Set;
        function Z(e, t1) {
            t1 ? q.add(e) : q.delete(e);
        }
        class W {
            constructor(){
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set, this._updatedImages = {};
            }
            isDirty() {
                return this._changed;
            }
            setDirty() {
                this._changed = !0;
            }
            getUpdatedSourceCaches() {
                return this._updatedSourceCaches;
            }
            updateSourceCache(e, t1) {
                this._updatedSourceCaches[e] = t1, this.setDirty();
            }
            discardSourceCacheUpdate(e) {
                delete this._updatedSourceCaches[e];
            }
            updateLayer(e) {
                const t1 = e.scope;
                this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._updatedLayers[t1].add(e.id), this.setDirty();
            }
            removeLayer(e) {
                const t1 = e.scope;
                this._removedLayers[t1] = this._removedLayers[t1] || {}, this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._removedLayers[t1][e.id] = e, this._updatedLayers[t1].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();
            }
            getRemovedLayer(e) {
                return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;
            }
            discardLayerRemoval(e) {
                this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];
            }
            getLayerUpdatesByScope() {
                const e = {};
                for(const t1 in this._updatedLayers)e[t1] = e[t1] || {}, e[t1].updatedIds = Array.from(this._updatedLayers[t1].values());
                for(const t1 in this._removedLayers)e[t1] = e[t1] || {}, e[t1].removedIds = Object.keys(this._removedLayers[t1]);
                return e;
            }
            getUpdatedPaintProperties() {
                return this._updatedPaintProps;
            }
            updatePaintProperties(e) {
                this._updatedPaintProps.add(e.fqid), this.setDirty();
            }
            getUpdatedImages(e) {
                return this._updatedImages[e] ? Array.from(this._updatedImages[e].values()) : [];
            }
            updateImage(t1, i) {
                this._updatedImages[i] = this._updatedImages[i] || new Set, this._updatedImages[i].add(e.I.toString(t1)), this.setDirty();
            }
            resetUpdatedImages(e) {
                this._updatedImages[e] && this._updatedImages[e].clear();
            }
            reset() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};
            }
        }
        function $(e) {
            const { userImage: t1 } = e;
            return !!(t1 && t1.render && t1.render()) && (e.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class X extends e.E {
            constructor(t1){
                super(), this.imageProviders = new Map, this.images = new Map, this.updatedImages = new Map, this.callbackDispatchedThisFrame = new Map, this.loaded = new Map, this.requestors = [], this.patterns = new Map, this.patternsInFlight = new Set, this.atlasImage = new Map, this.atlasTexture = new Map, this.dirty = !0, this.spriteFormat = t1, "raster" !== t1 && e.r() && (this.imageRasterizerDispatcher = new e.D(e.t(), this, "Image Rasterizer Worker", 1));
            }
            addScope(t1) {
                this.loaded.set(t1, !1), this.imageProviders.set(t1, new Map), this.images.set(t1, new Map), this.updatedImages.set(t1, new Set), this.callbackDispatchedThisFrame.set(t1, new Set), this.patterns.set(t1, new Map), this.atlasImage.set(t1, new e.q({
                    width: 1,
                    height: 1
                }));
            }
            removeScope(e) {
                this.loaded.delete(e), this.imageProviders.delete(e), this.images.delete(e), this.updatedImages.delete(e), this.callbackDispatchedThisFrame.delete(e), this.patterns.delete(e), this.atlasImage.delete(e);
                const t1 = this.atlasTexture.get(e);
                t1 && (t1.destroy(), this.atlasTexture.delete(e));
            }
            addImageProvider(e, t1) {
                this.imageProviders.has(t1) || this.imageProviders.set(t1, new Map), this.imageProviders.get(t1).set(e.id, e);
            }
            removeImageProvider(e, t1) {
                this.imageProviders.has(t1) && this.imageProviders.get(t1).delete(e);
            }
            getPendingImageProviders() {
                const e = [];
                for (const t1 of this.imageProviders.values())for (const i of t1.values())i.hasPendingRequests() && e.push(i);
                return e;
            }
            get imageRasterizer() {
                return this._imageRasterizer || (this._imageRasterizer = new e.x), this._imageRasterizer;
            }
            isLoaded() {
                for (const e of this.loaded.keys())if (!this.loaded.get(e)) return !1;
                return !0;
            }
            setLoaded(e, t1) {
                if (this.loaded.get(t1) !== e && (this.loaded.set(t1, e), e)) {
                    for (const { ids: e, callback: i } of this.requestors)this._notify(e, t1, i);
                    this.requestors = [];
                }
            }
            hasImage(e, t1) {
                return !!this.getImage(e, t1);
            }
            getImage(e, t1) {
                return this.images.get(t1).get(e.toString());
            }
            addImage(e, t1, i) {
                this._validate(e, i) && this.images.get(t1).set(e.toString(), i);
            }
            _validate(t1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.y(new Error(`Image "${t1.name}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.y(new Error(`Image "${t1.name}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.y(new Error(`Image "${t1.name}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(e, t1) {
                if (!e) return !0;
                let i = 0;
                for (const o of e){
                    if (o[0] < i || o[1] < o[0] || t1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(e, t1) {
                if (!e) return !0;
                if (4 !== e.length) return !1;
                if (!t1.usvg) {
                    if (e[0] < 0 || t1.data.width < e[0]) return !1;
                    if (e[1] < 0 || t1.data.height < e[1]) return !1;
                    if (e[2] < 0 || t1.data.width < e[2]) return !1;
                    if (e[3] < 0 || t1.data.height < e[3]) return !1;
                }
                return !(e[2] < e[0] || e[3] < e[1]);
            }
            updateImage(e, t1, i) {
                const o = this.images.get(t1).get(e.toString());
                i.version = o.version + 1, this.images.get(t1).set(e.toString(), i), this.updatedImages.get(t1).add(e), this.removeFromImageRasterizerCache(e, t1);
            }
            clearUpdatedImages(e) {
                this.updatedImages.get(e).clear();
            }
            removeFromImageRasterizerCache(t1, i) {
                "raster" !== this.spriteFormat && (e.r() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", {
                    imageIds: [
                        t1
                    ],
                    scope: i
                }) : this.imageRasterizer.removeImagesFromCacheByIds([
                    t1
                ], i));
            }
            removeImage(e, t1) {
                const i = this.images.get(t1), o = i.get(e.toString());
                i.delete(e.toString()), this.patterns.get(t1).delete(e.toString()), this.removeFromImageRasterizerCache(e, t1), o.userImage && o.userImage.onRemove && o.userImage.onRemove();
            }
            listImages(t1) {
                return Array.from(this.images.get(t1).keys()).map((t1)=>e.I.from(t1));
            }
            getImages(e, t1, i) {
                const o = [], s = [], r = this.imageProviders.get(t1);
                for (const i of e){
                    if (!i.iconsetId) {
                        o.push(i);
                        continue;
                    }
                    const e = r.get(i.iconsetId);
                    e && (this.getImage(i, t1) ? s.push(i) : e.addPendingRequest(i));
                }
                if (0 === o.length) return void this._notify(s, t1, i);
                let n = !0;
                const a = !!this.loaded.get(t1), l = this.images.get(t1);
                if (!a) for (const e of o)l.has(e.toString()) || (n = !1);
                a || n ? this._notify(o, t1, i) : this.requestors.push({
                    ids: o,
                    scope: t1,
                    callback: i
                });
            }
            rasterizeImages(e, t1) {
                const i = new Map, { tasks: o, scope: s } = e;
                for (const [e, t1] of o.entries()){
                    const o = this.getImage(t1.id, s);
                    o && i.set(e, {
                        image: o,
                        imageVariant: t1
                    });
                }
                this._rasterizeImages(s, i, t1);
            }
            _rasterizeImages(t1, i, o) {
                if (e.r()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", {
                    tasks: i,
                    scope: t1
                }, o);
                else {
                    const e = new Map;
                    for (const [o, { image: s, imageVariant: r }] of i.entries())e.set(o, this.imageRasterizer.rasterize(r, s, t1, 0));
                    o(void 0, e);
                }
            }
            getUpdatedImages(e) {
                return this.updatedImages.get(e) || new Set;
            }
            _notify(t1, i, o) {
                const s = this.images.get(i), r = new Map;
                for (const i of t1){
                    if (!s.get(i.toString())) {
                        if (i.iconsetId) continue;
                        this.fire(new e.z("styleimagemissing", {
                            id: i.name
                        }));
                    }
                    const t1 = s.get(i.toString());
                    if (!t1) {
                        e.w(`Image "${i.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                        continue;
                    }
                    const o = {
                        data: t1.usvg ? null : t1.data.clone(),
                        pixelRatio: t1.pixelRatio,
                        sdf: t1.sdf,
                        usvg: t1.usvg,
                        version: t1.version,
                        stretchX: t1.stretchX,
                        stretchY: t1.stretchY,
                        content: t1.content,
                        hasRenderCallback: Boolean(t1.userImage && t1.userImage.render)
                    };
                    t1.usvg && Object.assign(o, {
                        width: t1.icon.usvg_tree.width,
                        height: t1.icon.usvg_tree.height
                    }), r.set(e.I.toString(i), o);
                }
                o(null, r);
            }
            getPixelSize(e) {
                const { width: t1, height: i } = this.atlasImage.get(e);
                return {
                    width: t1,
                    height: i
                };
            }
            getPattern(t1, i, o) {
                const s = t1.toString(), r = this.patterns.get(i), n = r.get(s), a = this.getImage(t1, i);
                if (!a) return null;
                if (n) {
                    if (n.position.version === a.version) return n.position;
                    n.position.version = a.version;
                } else {
                    if (a.usvg && !a.data) {
                        const r = this.getPatternInFlightId(s, i);
                        if (this.patternsInFlight.has(r)) return null;
                        this.patternsInFlight.add(r);
                        const n = new e.A(t1).scaleSelf(e.o.devicePixelRatio), l = new Map([
                            [
                                n.toString(),
                                {
                                    image: a,
                                    imageVariant: n
                                }
                            ]
                        ]);
                        return this._rasterizeImages(i, l, (e, t1)=>this.storePatternImage(n, i, a, o, t1)), null;
                    }
                    this.storePattern(t1, i, a);
                }
                return this._updatePatternAtlas(i, o), r.get(s).position;
            }
            getPatternInFlightId(t1, i) {
                return e.B(t1, i);
            }
            hasPatternsInFlight() {
                return 0 !== this.patternsInFlight.size;
            }
            storePatternImage(e, t1, i, o, s) {
                const r = e.toString(), n = s ? s.get(r) : void 0;
                n && (i.data = n, this.storePattern(e.id, t1, i), this._updatePatternAtlas(t1, o), this.patternsInFlight.delete(this.getPatternInFlightId(e.id.toString(), t1)));
            }
            storePattern(t1, i, o) {
                const s = {
                    w: o.data.width + 2 * e.C,
                    h: o.data.height + 2 * e.C,
                    x: 0,
                    y: 0
                }, r = new e.F(s, o, e.C);
                this.patterns.get(i).set(t1.toString(), {
                    bin: s,
                    position: r
                });
            }
            destroyAtlasTextures() {
                for (const e of this.atlasTexture.values())e && e.destroy();
                this.atlasTexture.clear();
            }
            bind(t1, i) {
                const o = t1.gl;
                let s = this.atlasTexture.get(i);
                s ? this.dirty && (s.update(this.atlasImage.get(i)), this.dirty = !1) : (s = new e.T(t1, this.atlasImage.get(i), o.RGBA8), this.atlasTexture.set(i, s)), s.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas(t1, i) {
                const o = this.patterns.get(t1), s = Array.from(o.values()).map(({ bin: e })=>e), { w: r, h: n } = e.G(s), a = this.atlasImage.get(t1);
                a.resize({
                    width: r || 1,
                    height: n || 1
                });
                const l = this.images.get(t1);
                for (const [t1, { bin: s, position: r }] of o.entries()){
                    let o = r.padding;
                    const n = s.x + o, c = s.y + o, h = l.get(t1).data, d = h.width, u = h.height;
                    o = o > 1 ? o - 1 : o, e.q.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n,
                        y: c
                    }, {
                        width: d,
                        height: u
                    }, i), e.q.copy(h, a, {
                        x: 0,
                        y: u - o
                    }, {
                        x: n,
                        y: c - o
                    }, {
                        width: d,
                        height: o
                    }, i), e.q.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n,
                        y: c + u
                    }, {
                        width: d,
                        height: o
                    }, i), e.q.copy(h, a, {
                        x: d - o,
                        y: 0
                    }, {
                        x: n - o,
                        y: c
                    }, {
                        width: o,
                        height: u
                    }, i), e.q.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n + d,
                        y: c
                    }, {
                        width: o,
                        height: u
                    }, i), e.q.copy(h, a, {
                        x: d - o,
                        y: u - o
                    }, {
                        x: n - o,
                        y: c - o
                    }, {
                        width: o,
                        height: o
                    }, i), e.q.copy(h, a, {
                        x: 0,
                        y: u - o
                    }, {
                        x: n + d,
                        y: c - o
                    }, {
                        width: o,
                        height: o
                    }, i), e.q.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n + d,
                        y: c + u
                    }, {
                        width: o,
                        height: o
                    }, i), e.q.copy(h, a, {
                        x: d - o,
                        y: 0
                    }, {
                        x: n - o,
                        y: c + u
                    }, {
                        width: o,
                        height: o
                    }, i);
                }
                this.dirty = !0;
            }
            beginFrame() {
                for (const e of this.images.keys())this.callbackDispatchedThisFrame.set(e, new Set);
            }
            dispatchRenderCallbacks(e, t1) {
                const i = this.images.get(t1);
                for (const o of e){
                    if (this.callbackDispatchedThisFrame.get(t1).has(o.toString())) continue;
                    this.callbackDispatchedThisFrame.get(t1).add(o.toString());
                    const e = i.get(o.toString());
                    $(e) && this.updateImage(o, t1, e);
                }
            }
            destroy() {
                this.imageRasterizerDispatcher && this.imageRasterizerDispatcher.remove();
            }
        }
        function Y(t1) {
            const i = t1.value, o = t1.valueSpec, s = t1.style, r = t1.styleSpec, n = t1.key, a = t1.arrayElementValidator || ve;
            if (!Array.isArray(i)) return [
                new e.V(n, i, `array expected, ${e.K(i)} found`)
            ];
            if (o.length && i.length !== o.length) return [
                new e.V(n, i, `array length ${o.length} expected, length ${i.length} found`)
            ];
            if (o["min-length"] && i.length < o["min-length"]) return [
                new e.V(n, i, `array length at least ${o["min-length"]} expected, length ${i.length} found`)
            ];
            let l = {
                type: o.value,
                values: o.values,
                minimum: o.minimum,
                maximum: o.maximum,
                function: void 0
            };
            r.$version < 7 && (l.function = o.function), e.H(o.value) && (l = o.value);
            let c = [];
            for(let e = 0; e < i.length; e++)c = c.concat(a({
                array: i,
                arrayIndex: e,
                value: i[e],
                valueSpec: l,
                style: s,
                styleSpec: r,
                key: `${n}[${e}]`
            }, !0));
            return c;
        }
        function K(t1) {
            const i = t1.key, o = t1.value, s = t1.valueSpec;
            if (!e.L(o)) return [
                new e.V(i, o, `number expected, ${e.K(o)} found`)
            ];
            if (o != o) return [
                new e.V(i, o, "number expected, NaN found")
            ];
            if ("minimum" in s) {
                let r = s.minimum;
                if (Array.isArray(s.minimum) && (r = s.minimum[t1.arrayIndex]), o < r) return [
                    new e.V(i, o, `${o} is less than the minimum value ${r}`)
                ];
            }
            if ("maximum" in s) {
                let r = s.maximum;
                if (Array.isArray(s.maximum) && (r = s.maximum[t1.arrayIndex]), o > r) return [
                    new e.V(i, o, `${o} is greater than the maximum value ${r}`)
                ];
            }
            return [];
        }
        function J(t1) {
            const i = t1.key, o = t1.value;
            if (!e.H(o)) return [
                new e.V(i, o, `object expected, ${e.K(o)} found`)
            ];
            const s = t1.valueSpec, r = e.J(o.type);
            let n, a, l, c = {};
            const h = "categorical" !== r && void 0 === o.property, d = !h, u = function(t1) {
                const i = t1.stops;
                return Array.isArray(i) && Array.isArray(i[0]) && e.H(i[0][0]);
            }(o), _ = ye({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === r) return [
                            new e.V(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let i = [];
                        const o = t1.value;
                        return i = i.concat(Y({
                            key: t1.key,
                            value: o,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: p
                        })), Array.isArray(o) && 0 === o.length && i.push(new e.V(t1.key, o, "array must have at least one stop")), i;
                    },
                    default: function(e) {
                        return ve({
                            key: e.key,
                            value: e.value,
                            valueSpec: s,
                            style: e.style,
                            styleSpec: e.styleSpec
                        });
                    }
                }
            });
            return "identity" === r && h && _.push(new e.V(t1.key, t1.value, 'missing required property "property"')), "identity" === r || o.stops || _.push(new e.V(t1.key, t1.value, 'missing required property "stops"')), "exponential" === r && s.expression && !e.M(s) && _.push(new e.V(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (d && !e.N(s) ? _.push(new e.V(t1.key, t1.value, "property functions not supported")) : h && !e.O(s) && _.push(new e.V(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== o.property || _.push(new e.V(t1.key, t1.value, '"property" property is required')), _;
            //TURBOPACK unreachable
            ;
            function p(t1) {
                let i = [];
                const o = t1.value, r = t1.key;
                if (!Array.isArray(o)) return [
                    new e.V(r, o, `array expected, ${e.K(o)} found`)
                ];
                if (2 !== o.length) return [
                    new e.V(r, o, `array length 2 expected, length ${o.length} found`)
                ];
                if (u) {
                    if (!e.H(o[0])) return [
                        new e.V(r, o, `object expected, ${e.K(o[0])} found`)
                    ];
                    const s = o[0];
                    if (void 0 === s.zoom) return [
                        new e.V(r, o, "object stop key must have zoom")
                    ];
                    if (void 0 === s.value) return [
                        new e.V(r, o, "object stop key must have value")
                    ];
                    const n = e.J(s.zoom);
                    if ("number" != typeof n) return [
                        new e.V(r, s.zoom, "stop zoom values must be numbers")
                    ];
                    if (l && l > n) return [
                        new e.V(r, s.zoom, "stop zoom values must appear in ascending order")
                    ];
                    n !== l && (l = n, a = void 0, c = {}), i = i.concat(ye({
                        key: `${r}[0]`,
                        value: o[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: K,
                            value: f
                        }
                    }));
                } else i = i.concat(f({
                    key: `${r}[0]`,
                    value: o[0],
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, o));
                return e.Q(e.S(o[1])) ? i.concat([
                    new e.V(`${r}[1]`, o[1], "expressions are not allowed in function stops.")
                ]) : i.concat(ve({
                    key: `${r}[1]`,
                    value: o[1],
                    valueSpec: s,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function f(t1, i) {
                const o = e.K(t1.value), l = e.J(t1.value), h = null !== t1.value ? t1.value : i;
                if (n) {
                    if (o !== n) return [
                        new e.V(t1.key, h, `${o} stop domain type must match previous stop domain type ${n}`)
                    ];
                } else n = o;
                if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l) return [
                    new e.V(t1.key, h, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== o && "categorical" !== r) {
                    let i = `number expected, ${o} found`;
                    return e.N(s) && void 0 === r && (i += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new e.V(t1.key, h, i)
                    ];
                }
                return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof a && void 0 !== a && l < a ? [
                    new e.V(t1.key, h, "stop domain values must appear in ascending order")
                ] : (a = l, "categorical" === r && l in c ? [
                    new e.V(t1.key, h, "stop domain values must be unique")
                ] : (c[l] = !0, [])) : [
                    new e.V(t1.key, h, `integer expected, found ${String(l)}`)
                ];
            }
        }
        function Q(t1) {
            const i = ("property" === t1.expressionContext ? e.W : e.U)(e.S(t1.value), t1.valueSpec);
            if ("error" === i.result) return i.value.map((i)=>new e.V(`${t1.key}${i.key}`, t1.value, i.message));
            const o = i.value.expression || i.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !o.outputDefined()) return [
                new e.V(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !e.Z(o)) return [
                new e.V(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext) return ee(o, t1);
            if ("appearance" === t1.expressionContext) return te(o, t1);
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!e.X(o, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new e.V(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !e.Y(o)) return [
                    new e.V(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function ee(t1, i) {
            const o = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters)o.delete(e);
            if (0 === o.size) return [];
            const s = [];
            return t1 instanceof e._ && o.has(t1.name) ? [
                new e.V(i.key, i.value, `["${t1.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)
            ] : (t1.eachChild((e)=>{
                s.push(...ee(e, i));
            }), s);
        }
        function te(t1, i) {
            const o = new Set;
            if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters)o.add(e);
            if (0 === o.size) return [];
            const s = [];
            return t1 instanceof e._ && !o.has(t1.name) ? [
                new e.V(i.key, i.value, `["${t1.name}"] is not an allowed parameter`)
            ] : (t1.eachChild((e)=>{
                s.push(...te(e, i));
            }), s);
        }
        function ie(t1) {
            const i = t1.key, o = t1.value, s = t1.valueSpec, r = [];
            return Array.isArray(s.values) ? -1 === s.values.indexOf(e.J(o)) && r.push(new e.V(i, o, `expected one of [${s.values.join(", ")}], ${JSON.stringify(o)} found`)) : -1 === Object.keys(s.values).indexOf(e.J(o)) && r.push(new e.V(i, o, `expected one of [${Object.keys(s.values).join(", ")}], ${JSON.stringify(o)} found`)), r;
        }
        function oe(t1) {
            return e.a2(e.S(t1.value)) ? Q(Object.assign({}, t1, {
                expressionContext: "filter",
                valueSpec: t1.styleSpec[`filter_${t1.layerType || "fill"}`]
            })) : se(t1);
        }
        function se(t1) {
            const i = t1.value, o = t1.key;
            if (!Array.isArray(i)) return [
                new e.V(o, i, `array expected, ${e.K(i)} found`)
            ];
            if (i.length < 1) return [
                new e.V(o, i, "filter array must have at least 1 element")
            ];
            const s = t1.styleSpec;
            let r = ie({
                key: `${o}[0]`,
                value: i[0],
                valueSpec: s.filter_operator
            });
            const n = ()=>{
                i.length >= 2 && (e.a0(i[1]) || r.push(new e.V(`${o}[1]`, i[1], `string expected, ${e.K(i[1])} found`)));
                for(let t1 = 2; t1 < i.length; t1++)"$type" === e.J(i[1]) ? r = r.concat(ie({
                    key: `${o}[${t1}]`,
                    value: i[t1],
                    valueSpec: s.geometry_type
                })) : e.a0(i[t1]) || e.L(i[t1]) || e.$(i[t1]) || r.push(new e.V(`${o}[${t1}]`, i[t1], `string, number, or boolean expected, ${e.K(i[t1])} found.`));
            };
            switch(e.J(i[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    i.length >= 2 && "$type" === e.J(i[1]) && r.push(new e.V(o, i, `"$type" cannot be use with operator "${i[0]}"`)), 3 !== i.length && r.push(new e.V(o, i, `filter array for operator "${i[0]}" must have 3 elements`)), n();
                    break;
                case "==":
                case "!=":
                    3 !== i.length && r.push(new e.V(o, i, `filter array for operator "${i[0]}" must have 3 elements`)), n();
                    break;
                case "in":
                case "!in":
                    n();
                    break;
                case "any":
                case "all":
                case "none":
                    for(let e = 1; e < i.length; e++)r = r.concat(se({
                        key: `${o}[${e}]`,
                        value: i[e],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    2 !== i.length ? r.push(new e.V(o, i, `filter array for "${i[0]}" operator must have 2 elements`)) : e.a0(i[1]) || r.push(new e.V(`${o}[1]`, i[1], `string expected, ${e.K(i[1])} found`));
            }
            return r;
        }
        function re(t1, i) {
            const o = t1.key, s = t1.style, r = t1.layer, n = t1.styleSpec, a = t1.value, l = t1.objectKey, c = n[`${i}_${t1.layerType}`];
            if (!c) return [];
            const h = l.match(/^(.*)-use-theme$/);
            if (h && c[h[1]]) return e.Q(e.S(a)) ? [].concat(ve({
                key: o,
                value: a,
                valueSpec: {
                    type: "string",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                style: s,
                styleSpec: n,
                expressionContext: "property",
                propertyType: i,
                propertyKey: l
            })) : ve({
                key: o,
                value: a,
                valueSpec: {
                    type: "string"
                },
                style: s,
                styleSpec: n
            });
            const d = l.match(/^(.*)-transition$/);
            if ("paint" === i && d && c[d[1]] && c[d[1]].transition) return ve({
                key: o,
                value: a,
                valueSpec: n.transition,
                style: s,
                styleSpec: n
            });
            const u = t1.valueSpec || c[l];
            if (!u) return [
                new e.a3(o, a, `unknown property "${l}"`)
            ];
            let _;
            if (e.a0(a) && e.N(u) && !u.tokens && (_ = /^{([^}]+)}$/.exec(a))) {
                const t1 = `\`{ "type": "identity", "property": ${_ ? JSON.stringify(_[1]) : '"_"'} }\``;
                return [
                    new e.V(o, a, `"${l}" does not support interpolation syntax\nUse an identity property function instead: ${t1}.`)
                ];
            }
            const p = [];
            if ("symbol" === t1.layerType) "text-field" !== l || !s || s.glyphs || s.imports || p.push(new e.V(o, a, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l && e.a4(e.S(a)) && "identity" === e.J(a.type) && p.push(new e.V(o, a, '"text-font" does not support identity functions'));
            else if ("model" === t1.layerType && "paint" === i && r && r.layout && r.layout.hasOwnProperty("model-id") && e.N(u) && (e.a5(u) || e.O(u))) {
                const t1 = e.W(e.S(a), u).value, i = "expression" in t1 && t1.expression || "_styleExpression" in t1 && t1._styleExpression && t1._styleExpression.expression;
                i && !e.X(i, [
                    "measure-light"
                ]) && ("model-emissive-strength" === l && e.Y(i) && e.Z(i) || p.push(new e.V(o, a, `${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
            }
            return p.concat(ve({
                key: t1.key,
                value: a,
                valueSpec: u,
                style: s,
                styleSpec: n,
                expressionContext: "property",
                propertyType: i,
                propertyKey: l
            }));
        }
        function ne(e) {
            return re(e, "paint");
        }
        function ae(e) {
            return re(e, "layout");
        }
        function le(t1) {
            let i = [];
            const o = t1.value, s = t1.key, r = t1.style, n = t1.styleSpec;
            if (!e.H(o)) return [
                new e.V(s, o, "object expected")
            ];
            o.type || o.ref || i.push(new e.V(s, o, 'either "type" or "ref" is required'));
            let a = e.J(o.type);
            const l = e.J(o.ref);
            if (o.id) {
                const n = e.J(o.id);
                for(let a = 0; a < t1.arrayIndex; a++){
                    const t1 = r.layers[a];
                    e.J(t1.id) === n && i.push(new e.V(s, o.id, `duplicate layer id "${n}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in o) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in o && i.push(new e.V(s, o[t1], `"${t1}" is prohibited for ref layers`));
                }), r.layers.forEach((i)=>{
                    e.J(i.id) === l && (t1 = i);
                }), t1 ? t1.ref ? i.push(new e.V(s, o.ref, "ref cannot reference another ref layer")) : a = e.J(t1.type) : "string" == typeof l && i.push(new e.V(s, o.ref, `ref layer "${l}" not found`));
            } else if ("background" !== a && "sky" !== a && "slot" !== a) if (o.source) if (e.a0(o.source)) {
                const t1 = r.sources && r.sources[o.source], n = t1 && e.J(t1.type);
                t1 ? "vector" === n && "raster" === a ? i.push(new e.V(s, o.source, `layer "${o.id}" requires a raster source`)) : "raster" === n && "raster" !== a ? i.push(new e.V(s, o.source, `layer "${o.id}" requires a vector source`)) : "vector" !== n || o["source-layer"] ? "raster-dem" === n && "hillshade" !== a ? i.push(new e.V(s, o.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n || [
                    "raster",
                    "raster-particle"
                ].includes(a) ? "line" === a && o.paint && (o.paint["line-gradient"] || o.paint["line-trim-offset"]) && "geojson" === n && !t1.lineMetrics ? i.push(new e.V(s, o, `layer "${o.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : "raster-particle" === a && "raster-array" !== n && i.push(new e.V(s, o.source, `layer "${o.id}" requires a 'raster-array' source.`)) : i.push(new e.V(s, o.source, "raster-array source can only be used with layer type 'raster'.")) : i.push(new e.V(s, o, `layer "${o.id}" must specify a "source-layer"`)) : i.push(new e.V(s, o.source, `source "${o.source}" not found`));
            } else i.push(new e.V(`${s}.source`, o.source, '"source" must be a string'));
            else i.push(new e.V(s, o, 'missing required property "source"'));
            return i = i.concat(ye({
                key: s,
                value: o,
                valueSpec: n.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>ve({
                            key: `${s}.type`,
                            value: o.type,
                            valueSpec: n.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: o,
                            objectKey: "type"
                        }),
                    filter: (e)=>oe(Object.assign({
                            layerType: a
                        }, e)),
                    layout: (e)=>ye({
                            layer: o,
                            key: e.key,
                            value: e.value,
                            valueSpec: {},
                            style: e.style,
                            styleSpec: e.styleSpec,
                            objectElementValidators: {
                                "*": (e)=>ae(Object.assign({
                                        layerType: a
                                    }, e))
                            }
                        }),
                    paint: (e)=>ye({
                            layer: o,
                            key: e.key,
                            value: e.value,
                            valueSpec: {},
                            style: e.style,
                            styleSpec: e.styleSpec,
                            objectElementValidators: {
                                "*": (e)=>ne(Object.assign({
                                        layerType: a,
                                        layer: o
                                    }, e))
                            }
                        }),
                    appearances (t1) {
                        const i = Y({
                            key: t1.key,
                            value: t1.value,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: (t1)=>(function(t1) {
                                    const { key: i, layer: o, layerType: s } = t1, r = e.J(t1.value), n = e.J(r.name), a = e.J(r.condition), l = ye({
                                        key: i,
                                        value: r,
                                        valueSpec: t1.styleSpec.appearance,
                                        style: t1.style,
                                        styleSpec: t1.styleSpec,
                                        objectElementValidators: {
                                            condition: (t1)=>(function(t1) {
                                                    const i = [];
                                                    return i.push(...Q({
                                                        key: t1.key,
                                                        value: t1.object.condition,
                                                        valueSpec: e.a6.appearance.condition,
                                                        expressionContext: "appearance"
                                                    })), i;
                                                })(Object.assign({
                                                    layer: o,
                                                    layerType: s
                                                }, t1)),
                                            properties: (t1)=>(function(t1) {
                                                    const i = [], { styleSpec: o, layer: s, layerType: r } = t1, n = o[`paint_${r}`], a = o[`layout_${r}`], l = t1.object[t1.objectKey];
                                                    for(const o in l){
                                                        const c = o in n ? "paint" : o in a ? "layout" : void 0;
                                                        if (!c) {
                                                            i.push(new e.V(t1.key, o, `unknown property "${o}" for layer type "${r}"`));
                                                            continue;
                                                        }
                                                        const h = Object.assign({}, t1, {
                                                            key: `${t1.key}.${o}`,
                                                            object: l,
                                                            objectKey: o,
                                                            layer: s,
                                                            layerType: r,
                                                            value: l[o],
                                                            valueSpec: "paint" === c ? n[o] : a[o]
                                                        });
                                                        i.push(...re(h, c));
                                                    }
                                                    return i;
                                                })(Object.assign({
                                                    layer: o,
                                                    layerType: s
                                                }, t1))
                                        }
                                    });
                                    return "hidden" !== n && void 0 === a && l.push(new e.V(t1.key, "name", 'Appearance with name different than "hidden" must have a condition')), l;
                                })(Object.assign({
                                    layerType: a,
                                    layer: o
                                }, t1))
                        }), s = Array.isArray(t1.value) ? t1.value : [], r = new Set;
                        return s.forEach((s, n)=>{
                            const a = e.J(s.name);
                            if (a) if (r.has(a)) {
                                const s = e.J(o.id);
                                i.push(new e.V(t1.key, a, `Duplicated appearance name "${a}" for layer "${s}"`));
                            } else r.add(a);
                        }), i;
                    }
                }
            })), i;
        }
        function ce({ key: t1, value: i }) {
            return e.a0(i) ? [] : [
                new e.V(t1, i, `string expected, ${e.K(i)} found`)
            ];
        }
        const he = {
            promoteId: function t1({ key: i, value: o }) {
                if (e.a0(o)) return ce({
                    key: i,
                    value: o
                });
                if (Array.isArray(o)) {
                    const t1 = [], s = e.S(o), r = e.U(s);
                    return "error" === r.result && r.value.forEach((o)=>{
                        t1.push(new e.V(`${i}${o.key}`, null, `${o.message}`));
                    }), e.X(r.value.expression, [
                        "zoom",
                        "heatmap-density",
                        "line-progress",
                        "raster-value",
                        "sky-radial-progress",
                        "accumulated",
                        "is-supported-script",
                        "pitch",
                        "distance-from-center",
                        "measure-light",
                        "raster-particle-speed"
                    ]) || t1.push(new e.V(`${i}`, null, "promoteId expression should be only feature dependent")), t1;
                }
                if (!e.H(o)) return [
                    new e.V(i, o, `string, expression or object expected, "${e.K(o)}" found`)
                ];
                const s = [];
                for(const e in o)s.push(...t1({
                    key: `${i}.${e}`,
                    value: o[e]
                }));
                return s;
            }
        };
        function de(t1) {
            const i = t1.value, o = t1.key, s = t1.styleSpec, r = t1.style;
            if (!e.H(i)) return [
                new e.V(o, i, `object expected, ${e.K(i)} found`)
            ];
            if (!("type" in i)) return [
                new e.V(o, i, '"type" is required')
            ];
            const n = e.J(i.type);
            let a = [];
            switch([
                "vector",
                "raster",
                "raster-dem",
                "raster-array"
            ].includes(n) && ("url" in i || "tiles" in i || a.push(new e.a3(o, i, 'Either "url" or "tiles" is required.'))), n){
                case "vector":
                case "raster":
                case "raster-dem":
                case "raster-array":
                    return a = a.concat(ye({
                        key: o,
                        value: i,
                        valueSpec: s[`source_${n.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: s,
                        objectElementValidators: he
                    })), a;
                case "geojson":
                    if (a = ye({
                        key: o,
                        value: i,
                        valueSpec: s.source_geojson,
                        style: r,
                        styleSpec: s,
                        objectElementValidators: he
                    }), "cluster" in i && "clusterProperties" in i) {
                        if (!e.H(i.clusterProperties)) return [
                            new e.V(`${o}.clusterProperties`, i, `object expected, ${e.K(i)} found`)
                        ];
                        for(const t1 in i.clusterProperties){
                            const s = i.clusterProperties[t1];
                            if (!Array.isArray(s)) return [
                                new e.V(`${o}.clusterProperties.${t1}`, s, "array expected")
                            ];
                            const [r, n] = s, l = "string" == typeof r ? [
                                r,
                                [
                                    "accumulated"
                                ],
                                [
                                    "get",
                                    t1
                                ]
                            ] : r;
                            a.push(...Q({
                                key: `${o}.${t1}.map`,
                                value: n,
                                expressionContext: "cluster-map"
                            })), a.push(...Q({
                                key: `${o}.${t1}.reduce`,
                                value: l,
                                expressionContext: "cluster-reduce"
                            }));
                        }
                    }
                    return a;
                case "video":
                    return ye({
                        key: o,
                        value: i,
                        valueSpec: s.source_video,
                        style: r,
                        styleSpec: s
                    });
                case "image":
                    return ye({
                        key: o,
                        value: i,
                        valueSpec: s.source_image,
                        style: r,
                        styleSpec: s
                    });
                case "canvas":
                    return [
                        new e.V(o, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return ie({
                        key: `${o}.type`,
                        value: i.type,
                        valueSpec: {
                            values: ue(s)
                        }
                    });
            }
        }
        function ue(e) {
            return e.source.reduce((t1, i)=>{
                const o = e[i];
                return "enum" === o.type.type && (t1 = t1.concat(Object.keys(o.type.values || {}))), t1;
            }, []);
        }
        function _e(t1) {
            const i = t1.value, o = t1.styleSpec, s = o.light, r = t1.style;
            if (void 0 === i) return [];
            if (!e.H(i)) return [
                new e.V("light", i, `object expected, ${e.K(i)} found`)
            ];
            let n = [];
            for(const t1 in i){
                const a = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                n = n.concat(l && s[l[1]] ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: r,
                    styleSpec: o
                }) : a && s[a[1]] && s[a[1]].transition ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: o.transition,
                    style: r,
                    styleSpec: o
                }) : s[t1] ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: s[t1],
                    style: r,
                    styleSpec: o
                }) : [
                    new e.V(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return n;
        }
        function pe(t1) {
            const i = t1.value;
            if (!i) return [];
            const o = t1.key;
            if (!e.H(i)) return [
                new e.V(o, i, `object expected, ${e.K(i)} found`)
            ];
            let s = [];
            const r = t1.styleSpec, n = r["light-3d"], a = t1.style, l = t1.style.lights;
            for (const t1 of [
                "type",
                "id"
            ])if (!(t1 in i)) return s = s.concat([
                new e.V(o, i, `missing property "${t1}"`)
            ]), s;
            if (!e.a0(i.type)) return s = s.concat([
                new e.V(`${o}.type`, i.type, "string expected")
            ]), s;
            if (l) for(let r = 0; r < t1.arrayIndex; r++){
                const t1 = e.J(i.type), n = l[r];
                e.J(n.type) === t1 && s.push(new e.V(o, i.id, `duplicate light type "${i.type}", previously defined at line ${n.id.__line__}`));
            }
            const c = `properties_light_${i.type}`;
            if (!(c in r)) return s = s.concat([
                new e.V(`${o}.type`, i, `Invalid light type ${i.type}`)
            ]), s;
            const h = r[c];
            for(const o in i)if ("properties" === o) {
                const n = i[o];
                if (!e.H(n)) return s = s.concat([
                    new e.V("properties", n, `object expected, ${e.K(n)} found`)
                ]), s;
                for(const l in n){
                    const c = l.match(/^(.*)-transition$/), d = l.match(/^(.*)-use-theme$/);
                    s = s.concat(d && h[d[1]] ? ve({
                        key: o,
                        value: n[l],
                        valueSpec: {
                            type: "string"
                        },
                        style: a,
                        styleSpec: r
                    }) : c && h[c[1]] && h[c[1]].transition ? ve({
                        key: o,
                        value: i[o],
                        valueSpec: r.transition,
                        style: a,
                        styleSpec: r
                    }) : h[l] ? ve({
                        key: l,
                        value: n[l],
                        valueSpec: h[l],
                        style: a,
                        styleSpec: r
                    }) : [
                        new e.a3(t1.key, n[l], `unknown property "${l}"`)
                    ]);
                }
            } else s = s.concat(n[o] ? ve({
                key: o,
                value: i[o],
                valueSpec: n[o],
                style: a,
                styleSpec: r
            }) : [
                new e.a3(o, i[o], `unknown property "${o}"`)
            ]);
            return s;
        }
        function fe(t1) {
            const i = t1.value, o = t1.key, s = t1.style, r = t1.styleSpec, n = r.terrain;
            if (null == i) return [];
            if (!e.H(i)) return [
                new e.V("terrain", i, `object expected, ${e.K(i)} found`)
            ];
            let a = [];
            for(const t1 in i){
                const o = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                a = a.concat(l && n[l[1]] ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: s,
                    styleSpec: r
                }) : o && n[o[1]] && n[o[1]].transition ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: r.transition,
                    style: s,
                    styleSpec: r
                }) : n[t1] ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: n[t1],
                    style: s,
                    styleSpec: r
                }) : [
                    new e.a3(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            if (i.source) if (e.a0(i.source)) {
                const t1 = s.sources && s.sources[i.source], r = t1 && e.J(t1.type);
                t1 ? "raster-dem" !== r && a.push(new e.V(`${o}.source`, i.source, `terrain cannot be used with a source of type ${r}, it only be used with a "raster-dem" source type`)) : a.push(new e.V(`${o}.source`, i.source, `source "${i.source}" not found`));
            } else a.push(new e.V(`${o}.source`, i.source, "source must be a string"));
            else a.push(new e.V(o, i, 'terrain is missing required property "source"'));
            return a;
        }
        function me(t1) {
            const i = t1.value, o = t1.style, s = t1.styleSpec, r = s.fog;
            if (void 0 === i) return [];
            if (!e.H(i)) return [
                new e.V("fog", i, `object expected, ${e.K(i)} found`)
            ];
            let n = [];
            for(const t1 in i){
                const a = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                n = n.concat(l && r[l[1]] ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: o,
                    styleSpec: s
                }) : a && r[a[1]] && r[a[1]].transition ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: s.transition,
                    style: o,
                    styleSpec: s
                }) : r[t1] ? ve({
                    key: t1,
                    value: i[t1],
                    valueSpec: r[t1],
                    style: o,
                    styleSpec: s
                }) : [
                    new e.a3(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return n;
        }
        const ge = {
            "*": ()=>[],
            array: Y,
            boolean: function(t1) {
                const i = t1.value, o = t1.key;
                return e.$(i) ? [] : [
                    new e.V(o, i, `boolean expected, ${e.K(i)} found`)
                ];
            },
            number: K,
            color: function({ key: t1, value: i }) {
                return e.a0(i) ? null === e.a1.parseCSSColor(i) ? [
                    new e.V(t1, i, `color expected, "${i}" found`)
                ] : [] : [
                    new e.V(t1, i, `color expected, ${e.K(i)} found`)
                ];
            },
            enum: ie,
            filter: oe,
            function: J,
            layer: le,
            object: ye,
            source: de,
            model: e.a7,
            light: _e,
            "light-3d": pe,
            terrain: fe,
            fog: me,
            string: ce,
            formatted: function(e) {
                return 0 === ce(e).length ? [] : Q(e);
            },
            resolvedImage: function(e) {
                return 0 === ce(e).length ? [] : Q(e);
            },
            projection: function(t1) {
                const i = t1.value, o = t1.styleSpec, s = o.projection, r = t1.style;
                if (e.H(i)) {
                    let e = [];
                    for(const t1 in i)e = e.concat(ve({
                        key: t1,
                        value: i[t1],
                        valueSpec: s[t1],
                        style: r,
                        styleSpec: o
                    }));
                    return e;
                }
                return e.a0(i) ? [] : [
                    new e.V("projection", i, `object or string expected, ${e.K(i)} found`)
                ];
            },
            import: function(t1) {
                const i = t1.key, { value: o, styleSpec: s } = t1;
                if (!e.H(o)) return [
                    new e.V(i, o, "import must be an object")
                ];
                const { data: r, ...n } = o;
                Object.defineProperty(n, "__line__", {
                    value: o.__line__,
                    enumerable: !1
                });
                let a = ye(Object.assign({}, t1, {
                    value: n,
                    valueSpec: s.import
                }));
                return "" === e.J(n.id) && a.push(new e.V(`${t1.key}.id`, n, "import id can't be an empty string")), r && (a = a.concat(be(r, s, {
                    key: `${t1.key}.data`
                }))), a;
            },
            iconset: function(t1) {
                const i = t1.value, o = t1.key, s = t1.styleSpec, r = t1.style;
                if (!e.H(i)) return [
                    new e.V(o, i, "object expected")
                ];
                if (!i.type) return [
                    new e.V(o, i, '"type" is required')
                ];
                const n = e.J(i.type);
                let a = [];
                if (a = a.concat(ye({
                    key: o,
                    value: i,
                    valueSpec: s[`iconset_${n}`],
                    style: r,
                    styleSpec: s
                })), function(e, t1) {
                    return !("source" !== e || !t1.source);
                }(n, i)) {
                    const t1 = r.sources && r.sources[i.source], s = t1 && e.J(t1.type);
                    t1 ? "raster-array" !== s && a.push(new e.V(o, i.source, `iconset cannot be used with a source of type ${String(s)}, it only be used with a "raster-array" source type`)) : a.push(new e.V(o, i.source, `source "${i.source}" not found`));
                }
                return a;
            }
        };
        function ve(t1, i = !1) {
            const o = t1.value, s = t1.valueSpec, r = t1.styleSpec;
            if (s.expression) {
                if (e.a4(e.J(o))) return J(t1);
                if (e.Q(e.S(o))) return Q(t1);
            }
            if (s.type && ge[s.type]) {
                const e = ge[s.type](t1);
                return !0 === i && e.length > 0 && Array.isArray(t1.value) ? Q(t1) : e;
            }
            return ye(Object.assign({}, t1, {
                valueSpec: s.type ? r[s.type] : s
            }));
        }
        function ye(t1) {
            const i = t1.key, o = t1.value, s = t1.valueSpec || {}, r = t1.objectElementValidators || {}, n = t1.style, a = t1.styleSpec;
            if (!e.H(o)) return [
                new e.V(i, o, `object expected, ${e.K(o)} found`)
            ];
            let l = [];
            for(const t1 in o){
                const c = t1.split(".")[0];
                let h;
                r[c] ? h = r[c] : s[c] ? h = ve : r["*"] ? h = r["*"] : s["*"] && (h = ve), h ? l = l.concat(h({
                    key: (i ? `${i}.` : i) + t1,
                    value: o[t1],
                    valueSpec: s[c] || s["*"],
                    style: n,
                    styleSpec: a,
                    object: o,
                    objectKey: t1
                }, o)) : l.push(new e.a3(i, o[t1], `unknown property "${t1}"`));
            }
            for(const t1 in s){
                if (r[t1]) continue;
                const n = s[t1];
                n.required && void 0 === n.default && void 0 === o[t1] && l.push(new e.V(i, o, `missing required property "${t1}"`));
            }
            return l;
        }
        function xe({ key: t1, value: i }) {
            const o = ce({
                key: t1,
                value: i
            });
            if (o.length) return o;
            const s = i;
            return -1 === s.indexOf("{fontstack}") && o.push(new e.V(t1, i, '"glyphs" url must include a "{fontstack}" token')), -1 === s.indexOf("{range}") && o.push(new e.V(t1, i, '"glyphs" url must include a "{range}" token')), o;
        }
        function be(t1, i = e.a6, o = {}) {
            return ye({
                key: o.key || "",
                value: t1,
                valueSpec: Object.assign(i.$root, {
                    "*": {
                        type: "*"
                    }
                }),
                styleSpec: i,
                style: t1,
                objectElementValidators: {
                    glyphs: xe
                }
            });
        }
        function we(t1, i = e.a6) {
            return Me(be(t1, i));
        }
        const Te = (e)=>Me(de(e)), Ee = (e)=>Me(_e(e)), Se = (e)=>Me(pe(e)), Ie = (e)=>Me(fe(e)), Ce = (e)=>Me(me(e)), Re = (t1)=>Me(function(t1) {
                const i = t1.value, o = t1.style, s = t1.styleSpec, r = s.snow;
                if (void 0 === i) return [];
                if (!e.H(i)) return [
                    new e.V("snow", i, `object expected, ${e.K(i)} found`)
                ];
                let n = [];
                for(const t1 in i){
                    const a = t1.match(/^(.*)-transition$/);
                    n = n.concat(a && r[a[1]] && r[a[1]].transition ? ve({
                        key: t1,
                        value: i[t1],
                        valueSpec: s.transition,
                        style: o,
                        styleSpec: s
                    }) : r[t1] ? ve({
                        key: t1,
                        value: i[t1],
                        valueSpec: r[t1],
                        style: o,
                        styleSpec: s
                    }) : [
                        new e.a3(t1, i[t1], `unknown property "${t1}"`)
                    ]);
                }
                return n;
            }(t1)), Ae = (t1)=>Me(function(t1) {
                const i = t1.value, o = t1.style, s = t1.styleSpec, r = s.rain;
                if (void 0 === i) return [];
                if (!e.H(i)) return [
                    new e.V("rain", i, `object expected, ${e.K(i)} found`)
                ];
                let n = [];
                for(const t1 in i){
                    const a = t1.match(/^(.*)-transition$/);
                    n = n.concat(a && r[a[1]] && r[a[1]].transition ? ve({
                        key: t1,
                        value: i[t1],
                        valueSpec: s.transition,
                        style: o,
                        styleSpec: s
                    }) : r[t1] ? ve({
                        key: t1,
                        value: i[t1],
                        valueSpec: r[t1],
                        style: o,
                        styleSpec: s
                    }) : [
                        new e.a3(t1, i[t1], `unknown property "${t1}"`)
                    ]);
                }
                return n;
            }(t1)), Le = (e)=>Me(le(e)), De = (e)=>Me(oe(e)), Pe = (e)=>Me(ne(e)), Oe = (e)=>Me(ae(e)), ze = (t1)=>Me(e.a7(t1));
        function Me(e) {
            return e.slice().sort((e, t1)=>e.line && t1.line ? e.line - t1.line : 0);
        }
        function Fe(t1, i) {
            let o = !1;
            if (i && i.length) for (const s of i)s instanceof e.a3 ? e.w(s.message) : (t1.fire(new e.y(new Error(s.message))), o = !0);
            return o;
        }
        const Be = e.a6.light;
        let ke;
        class Ne extends e.E {
            constructor(t1, i = "flat"){
                super(), this._transitionable = new e.a8(ke || (ke = new e.a9({
                    anchor: new e.aa(Be.anchor),
                    position: new e.ab(Be.position),
                    color: new e.aa(Be.color),
                    intensity: new e.aa(Be.intensity)
                }))), this.setLight(t1, i), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(e, t1, i = {}) {
                this._validate(Ee, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Fe(this, t1.call(we, Object.assign({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a6
                })));
            }
        }
        const Ue = e.a6.terrain;
        let je = class extends e.E {
            constructor(t1, i, o, s, r){
                super(), this.scope = o, this._transitionable = new e.a8(new e.a9({
                    source: new e.aa(Ue.source),
                    exaggeration: new e.aa(Ue.exaggeration)
                }), o, s), this._transitionable.setTransitionOrValue(t1, s), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i, this.worldview = r;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(e, t1) {
                this._transitionable.setTransitionOrValue(e, t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            getExaggeration(t1) {
                return this._transitioning.possiblyEvaluate(new e.ac(t1, {
                    worldview: this.worldview
                })).get("exaggeration");
            }
            getAttenuationRange() {
                if (!this.isZoomDependent()) return null;
                const t1 = this._transitionable._values.exaggeration;
                if (!t1) return null;
                const i = t1.value.expression;
                if (!i) return null;
                let o = -1, s = -1, r = 1;
                for (const t1 of i.zoomStops)r = i.evaluate(new e.ac(t1, {
                    worldview: this.worldview
                })), r > .01 ? (o = t1, s = -1) : s = t1;
                return r < .01 && o > 0 && s > o ? [
                    o,
                    s
                ] : null;
            }
            isZoomDependent() {
                const t1 = this._transitionable._values.exaggeration;
                return null != t1 && null != t1.value && null != t1.value.expression && t1.value.expression instanceof e.ad;
            }
        };
        const Ve = .05;
        function Ge(t1, i, o, s) {
            const r = e.ah(45, 65, o), [n, a] = He(t1, s);
            let l = 1 - Math.min(1, Math.exp((i - n) / (a - n) * -6));
            return l *= l * l, l = Math.min(1, 1.00747 * l), l * r * t1.alpha;
        }
        function He(e, t1) {
            const i = .5 / Math.tan(.5 * t1);
            return [
                e.range[0] + i,
                e.range[1] + i
            ];
        }
        function qe(t1, i, o, s, r) {
            const n = e.af([], [
                i,
                o,
                s
            ], r.mercatorFogMatrix);
            return Ge(t1, e.ag(n), r.pitch, r._fov);
        }
        function Ze(t1, i, o, s, r, n, a) {
            const l = [
                [
                    o,
                    s,
                    0
                ],
                [
                    r,
                    s,
                    0
                ],
                [
                    r,
                    n,
                    0
                ],
                [
                    o,
                    n,
                    0
                ]
            ];
            let c = Number.MAX_VALUE, h = -Number.MAX_VALUE;
            for (const t1 of l){
                const o = e.af([], t1, i), s = e.ag(o);
                c = Math.min(c, s), h = Math.max(h, s);
            }
            return [
                Ge(t1, c, a.pitch, a._fov),
                Ge(t1, h, a.pitch, a._fov)
            ];
        }
        const We = e.a6.fog;
        class $e extends e.E {
            constructor(t1, i, o, s){
                super();
                const r = new e.a9({
                    range: new e.aa(We.range),
                    color: new e.aa(We.color),
                    "color-use-theme": new e.aa({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "high-color": new e.aa(We["high-color"]),
                    "high-color-use-theme": new e.aa({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "space-color": new e.aa(We["space-color"]),
                    "space-color-use-theme": new e.aa({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "horizon-blend": new e.aa(We["horizon-blend"]),
                    "star-intensity": new e.aa(We["star-intensity"]),
                    "vertical-range": new e.aa(We["vertical-range"])
                });
                this._transitionable = new e.a8(r, o, new Map(s)), this.set(t1, s), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.ai(r), this.scope = o;
            }
            get state() {
                const t1 = this._transform, i = "globe" === t1.projection.name, o = e.aj(t1.zoom), s = this.properties.get("range"), r = [
                    .5,
                    3
                ];
                return {
                    range: i ? [
                        e.ak(r[0], s[0], o),
                        e.ak(r[1], s[1], o)
                    ] : s,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(e, t1, i = {}) {
                if (this._validate(Ce, e, i)) return;
                const o = Object.assign({}, e);
                for (const e of Object.keys(We))void 0 === o[e] && (o[e] = We[e].default);
                this._options = o, this._transitionable.setTransitionOrValue(this._options, t1);
            }
            getOpacity(t1) {
                if (!this._transform.projection.supportsFog) return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e.ah(45, 65, t1)) * i.a;
            }
            getOpacityAtLatLng(t1, i) {
                return this._transform.projection.supportsFog ? function(t1, i, o) {
                    const s = e.ae.fromLngLat(i), r = o.elevation ? o.elevation.getAtPointOrZero(s) : 0;
                    return qe(t1, s.x, s.y, r, o);
                }(this.state, t1, i) : 0;
            }
            getOpacityForTile(t1) {
                if (!this._transform.projection.supportsFog) return [
                    1,
                    1
                ];
                const i = this._transform.calculateFogTileMatrix(t1.toUnwrapped());
                return Ze(this.state, i, 0, 0, e.al, e.al, this._transform);
            }
            getOpacityForBounds(e, t1, i, o, s) {
                return this._transform.projection.supportsFog ? Ze(this.state, e, t1, i, o, s, this._transform) : [
                    1,
                    1
                ];
            }
            getFovAdjustedRange(e) {
                return this._transform.projection.supportsFog ? He(this.state, e) : [
                    0,
                    1
                ];
            }
            isVisibleOnFrustum(t1) {
                if (!this._transform.projection.supportsFog) return !1;
                const i = [
                    4,
                    5,
                    6,
                    7
                ];
                for (const o of i){
                    const i = t1.points[o];
                    let s;
                    if (i[2] >= 0) s = i;
                    else {
                        const r = t1.points[o - 4];
                        s = e.am(r, i, r[2] / (r[2] - i[2]));
                    }
                    if (qe(this.state, s[0], s[1], 0, this._transform) >= Ve) return !0;
                }
                return !1;
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Fe(this, t1.call(we, Object.assign({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a6
                })));
            }
        }
        let Xe, Ye, Ke, Je = class extends e.E {
            constructor(t1, i, o, s){
                super();
                const r = Xe || (Xe = new e.a9({
                    density: new e.aa(e.a6.snow.density),
                    intensity: new e.aa(e.a6.snow.intensity),
                    color: new e.aa(e.a6.snow.color),
                    opacity: new e.aa(e.a6.snow.opacity),
                    vignette: new e.aa(e.a6.snow.vignette),
                    "vignette-color": new e.aa(e.a6.snow["vignette-color"]),
                    "center-thinning": new e.aa(e.a6.snow["center-thinning"]),
                    direction: new e.aa(e.a6.snow.direction),
                    "flake-size": new e.aa(e.a6.snow["flake-size"])
                }));
                this._transitionable = new e.a8(r, o, new Map(s)), this.set(t1, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r), this.scope = o;
            }
            get state() {
                const t1 = this.properties.get("opacity"), i = this.properties.get("color"), o = this.properties.get("direction"), s = e.an(o[0]), r = -Math.max(e.an(o[1]), .01), n = [
                    Math.cos(s) * Math.cos(r),
                    Math.sin(s) * Math.cos(r),
                    Math.sin(r)
                ], a = this.properties.get("vignette"), l = this.properties.get("vignette-color");
                return l.a = a, {
                    density: this.properties.get("density"),
                    intensity: this.properties.get("intensity"),
                    color: new e.ao(i.r, i.g, i.b, i.a * t1),
                    direction: n,
                    centerThinning: this.properties.get("center-thinning"),
                    flakeSize: this.properties.get("flake-size"),
                    vignetteColor: l
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(Re, t1, o)) return;
                const s = Object.assign({}, t1), r = e.a6.snow;
                for (const e of Object.keys(r))void 0 === s[e] && (s[e] = r[e].default);
                this._options = s, this._transitionable.setTransitionOrValue(this._options, i);
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Fe(this, t1.call(we, Object.assign({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a6
                })));
            }
        }, Qe = class extends e.E {
            constructor(t1, i, o, s){
                super();
                const r = Ye || (Ye = new e.a9({
                    density: new e.aa(e.a6.rain.density),
                    intensity: new e.aa(e.a6.rain.intensity),
                    color: new e.aa(e.a6.rain.color),
                    opacity: new e.aa(e.a6.rain.opacity),
                    vignette: new e.aa(e.a6.rain.vignette),
                    "vignette-color": new e.aa(e.a6.rain["vignette-color"]),
                    "center-thinning": new e.aa(e.a6.rain["center-thinning"]),
                    direction: new e.aa(e.a6.rain.direction),
                    "droplet-size": new e.aa(e.a6.rain["droplet-size"]),
                    "distortion-strength": new e.aa(e.a6.rain["distortion-strength"])
                }));
                this._transitionable = new e.a8(r, o, new Map(s)), this.set(t1, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r), this.scope = o;
            }
            get state() {
                const t1 = this.properties.get("opacity"), i = this.properties.get("color"), o = this.properties.get("direction"), s = e.an(o[0]), r = -Math.max(e.an(o[1]), .01), n = [
                    Math.cos(s) * Math.cos(r),
                    Math.sin(s) * Math.cos(r),
                    Math.sin(r)
                ], a = this.properties.get("vignette-color");
                return a.a = this.properties.get("vignette"), {
                    density: this.properties.get("density"),
                    intensity: this.properties.get("intensity"),
                    color: new e.ao(i.r, i.g, i.b, i.a * t1),
                    direction: n,
                    centerThinning: this.properties.get("center-thinning"),
                    dropletSize: this.properties.get("droplet-size"),
                    distortionStrength: this.properties.get("distortion-strength"),
                    vignetteColor: a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(Ae, t1, o)) return;
                const s = Object.assign({}, t1), r = e.a6.rain;
                for (const e of Object.keys(r))void 0 === s[e] && (s[e] = r[e].default);
                this._options = s, this._transitionable.setTransitionOrValue(this._options, i);
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Fe(this, t1.call(we, Object.assign({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a6
                })));
            }
        };
        class et extends e.E {
            constructor(t1, i, o, s){
                super(), this.scope = o, this._options = t1, this.properties = new e.ai(i), this._transitionable = new e.a8(i, o, new Map(s)), this._transitionable.setTransitionOrValue(t1.properties), this._transitioning = this._transitionable.untransitioned();
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            get() {
                return this._options.properties = this._transitionable.serialize(), this._options;
            }
            set(e, t1) {
                this._options = e, this._transitionable.setTransitionOrValue(e.properties, t1);
            }
            shadowsEnabled() {
                return !!this.properties && !0 === this.properties.get("cast-shadows");
            }
        }
        const tt = ()=>Ke || (Ke = new e.a9({
                color: new e.aa(e.a6.properties_light_ambient.color),
                "color-use-theme": new e.aa({
                    type: "string",
                    default: "default",
                    "property-type": "data-constant"
                }),
                intensity: new e.aa(e.a6.properties_light_ambient.intensity)
            }));
        let it;
        const ot = ()=>it || (it = new e.a9({
                direction: new e.ap(e.a6.properties_light_directional.direction),
                color: new e.aa(e.a6.properties_light_directional.color),
                "color-use-theme": new e.aa({
                    type: "string",
                    default: "default",
                    "property-type": "data-constant"
                }),
                intensity: new e.aa(e.a6.properties_light_directional.intensity),
                "cast-shadows": new e.aa(e.a6.properties_light_directional["cast-shadows"]),
                "shadow-quality": new e.aa(e.a6.properties_light_directional["shadow-quality"]),
                "shadow-intensity": new e.aa(e.a6.properties_light_directional["shadow-intensity"]),
                "shadow-draw-before-layer": new e.aa(e.a6.properties_light_directional["shadow-draw-before-layer"])
            }));
        class st {
            constructor(e, t1, i){
                this.screenBounds = e, this.cameraPoint = i.getCameraPoint(), this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = t1, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, i);
            }
            static createFromScreenPoints(t1, i) {
                let o, s;
                if (t1 instanceof e.P || "number" == typeof t1[0]) {
                    const r = e.P.convert(t1);
                    o = [
                        r
                    ], s = i.isPointAboveHorizon(r);
                } else {
                    const r = e.P.convert(t1[0]), n = e.P.convert(t1[1]), a = r.add(n)._div(2);
                    o = [
                        r,
                        n
                    ], s = e.aq(r, n).every((e)=>i.isPointAboveHorizon(e)) && i.isPointAboveHorizon(a);
                }
                return new st(o, s, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t1) {
                return e.aq(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t1);
            }
            bufferedCameraGeometry(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s = e.aq(i, o, 0, !1);
                return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? s.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? s[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (s[3] = this.cameraPoint)), e.ar(s, t1);
            }
            bufferedCameraGeometryGlobe(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s = e.aq(i, o, t1), r = this.cameraPoint.clone();
                switch(3 * ((r.y > i.y) + (r.y > o.y)) + ((r.x > i.x) + (r.x > o.x))){
                    case 0:
                        s[0] = r, s[4] = r.clone();
                        break;
                    case 1:
                        s.splice(1, 0, r);
                        break;
                    case 2:
                        s[1] = r;
                        break;
                    case 3:
                        s.splice(4, 0, r);
                        break;
                    case 5:
                        s.splice(2, 0, r);
                        break;
                    case 6:
                        s[3] = r;
                        break;
                    case 7:
                        s.splice(3, 0, r);
                        break;
                    case 8:
                        s[2] = r;
                }
                return s;
            }
            containsTile(t1, i, o, s = 0) {
                const r = Math.max(t1.queryPadding, t1.evaluateQueryRenderedFeaturePadding()) / i._pixelsPerMercatorPixel + 1, n = o ? this._bufferedCameraMercator(r, i) : this._bufferedScreenMercator(r, i);
                let a = t1.tileID.wrap + (n.unwrapped ? s : 0);
                const l = n.polygon.map((i)=>e.as(t1.tileTransform, i, a));
                if (!e.at(l, 0, 0, e.al, e.al)) return;
                a = t1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s : 0);
                const c = this.screenGeometryMercator.polygon.map((i)=>e.au(t1.tileTransform, i, a)), h = c.map((t1)=>new e.P(t1[0], t1[1])), d = i.getFreeCameraOptions().position || new e.ae(0, 0, 0), u = e.au(t1.tileTransform, d, a), _ = c.map((t1)=>{
                    const i = e.av(t1, t1, u);
                    return e.aw(i, i), new e.ax(u, i);
                }), p = e.ay(t1, 1, i.zoom) * i._pixelsPerMercatorPixel;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: _,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (f = e.az(l), f.min.x = e.aA(f.min.x, 0, e.al), f.min.y = e.aA(f.min.y, 0, e.al), f.max.x = e.aA(f.max.x, 0, e.al), f.max.y = e.aA(f.max.y, 0, e.al), f),
                    tile: t1,
                    tileID: t1.tileID,
                    pixelToTileUnitsFactor: p
                };
                //TURBOPACK unreachable
                ;
                var f;
            }
            _bufferedScreenMercator(e, t1) {
                const i = at(e);
                if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t1) : {
                        polygon: this.bufferedScreenGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._screenRaycastCache[i] = o, o;
                }
            }
            _bufferedCameraMercator(e, t1) {
                const i = at(e);
                if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t1) : {
                        polygon: this.bufferedCameraGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i] = o, o;
                }
            }
            _projectAndResample(t1, i) {
                const o = function(t1, i) {
                    const o = e.aB([], i.pixelMatrix, i.globeMatrix), s = [
                        0,
                        -e.aD,
                        0,
                        1
                    ], r = [
                        0,
                        e.aD,
                        0,
                        1
                    ], n = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e.aC(s, s, o), e.aC(r, r, o), e.aC(n, n, o);
                    const a = new e.P(s[0] / s[3], s[1] / s[3]), l = new e.P(r[0] / r[3], r[1] / r[3]), c = e.aE(t1, a) && s[3] < n[3], h = e.aE(t1, l) && r[3] < n[3];
                    if (!c && !h) return null;
                    const d = function(e, t1, i) {
                        for(let o = 1; o < e.length; o++){
                            const s = nt(t1.pointCoordinate3D(e[o - 1]).x), r = nt(t1.pointCoordinate3D(e[o]).x);
                            if (i < 0) {
                                if (s < r) return {
                                    idx: o,
                                    t: -s / (r - 1 - s)
                                };
                            } else if (r < s) return {
                                idx: o,
                                t: (1 - s) / (r + 1 - s)
                            };
                        }
                        return null;
                    }(t1, i, c ? -1 : 1);
                    if (!d) return null;
                    const { idx: u, t: _ } = d;
                    let p = u > 1 ? rt(t1.slice(0, u), i) : [], f = u < t1.length ? rt(t1.slice(u), i) : [];
                    p = p.map((t1)=>new e.P(nt(t1.x), t1.y)), f = f.map((t1)=>new e.P(nt(t1.x), t1.y));
                    const m = [
                        ...p
                    ];
                    0 === m.length && m.push(f[f.length - 1]);
                    const g = e.ak(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, _);
                    let v;
                    return v = c ? [
                        new e.P(0, g),
                        new e.P(0, 0),
                        new e.P(1, 0),
                        new e.P(1, g)
                    ] : [
                        new e.P(1, g),
                        new e.P(1, 1),
                        new e.P(0, 1),
                        new e.P(0, g)
                    ], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {
                        polygon: m.map((t1)=>new e.ae(t1.x, t1.y)),
                        unwrapped: !1
                    };
                }(t1, i);
                if (o) return o;
                const s = function(t1, i) {
                    let o = !1, s = -1 / 0, r = 0;
                    for(let e = 0; e < t1.length - 1; e++)t1[e].x > s && (s = t1[e].x, r = e);
                    for(let e = 0; e < t1.length - 1; e++){
                        const i = (r + e) % (t1.length - 1), s = t1[i], n = t1[i + 1];
                        Math.abs(s.x - n.x) > .5 && (s.x < n.x ? (s.x += 1, 0 === i && (t1[t1.length - 1].x += 1)) : (n.x += 1, i + 1 === t1.length - 1 && (t1[0].x += 1)), o = !0);
                    }
                    const n = e.aF(i.center.lng);
                    return o && n < Math.abs(n - 1) && t1.forEach((e)=>{
                        e.x -= 1;
                    }), {
                        polygon: t1,
                        unwrapped: o
                    };
                }(rt(t1, i).map((t1)=>new e.P(nt(t1.x), t1.y)), i);
                return {
                    polygon: s.polygon.map((t1)=>new e.ae(t1.x, t1.y)),
                    unwrapped: s.unwrapped
                };
            }
        }
        function rt(t1, i) {
            return e.aG(t1, (e)=>{
                const t1 = i.pointCoordinate3D(e);
                e.x = t1.x, e.y = t1.y;
            }, 1 / 256);
        }
        function nt(e) {
            return e < 0 ? 1 + e % 1 : e % 1;
        }
        function at(e) {
            return 100 * e | 0;
        }
        function lt(t1, i, o, s, r) {
            const n = function(o, s) {
                if (o) return r(o);
                if (s) {
                    if (t1.url && s.tiles && t1.tiles && delete t1.tiles, s.variants) {
                        if (!Array.isArray(s.variants)) return r(new Error("variants must be an array"));
                        for (const e of s.variants){
                            if (null == e || "object" != typeof e || e.constructor !== Object) return r(new Error("variant must be an object"));
                            if (!Array.isArray(e.capabilities)) return r(new Error("capabilities must be an array"));
                            if (1 === e.capabilities.length && "meshopt" === e.capabilities[0]) {
                                s = Object.assign(s, e);
                                break;
                            }
                        }
                    }
                    const o = e.aH(Object.assign({}, s, t1), [
                        "tilejson",
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "extra_bounds",
                        "scheme",
                        "tileSize",
                        "encoding",
                        "vector_layers",
                        "raster_layers",
                        "worldview_options",
                        "worldview_default",
                        "worldview"
                    ]);
                    o.tiles = i.canonicalizeTileset(o, t1.url), r(null, o);
                }
            }, a = function(e, t1, i) {
                if (!e) return null;
                if (!t1 && !i) return e;
                i = i || e.worldview_default;
                const o = Object.values(e.language || {});
                if (0 === o.length) return null;
                const s = Object.values(e.worldview || {});
                if (0 === s.length) return null;
                const r = o.every((e)=>e === t1), n = s.every((e)=>e === i);
                return r && n ? e : t1 in (e.language_options || {}) || i in (e.worldview_options || {}) ? null : e.language_options && e.worldview_options ? e : null;
            }(t1.data, o, s);
            return a ? e.o.frame(()=>n(null, a)) : t1.url ? e.m(i.transformRequest(i.normalizeSourceURL(t1.url, null, o, s), e.R.Source), n) : e.o.frame(()=>{
                const { data: e, ...i } = t1;
                n(null, i);
            });
        }
        function ct(t1, i) {
            const o = Math.pow(2, i.z), s = Math.floor(e.aF(t1.getWest()) * o), r = Math.floor(e.aJ(t1.getNorth()) * o), n = Math.ceil(e.aF(t1.getEast()) * o), a = Math.ceil(e.aJ(t1.getSouth()) * o);
            return i.x >= s && i.x < n && i.y >= r && i.y < a;
        }
        class ht {
            constructor(t1, i, o){
                this.bounds = t1 ? e.aI.convert(this.validateBounds(t1)) : null, this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(e) {
                return Array.isArray(e) && 4 === e.length ? [
                    Math.max(-180, e[0]),
                    Math.max(-90, e[1]),
                    Math.min(180, e[2]),
                    Math.min(90, e[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            addExtraBounds(t1) {
                if (t1) {
                    this.extraBounds || (this.extraBounds = []);
                    for (const i of t1)this.extraBounds.push(e.aI.convert(this.validateBounds(i)));
                }
            }
            contains(e) {
                if (e.z > this.maxzoom || e.z < this.minzoom) return !1;
                if (this.bounds && !ct(this.bounds, e)) return !1;
                if (!this.extraBounds) return !0;
                for (const t1 of this.extraBounds)if (ct(t1, e)) return !0;
                return !1;
            }
            static fromTileJSON(e) {
                if (!e.bounds && !e.extra_bounds) return null;
                const t1 = new ht(e.bounds, e.minzoom, e.maxzoom);
                return t1.addExtraBounds(e.extra_bounds), t1;
            }
        }
        class dt extends e.E {
            constructor(t1, i, o, s){
                if (super(), this.id = t1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, Object.assign(this, e.aH(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = Object.assign({
                    type: "vector"
                }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(s), this._tileWorkers = {}, this._deduped = new e.aK;
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.z("dataloading", {
                    dataType: "source"
                }));
                const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map.getWorldview();
                this._tileJSONRequest = lt(this._options, this.map._requestManager, i, o, (s, r)=>{
                    if (this._tileJSONRequest = null, this._loaded = !0, s) i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.y(s));
                    else if (r) {
                        if (Object.assign(this, r), this.hasWorldviews = !!r.worldview_options, r.worldview_default && (this.worldviewDefault = r.worldview_default), r.vector_layers) {
                            this.vectorLayers = r.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set;
                            for (const e of r.vector_layers)this.vectorLayerIds.push(e.id), r.worldview && r.worldview[e.source] && this.localizableLayerIds.add(e.id);
                        }
                        this.tileBounds = ht.fromTileJSON(r), P(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }));
                    }
                    t1 && t1(s);
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.B(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return Object.assign({}, this._options);
            }
            loadTile(t1, i) {
                const o = t1.tileID.canonical.url(this.tiles, this.scheme), s = this.map._requestManager.normalizeTileURL(o), r = this.map._requestManager.transformRequest(s, e.R.Tile), n = this.map.style ? this.map.style.getLut(this.scope) : null, a = n ? {
                    image: n.image.clone()
                } : null, l = {
                    request: r,
                    data: void 0,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    tileZoom: t1.tileZoom,
                    zoom: t1.tileID.overscaledZ,
                    maxZoom: this.maxzoom,
                    lut: a,
                    tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    pixelRatio: e.o.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: t1.isSymbolTile,
                    brightness: this.map.style && this.map.style.getBrightness() || 0,
                    extraShadowCaster: t1.isExtraShadowCaster,
                    tessellationStep: this.map._tessellationStep,
                    scaleFactor: this.map.getScaleFactor(),
                    worldview: this.map.getWorldview() || this.worldviewDefault,
                    indoor: this.map.getIndoorTileOptions(this.id, this.scope)
                };
                if (this.hasWorldviews && e.h(o) && (l.localizableLayerIds = this.localizableLayerIds), l.request.collectResourceTiming = this._collectResourceTiming, t1.actor && "expired" !== t1.state) "loading" === t1.state ? t1.reloadCallback = i : t1.request = t1.actor.send("reloadTile", l, c.bind(this));
                else if (t1.actor = this._tileWorkers[s] = this._tileWorkers[s] || this.dispatcher.getActor(), this.dispatcher.ready) t1.request = t1.actor.send("loadTile", l, c.bind(this), void 0, !0);
                else {
                    const i = e.aL.call({
                        deduped: this._deduped
                    }, l, (i, o)=>{
                        if (i || !o) c.call(this, i);
                        else {
                            const i = e.aM(o.responseHeaders);
                            l.data = {
                                rawData: o.rawData.slice(0),
                                expires: i.expires,
                                cacheControl: i.cacheControl
                            }, t1.actor && t1.actor.send("loadTile", l, c.bind(this), void 0, !0);
                        }
                    }, !0);
                    t1.request = {
                        cancel: i
                    };
                }
                function c(o, s) {
                    return delete t1.request, t1.aborted ? i(null) : o && o instanceof e.aN && 404 !== o.status ? i(o) : (s && s.resourceTiming && (t1.resourceTiming = s.resourceTiming), this.map._refreshExpiredTiles && s && t1.setExpiryData(s), t1.loadVectorData(s, this.map.painter), e.aO(this.dispatcher), i(null, s), void (t1.reloadCallback && (this.loadTile(t1, t1.reloadCallback), t1.reloadCallback = null)));
                }
            }
            abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                });
            }
            unloadTile(e, t1) {
                e.actor && e.actor.send("removeTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                }), e.destroy();
            }
            hasTransition() {
                return !1;
            }
            afterUpdate() {
                this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class ut extends e.E {
            constructor(t1, i, o, s){
                super(), this.id = t1, this.dispatcher = o, this.setEventedParent(s), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = Object.assign({
                    type: "raster"
                }, i), Object.assign(this, e.aH(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.z("dataloading", {
                    dataType: "source"
                }));
                const i = this.map.getWorldview();
                this._tileJSONRequest = lt(this._options, this.map._requestManager, null, i, (i, o)=>{
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.y(i)) : o && (Object.assign(this, o), o.raster_layers && (this.rasterLayers = o.raster_layers, this.rasterLayerIds = this.rasterLayers.map((e)=>e.id)), this.tileBounds = ht.fromTileJSON(o), P(o.tiles), this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(i);
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.B(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return Object.assign({}, this._options);
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loadTile(t1, i) {
                const o = e.o.devicePixelRatio >= 2, s = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
                t1.request = e.n(this.map._requestManager.transformRequest(s, e.R.Tile), (o, s, r)=>{
                    if (delete t1.request, t1.aborted) return t1.state = "unloaded", i(null);
                    if (o) return t1.state = "errored", i(o);
                    if (!s) return i(null);
                    const n = e.aM(r);
                    this.map._refreshExpiredTiles && t1.setExpiryData(n), t1.setTexture(s, this.map.painter), t1.state = "loaded", e.aO(this.dispatcher), i(null);
                });
            }
            abortTile(e, t1) {
                e.request && (e.request.cancel(), delete e.request), t1 && t1();
            }
            unloadTile(t1, i) {
                t1.texture && t1.texture instanceof e.T ? (t1.destroy(!1), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), i && i();
            }
            hasTransition() {
                return !1;
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        function _t([t1, i], o, s, { scaled: r = !0 } = {}) {
            const { tileSize: n, buffer: a } = s, { x: l, y: c, z: h } = o;
            if (!isFinite(l) || !isFinite(c) || !isFinite(h)) throw new Error("Invalid MRT header");
            const d = 2 ** h, u = d * e.aF(t1), _ = d * e.aJ(i);
            return function([e, t1], i, { scaled: o = !0 } = {}) {
                if (!i) throw new Error("bandView is undefined");
                const { data: s, tileSize: r, buffer: n, offset: a, scale: l, dimension: c } = i;
                if (e < -n || e > r + n || t1 < -n || t1 > r + n) throw new Error(`Point (${e}, ${t1}) out of bounds for tileSize=${r}, buffer=${n}`);
                const h = (t1 + n) * (r + 2 * n) + (e + n);
                if (4294967295 === new Uint32Array(s.buffer)[h]) return null;
                let d = [];
                d = o ? [] : new (0, i.data.constructor)(c);
                for(let e = 0; e < c; e++)d[e] = Math.round(1e12 * (s[c * h + e] * l + a)) / 1e12;
                return d;
            }([
                Math.min(Math.max(-a, Math.floor((u - l) * n)), n - 1 + a),
                Math.min(Math.max(-a, Math.floor((_ - c) * n)), n - 1 + a)
            ], s, {
                scaled: r
            });
        }
        class pt extends ut {
            constructor(e, t1, i, o){
                super(e, t1, i, o), this.type = "raster-array", this.maxzoom = 22, this.partial = !0, this._loadTilePending = {}, this._loadTileLoaded = {}, this._options = Object.assign({
                    type: "raster-array"
                }, t1);
            }
            triggerRepaint(e) {
                const t1 = this.map.painter._terrain, i = this.map.style.getSourceCache(this.id);
                t1 && t1.enabled && i && t1._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), s = this.map._requestManager.transformRequest(o, e.R.Tile), r = {
                    request: s,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    partial: this.partial
                };
                t1.source = this.id, t1.scope = this.scope, t1.requestParams = s, t1.actor || (t1.actor = this.dispatcher.getActor());
                const n = (o, s, r)=>{
                    if (delete t1.request, t1.aborted) return t1.state = "unloaded", i(null);
                    if (o) {
                        if ("AbortError" === o.name) return;
                        return t1.state = "errored", i(o);
                    }
                    if (this.map._refreshExpiredTiles && s) {
                        const i = e.aM(r);
                        t1.setExpiryData(i);
                    }
                    if (this.partial && "expired" !== t1.state) t1.state = "empty";
                    else if (!this.partial) {
                        if (!s) return i(null);
                        t1.state = "loaded", t1._isHeaderLoaded = !0, t1._mrt = s;
                    }
                    i(null);
                };
                t1.request = this.partial ? t1.fetchHeader(void 0, n.bind(this)) : t1.actor.send("loadTile", r, n.bind(this), void 0, !0);
            }
            abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                });
            }
            unloadTile(e, t1) {
                const i = e.texturePerLayer;
                if (e.flushAllQueues(), i.size) {
                    e.destroy(!1);
                    for (const e of i.values())this.map.painter.saveTileTexture(e);
                } else e.destroy();
            }
            prepareTile(t1, i, o, s) {
                t1._isHeaderLoaded && ("empty" !== t1.state && (t1.state = "reloading"), t1.fetchBandForRender(i, o, s, (i, s)=>{
                    if (i) return t1.state = "errored", this.fire(new e.y(i)), void this.triggerRepaint(t1);
                    s && (t1._isHeaderLoaded = !0, t1.setTexturePerLayer(o, s, this.map.painter), t1.state = "loaded", this.triggerRepaint(t1));
                }));
            }
            getInitialBand(e) {
                if (!this.rasterLayers) return 0;
                const t1 = this.rasterLayers.find(({ id: t1 })=>t1 === e), i = t1 && t1.fields, o = i && i.bands && i.bands;
                return o ? o[0] : 0;
            }
            getTextureDescriptor(t1, i, o) {
                if (!t1) return;
                const s = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
                if (!s) return;
                let r = null;
                i instanceof e.aR ? r = i.paint.get("raster-array-band") : i instanceof e.aS && (r = i.paint.get("raster-particle-array-band"));
                const n = r || this.getInitialBand(s);
                if (null == n) return;
                if (!t1.textureDescriptorPerLayer.get(i.id)) return void this.prepareTile(t1, s, i.id, n);
                if (t1.updateNeeded(i.id, n) && !o) return;
                const a = t1.textureDescriptorPerLayer.get(i.id);
                return Object.assign({}, a, {
                    texture: t1.texturePerLayer.get(i.id)
                });
            }
            getImages(t1, i) {
                const o = new Map;
                for (const s of t1)for (const t1 of i){
                    const [i, r] = t1.split("/"), n = s.getLayer(i);
                    if (!n) continue;
                    if (!n.hasBand(r) || !n.hasDataForBand(r)) continue;
                    const { bytes: a, tileSize: l, buffer: c } = n.getBandView(r), h = l + 2 * c, d = {
                        data: new e.q({
                            width: h,
                            height: h
                        }, a),
                        pixelRatio: 2,
                        sdf: !1,
                        usvg: !1,
                        version: 0
                    };
                    o.set(t1, d);
                }
                return o;
            }
            queryRasterArrayValueByBandId(t1, i, o) {
                const s = i._mrt;
                return new Promise((r)=>{
                    const n = {}, a = new Set;
                    for (const [l, c] of Object.entries(s.layers)){
                        if (o.layerName && l !== o.layerName) continue;
                        const h = {};
                        n[l] = h;
                        for (const { bands: d } of c.dataIndex)for (const u of d)o.bands && !o.bands.includes(u) || (a.add(e.B(l, u)), i.fetchBand(l, null, u, (i)=>{
                            e.o.frame(()=>{
                                h[u] = i ? null : _t([
                                    t1.lng,
                                    t1.lat
                                ], s, c.getBandView(u)), a.delete(e.B(l, u)), 0 === a.size && r(n);
                            });
                        }, !1));
                    }
                    0 === a.size && r(n);
                });
            }
            _loadTileForQuery(t1, i) {
                if (this._loadTileLoaded[t1.uid]) return void i(null, t1._mrt);
                if (this._loadTilePending[t1.uid]) return void this._loadTilePending[t1.uid].push(i);
                this._loadTilePending[t1.uid] = [
                    i
                ];
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), s = this.map._requestManager.transformRequest(o, e.R.Tile);
                t1.actor.send("loadTile", {
                    request: s,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    partial: !1
                }, (i, o, s)=>{
                    if (i) return this._loadTilePending[t1.uid].forEach((e)=>e(i, null)), void delete this._loadTilePending[t1.uid];
                    if (!o) return this._loadTilePending[t1.uid].forEach((e)=>e(null, null)), void delete this._loadTilePending[t1.uid];
                    if (this.map._refreshExpiredTiles && o) {
                        const i = e.aM(s);
                        t1.setExpiryData(i);
                    }
                    t1._mrt = o, t1._isHeaderLoaded = !0, t1.state = "loaded", this._loadTilePending[t1.uid].forEach((e)=>e(null, o)), this._loadTileLoaded[t1.uid] = !0, delete this._loadTilePending[t1.uid];
                }, void 0, !0);
            }
            queryRasterArrayValueByAllBands(e, t1, i) {
                return new Promise((o, s)=>{
                    this._loadTileForQuery(t1, (r, n)=>{
                        r ? s(r) : o(n ? this.queryRasterArrayValueByBandId(e, t1, i) : null);
                    });
                });
            }
            queryRasterArrayValue(t1, i) {
                const o = e.aT.convert(t1), s = this.findLoadedParent(o);
                return s && s._mrt ? i.bands || !this.partial ? this.queryRasterArrayValueByBandId(o, s, i) : this.queryRasterArrayValueByAllBands(o, s, i) : Promise.resolve(null);
            }
            findLoadedParent(t1) {
                const i = e.ae.fromLngLat(t1, this.map.transform.tileSize), o = this.maxzoom + 1, s = 1 << o, r = Math.floor(i.x), n = Math.floor((i.x - r) * s), a = Math.floor(i.y * s), l = this.map.style.getSourceCache(this.id), c = new e.aQ(o, r, o, n, a);
                return l.findLoadedParent(c, this.minzoom);
            }
        }
        const ft = {
            vector: dt,
            raster: ut,
            "raster-dem": class extends ut {
                constructor(e, t1, i, o){
                    super(e, t1, i, o), this.type = "raster-dem", this.maxzoom = 22, this._options = Object.assign({
                        type: "raster-dem"
                    }, t1), this.encoding = t1.encoding || "mapbox";
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function s(e, o) {
                        e && (t1.state = "errored", i(e)), o && (t1.dem = o, t1.dem.onDeserialize(), t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0, t1.state = "loaded", i(null));
                    }
                    t1.request = e.n(this.map._requestManager.transformRequest(o, e.R.Tile), (function(o, r, n) {
                        if (delete t1.request, t1.aborted) t1.state = "unloaded", i(null);
                        else if (o) t1.state = "errored", i(o);
                        else if (r) {
                            const i = e.aM(n);
                            this.map._refreshExpiredTiles && t1.setExpiryData(i);
                            const o = ImageBitmap && r instanceof ImageBitmap && e.r(), a = 1 - (r.width - e.aP(r.width)) / 2;
                            a < 1 || t1.neighboringTiles || (t1.neighboringTiles = this._getNeighboringTiles(t1.tileID));
                            const l = o ? r : e.o.getImageData(r, a), c = {
                                uid: t1.uid,
                                tileID: t1.tileID,
                                source: this.id,
                                type: this.type,
                                scope: this.scope,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: a
                            };
                            t1.actor && "expired" !== t1.state || (t1.actor = this.dispatcher.getActor(), t1.actor.send("loadTile", c, s.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t1) {
                    const i = t1.canonical, o = Math.pow(2, i.z), s = (i.x - 1 + o) % o, r = 0 === i.x ? t1.wrap - 1 : t1.wrap, n = (i.x + 1 + o) % o, a = i.x + 1 === o ? t1.wrap + 1 : t1.wrap, l = {};
                    return l[new e.aQ(t1.overscaledZ, r, i.z, s, i.y).key] = {
                        backfilled: !1
                    }, l[new e.aQ(t1.overscaledZ, a, i.z, n, i.y).key] = {
                        backfilled: !1
                    }, i.y > 0 && (l[new e.aQ(t1.overscaledZ, r, i.z, s, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aQ(t1.overscaledZ, t1.wrap, i.z, i.x, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aQ(t1.overscaledZ, a, i.z, n, i.y - 1).key] = {
                        backfilled: !1
                    }), i.y + 1 < o && (l[new e.aQ(t1.overscaledZ, r, i.z, s, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aQ(t1.overscaledZ, t1.wrap, i.z, i.x, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aQ(t1.overscaledZ, a, i.z, n, i.y + 1).key] = {
                        backfilled: !1
                    }), l;
                }
            },
            "raster-array": pt,
            geojson: class extends e.E {
                constructor(t1, i, o, s){
                    super(), this.id = t1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(s), this._data = i.data, this._options = Object.assign({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), void 0 !== i.minzoom && (this.minzoom = i.minzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                    const r = e.al / this.tileSize;
                    this.workerOptions = Object.assign({
                        source: this.id,
                        scope: this.scope,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * r,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * r,
                            extent: e.al,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: e.al,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * r,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter,
                        dynamic: i.dynamic
                    }, i.workerOptions);
                }
                onAdd(e) {
                    this.map = e, this.setData(this._data);
                }
                setData(e) {
                    return this._data = e, this._updateWorkerData(), this;
                }
                updateData(t1) {
                    if (!this._options.dynamic) return this.fire(new e.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
                    if ("string" != typeof t1 && ("Feature" === t1.type && (t1 = {
                        type: "FeatureCollection",
                        features: [
                            t1
                        ]
                    }), "FeatureCollection" !== t1.type)) return this.fire(new e.y(new Error("Data to update should be a feature or a feature collection.")));
                    if (this._coalesce && "string" != typeof t1 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
                        const e = new Map;
                        for (const t1 of this._data.features)e.set(t1.id, t1);
                        for (const i of t1.features)e.set(i.id, i);
                        this._data.features = [
                            ...e.values()
                        ];
                    } else this._data = t1;
                    return this._updateWorkerData(!0), this;
                }
                getClusterExpansionZoom(e, t1) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterChildren(e, t1) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterLeaves(e, t1, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        scope: this.scope,
                        clusterId: e,
                        limit: t1,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData(t1 = !1) {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e.z("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const i = Object.assign({
                        append: t1
                    }, this.workerOptions);
                    i.scope = this.scope;
                    const o = this._data;
                    "string" == typeof o ? (i.request = this.map._requestManager.transformRequest(e.o.resolveURL(o), e.R.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i, (i, o)=>{
                        if (this._loaded = !0, this._pendingLoad = null, i) this.fire(new e.y(i));
                        else {
                            const i = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && o && o.resourceTiming && o.resourceTiming[this.id] && (i.resourceTiming = o.resourceTiming[this.id]), t1 && (this._partialReload = !0), this.fire(new e.z("data", i)), this._partialReload = !1, this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(t1), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                reload() {
                    const t1 = e.B(this.id, this.scope);
                    this.map.style.clearSource(t1), this._updateWorkerData();
                }
                loadTile(t1, i) {
                    const o = t1.actor ? "reloadTile" : "loadTile";
                    t1.actor = this.actor;
                    const s = this.map.style ? this.map.style.getLut(this.scope) : null, r = s ? {
                        image: s.image.clone()
                    } : null, n = this._partialReload, a = {
                        type: this.type,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        lut: r,
                        scope: this.scope,
                        pixelRatio: e.o.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        extraShadowCaster: t1.isExtraShadowCaster,
                        scaleFactor: this.map.getScaleFactor(),
                        partial: n,
                        worldview: this.map.getWorldview(),
                        indoor: this.map.getIndoorTileOptions(this.id, this.scope)
                    };
                    t1.request = this.actor.send(o, a, (e, s)=>n && !s ? (t1.state = "loaded", i(null)) : (delete t1.request, t1.destroy(!1), t1.aborted ? i(null) : e ? i(e) : (t1.loadVectorData(s, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }
                abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
                }
                unloadTile(e, t1) {
                    this.actor.send("removeTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    }), e.destroy();
                }
                onRemove(e) {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return Object.assign({}, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends e.aU {
                constructor(e, t1, i, o){
                    super(e, t1, i, o), this.roundZoom = !0, this.type = "video", this.options = t1;
                }
                load() {
                    this._loaded = !1;
                    const t1 = this.options;
                    this.urls = [];
                    for (const i of t1.urls)this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);
                    e.aV(this.urls, (t1, i)=>{
                        this._loaded = !0, t1 ? this.fire(new e.y(t1)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t1) {
                    if (this.video) {
                        const i = this.video.seekable;
                        t1 < i.start(0) || t1 > i.end(0) ? this.fire(new e.y(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t1;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e) {
                    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t1 = this.map.painter.context, i = t1.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t1, this.video, i.RGBA8), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t1);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: e.aU,
            model: e.aX,
            "batched-model": class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.type = "batched-model", this.id = e, this.tileSize = 512, this._options = t1, this.tiles = this._options.tiles, this.maxzoom = t1.maxzoom || 19, this.minzoom = t1.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(o);
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                reload() {
                    this.cancelTileJSONRequest();
                    const t1 = e.B(this.id, this.scope);
                    this.load(()=>this.map.style.clearSource(t1));
                }
                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
                }
                load(t1) {
                    this._loaded = !1, this.fire(new e.z("dataloading", {
                        dataType: "source"
                    }));
                    const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map.getWorldview();
                    this._tileJSONRequest = lt(this._options, this.map._requestManager, i, o, (s, r)=>{
                        this._tileJSONRequest = null, this._loaded = !0, s ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.y(s))) : r && (Object.assign(this, r), r.bounds && (this.tileBounds = new ht(r.bounds, this.minzoom, this.maxzoom)), P(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }))), t1 && t1(s);
                    });
                }
                hasTransition() {
                    return !1;
                }
                hasTile(e) {
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), s = {
                        request: this.map._requestManager.transformRequest(o, e.R.Tile),
                        data: void 0,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        isSymbolTile: t1.isSymbolTile,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        pixelRatio: e.o.devicePixelRatio,
                        promoteId: this.promoteId
                    };
                    if (t1.actor && "expired" !== t1.state) if ("loading" === t1.state) t1.reloadCallback = i;
                    else {
                        if (t1.buckets) {
                            const e = Object.values(t1.buckets);
                            for (const t1 of e)t1.dirty = !0;
                            return void (t1.state = "loaded");
                        }
                        t1.request = t1.actor.send("reloadTile", s, r.bind(this));
                    }
                    else t1.actor = this.dispatcher.getActor(), t1.request = t1.actor.send("loadTile", s, r.bind(this), void 0, !0);
                    function r(e, o) {
                        return t1.aborted ? i(null) : e && 404 !== e.status ? i(e) : (this.map._refreshExpiredTiles && o && t1.setExpiryData(o), t1.loadModelData(o, this.map.painter), t1.state = "loaded", void i(null));
                    }
                }
                serialize() {
                    return Object.assign({}, this._options);
                }
            },
            canvas: class extends e.aU {
                constructor(t1, i, o, s){
                    super(t1, i, o, s), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e)=>!Array.isArray(e) || 2 !== e.length || e.some((e)=>"number" != typeof e)) || this.fire(new e.y(new e.V(`sources.${t1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.y(new e.V(`sources.${t1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.y(new e.V(`sources.${t1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.y(new e.V(`sources.${t1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.y(new e.V(`sources.${t1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e) {
                    this.map = e, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove(e) {
                    this.pause();
                }
                prepare() {
                    let t1 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t1 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i = this.map.painter.context;
                    this.texture ? !t1 && !this._playing || this.texture instanceof e.aW || this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA8, {
                        premultiply: !0
                    }), this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e) || e <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e.E {
                constructor(t1, i, o, s){
                    super(), this.id = t1, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(s), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new ht(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), Object.assign(this, e.aH(i, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e.aH(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t1) {
                    this.map = t1, this._loaded = !1, this.fire(new e.z("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t1), this.load();
                }
                onRemove(e) {
                    this._implementation.onRemove && this._implementation.onRemove(e);
                }
                hasTile(e) {
                    if (this._implementation.hasTile) {
                        const { x: t1, y: i, z: o } = e.canonical;
                        return this._implementation.hasTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loadTile(e, t1) {
                    const { x: i, y: o, z: s } = e.tileID.canonical, r = new AbortController;
                    e.request = Promise.resolve(this._implementation.loadTile({
                        x: i,
                        y: o,
                        z: s
                    }, {
                        signal: r.signal
                    })).then((function(i) {
                        return delete e.request, e.aborted ? (e.state = "unloaded", t1(null)) : void 0 === i ? (e.state = "errored", t1(null)) : null === i ? (this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), e.state = "loaded", t1(null)) : function(e) {
                            return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;
                        }(i) ? (this.loadTileData(e, i), e.state = "loaded", void t1(null)) : (e.state = "errored", t1(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((i)=>{
                        "AbortError" !== i.name && (e.state = "errored", t1(i));
                    }), e.request.cancel = ()=>r.abort();
                }
                loadTileData(e, t1) {
                    e.setTexture(t1, this.map.painter);
                }
                unloadTile(t1, i) {
                    if (t1.texture && t1.texture instanceof e.T ? (t1.destroy(!1), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), this._implementation.unloadTile) {
                        const { x: e, y: i, z: o } = t1.tileID.canonical;
                        this._implementation.unloadTile({
                            x: e,
                            y: i,
                            z: o
                        });
                    }
                    i && i();
                }
                abortTile(e, t1) {
                    e.request && e.request.cancel && (e.request.cancel(), delete e.request), t1 && t1();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this.map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e)=>({
                            x: e.canonical.x,
                            y: e.canonical.y,
                            z: e.canonical.z
                        }));
                }
                _clearTiles() {
                    const t1 = e.B(this.id, this.scope);
                    this.map.style.clearSource(t1);
                }
                _update() {
                    this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, mt = function(t1, i, o, s) {
            const r = new ft[i.type](t1, i, o, s);
            if (r.id !== t1) throw new Error(`Expected Source id to be ${t1} instead of ${r.id}`);
            return e.aY([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], r), r;
        };
        function gt(e, t1, i = "") {
            return `${i}:${t1.id || ""}:${t1.layer.id}:${function(e) {
                if ("layerId" in e) return `layer:${e.layerId}`;
                {
                    const { featuresetId: t1, importId: i } = e;
                    return `featureset:${t1}${i ? `:import:${i}` : ""}`;
                }
            }(e.target)}`;
        }
        function vt(e, t1, i, o = "") {
            if (e.uniqueFeatureID) {
                const s = gt(e, t1, o);
                if (i.has(s)) return !0;
                i.add(s);
            }
            return !1;
        }
        function yt(e, t1, i, o, s = !1, r = void 0) {
            const n = t1.sourceCache.transform, a = t1.sourceCache.tilesIn(e, t1.has3DLayers, s);
            a.sort(wt);
            const l = [];
            for (const e of a){
                const a = e.tile.queryRenderedFeatures(t1, e, i, o, n, s, r);
                Object.keys(a).length && l.push({
                    wrappedTileID: e.tile.tileID.wrapped().key,
                    queryResults: a
                });
            }
            for(const i in t1.layers){
                const s = t1.layers[i];
                if (s.styleLayer) {
                    const i = s.styleLayer.queryRenderedFeatures(e, t1.sourceCache, o);
                    Object.keys(i).length && l.push({
                        wrappedTileID: 0,
                        queryResults: i
                    });
                }
            }
            return 0 === l.length ? {} : function(e) {
                const t1 = {}, i = {};
                for (const o of e){
                    const e = o.queryResults, s = o.wrappedTileID, r = i[s] = i[s] || {};
                    for(const i in e){
                        const o = e[i], s = r[i] = r[i] || {}, n = t1[i] = t1[i] || [];
                        for (const e of o)s[e.featureIndex] || (s[e.featureIndex] = !0, n.push(e));
                    }
                }
                return t1;
            }(l);
        }
        function xt(e, t1, i, o, s, r) {
            const n = {}, a = o.queryRenderedSymbols(e), l = [];
            for (const e of Object.keys(a).map(Number))l.push(s[e]);
            l.sort(wt);
            for (const e of l){
                const o = e.featureIndex.lookupSymbolFeatures(a[e.bucketInstanceId], e.bucketIndex, e.sourceLayerIndex, t1, i, r);
                for(const t1 in o){
                    const i = n[t1] = n[t1] || [], s = o[t1];
                    s.sort((t1, i)=>{
                        const o = e.featureSortOrder;
                        if (o) {
                            const e = o.indexOf(t1.featureIndex);
                            return o.indexOf(i.featureIndex) - e;
                        }
                        return i.featureIndex - t1.featureIndex;
                    });
                    for (const e of s)i.push(e);
                }
            }
            return n;
        }
        function bt(e, t1) {
            const i = e.getRenderableIds().map((t1)=>e.getTileByID(t1)), o = [], s = {};
            for(let e = 0; e < i.length; e++){
                const r = i[e], n = r.tileID.canonical.key;
                s[n] || (s[n] = !0, r.querySourceFeatures(o, t1));
            }
            return o;
        }
        function wt(e, t1) {
            const i = e.tileID, o = t1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        function Tt(e, t1) {
            const i = {};
            if (!t1) return i;
            for (const o of e){
                const e = o.layerIds.map((e)=>t1.getLayer(e)).filter(Boolean);
                if (0 !== e.length) {
                    o.layers = e, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map((t1)=>e.filter((e)=>e.id === t1)[0]));
                    for (const t1 of e)i[t1.fqid] = o;
                }
            }
            return i;
        }
        const Et = 32, St = 33, It = new Uint16Array(8184);
        for(let e = 0; e < 2046; e++){
            let t1 = e + 2, i = 0, o = 0, s = 0, r = 0, n = 0, a = 0;
            for(1 & t1 ? s = r = n = Et : i = o = a = Et; (t1 >>= 1) > 1;){
                const e = i + s >> 1, l = o + r >> 1;
                1 & t1 ? (s = i, r = o, i = n, o = a) : (i = s, o = r, s = n, r = a), n = e, a = l;
            }
            const l = 4 * e;
            It[l + 0] = i, It[l + 1] = o, It[l + 2] = s, It[l + 3] = r;
        }
        const Ct = new Uint16Array(2178), Rt = new Uint8Array(1089), At = new Uint16Array(1089);
        function Lt(e) {
            return 0 === e ? -.03125 : 32 === e ? .03125 : 0;
        }
        const Dt = (()=>({
                type: 2,
                extent: e.al,
                loadGeometry: ()=>[
                        [
                            new e.P(0, 0),
                            new e.P(e.al + 1, 0),
                            new e.P(e.al + 1, e.al + 1),
                            new e.P(0, e.al + 1),
                            new e.P(0, 0)
                        ]
                    ]
            }))();
        class Pt {
            constructor(t1, i, o, s, r, n){
                this.tileID = t1, this.uid = e.b2(), this.uses = 0, this.tileSize = i, this.tileZoom = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = r, s && s.style && (this._lastUpdatedBrightness = s.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", s && s.transform && (this.projection = s.transform.projection), this.worldview = n, this._hasAppearances = null;
            }
            registerFadeDuration(t1) {
                const i = t1 + this.timeAdded;
                i < e.o.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = e.aZ(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t1, i, o) {
                if (this.unloadVectorData(), this.state = "loaded", t1) {
                    t1.featureIndex && (this.latestFeatureIndex = t1.featureIndex, t1.rawTileData ? (this.latestRawTileData = t1.rawTileData, this.latestFeatureIndex.rawTileData = t1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t1.collisionBoxArray, this.buckets = Tt(t1.buckets, i.style), this.hasSymbolBuckets = !1;
                    for(const t1 in this.buckets){
                        const i = this.buckets[t1];
                        if (i instanceof e.b4) {
                            if (this.hasSymbolBuckets = !0, !o) break;
                            i.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t1 in this.buckets){
                        const i = this.buckets[t1];
                        if (i instanceof e.b4 && i.hasRTLText) {
                            this.hasRTLText = !0, e.b5();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const e in this.buckets){
                        const t1 = this.buckets[e], o = i.style.getOwnLayer(e);
                        if (!o) continue;
                        const s = o.queryRadius(t1);
                        this.queryPadding = Math.max(this.queryPadding, s);
                    }
                    t1.imageAtlas && (this.imageAtlas = t1.imageAtlas), t1.glyphAtlasImage && (this.glyphAtlasImage = t1.glyphAtlasImage), t1.lineAtlas && (this.lineAtlas = t1.lineAtlas), this._lastUpdatedBrightness = t1.brightness;
                } else this.collisionBoxArray = new e.b3;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const e in this.buckets)this.buckets[e].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            loadModelData(e, t1, i) {
                e && (e.resourceTiming && (this.resourceTiming = e.resourceTiming), this.buckets = Object.assign({}, this.buckets, Tt(e.buckets, t1.style)), e.featureIndex && (this.latestFeatureIndex = e.featureIndex));
            }
            getBucket(e) {
                return this.buckets[e.fqid];
            }
            upload(t1, i) {
                for(const e in this.buckets){
                    const o = this.buckets[e];
                    if (o.uploadPending()) {
                        let e = {}, s = [], r = {
                            zoom: 0,
                            pitch: 0,
                            brightness: 0,
                            worldview: ""
                        };
                        if (i) {
                            if (i.style) {
                                s = i.style.listImages();
                                const t1 = o.layers[0], r = t1.sourceLayer || "_geojsonTileLayer", n = i.style.getLayerSourceCache(t1);
                                n && (e = n._state.getState(r, void 0));
                            }
                            r = {
                                zoom: i.transform.zoom || 0,
                                pitch: i.transform.pitch || 0,
                                brightness: i.style.getBrightness() || 0,
                                worldview: i.worldview || ""
                            };
                        }
                        o.upload(t1, this.tileID.canonical, e, s, r);
                    }
                }
                const o = t1.gl, s = this.imageAtlas;
                s && !s.uploaded && (this.imageAtlasTexture = new e.T(t1, s.image, o.RGBA8, {
                    useMipmap: !!s.patternPositions.size
                }), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t1, this.glyphAtlasImage, o.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t1, this.lineAtlas.image, o.R8), this.lineAtlas.uploaded = !0);
            }
            prepare(e, t1, i) {
                if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture, i), !t1 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
                const o = t1.style.getBrightness();
                null === this._hasAppearances && (this._hasAppearances = this.hasAppearances(t1)), (this._lastUpdatedBrightness || o || this._hasAppearances) && (!this._hasAppearances && this._lastUpdatedBrightness && o && Math.abs(this._lastUpdatedBrightness - o) < .001 || (this.updateBuckets(t1, this._lastUpdatedBrightness !== o), this._lastUpdatedBrightness = o));
            }
            evaluateQueryRenderedFeaturePadding() {
                let e = 0;
                for(const t1 in this.buckets){
                    const i = this.buckets[t1];
                    i.evaluateQueryRenderedFeaturePadding && (e = Math.max(e, i.evaluateQueryRenderedFeaturePadding()));
                }
                return e;
            }
            queryRenderedFeatures(t1, i, o, s, r, n, a) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
                const l = this.evaluateQueryRenderedFeaturePadding(), c = function(t1, i) {
                    const o = e.bq([], [
                        .5 * t1.width,
                        .5 * -t1.height,
                        1
                    ]);
                    return e.br(o, o, [
                        1,
                        -1,
                        0
                    ]), e.aB(o, o, t1.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
                }(r, this.tileID);
                return this.latestFeatureIndex.query(t1, {
                    tilespaceGeometry: i,
                    pixelPosMatrix: c,
                    transform: s,
                    availableImages: o,
                    tileTransform: this.tileTransform,
                    worldview: this.worldview,
                    queryRadius: l,
                    scope: a
                });
            }
            querySourceFeatures(t1, i) {
                const o = this.latestFeatureIndex;
                if (!o || !o.rawTileData) return;
                const s = o.loadVTLayers(), r = i ? i.sourceLayer : "", n = s._geojsonTileLayer || s[r];
                if (!n) return;
                const a = e.b6(i && i.filter), { z: l, x: c, y: h } = this.tileID.canonical, d = {
                    z: l,
                    x: c,
                    y: h
                };
                for(let i = 0; i < n.length; i++){
                    const s = n.feature(i);
                    if (a.needGeometry) {
                        const t1 = e.b7(s, !0);
                        if (!a.filter(new e.ac(this.tileID.overscaledZ, {
                            worldview: this.worldview
                        }), t1, this.tileID.canonical)) continue;
                    } else if (!a.filter(new e.ac(this.tileID.overscaledZ, {
                        worldview: this.worldview
                    }), s)) continue;
                    const u = o.getId(s, r), _ = new e.b8(s, l, c, h, u);
                    _.tile = d, t1.push(_);
                }
            }
            loaded() {
                return "loaded" === this.state || "errored" === this.state;
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;
            }
            setExpiryData(t1) {
                const i = this.expirationTime;
                if (t1.cacheControl) {
                    const i = e.b9(t1.cacheControl);
                    i["max-age"] && (this.expirationTime = Date.now() + 1e3 * i["max-age"]);
                } else t1.expires && (this.expirationTime = new Date(t1.expires).getTime());
                if (this.expirationTime) {
                    const e = Date.now();
                    let t1 = !1;
                    if (this.expirationTime > e) t1 = !1;
                    else if (i) if (this.expirationTime < i) t1 = !0;
                    else {
                        const o = this.expirationTime - i;
                        o ? this.expirationTime = e + Math.max(o, 3e4) : t1 = !0;
                    }
                    else t1 = !0;
                    t1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            refreshFeatureState(e) {
                this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e && this.updateBuckets(e);
            }
            hasAppearances(e) {
                for(const t1 in this.buckets)if (e.style.hasLayer(t1) && this.buckets[t1].layers.some((e)=>e.appearances && e.appearances.length > 0)) return !0;
                return !1;
            }
            updateBuckets(t1, i) {
                if (!this.latestFeatureIndex) return;
                if (!t1.style) return;
                const o = t1.style.listImages(), s = t1.style.getBrightness();
                for(const r in this.buckets){
                    if (!t1.style.hasLayer(r)) continue;
                    const n = this.buckets[r], a = n.layers[0], l = a.sourceLayer || "_geojsonTileLayer", c = t1.style.getLayerSourceCache(a);
                    let h = {};
                    c && (h = c._state.getState(l, void 0));
                    const d = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, u = Object.keys(h).length > 0 && !i;
                    n.hasAppearances = n.layers.some((e)=>e.appearances && e.appearances.length > 0);
                    const _ = u ? n.stateDependentLayers : n.layers;
                    if (u && 0 !== n.stateDependentLayers.length || i) {
                        const e = this.latestFeatureIndex.loadVTLayers();
                        n.update(h, e[l], o, d, _, i, s);
                    }
                    if (u && 0 !== n.stateDependentLayers.length || i || n.hasAppearances) {
                        const e = {
                            zoom: t1.transform.zoom,
                            pitch: t1.transform.pitch,
                            brightness: t1.style.getBrightness() || 0,
                            worldview: t1.worldview
                        };
                        n.updateAppearances(this.tileID.canonical, h, o, e, t1.imageManager);
                    }
                    (n instanceof e.ba || n instanceof e.bb) && t1._terrain && t1._terrain.enabled && c && n.uploadPending() && t1._terrain._clearRenderCacheForTile(c.id, this.tileID);
                    const p = t1 && t1.style && t1.style.getOwnLayer(r);
                    p && (this.queryPadding = Math.max(this.queryPadding, p.queryRadius(n)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.o.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t1) {
                this.symbolFadeHoldUntil = e.o.now() + t1;
            }
            setTexture(t1, i) {
                const o = i.context, s = o.gl;
                this.texture = this.texture || i.getTileTexture(t1.width), this.texture && this.texture instanceof e.T ? this.texture.update(t1) : (this.texture = new e.T(o, t1, s.RGBA8, {
                    useMipmap: !0
                }), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            }
            setDependencies(e, t1) {
                const i = {};
                for (const e of t1)i[e] = !0;
                this.dependencies[e] = i;
            }
            hasDependency(e, t1) {
                for (const i of e){
                    const e = this.dependencies[i];
                    if (e) {
                        for (const i of t1)if (e[i]) return !0;
                    }
                }
                return !1;
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t1, i) {
                if (!i || "mercator" === i.name || this._tileDebugBuffer) return;
                const o = e.bc(Dt, this.tileID.canonical, this.tileTransform)[0], s = new e.bd, r = new e.be;
                for(let e = 0; e < o.length; e++){
                    const { x: t1, y: i } = o[e];
                    s.emplaceBack(t1, i), r.emplaceBack(e);
                }
                r.emplaceBack(0), this._tileDebugIndexBuffer = t1.createIndexBuffer(r), this._tileDebugBuffer = t1.createVertexBuffer(s, e.bf.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, s.length, r.length);
            }
            _makeTileBoundsBuffers(t1, i) {
                if (this._tileBoundsBuffer || !i || "mercator" === i.name) return;
                const o = e.bc(Dt, this.tileID.canonical, this.tileTransform)[0];
                let s, r;
                if (this.isRaster) {
                    const t1 = function(t1, i) {
                        const o = e.aZ(t1, i), s = Math.pow(2, t1.z);
                        for(let r = 0; r < St; r++)for(let n = 0; n < St; n++){
                            const a = e.a_((t1.x + (n + Lt(n)) / Et) / s), l = e.a$((t1.y + (r + Lt(r)) / Et) / s), c = i.project(a, l), h = r * St + n;
                            Ct[2 * h + 0] = Math.round((c.x * o.scale - o.x) * e.al), Ct[2 * h + 1] = Math.round((c.y * o.scale - o.y) * e.al);
                        }
                        Rt.fill(0), At.fill(0);
                        for(let e = 2045; e >= 0; e--){
                            const t1 = 4 * e, i = It[t1 + 0], o = It[t1 + 1], s = It[t1 + 2], r = It[t1 + 3], n = i + s >> 1, a = o + r >> 1, l = n + a - o, c = a + i - n, h = o * St + i, d = r * St + s, u = a * St + n, _ = Math.hypot((Ct[2 * h + 0] + Ct[2 * d + 0]) / 2 - Ct[2 * u + 0], (Ct[2 * h + 1] + Ct[2 * d + 1]) / 2 - Ct[2 * u + 1]) >= 16;
                            Rt[u] = Rt[u] || (_ ? 1 : 0), e < 1022 && (Rt[u] = Rt[u] || Rt[(o + c >> 1) * St + (i + l >> 1)] || Rt[(r + c >> 1) * St + (s + l >> 1)]);
                        }
                        const r = new e.b1, n = new e.b0;
                        let a = 0;
                        function l(t1, i) {
                            const o = i * St + t1;
                            return 0 === At[o] && (r.emplaceBack(Ct[2 * o + 0], Ct[2 * o + 1], t1 * e.al / Et, i * e.al / Et), At[o] = ++a), At[o] - 1;
                        }
                        function c(e, t1, i, o, s, r) {
                            const a = e + i >> 1, h = t1 + o >> 1;
                            if (Math.abs(e - s) + Math.abs(t1 - r) > 1 && Rt[h * St + a]) c(s, r, e, t1, a, h), c(i, o, s, r, a, h);
                            else {
                                const a = l(e, t1), c = l(i, o), h = l(s, r);
                                n.emplaceBack(a, c, h);
                            }
                        }
                        return c(0, 0, Et, Et, Et, 0), c(Et, Et, 0, 0, 0, Et), {
                            vertices: r,
                            indices: n
                        };
                    }(this.tileID.canonical, i);
                    s = t1.vertices, r = t1.indices;
                } else {
                    s = new e.b1, r = new e.b0;
                    for (const { x: e, y: t1 } of o)s.emplaceBack(e, t1, 0, 0);
                    const t1 = e.bh(s.int16.subarray(0, 4 * s.length), void 0, 4);
                    for(let e = 0; e < t1.length; e += 3)r.emplaceBack(t1[e], t1[e + 1], t1[e + 2]);
                }
                this._tileBoundsBuffer = t1.createVertexBuffer(s, e.bi.members), this._tileBoundsIndexBuffer = t1.createIndexBuffer(r), this._tileBoundsSegments = e.bg.simpleSegment(0, 0, s.length, r.length);
            }
            _makeGlobeTileDebugBuffers(t1, i) {
                const o = i.projection;
                if (!o || "globe" !== o.name || i.freezeTileCoverage) return;
                const s = this.tileID.canonical, r = e.bj(s, i), n = e.bk(r), a = e.aj(i.zoom);
                let l;
                a > 0 && (l = e.bl(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t1, s, i, n, l, a), this._makeGlobeTileDebugTextBuffer(t1, s, i, n, l, a);
            }
            _globePoint(t1, i, o, s, r, n, a) {
                let l = e.bm(t1, i, o);
                if (n) {
                    const r = 1 << o.z, c = e.aF(s.center.lng), h = e.aJ(s.center.lat), d = (o.x + .5) / r - c;
                    let u = 0;
                    d > .5 ? u = -1 : d < -.5 && (u = 1);
                    let _ = (t1 / e.al + o.x) / r + u, p = (i / e.al + o.y) / r;
                    _ = (_ - c) * s._pixelsPerMercatorPixel + c, p = (p - h) * s._pixelsPerMercatorPixel + h;
                    const f = [
                        _ * s.worldSize,
                        p * s.worldSize,
                        0
                    ];
                    e.af(f, f, n), l = e.bn(l, f, a);
                }
                return e.af(l, l, r);
            }
            _makeGlobeTileDebugBorderBuffer(t1, i, o, s, r, n) {
                const a = new e.bd, l = new e.be, c = new e.bo, h = (e, t1, h, d, u)=>{
                    const _ = (h - e) / (u - 1), p = (d - t1) / (u - 1), f = a.length;
                    for(let h = 0; h < u; h++){
                        const d = e + h * _, u = t1 + h * p;
                        a.emplaceBack(d, u);
                        const m = this._globePoint(d, u, i, o, s, r, n);
                        c.emplaceBack(m[0], m[1], m[2]), l.emplaceBack(f + h);
                    }
                }, d = e.al;
                h(0, 0, d, 0, 16), h(d, 0, d, d, 16), h(d, d, 0, d, 16), h(0, d, 0, 0, 16), this._tileDebugIndexBuffer = t1.createIndexBuffer(l), this._tileDebugBuffer = t1.createVertexBuffer(a, e.bf.members), this._globeTileDebugBorderBuffer = t1.createVertexBuffer(c, e.bp.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, a.length, l.length);
            }
            _makeGlobeTileDebugTextBuffer(t1, i, o, s, r, n) {
                const a = e.al / 4, l = new e.bd, c = new e.b0, h = new e.bo, d = 25;
                c.reserve(32), l.reserve(d), h.reserve(d);
                const u = (e, t1)=>d * e + t1;
                for(let e = 0; e < d; e++){
                    const t1 = e * a;
                    for(let e = 0; e < d; e++){
                        const c = e * a;
                        l.emplaceBack(c, t1);
                        const d = this._globePoint(c, t1, i, o, s, r, n);
                        h.emplaceBack(d[0], d[1], d[2]);
                    }
                }
                for(let e = 0; e < 4; e++)for(let t1 = 0; t1 < 4; t1++){
                    const i = u(e, t1), o = u(e, t1 + 1), s = u(e + 1, t1), r = u(e + 1, t1 + 1);
                    c.emplaceBack(i, o, s), c.emplaceBack(s, o, r);
                }
                this._tileDebugTextIndexBuffer = t1.createIndexBuffer(c), this._tileDebugTextBuffer = t1.createVertexBuffer(l, e.bf.members), this._globeTileDebugTextBuffer = t1.createVertexBuffer(h, e.bp.members), this._tileDebugTextSegments = e.bg.simpleSegment(0, 0, d, 32);
            }
            destroy(t1 = !0) {
                for(const e in this.buckets)this.buckets[e].destroy(t1);
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), t1 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.emissiveTexture && this.emissiveTexture instanceof e.T && (this.emissiveTexture.destroy(), delete this.emissiveTexture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
            }
        }
        e.bs.setPbf(e.bt);
        class Ot extends Pt {
            constructor(e, t1, i, o, s){
                super(e, t1, i, o, s), this._workQueuePerLayer = new Map, this._fetchQueuePerLayer = new Map, this._taskQueue = new Map, this._isHeaderLoaded = !1, this.textureDescriptorPerLayer = new Map, this.texturePerLayer = new Map;
            }
            getLayers() {
                return this._mrt ? Object.values(this._mrt.layers) : [];
            }
            getLayer(e) {
                return this._mrt && this._mrt.getLayer(e);
            }
            setTexturePerLayer(t1, i, o) {
                const s = o.context, r = s.gl;
                let n = this.texturePerLayer.get(t1) || o.getTileTexture(i.width);
                n && n instanceof e.T ? n.update(i, {
                    premultiply: !1
                }) : n = new e.T(s, i, r.RGBA8, {
                    premultiply: !1
                }), this.texturePerLayer.has(t1) || this.texturePerLayer.set(t1, n);
            }
            flushQueues(e) {
                const t1 = this._workQueuePerLayer.get(e) || [], i = this._fetchQueuePerLayer.get(e) || [];
                for(; t1.length;)t1.pop()();
                for(; i.length;)i.pop()();
            }
            flushAllQueues() {
                for (const e of this._workQueuePerLayer.keys()){
                    const t1 = this._workQueuePerLayer.get(e) || [];
                    for(; t1.length;)t1.pop()();
                }
                for (const e of this._fetchQueuePerLayer.keys()){
                    const t1 = this._fetchQueuePerLayer.get(e) || [];
                    for(; t1.length;)t1.pop()();
                }
            }
            fetchHeader(t1 = 16384, i) {
                const o = this._mrt = new e.bs(30), s = Object.assign({}, this.requestParams, {
                    headers: {
                        Range: "bytes=0-" + (t1 - 1)
                    }
                });
                return this.entireBuffer = null, this.request = e.bu(s, (e, s, r)=>{
                    if (e) i(e);
                    else try {
                        const e = o.getHeaderLength(s);
                        if (e > t1) return void (this.request = this.fetchHeader(e, i));
                        o.parseHeader(s), this._isHeaderLoaded = !0;
                        let n = 0;
                        for (const e of Object.values(o.layers))n = Math.max(n, e.dataIndex[e.dataIndex.length - 1].lastByte);
                        s.byteLength >= n && (this.entireBuffer = s), i(null, this.entireBuffer || s, r);
                    } catch (e) {
                        i(e);
                    }
                }), this.request;
            }
            fetchBandForRender(e, t1, i, o) {
                this.fetchBand(e, t1, i, (s)=>{
                    if (s) return void o(s);
                    this.updateTextureDescriptor(e, t1, i);
                    const r = this.textureDescriptorPerLayer.get(t1);
                    o(null, r ? r.img : null);
                });
            }
            fetchBand(t1, i, o, s, r = !0) {
                const n = this._mrt;
                if (!this._isHeaderLoaded || !n) return void s(new Error("Tile header is not ready"));
                const a = this.actor;
                if (!a) return void s(new Error("Can't fetch tile band without an actor"));
                let l;
                const c = e.B(String(o), e.B(this.tileID.key, t1));
                let h = this._taskQueue.get(c);
                h ? h.add(s) : (h = new Set, h.add(s), this._taskQueue.set(c, h));
                const d = (e, t1)=>{
                    l.complete(e, t1), e ? s(e) : (h.forEach((e)=>e(null, t1)), this._taskQueue.delete(c));
                }, u = (e, t1)=>{
                    if (e) return s(e);
                    const o = a.send("decodeRasterArray", {
                        type: "raster-array",
                        source: this.source,
                        scope: this.scope,
                        tileID: this.tileID,
                        uid: this.uid,
                        buffer: t1,
                        task: l
                    }, d, void 0, !0);
                    if (null !== i) {
                        const e = this._workQueuePerLayer.get(i) || [];
                        e.push(()=>{
                            o && o.cancel(), l.cancel();
                        }), this._workQueuePerLayer.has(i) || this._workQueuePerLayer.set(i, e);
                    }
                };
                let _;
                try {
                    _ = n.getLayer(t1);
                } catch (e) {
                    if ("reloading" === this.state) return;
                    throw e;
                }
                if (!_) return void s(new Error(`Unknown sourceLayer "${t1}"`));
                if (_.hasDataForBand(o)) return h.forEach((e)=>e(null, null)), void this._taskQueue.delete(c);
                const p = _.getDataRange([
                    o
                ]);
                if (l = n.createDecodingTask(p), !l || l.tasks.length) if (null !== i && this.flushQueues(i), this.entireBuffer) u(null, this.entireBuffer.slice(p.firstByte, p.lastByte + 1));
                else {
                    const t1 = Object.assign({}, this.requestParams, {
                        headers: {
                            Range: `bytes=${p.firstByte}-${p.lastByte}`
                        }
                    }), o = e.bu(t1, u);
                    if (null !== i) {
                        const e = this._fetchQueuePerLayer.get(i) || [];
                        e.push(()=>{
                            o.cancel(), l.cancel();
                        }), this._fetchQueuePerLayer.has(i) || this._fetchQueuePerLayer.set(i, e);
                    }
                }
            }
            updateNeeded(e, t1) {
                return (!this.textureDescriptorPerLayer.get(e) || this.textureDescriptorPerLayer.get(e).band !== t1 || this.refreshedUponExpiration) && "errored" !== this.state;
            }
            updateTextureDescriptor(t1, i, o) {
                if (!this._mrt) return;
                const s = this._mrt.getLayer(t1);
                if (!s || !s.hasBand(o) || !s.hasDataForBand(o)) return;
                const { bytes: r, tileSize: n, buffer: a, offset: l, scale: c } = s.getBandView(o), h = n + 2 * a, d = new e.q({
                    width: h,
                    height: h
                }, r), u = this.texturePerLayer.get(i);
                u && u instanceof e.T && u.update(d, {
                    premultiply: !1
                }), this.textureDescriptorPerLayer.set(i, {
                    layer: t1,
                    band: o,
                    img: d,
                    buffer: a,
                    offset: l,
                    tileSize: n,
                    format: s.pixelFormat,
                    mix: [
                        c,
                        256 * c,
                        65536 * c,
                        16777216 * c
                    ]
                });
            }
            destroy(t1 = !1) {
                if (super.destroy(t1), delete this._mrt, !t1) for (const t1 of this.texturePerLayer.values())t1 && t1 instanceof e.T && t1.destroy();
                this.texturePerLayer.clear(), this.textureDescriptorPerLayer.clear(), this.fbo && (this.fbo.destroy(), delete this.fbo), delete this.request, delete this.requestParams, this._isHeaderLoaded = !1;
            }
        }
        class zt {
            constructor(e, t1){
                this.max = e, this.onRemove = t1, this.reset();
            }
            reset() {
                for(const e in this.data)for (const t1 of this.data[e])t1.timeout && clearTimeout(t1.timeout), this.onRemove(t1.value);
                return this.data = {}, this.order = [], this;
            }
            add(e, t1, i) {
                const o = e.wrapped().key;
                void 0 === this.data[o] && (this.data[o] = []);
                const s = {
                    value: t1,
                    timeout: void 0
                };
                if (void 0 !== i && (s.timeout = setTimeout(()=>{
                    this.remove(e, s);
                }, i)), this.data[o].push(s), this.order.push(o), this.order.length > this.max) {
                    const e = this._getAndRemoveByKey(this.order[0]);
                    e && this.onRemove(e);
                }
                return this;
            }
            has(e) {
                return e.wrapped().key in this.data;
            }
            getAndRemove(e) {
                return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
            }
            _getAndRemoveByKey(e) {
                const t1 = this.data[e].shift();
                return t1.timeout && clearTimeout(t1.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t1.value;
            }
            getByKey(e) {
                const t1 = this.data[e];
                return t1 ? t1[0].value : null;
            }
            get(e) {
                return this.has(e) ? this.data[e.wrapped().key][0].value : null;
            }
            remove(e, t1) {
                if (!this.has(e)) return this;
                const i = e.wrapped().key, o = void 0 === t1 ? 0 : this.data[i].indexOf(t1), s = this.data[i][o];
                return this.data[i].splice(o, 1), s.timeout && clearTimeout(s.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(s.value), this.order.splice(this.order.indexOf(i), 1), this;
            }
            setMaxSize(e) {
                for(this.max = e; this.order.length > this.max;){
                    const e = this._getAndRemoveByKey(this.order[0]);
                    e && this.onRemove(e);
                }
                return this;
            }
            filter(e) {
                const t1 = [];
                for(const i in this.data)for (const o of this.data[i])e(o.value) || t1.push(o);
                for (const e of t1)this.remove(e.value.tileID, e);
            }
        }
        class Mt {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e, t1, i) {
                const o = String(t1);
                if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][o] = this.stateChanges[e][o] || {}, Object.assign(this.stateChanges[e][o], i), null === this.deletedStates[e]) {
                    this.deletedStates[e] = {};
                    for(const t1 in this.state[e])t1 !== o && (this.deletedStates[e][t1] = null);
                } else if (this.deletedStates[e] && null === this.deletedStates[e][o]) {
                    this.deletedStates[e][o] = {};
                    for(const t1 in this.state[e][o])i[t1] || (this.deletedStates[e][o][t1] = null);
                } else for(const t1 in i)this.deletedStates[e] && this.deletedStates[e][o] && null === this.deletedStates[e][o][t1] && delete this.deletedStates[e][o][t1];
            }
            removeFeatureState(e, t1, i) {
                if (null === this.deletedStates[e]) return;
                const o = String(t1);
                if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t1) null !== this.deletedStates[e][o] && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);
                else if (void 0 !== t1) if (this.stateChanges[e] && this.stateChanges[e][o]) for(i in this.deletedStates[e][o] = {}, this.stateChanges[e][o])this.deletedStates[e][o][i] = null;
                else this.deletedStates[e][o] = null;
                else this.deletedStates[e] = null;
            }
            getState(e, t1) {
                const i = this.state[e] || {}, o = this.stateChanges[e] || {}, s = this.deletedStates[e];
                if (null === s) return {};
                if (void 0 !== t1) {
                    const e = String(t1), r = Object.assign({}, i[e], o[e]);
                    if (s) {
                        const e = s[t1];
                        if (null === e) return {};
                        for(const t1 in e)delete r[t1];
                    }
                    return r;
                }
                const r = Object.assign({}, i, o);
                if (s) for(const e in s)delete r[e];
                return r;
            }
            initializeTileState(e, t1) {
                e.refreshFeatureState(t1);
            }
            coalesceChanges(e, t1) {
                const i = {};
                for(const e in this.stateChanges){
                    this.state[e] = this.state[e] || {};
                    const t1 = {};
                    for(const i in this.stateChanges[e])this.state[e][i] || (this.state[e][i] = {}), Object.assign(this.state[e][i], this.stateChanges[e][i]), t1[i] = this.state[e][i];
                    i[e] = t1;
                }
                for(const e in this.deletedStates){
                    this.state[e] = this.state[e] || {};
                    const t1 = {};
                    if (null === this.deletedStates[e]) for(const i in this.state[e])t1[i] = {}, this.state[e][i] = {};
                    else for(const i in this.deletedStates[e]){
                        if (null === this.deletedStates[e][i]) this.state[e][i] = {};
                        else if (this.state[e][i]) for (const t1 of Object.keys(this.deletedStates[e][i]))delete this.state[e][i][t1];
                        t1[i] = this.state[e][i];
                    }
                    i[e] = i[e] || {}, Object.assign(i[e], t1);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i).length) for(const i in e)e[i].refreshFeatureState(t1);
            }
        }
        class Ft extends e.E {
            constructor(e, t1, i){
                super(), this.id = e, this._onlySymbols = i, t1.on("data", (e)=>{
                    "source" === e.dataType && "metadata" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), t1.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = t1, this._tiles = {}, this._cache = new zt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Mt, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(e) {
                this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const e in this._tiles)if (!this._tiles[e].loaded()) return !1;
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const e = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(e, t1) {
                return e.isSymbolTile = this._onlySymbols, e.isExtraShadowCaster = this._shadowCasterTiles[e.tileID.key], this._source.loadTile(e, t1);
            }
            _unloadTile(e) {
                if (this._source.unloadTile) return this._source.unloadTile(e);
            }
            _abortTile(e) {
                if (this._source.abortTile) return this._source.abortTile(e);
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(e) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const t1 in this._tiles){
                    const i = this._tiles[t1];
                    i.upload(e, this.map ? this.map.painter : void 0), i.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
                }
            }
            getIds() {
                return Object.values(this._tiles).map((e)=>e.tileID).sort(Bt).map((e)=>e.key);
            }
            getRenderableIds(t1, i) {
                const o = [];
                for(const e in this._tiles)this._isIdRenderable(+e, t1, i) && o.push(this._tiles[e]);
                return t1 ? o.sort((t1, i)=>{
                    const o = t1.tileID, s = i.tileID, r = new e.P(o.canonical.x, o.canonical.y)._rotate(this.transform.angle), n = new e.P(s.canonical.x, s.canonical.y)._rotate(this.transform.angle);
                    return o.overscaledZ - s.overscaledZ || n.y - r.y || n.x - r.x;
                }).map((e)=>e.tileID.key) : o.map((e)=>e.tileID).sort(Bt).map((e)=>e.key);
            }
            hasRenderableParent(e) {
                const t1 = this.findLoadedParent(e, 0);
                return !!t1 && this._isIdRenderable(t1.tileID.key);
            }
            _isIdRenderable(e, t1, i) {
                return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t1 || !this._tiles[e].holdingForFade()) && (i || !this._shadowCasterTiles[e]);
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const e in this._tiles)"errored" !== this._tiles[e].state && this._reloadTile(+e, "reloading");
                }
            }
            _reloadTile(e, t1) {
                const i = this._tiles[e];
                i && ("loading" !== i.state && (i.state = t1), this._loadTile(i, this._tileLoaded.bind(this, i, e, t1)));
            }
            _tileLoaded(t1, i, o, s, r) {
                if (s) {
                    if (t1.state = "errored", 404 !== s.status) this._source.fire(new e.y(s, {
                        tile: t1
                    }));
                    else {
                        if (this._source.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "error",
                            sourceId: this._source.id,
                            tile: t1
                        })), !(t1.tileID.key in this._loadedParentTiles)) return;
                        if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                            const e = this.map.painter.terrain;
                            this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id);
                        } else this.update(this.transform);
                    }
                    return;
                }
                t1.timeAdded = e.o.now(), "expired" === o && (t1.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t1), "raster-dem" === this._source.type && t1.dem && this._backfillDEM(t1), this._state.initializeTileState(t1, this.map ? this.map.painter : null);
                let n = new Map;
                r && r.responseHeaders && (n = r.responseHeaders), this._source.fire(new e.z("data", {
                    dataType: "source",
                    tile: t1,
                    coord: t1.tileID,
                    sourceCacheId: this.id,
                    responseHeaders: n
                }));
            }
            _backfillDEM(e) {
                const t1 = this.getRenderableIds();
                for(let o = 0; o < t1.length; o++){
                    const s = t1[o];
                    if (e.neighboringTiles && e.neighboringTiles[s]) {
                        const t1 = this.getTileByID(s);
                        i(e, t1), i(t1, e);
                    }
                }
                function i(e, t1) {
                    if (!e.dem || e.dem.borderReady) return;
                    e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;
                    let i = t1.tileID.canonical.x - e.tileID.canonical.x;
                    const o = t1.tileID.canonical.y - e.tileID.canonical.y, s = Math.pow(2, e.tileID.canonical.z), r = t1.tileID.key;
                    0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + s) ? i += s : 1 === Math.abs(i - s) && (i -= s)), t1.dem && e.dem && (e.dem.backfillBorder(t1.dem, i, o), e.neighboringTiles && e.neighboringTiles[r] && (e.neighboringTiles[r].backfilled = !0)));
                }
            }
            getTile(e) {
                return this.getTileByID(e.key);
            }
            getTileByID(e) {
                return this._tiles[e];
            }
            _retainLoadedChildren(e, t1, i, o) {
                for(const s in this._tiles){
                    let r = this._tiles[s];
                    if (o[s] || !r.hasData() || r.tileID.overscaledZ <= t1 || r.tileID.overscaledZ > i) continue;
                    let n = r.tileID;
                    for(; r && r.tileID.overscaledZ > t1 + 1;){
                        const e = r.tileID.scaledTo(r.tileID.overscaledZ - 1);
                        r = this._tiles[e.key], r && r.hasData() && (n = e);
                    }
                    let a = n;
                    for(; a.overscaledZ > t1;)if (a = a.scaledTo(a.overscaledZ - 1), e[a.key]) {
                        o[n.key] = n;
                        break;
                    }
                }
            }
            findLoadedParent(e, t1) {
                if (e.key in this._loadedParentTiles) {
                    const i = this._loadedParentTiles[e.key];
                    return i && i.tileID.overscaledZ >= t1 ? i : null;
                }
                for(let i = e.overscaledZ - 1; i >= t1; i--){
                    const t1 = e.scaledTo(i), o = this._getLoadedTile(t1);
                    if (o) return o;
                }
            }
            _getLoadedTile(e) {
                const t1 = this._tiles[e.key];
                return t1 && t1.hasData() ? t1 : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);
            }
            updateCacheSize(e, t1) {
                t1 = t1 || this._source.tileSize;
                const i = Math.ceil(e.width / t1) + 1, o = Math.ceil(e.height / t1) + 1, s = Math.floor(i * o * 5), r = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s) : s, n = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r) : r;
                this._cache.setMaxSize(n);
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);
                if (this._prevLng = e, t1) {
                    const e = {};
                    for(const i in this._tiles){
                        const o = this._tiles[i];
                        o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t1), e[o.tileID.key] = o;
                    }
                    this._tiles = e;
                    for(const e in this._timers)clearTimeout(this._timers[e]), delete this._timers[e];
                    for(const e in this._tiles)this._setTileReloadTimer(+e, this._tiles[e]);
                }
            }
            update(t1, i, o, s, r) {
                if (this.transform = t1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !o) return;
                this.updateCacheSize(t1, i), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
                const n = "batched-model" === this._source.type;
                let a, l = this._source.maxzoom;
                const c = this.map && this.map.painter ? this.map.painter._terrain : null;
                if (c && c.sourceCache === this && c.attenuationRange()) {
                    const e = c.attenuationRange()[0], t1 = Math.floor(e) - Math.log2(c.getDemUpscale());
                    l > t1 && (l = t1);
                }
                if (this.used || this.usedForTerrain) {
                    if (this._source.tileID) a = t1.getVisibleUnwrappedCoordinates(this._source.tileID).map((t1)=>new e.aQ(t1.canonical.z, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y));
                    else if (0 !== this.tileCoverLift) {
                        const s = t1.clone();
                        s.tileCoverLift = this.tileCoverLift, a = s.coveringTiles({
                            tileSize: i || this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: l,
                            roundZoom: this._source.roundZoom && !o,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain,
                            calculateQuadrantVisibility: n
                        }), this._source.minzoom <= 1 && "globe" === t1.projection.name && (a.push(new e.aQ(1, 0, 1, 0, 0)), a.push(new e.aQ(1, 0, 1, 1, 0)), a.push(new e.aQ(1, 0, 1, 0, 1)), a.push(new e.aQ(1, 0, 1, 1, 1)));
                    } else if (a = t1.coveringTiles({
                        tileSize: i || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: l,
                        roundZoom: this._source.roundZoom && !o,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain,
                        calculateQuadrantVisibility: n
                    }), this._source.hasTile) {
                        const e = this._source.hasTile.bind(this._source);
                        a = a.filter((t1)=>e(t1));
                    }
                } else a = [];
                if (a.length > 0 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !kt(this._source.type)) {
                    const e = t1.coveringZoomLevel({
                        tileSize: i || this._source.tileSize,
                        roundZoom: this._source.roundZoom && !o
                    }), l = Math.min(e, this._source.maxzoom);
                    if (n) {
                        const e = t1.extendTileCover(a, l);
                        for (const t1 of e)a.push(t1);
                    } else if (r) {
                        const e = t1.extendTileCoverToNearPlane(a, this.transform.getFrustum(l), l);
                        for (const t1 of e)a.push(t1);
                    } else if (this.castsShadows && s) {
                        const e = t1.extendTileCover(a, l, s, 16);
                        for (const t1 of e)this._shadowCasterTiles[t1.key] = !0, a.push(t1);
                    }
                }
                const h = this._updateRetainedTiles(a);
                if (kt(this._source.type) && 0 !== a.length) {
                    const t1 = {}, i = {}, o = Object.keys(h);
                    for (const s of o){
                        const o = h[s], r = this._tiles[s];
                        if (!r || r.fadeEndTime && r.fadeEndTime <= e.o.now()) continue;
                        const n = this.findLoadedParent(o, Math.max(o.overscaledZ - Ft.maxOverzooming, this._source.minzoom));
                        n && (this._addTile(n.tileID), t1[n.tileID.key] = n.tileID), i[s] = o;
                    }
                    const s = a[a.length - 1].overscaledZ;
                    for(const e in this._tiles){
                        const t1 = this._tiles[e];
                        if (h[e] || !t1.hasData()) continue;
                        let o = t1.tileID;
                        for(; o.overscaledZ > s;){
                            o = o.scaledTo(o.overscaledZ - 1);
                            const s = this._tiles[o.key];
                            if (s && s.hasData() && i[o.key]) {
                                h[e] = t1.tileID;
                                break;
                            }
                        }
                    }
                    for(const e in t1)h[e] || (this._coveredTiles[e] = !0, h[e] = t1[e]);
                }
                for(const e in h)this._tiles[e].clearFadeHold();
                const d = e.bv(this._tiles, h);
                for (const e of d){
                    const t1 = this._tiles[e];
                    t1.hasSymbolBuckets && !t1.holdingForFade() ? t1.setHoldDuration(this.map._fadeDuration) : t1.hasSymbolBuckets && !t1.symbolFadeFinished() || this._removeTile(+e);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const e in this._tiles)this._tiles[e].holdingForFade() && this._removeTile(+e);
            }
            _updateRetainedTiles(e) {
                const t1 = {};
                if (0 === e.length) return t1;
                const i = {}, o = e.reduce((e, t1)=>Math.min(e, t1.overscaledZ), 1 / 0), s = e[0].overscaledZ, r = Math.max(s - Ft.maxOverzooming, this._source.minzoom), n = Math.max(s + Ft.maxUnderzooming, this._source.minzoom), a = {};
                for (const i of e){
                    const e = this._addTile(i);
                    t1[i.key] = i, e.hasData() || o < this._source.maxzoom && (a[i.key] = i);
                }
                this._retainLoadedChildren(a, o, n, t1);
                for (const o of e){
                    let e = this._tiles[o.key];
                    if (e.hasData()) continue;
                    if (o.canonical.z >= this._source.maxzoom) {
                        const e = o.children(this._source.maxzoom)[0], i = this.getTile(e);
                        if (i && i.hasData()) {
                            t1[e.key] = e;
                            continue;
                        }
                    } else {
                        const e = o.children(this._source.maxzoom);
                        if (t1[e[0].key] && t1[e[1].key] && t1[e[2].key] && t1[e[3].key]) continue;
                    }
                    let s = e.wasRequested();
                    for(let n = o.overscaledZ - 1; n >= r; --n){
                        const r = o.scaledTo(n);
                        if (i[r.key]) break;
                        if (i[r.key] = !0, e = this.getTile(r), !e && s && (e = this._addTile(r)), e && (t1[r.key] = r, s = e.wasRequested(), e.hasData())) break;
                    }
                }
                return t1;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const e in this._tiles){
                    const t1 = [];
                    let i, o = this._tiles[e].tileID;
                    for(; o.overscaledZ > 0;){
                        if (o.key in this._loadedParentTiles) {
                            i = this._loadedParentTiles[o.key];
                            break;
                        }
                        t1.push(o.key);
                        const e = o.scaledTo(o.overscaledZ - 1);
                        if (i = this._getLoadedTile(e), i) break;
                        o = e;
                    }
                    for (const e of t1)this._loadedParentTiles[e] = i;
                }
            }
            _addTile(t1) {
                let i = this._tiles[t1.key];
                if (i) return !0 !== i.isExtraShadowCaster || !!this._shadowCasterTiles[t1.key] || this._reloadTile(t1.key, "reloading"), i;
                i = this._cache.getAndRemove(t1), i && (this._setTileReloadTimer(t1.key, i), i.tileID = t1, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t1.key] && (clearTimeout(this._cacheTimers[t1.key]), delete this._cacheTimers[t1.key], this._setTileReloadTimer(t1.key, i)));
                const o = Boolean(i);
                if (!o) {
                    const e = this.map ? this.map.painter : null, o = this._source.tileSize * t1.overscaleFactor();
                    i = "raster-array" === this._source.type ? new Ot(t1, o, this.transform.tileZoom, e, this._isRaster) : new Pt(t1, o, this.transform.tileZoom, e, this._isRaster, this._source.worldview), this._loadTile(i, this._tileLoaded.bind(this, i, t1.key, i.state));
                }
                return i.uses++, this._tiles[t1.key] = i, o || this._source.fire(new e.z("dataloading", {
                    tile: i,
                    coord: i.tileID,
                    dataType: "source"
                })), i;
            }
            _setTileReloadTimer(e, t1) {
                e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
                const i = t1.getExpiryTimeout();
                i && (this._timers[e] = setTimeout(()=>{
                    this._reloadTile(e, "expired"), delete this._timers[e];
                }, i));
            }
            _removeTile(e) {
                const t1 = this._tiles[e];
                t1 && (t1.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t1.uses > 0 || (t1.hasData() && "reloading" !== t1.state || "empty" === t1.state ? this._cache.add(t1.tileID, t1, t1.getExpiryTimeout()) : (t1.aborted = !0, this._abortTile(t1), this._unloadTile(t1))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const e in this._tiles)this._removeTile(+e);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t1, i, o) {
                const s = [], r = this.transform;
                if (!r) return s;
                const n = "globe" === r.projection.name, a = e.aF(r.center.lng);
                for(const l in this._tiles){
                    const c = this._tiles[l];
                    if (o && c.clearQueryDebugViz(), c.holdingForFade()) continue;
                    let h;
                    if (n) {
                        const t1 = c.tileID.canonical;
                        if (0 === t1.z) {
                            const i = [
                                Math.abs(e.aA(a, ...Nt(t1, -1)) - a),
                                Math.abs(e.aA(a, ...Nt(t1, 1)) - a)
                            ];
                            h = [
                                0,
                                2 * i.indexOf(Math.min(...i)) - 1
                            ];
                        } else {
                            const i = [
                                Math.abs(e.aA(a, ...Nt(t1, -1)) - a),
                                Math.abs(e.aA(a, ...Nt(t1, 0)) - a),
                                Math.abs(e.aA(a, ...Nt(t1, 1)) - a)
                            ];
                            h = [
                                i.indexOf(Math.min(...i)) - 1
                            ];
                        }
                    } else h = [
                        0
                    ];
                    for (const e of h){
                        const o = t1.containsTile(c, r, i, e);
                        o && s.push(o);
                    }
                }
                return s;
            }
            getShadowCasterCoordinates() {
                return this._getRenderableCoordinates(!1, !0);
            }
            getVisibleCoordinates(e) {
                return this._getRenderableCoordinates(e);
            }
            _getRenderableCoordinates(e, t1) {
                const i = this.getRenderableIds(e, t1).map((e)=>this._tiles[e].tileID), o = "globe" === this.transform.projection.name;
                for (const e of i)e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped()), e.expandedProjMatrix = o ? this.transform.calculateProjMatrix(e.toUnwrapped(), !1, !0) : e.projMatrix;
                return i;
            }
            sortCoordinatesByDistance(e) {
                const t1 = e.slice(), i = this.transform._camera.position, o = this.transform._camera.forward(), s = {};
                for (const e of t1){
                    const t1 = 1 / (1 << e.canonical.z);
                    s[e.key] = ((e.canonical.x + .5) * t1 + e.wrap - i[0]) * o[0] + ((e.canonical.y + .5) * t1 - i[1]) * o[1] - i[2] * o[2];
                }
                return t1.sort((e, t1)=>s[e.key] - s[t1.key]), t1;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (kt(this._source.type)) for(const t1 in this._tiles){
                    const i = this._tiles[t1];
                    if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.o.now()) return !0;
                }
                return !1;
            }
            setFeatureState(e, t1, i) {
                this._state.updateState(e = e || "_geojsonTileLayer", t1, i);
            }
            removeFeatureState(e, t1, i) {
                this._state.removeFeatureState(e = e || "_geojsonTileLayer", t1, i);
            }
            getFeatureState(e, t1) {
                return this._state.getState(e = e || "_geojsonTileLayer", t1);
            }
            setDependencies(e, t1, i) {
                const o = this._tiles[e];
                o && o.setDependencies(t1, i);
            }
            reloadTilesForDependencies(e, t1) {
                for(const i in this._tiles)this._tiles[i].hasDependency(e, t1) && this._reloadTile(+i, "reloading");
                this._cache.filter((i)=>!i.hasDependency(e, t1));
            }
            _preloadTiles(t1, i) {
                if (!this._sourceLoaded) {
                    const e = ()=>{
                        this._sourceLoaded && (this._source.off("data", e), this._preloadTiles(t1, i));
                    };
                    return void this._source.on("data", e);
                }
                const o = new Map, s = Array.isArray(t1) ? t1 : [
                    t1
                ], r = this.map.painter.terrain, n = this.usedForTerrain && r ? r.getScaledDemTileSize() : this._source.tileSize;
                for (const e of s){
                    const t1 = e.coveringTiles({
                        tileSize: n,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const e of t1)o.set(e.key, e);
                    this.usedForTerrain && e.updateElevation(!1);
                }
                const a = Array.from(o.values());
                e.bw(a, (e, t1)=>{
                    const i = new Pt(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster, this._source.worldview);
                    this._loadTile(i, (e)=>{
                        "raster-dem" === this._source.type && i.dem && this._backfillDEM(i), t1(e, i);
                    });
                }, i);
            }
        }
        function Bt(e, t1) {
            const i = Math.abs(2 * e.wrap) - +(e.wrap < 0), o = Math.abs(2 * t1.wrap) - +(t1.wrap < 0);
            return e.overscaledZ - t1.overscaledZ || o - i || t1.canonical.y - e.canonical.y || t1.canonical.x - e.canonical.x;
        }
        function kt(e) {
            return "raster" === e || "image" === e || "video" === e || "custom" === e;
        }
        function Nt(e, t1) {
            const i = 1 << e.z;
            return [
                e.x / i + t1,
                (e.x + 1) / i + t1
            ];
        }
        Ft.maxOverzooming = 10, Ft.maxUnderzooming = 3;
        class Ut {
            constructor(e){
                this.style = e, this.layersGotHidden = !1, this.layers = [];
            }
            processLayersChanged() {
                this.layers = [];
                const e = !1, t1 = !1;
                for(const i in this.style._mergedLayers){
                    const o = this.style._mergedLayers[i];
                    if ("fill-extrusion" === o.type || "building" === o.type) this.layers.push({
                        layer: o,
                        visible: e,
                        visibilityChanged: t1
                    });
                    else if ("model" === o.type) {
                        const i = this.style.getLayerSource(o);
                        i && "batched-model" === i.type && this.layers.push({
                            layer: o,
                            visible: e,
                            visibilityChanged: t1
                        });
                    }
                }
            }
            onNewFrame(e) {
                this.layersGotHidden = !1;
                for (const t1 of this.layers){
                    const i = t1.layer;
                    let o = !1;
                    "fill-extrusion" === i.type ? o = !i.isHidden(e) && i.paint.get("fill-extrusion-opacity") > 0 : "building" === i.type ? o = !i.isHidden(e) && i.paint.get("building-opacity") > 0 : "model" === i.type && (o = !i.isHidden(e) && i.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o && t1.visible, t1.visible = o;
                }
            }
            updateZOffset(e, t1) {
                this.currentBuildingBuckets = [];
                for (const e of this.layers){
                    const i = e.layer, o = this.style.getLayerSourceCache(i);
                    let s = 1;
                    "fill-extrusion" === i.type ? s = e.visible ? i.paint.get("fill-extrusion-vertical-scale") : 0 : "building" === i.type && (s = e.visible ? i.paint.get("building-vertical-scale") : 0);
                    let r = o ? o.getTile(t1) : null;
                    if (!r && o) for(const e in o._tiles){
                        const i = o._tiles[e];
                        if (t1.canonical.isChildOf(i.tileID.canonical)) {
                            r = i;
                            break;
                        }
                    }
                    this.currentBuildingBuckets.push({
                        bucket: r ? r.getBucket(i) : null,
                        tileID: r ? r.tileID : t1,
                        verticalScale: s
                    });
                }
                e.hasAnyZOffset = !1;
                let i = !1;
                for(let o = 0; o < e.symbolInstances.length; o++){
                    const s = e.symbolInstances.get(o), r = s.zOffset, n = this._getHeightAtTileOffset(t1, s.tileAnchorX, s.tileAnchorY);
                    s.zOffset = n !== Number.NEGATIVE_INFINITY ? n : r, i || r === s.zOffset || (i = !0), e.hasAnyZOffset || 0 === s.zOffset || (e.hasAnyZOffset = !0);
                }
                i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);
            }
            _mapCoordToOverlappingTile(t1, i, o, s) {
                let r = i, n = o;
                if (t1.canonical.z !== s.canonical.z) {
                    const a = s.canonical, l = 1 / (1 << t1.canonical.z - a.z);
                    r = (i + t1.canonical.x * e.al) * l - a.x * e.al | 0, n = (o + t1.canonical.y * e.al) * l - a.y * e.al | 0;
                }
                return {
                    tileX: r,
                    tileY: n
                };
            }
            _getHeightAtTileOffset(e, t1, i) {
                let o, s;
                for(let r = 0; r < this.layers.length; ++r){
                    const n = this.layers[r].layer;
                    if ("fill-extrusion" !== n.type && "building" !== n.type) continue;
                    const { bucket: a, tileID: l, verticalScale: c } = this.currentBuildingBuckets[r];
                    if (!a) continue;
                    const { tileX: h, tileY: d } = this._mapCoordToOverlappingTile(e, t1, i, l), u = a.getHeightAtTileCoord(h, d);
                    u && void 0 !== u.height && (u.hidden ? o = u.height : s = Math.max(u.height * c, s || 0));
                }
                if (void 0 !== s) return s;
                for(let s = 0; s < this.layers.length; ++s){
                    const r = this.layers[s];
                    if ("model" !== r.layer.type || !r.visible) continue;
                    const { bucket: n, tileID: a } = this.currentBuildingBuckets[s];
                    if (!n) continue;
                    const { tileX: l, tileY: c } = this._mapCoordToOverlappingTile(e, t1, i, a), h = n.getHeightAtTileCoord(l, c);
                    if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : h.height ? h.height * h.verticalScale : Number.NEGATIVE_INFINITY;
                }
                return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
            }
        }
        function jt(t1, i) {
            const o = {};
            for(const e in t1)"ref" !== e && (o[e] = t1[e]);
            return e.bx.forEach((e)=>{
                e in i && (o[e] = i[e]);
            }), o;
        }
        function Vt(e) {
            e = e.slice();
            const t1 = Object.create(null);
            for(let i = 0; i < e.length; i++)t1[e[i].id] = e[i];
            for(let i = 0; i < e.length; i++)"ref" in e[i] && (e[i] = jt(e[i], t1[e[i].ref]));
            return e;
        }
        const Gt = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setSlot: "setSlot",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setSnow: "setSnow",
            setRain: "setRain",
            setCamera: "setCamera",
            setLights: "setLights",
            setProjection: "setProjection",
            addImport: "addImport",
            removeImport: "removeImport",
            updateImport: "updateImport",
            addIconset: "addIconset",
            removeIconset: "removeIconset"
        };
        function Ht(e, t1, i) {
            i.push({
                command: Gt.addSource,
                args: [
                    e,
                    t1[e]
                ]
            });
        }
        function qt(e, t1, i) {
            t1.push({
                command: Gt.removeSource,
                args: [
                    e
                ]
            }), i[e] = !0;
        }
        function Zt(e, t1, i, o) {
            qt(e, i, o), Ht(e, t1, i);
        }
        function Wt(t1, i, o) {
            let s;
            for(s in t1[o])if (t1[o].hasOwnProperty(s) && "data" !== s && !e.by(t1[o][s], i[o][s])) return !1;
            for(s in i[o])if (i[o].hasOwnProperty(s) && "data" !== s && !e.by(t1[o][s], i[o][s])) return !1;
            return !0;
        }
        function $t(t1, i, o, s, r, n) {
            let a;
            for(a in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(a) && (e.by(t1[a], i[a]) || o.push({
                command: n,
                args: [
                    s,
                    a,
                    i[a],
                    r
                ]
            }));
            for(a in i)i.hasOwnProperty(a) && !t1.hasOwnProperty(a) && (e.by(t1[a], i[a]) || o.push({
                command: n,
                args: [
                    s,
                    a,
                    i[a],
                    r
                ]
            }));
        }
        function Xt(e) {
            return e.id;
        }
        function Yt(e, t1) {
            return e[t1.id] = t1, e;
        }
        function Kt(t1, i, o) {
            const s = i.createTileMatrix(t1, t1.worldSize, o.toUnwrapped());
            return e.aB(new Float32Array(16), t1.projMatrix, s);
        }
        function Jt(e, t1, i) {
            if (t1.projection.name === i.projection.name) return e.projMatrix;
            const o = i.clone();
            return o.setProjection(t1.projection), Kt(o, t1.getProjection(), e);
        }
        function Qt(e, t1, i) {
            return t1.name === i.projection.name ? e.projMatrix : Kt(i, t1, e);
        }
        class ei {
            constructor(e, t1){
                this.reset(e, t1);
            }
            reset(e, t1) {
                this.points = e || [], this._distances = [
                    0
                ];
                for(let e = 1; e < this.points.length; e++)this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t1) {
                if (1 === this.points.length) return this.points[0];
                t1 = e.aA(t1, 0, 1);
                let i = 1, o = this._distances[i];
                const s = t1 * this.paddedLength + this.padding;
                for(; o < s && i < this._distances.length;)o = this._distances[++i];
                const r = i - 1, n = this._distances[r], a = o - n, l = a > 0 ? (s - n) / a : 0;
                return this.points[r].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        class ti {
            constructor(e, t1, i){
                const o = this.boxCells = [], s = this.circleCells = [];
                this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t1 / i);
                for(let e = 0; e < this.xCellCount * this.yCellCount; e++)o.push([]), s.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t1, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e, t1, i, o, s) {
                this._forEachCell(t1, i, o, s, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(s);
            }
            insertCircle(e, t1, i, o) {
                this._forEachCell(t1 - o, i - o, t1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e, t1, i, o, s, r) {
                this.boxCells[s].push(r);
            }
            _insertCircleCell(e, t1, i, o, s, r) {
                this.circleCells[s].push(r);
            }
            _query(e, t1, i, o, s, r) {
                if (i < 0 || e > this.width || o < 0 || t1 > this.height) return !s && [];
                const n = [];
                if (e <= 0 && t1 <= 0 && this.width <= i && this.height <= o) {
                    if (s) return !0;
                    for(let e = 0; e < this.boxKeys.length; e++)n.push({
                        key: this.boxKeys[e],
                        x1: this.bboxes[4 * e],
                        y1: this.bboxes[4 * e + 1],
                        x2: this.bboxes[4 * e + 2],
                        y2: this.bboxes[4 * e + 3]
                    });
                    for(let e = 0; e < this.circleKeys.length; e++){
                        const t1 = this.circles[3 * e], i = this.circles[3 * e + 1], o = this.circles[3 * e + 2];
                        n.push({
                            key: this.circleKeys[e],
                            x1: t1 - o,
                            y1: i - o,
                            x2: t1 + o,
                            y2: i + o
                        });
                    }
                    return r ? n.filter(r) : n;
                }
                return this._forEachCell(e, t1, i, o, this._queryCell, n, {
                    hitTest: s,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, r), s ? n.length > 0 : n;
            }
            _queryCircle(e, t1, i, o, s) {
                const r = e - i, n = e + i, a = t1 - i, l = t1 + i;
                if (n < 0 || r > this.width || l < 0 || a > this.height) return !o && [];
                const c = [];
                return this._forEachCell(r, a, n, l, this._queryCellCircle, c, {
                    hitTest: o,
                    circle: {
                        x: e,
                        y: t1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, s), o ? c.length > 0 : c;
            }
            query(e, t1, i, o, s) {
                return this._query(e, t1, i, o, !1, s);
            }
            hitTest(e, t1, i, o, s) {
                return this._query(e, t1, i, o, !0, s);
            }
            hitTestCircle(e, t1, i, o) {
                return this._queryCircle(e, t1, i, !0, o);
            }
            _queryCell(e, t1, i, o, s, r, n, a) {
                const l = n.seenUids, c = this.boxCells[s];
                if (null !== c) {
                    const s = this.bboxes;
                    for (const h of c)if (!l.box[h]) {
                        l.box[h] = !0;
                        const c = 4 * h;
                        if (e <= s[c + 2] && t1 <= s[c + 3] && i >= s[c + 0] && o >= s[c + 1] && (!a || a(this.boxKeys[h]))) {
                            if (n.hitTest) return r.push(!0), !0;
                            r.push({
                                key: this.boxKeys[h],
                                x1: s[c],
                                y1: s[c + 1],
                                x2: s[c + 2],
                                y2: s[c + 3]
                            });
                        }
                    }
                }
                const h = this.circleCells[s];
                if (null !== h) {
                    const s = this.circles;
                    for (const c of h)if (!l.circle[c]) {
                        l.circle[c] = !0;
                        const h = 3 * c;
                        if (this._circleAndRectCollide(s[h], s[h + 1], s[h + 2], e, t1, i, o) && (!a || a(this.circleKeys[c]))) {
                            if (n.hitTest) return r.push(!0), !0;
                            {
                                const e = s[h], t1 = s[h + 1], i = s[h + 2];
                                r.push({
                                    key: this.circleKeys[c],
                                    x1: e - i,
                                    y1: t1 - i,
                                    x2: e + i,
                                    y2: t1 + i
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e, t1, i, o, s, r, n, a) {
                const l = n.circle, c = n.seenUids, h = this.boxCells[s];
                if (null !== h) {
                    const e = this.bboxes;
                    for (const t1 of h)if (!c.box[t1]) {
                        c.box[t1] = !0;
                        const i = 4 * t1;
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t1]))) return r.push(!0), !0;
                    }
                }
                const d = this.circleCells[s];
                if (null !== d) {
                    const e = this.circles;
                    for (const t1 of d)if (!c.circle[t1]) {
                        c.circle[t1] = !0;
                        const i = 3 * t1;
                        if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t1]))) return r.push(!0), !0;
                    }
                }
            }
            _forEachCell(e, t1, i, o, s, r, n, a) {
                const l = this._convertToXCellCoord(e), c = this._convertToYCellCoord(t1), h = this._convertToXCellCoord(i), d = this._convertToYCellCoord(o);
                for(let u = l; u <= h; u++)for(let l = c; l <= d; l++)if (s.call(this, e, t1, i, o, this.xCellCount * l + u, r, n, a)) return;
            }
            _convertToXCellCoord(e) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
            }
            _convertToYCellCoord(e) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
            }
            _circlesCollide(e, t1, i, o, s, r) {
                const n = o - e, a = s - t1, l = i + r;
                return l * l > n * n + a * a;
            }
            _circleAndRectCollide(e, t1, i, o, s, r, n) {
                const a = (r - o) / 2, l = Math.abs(e - (o + a));
                if (l > a + i) return !1;
                const c = (n - s) / 2, h = Math.abs(t1 - (s + c));
                if (h > c + i) return !1;
                if (l <= a || h <= c) return !0;
                const d = l - a, u = h - c;
                return d * d + u * u <= i * i;
            }
        }
        const ii = Math.tan(85 * Math.PI / 180);
        function oi(t1, i, o, s, r, n, a) {
            const l = e.bC();
            if (o) if ("globe" === n.name) {
                const t1 = e.bD(r, i);
                e.aB(l, l, t1);
            } else {
                const t1 = e.bE([], a);
                l[0] = t1[0], l[1] = t1[1], l[4] = t1[2], l[5] = t1[3], s || e.bB(l, l, r.angle);
            }
            else e.aB(l, r.labelPlaneMatrix, t1);
            return l;
        }
        function si(e, t1, i, o, s, r, n) {
            const a = oi(e, t1, i, o, s, r, n);
            return "globe" === r.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;
        }
        function ri(t1, i, o, s, r, n, a) {
            if (o) {
                if ("globe" === n.name) {
                    const l = oi(t1, i, o, s, r, n, a);
                    return e.bl(l, l), e.aB(l, t1, l), l;
                }
                {
                    const i = e.bz(t1), o = e.bA([]);
                    return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.aB(i, i, o), s || e.bB(i, i, -r.angle), i;
                }
            }
            return r.glCoordMatrix;
        }
        function ni(t1, i, o, s) {
            const r = [
                t1,
                i,
                o,
                1
            ];
            o ? e.aC(r, r, s) : gi(r, r, s);
            const n = r[3];
            return r[0] /= n, r[1] /= n, r[2] /= n, r;
        }
        function ai(e, t1) {
            return Math.min(.5 + e / t1 * .5, 1.5);
        }
        function li(e, t1) {
            const i = e[0] / e[3], o = e[1] / e[3];
            return i >= -t1[0] && i <= t1[0] && o >= -t1[1] && o <= t1[1];
        }
        function ci(t1, i, o, s, r, n, a, l, c, h, d = 1) {
            const u = o.transform, _ = s ? t1.textSizeData : t1.iconSizeData, p = e.bK(_, o.transform.zoom, d), f = "globe" === u.projection.name, m = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], g = s ? t1.text.dynamicLayoutVertexArray : t1.icon.dynamicLayoutVertexArray;
            g.clear();
            let v = null;
            f && (v = s ? t1.text.globeExtVertexArray : t1.icon.globeExtVertexArray);
            const y = t1.lineVertexArray, x = s ? t1.text.placedSymbolArray : t1.icon.placedSymbolArray, b = o.transform.width / o.transform.height;
            let w, T = !1;
            for(let s = 0; s < x.length; s++){
                const d = x.get(s), { numGlyphs: f, writingMode: E } = d;
                if (E !== e.bL.vertical || T || w === e.bL.horizontal || (T = !0), w = E, (d.hidden || E === e.bL.vertical) && !T) {
                    mi(f, g);
                    continue;
                }
                T = !1;
                const S = new e.P(d.tileAnchorX, d.tileAnchorY), I = "road" === t1.elevationType, C = !!u.elevation || I;
                let { x: R, y: A, z: L } = u.projection.projectTilePoint(S.x, S.y, h.canonical), D = null;
                if (C) {
                    const e = I ? t1.getElevationFeatureForText(s) : null;
                    D = {
                        getElevation: c,
                        elevation: u.elevation,
                        elevationFeature: e
                    };
                    const [i, o, r] = c(S, u.elevation, e);
                    R += i, A += o, L += r;
                }
                const P = [
                    R,
                    A,
                    L,
                    1
                ];
                if (e.aC(P, P, i), !li(P, m)) {
                    mi(f, g);
                    continue;
                }
                const O = P[3], z = ai(o.transform.getCameraToCenterDistance(u.projection), O), M = e.bM(_, p, d), F = a ? M / z : M * z, B = ni(R, A, L, r);
                if (B[3] <= 0) {
                    mi(f, g);
                    continue;
                }
                let k = {};
                const N = e.an(t1.layers[0].layout.get("text-max-angle")), U = Math.cos(N), j = a ? null : D, V = ui(d, F, !1, l, i, r, n, t1.glyphOffsetArray, y, g, v, B, S, k, b, j, u.projection, h, a, U);
                T = V.useVertical, j && V.needsFlipping && (k = {}), (V.notEnoughRoom || T || V.needsFlipping && ui(d, F, !0, l, i, r, n, t1.glyphOffsetArray, y, g, v, B, S, k, b, j, u.projection, h, a, U).notEnoughRoom) && mi(f, g);
            }
            s ? (t1.text.dynamicLayoutVertexBuffer.updateData(g), v && t1.text.globeExtVertexBuffer && t1.text.globeExtVertexBuffer.updateData(v)) : (t1.icon.dynamicLayoutVertexBuffer.updateData(g), v && t1.icon.globeExtVertexBuffer && t1.icon.globeExtVertexBuffer.updateData(v));
        }
        function hi(e, t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m) {
            const { lineStartIndex: g, glyphStartIndex: v, segment: y } = a, x = v + a.numGlyphs, b = g + a.lineLength, w = t1.getoffsetX(v), T = t1.getoffsetX(x - 1), E = fi(e * w, i, o, s, r, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);
            if (!E) return null;
            const S = fi(e * T, i, o, s, r, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);
            return S ? {
                first: E,
                last: S
            } : null;
        }
        function di(t1, i, o, s) {
            return t1 === e.bL.horizontal && Math.abs(s) > Math.abs(o) ? {
                useVertical: !0
            } : t1 === e.bL.vertical ? s > 0 ? {
                needsFlipping: !0
            } : null : 0 !== i && function(e, t1) {
                return 0 === e || Math.abs(t1 / e) > ii;
            }(o, s) ? 1 === i ? {
                needsFlipping: !0
            } : null : o < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function ui(t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {
            const b = i / 24, w = t1.lineOffsetX * b, T = t1.lineOffsetY * b, { lineStartIndex: E, glyphStartIndex: S, numGlyphs: I, segment: C, writingMode: R, flipState: A } = t1, L = E + t1.lineLength, D = (t1)=>{
                if (d) {
                    const [i, o, s] = t1.up, r = h.length;
                    e.bN(d, r + 0, i, o, s), e.bN(d, r + 1, i, o, s), e.bN(d, r + 2, i, o, s), e.bN(d, r + 3, i, o, s);
                }
                const [i, o, s] = t1.point;
                e.bO(h, i, o, s, t1.angle);
            };
            if (I > 1) {
                const e = hi(b, l, w, T, o, u, _, t1, c, n, p, m, !1, g, v, y, x);
                if (!e) return {
                    notEnoughRoom: !0
                };
                if (s && !o) {
                    let [i, o, s] = e.first.point, [r, n, l] = e.last.point;
                    [i, o] = ni(i, o, s, a), [r, n] = ni(r, n, l, a);
                    const c = di(R, A, (r - i) * f, n - o);
                    if (t1.flipState = c && c.needsFlipping ? 1 : 2, c) return c;
                }
                D(e.first);
                for(let e = S + 1; e < S + I - 1; e++){
                    const t1 = fi(b * l.getoffsetX(e), w, T, o, u, _, C, E, L, c, n, p, m, !1, !1, g, v, y, x);
                    if (!t1) return h.length -= 4 * (e - S), {
                        notEnoughRoom: !0
                    };
                    D(t1);
                }
                D(e.last);
            } else {
                if (s && !o) {
                    const i = ni(_.x, _.y, 0, r), o = E + C + 1, s = new e.P(c.getx(o), c.gety(o)), n = ni(s.x, s.y, 0, r), a = n[3] > 0 ? n : pi(_, s, i, 1, r, void 0, g, v.canonical), l = di(R, A, (a[0] - i[0]) * f, a[1] - i[1]);
                    if (t1.flipState = l && l.needsFlipping ? 1 : 2, l) return l;
                }
                const i = fi(b * l.getoffsetX(S), w, T, o, u, _, C, E, L, c, n, p, m, !1, !1, g, v, y, x);
                if (!i) return {
                    notEnoughRoom: !0
                };
                D(i);
            }
            return {};
        }
        function _i(e, t1, i, o, s) {
            const { x: r, y: n, z: a } = o.projectTilePoint(e.x, e.y, t1);
            if (!s) return ni(r, n, a, i);
            const [l, c, h] = s.getElevation(e, s.elevation, s.elevationFeature);
            return ni(r + l, n + c, a + h, i);
        }
        function pi(t1, i, o, s, r, n, a, l) {
            const c = _i(t1.sub(i)._unit()._add(t1), l, r, a, n);
            return e.av(c, o, c), e.aw(c, c), e.bH(c, o, c, s);
        }
        function fi(t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y) {
            const x = s ? t1 - i : t1 + i;
            let b = x > 0 ? 1 : -1, w = 0;
            s && (b *= -1, w = Math.PI), b < 0 && (w += Math.PI);
            let T = l + a + (b > 0 ? 0 : 1) | 0, E = r, S = r, I = 0, C = 0;
            const R = Math.abs(x), A = [], L = [];
            let D = n, P = D, O = e.bF([]);
            const z = ()=>pi(P, D, S, R - I + 1, d, _, m, g.canonical);
            for(; I + C <= R;){
                if (T += b, T < l || T >= c) return null;
                if (S = E, P = D, A.push(S), p && L.push(P), D = new e.P(h.getx(T), h.gety(T)), E = u[T], !E) {
                    const e = _i(D, g.canonical, d, m, _);
                    E = e[3] > 0 ? u[T] = e : z();
                }
                I += C;
                const t1 = e.av([], E, S), i = e.bG(S, E);
                if (o && i > 0 && C > 0 && e.bJ(O, t1) / (C * i) < y) return null;
                C = i, O = t1;
            }
            f && _ && (u[T] && (E = z(), C = e.bG(S, E), O = e.av([], E, S)), u[T] = E);
            const M = (R - I) / C, F = D.sub(P)._mult(M)._add(P), B = e.bH([], S, O, M);
            let k = [
                0,
                0,
                1
            ], N = O[0], U = O[1];
            if (v && (k = m.upVector(g.canonical, F.x, F.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
                const t1 = [
                    k[2],
                    0,
                    -k[0]
                ], i = e.bI([], k, t1);
                e.aw(t1, t1), e.aw(i, i), N = e.bJ(O, t1), U = e.bJ(O, i);
            }
            if (o) {
                const t1 = e.bI([], k, O);
                e.aw(t1, t1), e.bH(B, B, t1, o * b);
            }
            const j = w + Math.atan2(U, N);
            return A.push(B), p && L.push(F), {
                point: B,
                angle: j,
                path: A,
                tilePath: L,
                up: k
            };
        }
        function mi(e, t1) {
            const i = t1.length, o = i + 4 * e;
            t1.resize(o), t1.float32.fill(-1 / 0, 4 * i, 4 * o);
        }
        function gi(e, t1, i) {
            const o = t1[0], s = t1[1];
            return e[0] = i[0] * o + i[4] * s + i[12], e[1] = i[1] * o + i[5] * s + i[13], e[3] = i[3] * o + i[7] * s + i[15], e;
        }
        const vi = 100;
        class yi {
            constructor(e, t1, i = new ti(e.width + 200, e.height + 200, 25), o = new ti(e.width + 200, e.height + 200, 25)){
                this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + vi, this.screenBottomBoundary = e.height + vi, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t1;
            }
            placeCollisionBox(t1, i, o, s, r, n, a, l, c, h, d) {
                let u = o.projectedAnchorX, _ = o.projectedAnchorY, p = o.projectedAnchorZ;
                const f = o.tileAnchorX, m = o.tileAnchorY, g = o.elevation, v = o.tileID, y = t1.getProjection();
                if (g && v) {
                    const [e, t1, i] = y.upVector(v.canonical, o.tileAnchorX, o.tileAnchorY), s = y.upVectorScale(v.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    u += e * g * s, _ += t1 * g * s, p += i * g * s;
                }
                const x = "globe" === t1.projection.name, b = "globe" === t1.projection.name ? e.aj(this.transform.zoom) : 0;
                if (v && x && b < 1 && !n) {
                    const t1 = 1 << v.canonical.z, i = e.bP(f, m);
                    e.bQ(i, i, 1 / e.al), e.bR(i, i, e.bP(v.canonical.x, v.canonical.y)), e.bQ(i, i, 1 / t1), e.bS(i, i, e.bP(s[0], s[1])), i[0] = e.bT(i[0], -.5, .5), e.bQ(i, i, e.al);
                    const o = e.bU(i[0], i[1], e.al / (2 * Math.PI), 1);
                    e.aC(o, o, r), u = e.ak(u, o[0], b), _ = e.ak(_, o[1], b), p = e.ak(p, o[2], b);
                }
                const w = this.projectAndGetPerspectiveRatio(h, u, _, p, o.tileID, "globe" === y.name || !!g || this.transform.pitch > 0, y), T = c * w.perspectiveRatio, E = (o.x1 * i + a.x - o.padding) * T + w.point.x, S = (o.y1 * i + a.y - o.padding) * T + w.point.y, I = (o.x2 * i + a.x + o.padding) * T + w.point.x, C = (o.y2 * i + a.y + o.padding) * T + w.point.y, R = w.perspectiveRatio <= .55 || w.occluded;
                return !this.isInsideGrid(E, S, I, C) || !l && this.grid.hitTest(E, S, I, C, d) || R ? {
                    box: [],
                    offscreen: !1,
                    occluded: w.occluded
                } : {
                    box: [
                        E,
                        S,
                        I,
                        C
                    ],
                    offscreen: this.isOffscreen(E, S, I, C),
                    occluded: !1
                };
            }
            placeCollisionCircles(t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m) {
                const g = [], v = this.transform.elevation, y = t1.getProjection(), x = "road" === t1.elevationType, b = !!v || x, w = e.bV.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, y), T = new e.P(o.tileAnchorX, o.tileAnchorY), E = new e.P(o.tileAnchorX, o.tileAnchorY);
                let { x: S, y: I, z: C } = y.projectTilePoint(E.x, E.y, m.canonical), R = null;
                if (b) {
                    const e = x ? t1.getElevationFeatureForText(s) : null;
                    R = {
                        getElevation: w,
                        elevation: v,
                        elevationFeature: e
                    };
                    const [i, o, r] = w(T, v, e);
                    S += i, I += o, C += r;
                }
                const A = "globe" === y.name, L = this.projectAndGetPerspectiveRatio(l, S, I, C, m, A || !!v || this.transform.pitch > 0, y), { perspectiveRatio: D } = L, P = (u ? a / D : a * D) / e.bY, O = ni(S, I, C, c), z = o.lineOffsetX * P, M = o.lineOffsetY * P, F = e.an(t1.layers[0].layout.get("text-max-angle")), B = Math.cos(F), k = L.signedDistanceFromCamera > 0 ? hi(P, n, z, M, x && 1 === o.flipState, O, E, o, r, c, {}, b && !u ? R : null, u && b, y, m, u, B) : null;
                let N = !1, U = !1, j = !0;
                if (k && !L.occluded) {
                    const t1 = .5 * p * D + f, o = new e.P(-100, -100), s = new e.P(this.screenRightBoundary, this.screenBottomBoundary), r = new ei, { first: n, last: a } = k, l = n.path.length;
                    let c = [];
                    for(let e = l - 1; e >= 1; e--)c.push(n.path[e]);
                    for(let e = 1; e < a.path.length; e++)c.push(a.path[e]);
                    const u = 2.5 * t1;
                    h && (c = c.map(([e, t1, i], o)=>(b && !A && (i = w(o < l - 1 ? n.tilePath[l - 1 - o] : a.tilePath[o - l + 2], v, R.elevationFeature)[2]), ni(e, t1, i, h))), c.some((e)=>e[3] <= 0) && (c = []));
                    let m = [];
                    if (c.length > 0) {
                        let t1 = 1 / 0, i = -1 / 0, r = 1 / 0, n = -1 / 0;
                        for (const e of c)t1 = Math.min(t1, e[0]), r = Math.min(r, e[1]), i = Math.max(i, e[0]), n = Math.max(n, e[1]);
                        i >= o.x && t1 <= s.x && n >= o.y && r <= s.y && (m = [
                            c.map((t1)=>new e.P(t1[0], t1[1]))
                        ], (t1 < o.x || i > s.x || r < o.y || n > s.y) && (m = e.bW(m, o.x, o.y, s.x, s.y)));
                    }
                    for (const e of m){
                        r.reset(e, .25 * t1);
                        let o = 0;
                        o = r.length <= .5 * t1 ? 1 : Math.ceil(r.paddedLength / u) + 1;
                        for(let e = 0; e < o; e++){
                            const s = e / Math.max(o - 1, 1), n = r.lerp(s), a = n.x + vi, l = n.y + vi;
                            g.push(a, l, t1, 0);
                            const c = a - t1, h = l - t1, u = a + t1, p = l + t1;
                            if (j = j && this.isOffscreen(c, h, u, p), U = U || this.isInsideGrid(c, h, u, p), !i && this.grid.hitTestCircle(a, l, t1, _) && (N = !0, !d)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: N,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !d && N || !U ? [] : g,
                    offscreen: j,
                    collisionDetected: N,
                    occluded: L.occluded
                };
            }
            queryRenderedSymbols(t1) {
                if (0 === t1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, s = 1 / 0, r = -1 / 0, n = -1 / 0;
                for (const a of t1){
                    const t1 = new e.P(a.x + vi, a.y + vi);
                    o = Math.min(o, t1.x), s = Math.min(s, t1.y), r = Math.max(r, t1.x), n = Math.max(n, t1.y), i.push(t1);
                }
                const a = this.grid.query(o, s, r, n).concat(this.ignoredGrid.query(o, s, r, n)), l = {}, c = {};
                for (const t1 of a){
                    const o = t1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const s = [
                        new e.P(t1.x1, t1.y1),
                        new e.P(t1.x2, t1.y1),
                        new e.P(t1.x2, t1.y2),
                        new e.P(t1.x1, t1.y2)
                    ];
                    e.bX(i, s) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(e, t1, i, o, s) {
                (t1 ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: s
                }, e[0], e[1], e[2], e[3]);
            }
            insertCollisionCircles(e, t1, i, o, s) {
                const r = t1 ? this.ignoredGrid : this.grid, n = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: s
                };
                for(let t1 = 0; t1 < e.length; t1 += 4)r.insertCircle(n, e[t1], e[t1 + 1], e[t1 + 2]);
            }
            projectAndGetPerspectiveRatio(t1, i, o, s, r, n, a) {
                const l = [
                    i,
                    o,
                    s,
                    1
                ];
                let c = !1;
                if (s || this.transform.pitch > 0) {
                    if (e.aC(l, l, t1), this.fogState && r && "globe" !== a.name) {
                        const t1 = function(t1, i, o, s, r, n) {
                            const a = n.calculateFogTileMatrix(r), l = [
                                i,
                                o,
                                s
                            ];
                            return e.af(l, l, a), Ge(t1, e.ag(l), n.pitch, n._fov);
                        }(this.fogState, i, o, s, r.toUnwrapped(), this.transform);
                        c = t1 > .9;
                    }
                } else gi(l, l, t1);
                const h = l[3];
                return {
                    point: new e.P((l[0] / h + 1) / 2 * this.transform.width + vi, (-l[1] / h + 1) / 2 * this.transform.height + vi),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),
                    signedDistanceFromCamera: h,
                    occluded: n && l[2] > h || c
                };
            }
            isOffscreen(e, t1, i, o) {
                return i < vi || e >= this.screenRightBoundary || o < vi || t1 > this.screenBottomBoundary;
            }
            isInsideGrid(e, t1, i, o) {
                return i >= 0 && e < this.gridRightBoundary && o >= 0 && t1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t1 = e.bA([]);
                return e.br(t1, t1, [
                    -100,
                    -100,
                    0
                ]), t1;
            }
        }
        class xi {
            constructor(e, t1, i, o){
                this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t1 : -t1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class bi {
            constructor(e, t1, i, o, s, r = !1){
                this.text = new xi(e ? e.text : null, t1, i, s), this.icon = new xi(e ? e.icon : null, t1, o, s), this.clipped = r;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class wi {
            constructor(e, t1, i, o = !1){
                this.text = e, this.icon = t1, this.skipFade = i, this.clipped = o;
            }
        }
        class Ti {
            constructor(){
                this.invProjMatrix = e.bC(), this.viewportMatrix = e.bC(), this.circles = [];
            }
        }
        class Ei {
            constructor(e, t1, i, o, s){
                this.bucketInstanceId = e, this.featureIndex = t1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = s;
            }
        }
        class Si {
            constructor(e){
                this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e]) {
                    const t1 = ++this.maxGroupID;
                    this.collisionGroups[e] = {
                        ID: t1,
                        predicate: (e)=>e.collisionGroupID === t1
                    };
                }
                return this.collisionGroups[e];
            }
        }
        function Ii(t1, i, o, s, r) {
            const { horizontalAlign: n, verticalAlign: a } = e.c1(t1), l = -(n - .5) * i, c = -(a - .5) * o, h = e.c2(t1, s);
            return new e.P(l + h[0] * r, c + h[1] * r);
        }
        function Ci(t1, i, o, s, r) {
            const n = new e.P(t1, i);
            return o && n._rotate(s ? r : -r), n;
        }
        class Ri {
            constructor(e, t1, i, o, s, r){
                this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new yi(this.transform, s), this.buildingIndex = r, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t1, this.retainedQueryData = {}, this.collisionGroups = new Si(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {}, this.lastReplacementSourceUpdateTime = 0;
            }
            getBucketParts(t1, i, o, s, r = 1) {
                const n = o.getBucket(i), a = o.latestFeatureIndex;
                if (!n || !a || i.fqid !== n.layerIds[0]) return;
                const l = n.layers[0].layout, c = n.layers[0].paint, h = o.collisionBoxArray, d = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), u = o.tileSize / e.al, _ = o.tileID.toUnwrapped();
                this.transform.setProjection(n.projection);
                const p = (f = o.tileID, m = n.getProjection(), g = this.transform, m.name === this.projection ? g.calculateProjMatrix(f.toUnwrapped()) : Kt(g, m, f));
                var f, m, g;
                const v = "map" === l.get("text-pitch-alignment"), y = "map" === l.get("text-rotation-alignment");
                i.compileFilter(i.options);
                const x = i.dynamicFilter(), b = i.dynamicFilterNeedsFeature(), w = this.transform.calculatePixelsToTileUnitsMatrix(o), T = si(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);
                let E = null;
                const S = n.getProjection().createInversionMatrix(this.transform, o.tileID.canonical);
                if (v) {
                    const t1 = ri(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);
                    E = e.aB([], this.transform.labelPlaneMatrix, t1);
                }
                let I = null;
                x && o.latestFeatureIndex && (I = {
                    unwrappedTileID: _,
                    dynamicFilter: x,
                    dynamicFilterNeedsFeature: b
                }), this.retainedQueryData[n.bucketInstanceId] = new Ei(n.bucketInstanceId, a, n.sourceLayerIndex, n.index, o.tileID);
                const [C, R] = n.layers[0].layout.get("text-size-scale-range"), A = e.aA(r, C, R), [L, D] = l.get("icon-size-scale-range"), P = e.aA(r, L, D), O = {
                    bucket: n,
                    layout: l,
                    paint: c,
                    posMatrix: p,
                    invMatrix: S,
                    mercatorCenter: [
                        e.aF(this.transform.center.lng),
                        e.aJ(this.transform.center.lat)
                    ],
                    textLabelPlaneMatrix: T,
                    labelToScreenMatrix: E,
                    clippingData: I,
                    scale: d,
                    textPixelRatio: u,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: h,
                    partiallyEvaluatedTextSize: e.bK(n.textSizeData, this.transform.zoom, A),
                    partiallyEvaluatedIconSize: e.bK(n.iconSizeData, this.transform.zoom, P),
                    collisionGroup: this.collisionGroups.get(n.sourceID),
                    latestFeatureIndex: o.latestFeatureIndex
                };
                if (s) for (const e of n.sortKeyRanges){
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: s } = e;
                    t1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: s,
                        parameters: O
                    });
                }
                else t1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: n.symbolInstances.length,
                    parameters: O
                });
            }
            attemptAnchorPlacement(e, t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {
                const { textOffset0: b, textOffset1: w, crossTileID: T } = p, E = [
                    b,
                    w
                ], S = Ii(e, r, n, E, a), I = this.collisionIndex.placeCollisionBox(m, a, t1, i, o, s, Ci(S.x, S.y, l, c, this.transform.angle), _, h, d, u.predicate);
                if (v) {
                    const e = m.getSymbolInstanceIconSize(x, this.transform.zoom, p.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(m, e, v, i, o, s, Ci(S.x, S.y, l, c, this.transform.angle), _, h, d, u.predicate).box.length) return;
                }
                if (I.box.length > 0) {
                    let t1;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[T] && this.prevPlacement.placements[T] && this.prevPlacement.placements[T].text && (t1 = this.prevPlacement.variableOffsets[T].anchor), this.variableOffsets[T] = {
                        textOffset: E,
                        width: r,
                        height: n,
                        anchor: e,
                        textScale: a,
                        prevAnchor: t1
                    }, this.markUsedJustification(m, e, p, g), m.allowVerticalPlacement && (this.markUsedOrientation(m, g, p), this.placedOrientations[T] = g), {
                        shift: S,
                        placedGlyphBoxes: I
                    };
                }
            }
            placeLayerBucketPart(t1, i, o, s, r = 1) {
                const { bucket: n, layout: a, paint: l, posMatrix: c, textLabelPlaneMatrix: h, labelToScreenMatrix: d, clippingData: u, textPixelRatio: _, mercatorCenter: p, invMatrix: f, holdingForFade: m, collisionBoxArray: g, partiallyEvaluatedTextSize: v, partiallyEvaluatedIconSize: y, collisionGroup: x, latestFeatureIndex: b } = t1.parameters, w = a.get("text-optional"), T = a.get("icon-optional"), E = a.get("text-allow-overlap"), S = a.get("icon-allow-overlap"), I = "map" === a.get("text-rotation-alignment"), C = "map" === a.get("icon-rotation-alignment"), R = "map" === a.get("text-pitch-alignment"), A = l.get("symbol-z-offset"), L = "sea" === a.get("symbol-elevation-reference"), D = a.get("symbol-placement"), [P, O] = a.get("text-size-scale-range"), [z, M] = a.get("icon-size-scale-range"), F = e.aA(r, P, O), B = e.aA(r, z, M), k = a.get("text-variable-anchor"), N = I && "point" !== D, U = C && "point" !== D, j = k && n.hasTextData(), V = n.hasIconTextFit() && j && n.hasIconData();
                this.transform.setProjection(n.projection);
                const G = j || N, H = U || V;
                let q = E && (S || !n.hasIconData() || T), Z = S && (E || !n.hasTextData() || w);
                const W = !A.isConstant();
                !n.collisionArrays && g && n.deserializeCollisionBoxes(g), o && s && n.updateCollisionDebugBuffers(this.transform.zoom, g, F, B);
                const $ = (t1, s, r)=>{
                    const { crossTileID: l, numVerticalGlyphVertices: g } = t1;
                    let C = null;
                    if (u && u.dynamicFilterNeedsFeature || W) {
                        const e = this.retainedQueryData[n.bucketInstanceId];
                        C = b.loadFeature({
                            featureIndex: t1.featureIndex,
                            bucketIndex: e.bucketIndex,
                            sourceLayerIndex: e.sourceLayerIndex,
                            layoutVertexArrayOffset: 0
                        });
                        const i = C.properties ? C.properties.worldview : null;
                        if (n.localizable && n.worldview && "string" == typeof i) if ("all" === i) C.properties.$localized = !0;
                        else {
                            if (!i.split(",").includes(n.worldview)) return;
                            C.properties.$localized = !0, C.properties.worldview = n.worldview;
                        }
                    }
                    if (u && !(0, u.dynamicFilter)({
                        zoom: this.transform.zoom,
                        pitch: this.transform.pitch,
                        worldview: n.worldview
                    }, C, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.P(t1.tileAnchorX, t1.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return this.placements[l] = new wi(!1, !1, !1, !0), void i.add(l);
                    const D = A.evaluate(C, {});
                    if (i.has(l)) return;
                    if (m) return void (this.placements[l] = new wi(!1, !1, !1));
                    let P = !1, O = !1, z = !0, M = !1, F = !1, B = null, N = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, U = {
                        box: null
                    }, j = null, V = null, $ = null, X = 0, Y = 0, K = 0;
                    r.textFeatureIndex ? X = r.textFeatureIndex : t1.useRuntimeCollisionCircles && (X = t1.featureIndex), r.verticalTextFeatureIndex && (Y = r.verticalTextFeatureIndex);
                    const J = n.elevationFeatures ? n.elevationFeatures[t1.elevationFeatureIndex] : void 0, Q = (i)=>{
                        i.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;
                        const o = this.transform.elevation;
                        i.elevation = L ? D : D + e.bV.getAtTileOffset(i.tileID, new e.P(i.tileAnchorX, i.tileAnchorY), o, J), i.elevation += t1.zOffset;
                    }, ee = r.textBox;
                    if (ee) {
                        Q(ee);
                        const i = (i)=>{
                            let o = e.bL.horizontal;
                            if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e = this.prevPlacement.placedOrientations[l];
                                e && (this.placedOrientations[l] = e, o = e, this.markUsedOrientation(n, o, t1));
                            }
                            return o;
                        }, o = (t1, i)=>{
                            if (n.allowVerticalPlacement && g > 0 && r.verticalTextBox) {
                                for (const o of n.writingModes)if (o === e.bL.vertical ? (N = i(), U = N) : N = t1(), N && N.box && N.box.length) break;
                            } else N = t1();
                        };
                        if (k) {
                            let a = k;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[l]) {
                                const e = this.prevPlacement.variableOffsets[l];
                                a.indexOf(e.anchor) > 0 && (a = a.filter((t1)=>t1 !== e.anchor), a.unshift(e.anchor));
                            }
                            const h = (e, i, o)=>{
                                const r = n.getSymbolInstanceTextSize(v, t1, this.transform.zoom, s), l = (e.x2 - e.x1) * r + 2 * e.padding, h = (e.y2 - e.y1) * r + 2 * e.padding, d = t1.hasIconTextFit && !S ? i : null;
                                d && Q(d);
                                let u = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const m = E ? 2 * a.length : a.length;
                                for(let i = 0; i < m; ++i){
                                    const m = this.attemptAnchorPlacement(a[i % a.length], e, p, f, G, l, h, r, I, R, _, c, x, i >= a.length, t1, s, n, o, d, v, y);
                                    if (m && (u = m.placedGlyphBoxes, u && u.box && u.box.length)) {
                                        P = !0, B = m.shift;
                                        break;
                                    }
                                }
                                return u;
                            };
                            o(()=>h(ee, r.iconBox, e.bL.horizontal), ()=>{
                                const t1 = r.verticalTextBox;
                                return t1 && Q(t1), n.allowVerticalPlacement && !(N && N.box && N.box.length) && g > 0 && t1 ? h(t1, r.verticalIconBox, e.bL.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), N && (P = N.box, z = N.offscreen, M = N.occluded);
                            const d = i(!(!N || !N.box));
                            if (!P && this.prevPlacement) {
                                const e = this.prevPlacement.variableOffsets[l];
                                e && (this.variableOffsets[l] = e, this.markUsedJustification(n, e.anchor, t1, d));
                            }
                        } else {
                            const a = (i, o)=>{
                                const r = n.getSymbolInstanceTextSize(v, t1, this.transform.zoom, s), a = this.collisionIndex.placeCollisionBox(n, r, i, p, f, G, new e.P(0, 0), E, _, c, x.predicate);
                                return a && a.box && a.box.length && (this.markUsedOrientation(n, o, t1), this.placedOrientations[l] = o), a;
                            };
                            o(()=>a(ee, e.bL.horizontal), ()=>{
                                const t1 = r.verticalTextBox;
                                return n.allowVerticalPlacement && g > 0 && t1 ? (Q(t1), a(t1, e.bL.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i(!!(N && N.box && N.box.length));
                        }
                    }
                    if (j = N, P = j && j.box && j.box.length > 0, z = j && j.offscreen, M = j && j.occluded, t1.useRuntimeCollisionCircles) {
                        const i = t1.centerJustifiedTextSymbolIndex >= 0 ? t1.centerJustifiedTextSymbolIndex : t1.verticalPlacedTextSymbolIndex, s = n.text.placedSymbolArray.get(i), r = e.bM(n.textSizeData, v, s), l = a.get("text-padding");
                        V = this.collisionIndex.placeCollisionCircles(n, E, s, i, n.lineVertexArray, n.glyphOffsetArray, r, c, h, d, o, R, x.predicate, t1.collisionCircleDiameter * r / e.bY, l, this.retainedQueryData[n.bucketInstanceId].tileID), P = E || V.circles.length > 0 && !V.collisionDetected, z = z && V.offscreen, M = V.occluded;
                    }
                    if (r.iconFeatureIndex && (K = r.iconFeatureIndex), r.iconBox) {
                        const i = (i)=>{
                            Q(i);
                            const o = t1.hasIconTextFit && B ? Ci(B.x, B.y, I, R, this.transform.angle) : new e.P(0, 0), s = n.getSymbolInstanceIconSize(y, this.transform.zoom, t1.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(n, s, i, p, f, H, o, S, _, c, x.predicate);
                        };
                        U && U.box && U.box.length && r.verticalIconBox ? ($ = i(r.verticalIconBox), O = $.box.length > 0) : ($ = i(r.iconBox), O = $.box.length > 0), z = z && $.offscreen, F = $.occluded;
                    }
                    const te = w || 0 === t1.numHorizontalGlyphVertices && 0 === g, ie = T || 0 === t1.numIconVertices;
                    if (te || ie ? ie ? te || (O = O && P) : P = O && P : O = P = O && P, P && j && j.box && this.collisionIndex.insertCollisionBox(j.box, a.get("text-ignore-placement"), n.bucketInstanceId, U && U.box && Y ? Y : X, x.ID), O && $ && this.collisionIndex.insertCollisionBox($.box, a.get("icon-ignore-placement"), n.bucketInstanceId, K, x.ID), V && (P && this.collisionIndex.insertCollisionCircles(V.circles, a.get("text-ignore-placement"), n.bucketInstanceId, X, x.ID), o)) {
                        const e = n.bucketInstanceId;
                        let t1 = this.collisionCircleArrays[e];
                        void 0 === t1 && (t1 = this.collisionCircleArrays[e] = new Ti);
                        for(let e = 0; e < V.circles.length; e += 4)t1.circles.push(V.circles[e + 0]), t1.circles.push(V.circles[e + 1]), t1.circles.push(V.circles[e + 2]), t1.circles.push(V.collisionDetected ? 1 : 0);
                    }
                    const oe = "globe" !== n.projection.name;
                    q = q && (oe || !M), Z = Z && (oe || !F), this.placements[l] = new wi(P || q, O || Z, z || n.justReloaded), i.add(l);
                }, X = this.retainedQueryData[n.bucketInstanceId].tileID;
                if ("offset" === n.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n, X), "road" === n.elevationType && n.updateRoadElevation(X.canonical), n.updateZOffset(), n.sortFeaturesByY) {
                    const t1 = n.getSortedSymbolIndexes(this.transform.angle);
                    for(let e = t1.length - 1; e >= 0; --e){
                        const i = t1[e];
                        $(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                    n.hasAnyZOffset && e.w(`${n.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
                } else if (n.hasAnyZOffset) {
                    const e = n.getSortedIndexesByZOffset();
                    for(let t1 = 0; t1 < e.length; ++t1){
                        const i = e[t1];
                        $(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                } else for(let e = t1.symbolInstanceStart; e < t1.symbolInstanceEnd; e++)$(n.symbolInstances.get(e), e, n.collisionArrays[e]);
                if (o && n.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[n.bucketInstanceId];
                    e.bl(t1.invProjMatrix, c), t1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                n.justReloaded = !1;
            }
            markUsedJustification(t1, i, o, s) {
                const { leftJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c } = o, h = e.c3(i), d = s === e.bL.vertical ? l : "left" === h ? r : "center" === h ? n : "right" === h ? a : -1;
                r >= 0 && (t1.text.placedSymbolArray.get(r).crossTileID = d >= 0 && r !== d ? 0 : c), n >= 0 && (t1.text.placedSymbolArray.get(n).crossTileID = d >= 0 && n !== d ? 0 : c), a >= 0 && (t1.text.placedSymbolArray.get(a).crossTileID = d >= 0 && a !== d ? 0 : c), l >= 0 && (t1.text.placedSymbolArray.get(l).crossTileID = d >= 0 && l !== d ? 0 : c);
            }
            markUsedOrientation(t1, i, o) {
                const s = i === e.bL.horizontal || i === e.bL.horizontalOnly ? i : 0, r = i === e.bL.vertical ? i : 0, { leftJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = o, h = t1.text.placedSymbolArray;
                n >= 0 && (h.get(n).placedOrientation = s), a >= 0 && (h.get(a).placedOrientation = s), l >= 0 && (h.get(l).placedOrientation = s), c >= 0 && (h.get(c).placedOrientation = r);
            }
            commit(e) {
                this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t1 ? t1.zoomAdjustment(this.transform.zoom) : 0;
                const o = t1 ? t1.symbolFadeChange(e) : 1, s = t1 ? t1.opacities : {}, r = t1 ? t1.variableOffsets : {}, n = t1 ? t1.placedOrientations : {};
                for(const e in this.placements){
                    const t1 = this.placements[e], r = s[e];
                    r ? (this.opacities[e] = new bi(r, o, t1.text, t1.icon, null, t1.clipped), i = i || t1.text !== r.text.placed || t1.icon !== r.icon.placed) : (this.opacities[e] = new bi(null, o, t1.text, t1.icon, t1.skipFade, t1.clipped), i = i || t1.text || t1.icon);
                }
                for(const e in s){
                    const t1 = s[e];
                    if (!this.opacities[e]) {
                        const s = new bi(t1, o, !1, !1);
                        s.isHidden() || (this.opacities[e] = s, i = i || t1.text.placed || t1.icon.placed);
                    }
                }
                for(const e in r)this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = r[e]);
                for(const e in n)this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = n[e]);
                i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t1 ? t1.lastPlacementChangeTime : e);
            }
            updateLayerOpacities(e, t1, i, o) {
                o && (this.lastReplacementSourceUpdateTime = o.updateTime);
                const s = new Set;
                for (const r of t1){
                    const t1 = r.getBucket(e);
                    t1 && r.latestFeatureIndex && e.fqid === t1.layerIds[0] && (this.updateBucketOpacities(t1, s, r, r.collisionBoxArray, i, o, r.tileID, e.scope), "offset" === t1.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t1, r.tileID), "road" === t1.elevationType && t1.updateRoadElevation(r.tileID.canonical), t1.updateZOffset());
                }
            }
            updateBucketOpacities(t1, i, o, s, r, n, a, l) {
                t1.hasTextData() && t1.text.opacityVertexArray.clear(), t1.hasIconData() && t1.icon.opacityVertexArray.clear(), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexArray.clear(), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexArray.clear();
                const c = t1.layers[0].layout, h = t1.layers[0].paint, d = !!t1.layers[0].dynamicFilter(), u = new bi(null, 0, !1, !1, !0), _ = c.get("text-allow-overlap"), p = c.get("icon-allow-overlap"), f = c.get("text-variable-anchor"), m = "map" === c.get("text-rotation-alignment"), g = "map" === c.get("text-pitch-alignment"), v = h.get("symbol-z-offset"), y = "sea" === c.get("symbol-elevation-reference"), x = !v.isConstant(), b = new bi(null, 0, _ && (p || !t1.hasIconData() || c.get("icon-optional")), p && (_ || !t1.hasTextData() || c.get("text-optional")), !0);
                !t1.collisionArrays && s && (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) && t1.deserializeCollisionBoxes(s);
                const w = (e, t1, i)=>{
                    for(let o = 0; o < t1 / 4; o++)e.opacityVertexArray.emplaceBack(i);
                };
                let T = 0;
                n && t1.updateReplacement(a, n);
                for(let s = 0; s < t1.symbolInstances.length; s++){
                    const c = t1.symbolInstances.get(s), { numHorizontalGlyphVertices: h, numVerticalGlyphVertices: _, crossTileID: p, numIconVertices: E, tileAnchorX: S, tileAnchorY: I } = c;
                    let C = null;
                    const R = this.retainedQueryData[t1.bucketInstanceId];
                    x && c && R && (C = o.latestFeatureIndex.loadFeature({
                        featureIndex: c.featureIndex,
                        bucketIndex: R.bucketIndex,
                        sourceLayerIndex: R.sourceLayerIndex,
                        layoutVertexArrayOffset: 0
                    }));
                    const A = v.evaluate(C, {}), L = i.has(p);
                    let D = this.opacities[p];
                    L ? D = u : D || (D = b, this.opacities[p] = D), i.add(p);
                    const P = h > 0 || _ > 0, O = E > 0, z = this.placedOrientations[p], M = z === e.bL.vertical, F = z === e.bL.horizontal || z === e.bL.horizontalOnly;
                    !P && !O || D.isHidden() || T++;
                    let B = !1;
                    if ((P || O) && n) for (const i of t1.activeReplacements){
                        if (e.bZ(i, r, e.b_.Symbol, l)) continue;
                        if (i.min.x > S || S > i.max.x || i.min.y > I || I > i.max.y) continue;
                        const t1 = e.b$(S, I, a.canonical, i.footprintTileId.canonical);
                        if (B = e.c0(t1, i.footprint), B) break;
                    }
                    if (P) {
                        const e = B ? ki : Bi(D.text);
                        w(t1.text, h, M ? ki : e), w(t1.text, _, F ? ki : e);
                        const i = D.text.isHidden(), { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: r, verticalPlacedTextSymbolIndex: n } = c, a = t1.text.placedSymbolArray, l = i || M ? 1 : 0;
                        o >= 0 && (a.get(o).hidden = l), s >= 0 && (a.get(s).hidden = l), r >= 0 && (a.get(r).hidden = l), n >= 0 && (a.get(n).hidden = i || F ? 1 : 0);
                        const d = this.variableOffsets[p];
                        d && this.markUsedJustification(t1, d.anchor, c, z);
                        const u = this.placedOrientations[p];
                        u && (this.markUsedJustification(t1, "left", c, u), this.markUsedOrientation(t1, u, c));
                    }
                    if (O) {
                        const e = B ? ki : Bi(D.icon), { placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: o } = c, s = t1.icon.placedSymbolArray, r = D.icon.isHidden() ? 1 : 0;
                        i >= 0 && (w(t1.icon, E, M ? ki : e), s.get(i).hidden = r), o >= 0 && (w(t1.icon, c.numVerticalIconVertices, F ? ki : e), s.get(o).hidden = r);
                    }
                    if (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) {
                        const i = t1.collisionArrays[s];
                        if (i) {
                            let o = new e.P(0, 0), s = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (f) {
                                    const e = this.variableOffsets[p];
                                    e ? (o = Ii(e.anchor, e.width, e.height, e.textOffset, e.textScale), m && o._rotate(g ? this.transform.angle : -this.transform.angle)) : s = !1;
                                }
                                d && (s = !D.clipped), i.textBox && Ai(t1.textCollisionBox.collisionVertexArray, D.text.placed, !s || M, A, y, o.x, o.y), i.verticalTextBox && Ai(t1.textCollisionBox.collisionVertexArray, D.text.placed, !s || F, A, y, o.x, o.y);
                            }
                            const r = s && Boolean(!F && i.verticalIconBox);
                            i.iconBox && Ai(t1.iconCollisionBox.collisionVertexArray, D.icon.placed, r, A, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0), i.verticalIconBox && Ai(t1.iconCollisionBox.collisionVertexArray, D.icon.placed, !r, A, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0);
                        }
                    }
                }
                if (t1.fullyClipped = 0 === T, t1.sortFeatures(this.transform.angle), this.retainedQueryData[t1.bucketInstanceId] && (this.retainedQueryData[t1.bucketInstanceId].featureSortOrder = t1.featureSortOrder), t1.hasTextData() && t1.text.opacityVertexBuffer && t1.text.opacityVertexBuffer.updateData(t1.text.opacityVertexArray), t1.hasIconData() && t1.icon.opacityVertexBuffer && t1.icon.opacityVertexBuffer.updateData(t1.icon.opacityVertexArray), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexBuffer && t1.iconCollisionBox.collisionVertexBuffer.updateData(t1.iconCollisionBox.collisionVertexArray), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexBuffer && t1.textCollisionBox.collisionVertexBuffer.updateData(t1.textCollisionBox.collisionVertexArray), t1.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[t1.bucketInstanceId];
                    t1.placementInvProjMatrix = e.invProjMatrix, t1.placementViewportMatrix = e.viewportMatrix, t1.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t1.bucketInstanceId];
                }
            }
            symbolFadeChange(e) {
                return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e) {
                return Math.max(0, (this.transform.zoom - e) / 1.5);
            }
            hasTransitions(e) {
                return e - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e, t1) {
                const i = this.zoomAtLastRecencyCheck === t1 ? 1 - this.zoomAdjustment(t1) : 1;
                return this.zoomAtLastRecencyCheck = t1, this.commitTime + this.fadeDuration * i > e;
            }
            isStale() {
                return this.stale;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function Ai(e, t1, i, o, s, r, n) {
            e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0);
        }
        const Li = Math.pow(2, 25), Di = Math.pow(2, 24), Pi = Math.pow(2, 17), Oi = Math.pow(2, 16), zi = Math.pow(2, 9), Mi = Math.pow(2, 8), Fi = Math.pow(2, 1);
        function Bi(e) {
            if (0 === e.opacity && !e.placed) return 0;
            if (1 === e.opacity && e.placed) return 4294967295;
            const t1 = e.placed ? 1 : 0, i = Math.floor(127 * e.opacity);
            return i * Li + t1 * Di + i * Pi + t1 * Oi + i * zi + t1 * Mi + i * Fi + t1;
        }
        const ki = 0;
        class Ni {
            constructor(e){
                this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = [];
            }
            continuePlacement(e, t1, i, o, s, r) {
                const n = this._bucketParts;
                for(; this._currentTileIndex < e.length;)if (t1.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles, r), this._currentTileIndex++, s()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t1)=>e.sortKey - t1.sortKey)); this._currentPartIndex < n.length;){
                    const e = n[this._currentPartIndex];
                    if (t1.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart, r), this._currentPartIndex++, s()) return !0;
                }
                return !1;
            }
        }
        class Ui {
            startNewPlacement(e, t1, i, o, s, r, n, a) {
                return this.placement = new Ri(e, o, s, r, n, a), this._currentPlacementIndex = t1.length - 1, this._forceFullPlacement = !1, this._showCollisionBoxes = i, this._fadeDuration = o, this._done = !1, this._inProgressLayer = null, this;
            }
            requestFullPlacement() {
                this._forceFullPlacement = !0;
            }
            isFullPlacementRequested() {
                return this._forceFullPlacement;
            }
            setStale() {
                this.placement && (this.placement.stale = !0);
            }
            isStale() {
                return !!this.placement && this.placement.stale;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t1, i, o, s, r) {
                const n = e.o.now(), a = ()=>{
                    const t1 = e.o.now() - n;
                    return !this.isFullPlacementRequested() && 0 !== this._fadeDuration && t1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const n = i[t1[this._currentPlacementIndex]], l = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === n.type && "none" !== n.visibility && (!n.minzoom || n.minzoom <= l) && (!n.maxzoom || n.maxzoom > l)) {
                        const t1 = n, i = t1.layout.get("symbol-z-elevate"), l = void 0 !== t1.layout.get("symbol-sort-key").constantOr(1), c = t1.layout.get("symbol-z-order"), h = "viewport-y" === c || "auto" === c && !("viewport-y" !== c && l), d = t1.layout.get("text-allow-overlap") || t1.layout.get("icon-allow-overlap") || t1.layout.get("text-ignore-placement") || t1.layout.get("icon-ignore-placement"), u = h && d, _ = this._inProgressLayer = this._inProgressLayer || new Ni(t1), p = e.B(n.source, n.scope);
                        if (_.continuePlacement(i || u ? s[p] : o[p], this.placement, this._showCollisionBoxes, n, a, r)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._forceFullPlacement = !1, this._done = !0;
            }
            commit(e) {
                return this.placement.commit(e), this.placement;
            }
        }
        const ji = 512 / e.al / 2;
        class Vi {
            constructor(t1, i, o){
                this.tileID = t1, this.bucketInstanceId = o, this.index = new e.c4(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
                const s = t1.canonical.x * e.al, r = t1.canonical.y * e.al;
                for(let e = 0; e < i.length; e++){
                    const { key: t1, crossTileID: o, tileAnchorX: n, tileAnchorY: a } = i.get(e), l = Math.floor((s + n) * ji), c = Math.floor((r + a) * ji);
                    this.index.add(l, c), this.keys.push(t1), this.crossTileIDs.push(o);
                }
                this.index.finish();
            }
            findMatches(t1, i, o) {
                const s = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z), r = ji / Math.pow(2, i.canonical.z - this.tileID.canonical.z), n = i.canonical.x * e.al, a = i.canonical.y * e.al;
                for(let e = 0; e < t1.length; e++){
                    const i = t1.get(e);
                    if (i.crossTileID) continue;
                    const { key: l, tileAnchorX: c, tileAnchorY: h } = i, d = Math.floor((n + c) * r), u = Math.floor((a + h) * r), _ = this.index.range(d - s, u - s, d + s, u + s).sort((e, t1)=>e - t1);
                    for (const e of _){
                        const t1 = this.crossTileIDs[e];
                        if (this.keys[e] === l && !o.has(t1)) {
                            o.add(t1), i.crossTileID = t1;
                            break;
                        }
                    }
                }
            }
        }
        class Gi {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class Hi {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - this.lng) / 360);
                if (0 !== t1) for(const e in this.indexes){
                    const i = this.indexes[e], o = {};
                    for(const e in i){
                        const s = i[e];
                        s.tileID = s.tileID.unwrapTo(s.tileID.wrap + t1), o[s.tileID.key] = s;
                    }
                    this.indexes[e] = o;
                }
                this.lng = e;
            }
            addBucket(e, t1, i) {
                if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                    if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                }
                for(let e = 0; e < t1.symbolInstances.length; e++)t1.symbolInstances.get(e).crossTileID = 0;
                this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set);
                const o = this.usedCrossTileIDs[e.overscaledZ];
                for(const i in this.indexes){
                    const s = this.indexes[i];
                    if (Number(i) > e.overscaledZ) for(const i in s){
                        const r = s[i];
                        r.tileID.isChildOf(e) && r.findMatches(t1.symbolInstances, e, o);
                    }
                    else {
                        const r = s[e.scaledTo(Number(i)).key];
                        r && r.findMatches(t1.symbolInstances, e, o);
                    }
                }
                for(let e = 0; e < t1.symbolInstances.length; e++){
                    const s = t1.symbolInstances.get(e);
                    s.crossTileID || (s.crossTileID = i.generate(), o.add(s.crossTileID));
                }
                return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Vi(e, t1.symbolInstances, t1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e, t1) {
                for (const i of t1.crossTileIDs)this.usedCrossTileIDs[e].delete(i);
            }
            removeStaleBuckets(e) {
                let t1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const s in o)e[o[s].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[s]), delete o[s], t1 = !0);
                }
                return t1;
            }
        }
        class qi {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new Gi, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e, t1, i, o) {
                let s = this.layerIndexes[e.fqid];
                void 0 === s && (s = this.layerIndexes[e.fqid] = new Hi);
                let r = !1;
                const n = {};
                "globe" !== o.name && s.handleWrapJump(i);
                for (const i of t1){
                    const t1 = i.getBucket(e);
                    t1 && e.fqid === t1.layerIds[0] && (t1.bucketInstanceId || (t1.bucketInstanceId = ++this.maxBucketInstanceId), s.addBucket(i.tileID, t1, this.crossTileIDs) && (r = !0), n[t1.bucketInstanceId] = !0);
                }
                return s.removeStaleBuckets(n) && (r = !0), r;
            }
            pruneUnusedLayers(e) {
                const t1 = {};
                e.forEach((e)=>{
                    t1[e] = !0;
                });
                for(const e in this.layerIndexes)t1[e] || delete this.layerIndexes[e];
            }
        }
        const Zi = 771;
        class Wi {
            constructor(e, t1, i, o){
                this.blendFunction = e, this.blendColor = t1.toNonPremultipliedRenderColor(null), this.mask = i, this.blendEquation = o;
            }
        }
        Wi.Replace = [
            1,
            0,
            1,
            0
        ], Wi.disabled = new Wi(Wi.Replace, e.ao.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), Wi.unblended = new Wi(Wi.Replace, e.ao.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Wi.alphaBlended = new Wi([
            1,
            Zi,
            1,
            Zi
        ], e.ao.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Wi.alphaBlendedNonPremultiplied = new Wi([
            770,
            Zi,
            770,
            Zi
        ], e.ao.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Wi.multiply = new Wi([
            774,
            0,
            774,
            0
        ], e.ao.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Wi.additive = new Wi([
            1,
            1,
            1,
            1
        ], e.ao.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        class $i {
            constructor(e, t1, i){
                this.func = e, this.mask = t1, this.range = i;
            }
        }
        $i.ReadOnly = !1, $i.ReadWrite = !0, $i.disabled = new $i(519, $i.ReadOnly, [
            0,
            1
        ]);
        const Xi = 7680;
        class Yi {
            constructor(e, t1, i, o, s, r){
                this.test = e, this.ref = t1, this.mask = i, this.fail = o, this.depthFail = s, this.pass = r;
            }
        }
        Yi.disabled = new Yi({
            func: 519,
            mask: 0
        }, 0, 0, Xi, Xi, Xi);
        const Ki = 1029, Ji = 2305;
        class Qi {
            constructor(e, t1, i){
                this.enable = e, this.mode = t1, this.frontFace = i;
            }
        }
        function eo(t1, i) {
            const o = e.ca(t1, 3);
            e.cc(t1, i), e.cg(t1, 3, o);
        }
        function to(t1, i) {
            const o = e.c7([]);
            return e.c8(o, o, -i), e.c9(o, o, -t1), o;
        }
        function io(t1, i) {
            const o = [
                t1[0],
                t1[1],
                0
            ], s = [
                i[0],
                i[1],
                0
            ];
            if (e.ag(o) >= 1e-15) {
                const t1 = e.aw([], o);
                e.c5(s, t1, e.bJ(s, t1)), i[0] = s[0], i[1] = s[1];
            }
            const r = e.bI([], i, t1);
            if (e.c6(r) < 1e-15) return null;
            const n = Math.atan2(-r[1], r[0]);
            return to(Math.atan2(Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]), -t1[2]), n);
        }
        Qi.disabled = new Qi(!1, Ki, Ji), Qi.backCCW = new Qi(!0, Ki, Ji), Qi.backCW = new Qi(!0, Ki, 2304), Qi.frontCW = new Qi(!0, 1028, 2304), Qi.frontCCW = new Qi(!0, 1028, Ji);
        class oo {
            constructor(e, t1){
                this.position = e, this.orientation = t1;
            }
            get position() {
                return this._position;
            }
            set position(t1) {
                if (t1) {
                    const i = t1 instanceof e.ae ? t1 : new e.ae(t1[0], t1[1], t1[2]);
                    this._renderWorldCopies && (i.x = e.bT(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }
            lookAtPoint(t1, i, o) {
                if (this.orientation = null, !this.position) return;
                const s = this.position, r = o || (this._elevation ? this._elevation.getAtPointOrZero(e.ae.fromLngLat(t1)) : 0), n = e.ae.fromLngLat(t1, r), a = [
                    n.x - s.x,
                    n.y - s.y,
                    n.z - s.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = io(a, i);
            }
            setPitchBearing(t1, i) {
                this.orientation = to(e.an(t1), e.an(-i));
            }
        }
        class so {
            constructor(t1, i){
                this._transform = e.bA([]), this.orientation = i, this.position = t1;
            }
            get mercatorPosition() {
                const t1 = this.position;
                return new e.ae(t1[0], t1[1], t1[2]);
            }
            get position() {
                const t1 = e.ca(this._transform, 3);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            set position(t1) {
                var i;
                t1 && e.cg(this._transform, 3, [
                    (i = t1)[0],
                    i[1],
                    i[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t1) {
                this._orientation = t1 || e.c7([]), t1 && eo(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e = this.forward(), t1 = this.right();
                return {
                    bearing: Math.atan2(-t1[1], t1[0]),
                    pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
                };
            }
            setPitchBearing(e, t1) {
                this._orientation = to(e, t1), eo(this._transform, this._orientation);
            }
            forward() {
                const t1 = e.ca(this._transform, 2);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            up() {
                const t1 = e.ca(this._transform, 1);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            right() {
                const t1 = e.ca(this._transform, 0);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            getCameraToWorld(t1, i) {
                const o = new Float64Array(16);
                return e.bl(o, this.getWorldToCamera(t1, i)), o;
            }
            getCameraToWorldMercator() {
                return this._transform;
            }
            getWorldToCameraPosition(t1, i, o) {
                const s = this.position;
                e.c5(s, s, -t1);
                const r = new Float64Array(16);
                return e.bq(r, [
                    o,
                    o,
                    o
                ]), e.br(r, r, s), r[10] *= i, r;
            }
            getWorldToCamera(t1, i) {
                const o = new Float64Array(16), s = new Float64Array(4), r = this.position;
                return e.cb(s, this._orientation), e.c5(r, r, -t1), e.cc(o, s), e.br(o, o, r), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }
            getCameraToClipPerspective(t1, i, o, s) {
                const r = new Float64Array(16);
                return e.cd(r, t1, i, o, s), r;
            }
            getCameraToClipOrthographic(t1, i, o, s, r, n) {
                const a = new Float64Array(16);
                return e.ce(a, t1, i, o, s, r, n), a;
            }
            getDistanceToElevation(t1, i = !1) {
                const o = 0 === t1 ? 0 : e.cf(t1, i ? e.a$(this.position[1]) : this.position[1]), s = this.forward();
                return (o - this.position[2]) / s[2];
            }
            clone() {
                return new so([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        const ro = (e, t1)=>({
                u_matrix: e,
                u_ground_shadow_factor: t1
            });
        class no {
            constructor(e = 0, t1 = 0, i = 0, o = 0){
                if (isNaN(e) || e < 0 || isNaN(t1) || t1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e, this.bottom = t1, this.left = i, this.right = o;
            }
            interpolate(t1, i, o) {
                return null != i.top && null != t1.top && (this.top = e.ak(t1.top, i.top, o)), null != i.bottom && null != t1.bottom && (this.bottom = e.ak(t1.bottom, i.bottom, o)), null != i.left && null != t1.left && (this.left = e.ak(t1.left, i.left, o)), null != i.right && null != t1.right && (this.right = e.ak(t1.right, i.right, o)), this;
            }
            getCenter(t1, i) {
                const o = e.aA((this.left + t1 - this.right) / 2, 0, t1), s = e.aA((this.top + i - this.bottom) / 2, 0, i);
                return new e.P(o, s);
            }
            equals(e) {
                return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
            }
            clone() {
                return new no(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        const ao = 15;
        class lo {
            constructor(t1, i, o, s, r, n, a){
                this.tileSize = 512, this._renderWorldCopies = void 0 === r || r, this._minZoom = t1 || 0, this._maxZoom = i || 22, this._minPitch = o ?? 0, this._maxPitch = s ?? 60, this.setProjection(n), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.aT(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new no, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new so, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1;
            }
            clone() {
                const e = new lo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
                return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e._allowWorldUnderZoom = this._allowWorldUnderZoom, e;
            }
            get isOrthographic() {
                return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < ao;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e) {
                this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            get depthOcclusionForSymbolsAndCircles() {
                return "globe" !== this.projection.name && !this.isOrthographic;
            }
            updateElevation(e, t1 = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t1), this._calcMatrices();
            }
            getProjection() {
                return e.aH(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(t1) {
                this.projectionOptions = t1 || {
                    name: "mercator"
                };
                const i = this.projection ? this.getProjection() : void 0;
                this.projection = e.cm(this.projectionOptions);
                const o = this.getProjection(), s = !e.by(i, o);
                return s && this._calcMatrices(), this.mercatorFromTransition = !1, s;
            }
            setOrthographicProjectionAtLowPitch(e) {
                return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);
            }
            setMercatorFromTransition() {
                const t1 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e.cm({
                    name: "mercator"
                });
                const i = t1 !== this.projection.name;
                return i && this._calcMatrices(), i;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e) {
                this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e) {
                this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e) {
                this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e) {
                this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e) {
                void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get cameraWorldSize() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e.cf(1, this.center.lat) * this.cameraWorldSizeForFog;
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e.P(this.width, this.height);
            }
            get bearing() {
                return e.bT(this.rotation, -180, 180);
            }
            set bearing(e) {
                this.rotation = e;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t1) {
                const i = -t1 * Math.PI / 180;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.cn(), e.co(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t1) {
                const i = e.aA(t1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fov() {
                return this._fov / Math.PI * 180;
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = e.an(t1), this._calcMatrices());
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e);
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e) {
                this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e) {
                const t1 = Math.min(Math.max(e, this.minZoom), this.maxZoom);
                this._zoom !== t1 && (this._unmodified = !1, this._setZoom(t1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e) {
                this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
            }
            get tileCoverLift() {
                return this._tileCoverLift;
            }
            set tileCoverLift(e) {
                this._tileCoverLift !== e && (this._tileCoverLift = e);
            }
            _updateCameraOnTerrain() {
                const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t1 = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
                if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t1 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const i = this._elevation;
                t1 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                if (void 0 === this._centerAltitudeValidForExaggeration) return;
                const e = Math.max(0, (this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);
                this._seaLevelZoom = this._zoomFromMercatorZ(e);
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t1 = this._elevation, i = [
                    [
                        .5,
                        .2
                    ],
                    [
                        .3,
                        .5
                    ],
                    [
                        .5,
                        .5
                    ],
                    [
                        .7,
                        .5
                    ],
                    [
                        .5,
                        .8
                    ]
                ], o = this.horizonLineFromTop();
                let s = 0, r = 0;
                for(let n = 0; n < i.length; n++){
                    const a = new e.P(i[n][0] * this.width, o + i[n][1] * (this.height - o)), l = t1.pointCoordinate(a);
                    if (!l) continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    s += l[3] * c, r += c;
                }
                return 0 === r ? NaN : s / r;
            }
            get center() {
                return this._center;
            }
            set center(e) {
                e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e = this._seaLevelZoom, t1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i = this.pixelsPerMeter / this.worldSize * t1, o = this._mercatorZfromZoom(e), s = this._mercatorZfromZoom(this._maxZoom), r = Math.max(o - i, s);
                this._setZoom(this._zoomFromMercatorZ(r));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e) {
                this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
            }
            equals(e) {
                const t1 = this.elevation, i = e.elevation, o = null != t1 != (null != i) || t1 && i && t1.exaggeration() !== i.exaggeration();
                return this.width === e.width && this.height === e.height && this.center.lng === e.center.lng && this.center.lat === e.center.lat && this.zoom === e.zoom && this.bearing === e.bearing && this.pitch === e.pitch && this.fov === e.fov && this.projection.name === e.projection.name && this._edgeInsets.equals(e.padding) && !o;
            }
            computeZoomRelativeTo(t1) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t1.toAltitude()));
                let o;
                o = t1.z < this._camera.position[2] ? [
                    i.x,
                    i.y,
                    i.z
                ] : [
                    t1.x,
                    t1.y,
                    t1.z
                ];
                const s = e.ag(e.av([], this._camera.position, o));
                return e.aA(this._zoomFromMercatorZ(s), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t1) {
                if (!this.height) return;
                if (!t1.position && !t1.orientation) return;
                this._updateCameraState();
                let i = !1;
                if (t1.orientation && !e.cp(t1.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t1.orientation)), t1.position) {
                    const o = [
                        t1.position.x,
                        t1.position.y,
                        t1.position.z
                    ];
                    e.cq(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }
                i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t1 = this._camera.position, i = new oo;
                return i.position = new e.ae(t1[0], t1[1], t1[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }
            _setCameraOrientation(t1) {
                if (!e.cr(t1)) return !1;
                e.cs(t1, t1);
                const i = e.ct([], [
                    0,
                    0,
                    -1
                ], t1), o = e.ct([], [
                    0,
                    -1,
                    0
                ], t1);
                if (o[2] < 0) return !1;
                const s = io(i, o);
                return !!s && (this._camera.orientation = s, !0);
            }
            _setCameraPosition(t1) {
                const i = this.zoomScale(this.minZoom) * this.tileSize, o = this.zoomScale(this.maxZoom) * this.tileSize, s = this.cameraToCenterDistance;
                t1[2] = e.aA(t1[2], s / o, s / i), this._camera.position = t1;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e) {
                return this._edgeInsets.equals(e);
            }
            interpolatePadding(e, t1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e, t1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e) {
                const t1 = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
                return Math.max(0, t1);
            }
            getVisibleUnwrappedCoordinates(t1) {
                const i = [
                    new e.cu(0, t1)
                ];
                if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e.P(0, 0)), s = this.pointCoordinate(new e.P(this.width, 0)), r = this.pointCoordinate(new e.P(this.width, this.height)), n = this.pointCoordinate(new e.P(0, this.height)), a = Math.floor(Math.min(o.x, s.x, r.x, n.x)), l = Math.floor(Math.max(o.x, s.x, r.x, n.x)), c = 1;
                    for(let o = a - c; o <= l + c; o++)0 !== o && i.push(new e.cu(o, t1));
                }
                return i;
            }
            isLODDisabled(e) {
                return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
            }
            extendTileCover(t1, i, o, s) {
                let r = [];
                const n = null != o, a = !n;
                if (a && this.zoom < i) return r;
                if (n && 0 === o[0] && 0 === o[1]) return r;
                const l = new Set, c = (t1, i, o, s, n)=>{
                    const a = e.cY(i, t1, o, s, n);
                    l.has(a) || (r.push(new e.aQ(t1, i, o, s, n)), l.add(a));
                };
                for(let e = 0; e < t1.length; e++){
                    const r = t1[e];
                    if (a && r.canonical.z !== i) continue;
                    if (n && void 0 !== s && s > r.canonical.z) continue;
                    const l = r.canonical, h = r.overscaledZ, d = r.wrap, u = 1 << l.z, _ = l.x + 1 < u, p = l.x > 0, f = l.y + 1 < u, m = l.y > 0, g = r.wrap - (p ? 0 : 1), v = r.wrap + (_ ? 0 : 1), y = p ? l.x - 1 : u - 1, x = _ ? l.x + 1 : 0;
                    if (n) o[0] < 0 ? (c(h, v, l.z, x, l.y), o[1] < 0 && f && (c(h, d, l.z, l.x, l.y + 1), c(h, v, l.z, x, l.y + 1)), o[1] > 0 && m && (c(h, d, l.z, l.x, l.y - 1), c(h, v, l.z, x, l.y - 1))) : o[0] > 0 ? (c(h, g, l.z, y, l.y), o[1] < 0 && f && (c(h, d, l.z, l.x, l.y + 1), c(h, g, l.z, y, l.y + 1)), o[1] > 0 && m && (c(h, d, l.z, l.x, l.y - 1), c(h, g, l.z, y, l.y - 1))) : o[1] < 0 && f ? c(h, d, l.z, l.x, l.y + 1) : m && c(h, d, l.z, l.x, l.y - 1);
                    else {
                        const e = r.visibleQuadrants;
                        1 & e && (c(h, g, l.z, y, l.y), m && (c(h, d, l.z, l.x, l.y - 1), c(h, g, l.z, y, l.y - 1))), 2 & e && (c(h, v, l.z, x, l.y), m && (c(h, d, l.z, l.x, l.y - 1), c(h, v, l.z, x, l.y - 1))), 4 & e && (c(h, g, l.z, y, l.y), f && (c(h, d, l.z, l.x, l.y + 1), c(h, g, l.z, y, l.y + 1))), 8 & e && (c(h, v, l.z, x, l.y), f && (c(h, d, l.z, l.x, l.y + 1), c(h, v, l.z, x, l.y + 1)));
                    }
                }
                const h = [];
                for (const e of r)r.some((t1)=>e.isChildOf(t1)) || h.push(e);
                if (r = h.filter((e)=>!t1.some((t1)=>!!(e.overscaledZ < i && t1.isChildOf(e)) || e.equals(t1) || e.isChildOf(t1))), a) {
                    const e = 1 << i, t1 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o = [
                        e * t1.x,
                        e * t1.y
                    ], s = 4, n = s * s;
                    r = r.filter((e)=>{
                        const t1 = e.canonical.x + .5 - o[0], i = e.canonical.y + .5 - o[1];
                        return t1 * t1 + i * i < n;
                    });
                }
                return r;
            }
            extendTileCoverToNearPlane(t1, i, o) {
                const s = [], r = new Set;
                for (const e of t1)r.add(e.key);
                const n = (t1, i, o, n, a)=>{
                    const l = e.cY(i, t1, o, n, a);
                    r.has(l) || (s.push(new e.aQ(t1, i, o, n, a)), r.add(l));
                }, a = t1.reduce((e, t1)=>Math.max(e, t1.overscaledZ), o), l = 1 << o, c = [
                    new e.P(0, 0),
                    new e.P(e.al, 0),
                    new e.P(e.al, e.al),
                    new e.P(0, e.al)
                ], h = new e.P(0, 0), d = new e.P(0, 0), u = (t1, i)=>{
                    const s = Math.floor(t1[0]), r = Math.floor(t1[1]), u = (t1[0] - s) * e.al, _ = (t1[1] - r) * e.al, p = Math.floor(i[0]), f = Math.floor(i[1]), m = (i[0] - p) * e.al, g = (i[1] - f) * e.al;
                    for(let t1 = -1; t1 <= 1; t1++){
                        const i = s + t1;
                        if (!(i < 0 || i >= l)) {
                            h.x = u - t1 * e.al, d.x = m - (i - p) * e.al;
                            for(let t1 = -1; t1 <= 1; t1++){
                                const s = r + t1;
                                h.y = _ - t1 * e.al, d.y = g - (s - f) * e.al, e.cZ(h, d, c) && n(a, 0, o, i, s);
                            }
                        }
                    }
                }, _ = i.points, p = _[e.cv], f = _[e.cw], m = this._projectToGround(p, _[e.cx]), g = this._projectToGround(f, _[e.cy]);
                return u(p, m), u(f, g), s;
            }
            _projectToGround(t1, i) {
                return e.cz(e.cA(), t1, i, t1[2] / (t1[2] - i[2]));
            }
            coveringTiles(t1) {
                let i = this.coveringZoomLevel(t1);
                const o = i, s = this.elevation && this.elevation.exaggeration(), r = s && !t1.isTerrainDEM, n = "mercator" === this.projection.name;
                if (void 0 !== t1.minzoom && i < t1.minzoom) return [];
                void 0 !== t1.maxzoom && i > t1.maxzoom && (i = t1.maxzoom);
                const a = this.locationCoordinate(this.center), l = this.center.lat, c = 1 << i, h = [
                    c * a.x,
                    c * a.y,
                    0
                ], d = "globe" === this.projection.name, u = !d, _ = e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u), p = d ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f = c * e.cf(1, this.center.lat), m = this._camera.position[2] / e.cf(1, this.center.lat), g = [
                    c * p.x,
                    c * p.y,
                    m * (u ? 1 : f)
                ], v = d || s, y = this.cameraToCenterDistance / t1.tileSize * (t1.roundZoom ? 1 : .502), x = this.isLODDisabled(!0) ? i : 0;
                let b;
                if (this._elevation && t1.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();
                else if (this._elevation) {
                    const e = this._elevation.getMinMaxForVisibleTiles();
                    b = e ? e.max : this._centerAltitude;
                } else b = this._centerAltitude;
                const w = t1.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T = this.projection.isReprojectedInTileSpace ? e.cC(this) : 1, E = (t1)=>{
                    const i = 1 / 4e4, o = new e.ae(t1.x + i, t1.y, t1.z), s = new e.ae(t1.x, t1.y + i, t1.z), r = t1.toLngLat(), n = o.toLngLat(), a = s.toLngLat(), l = this.locationCoordinate(r), c = this.locationCoordinate(n), h = this.locationCoordinate(a), d = Math.hypot(c.x - l.x, c.y - l.y), u = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(d * u) * T / i;
                }, S = (t1)=>{
                    const i = b, o = w;
                    return {
                        aabb: e.cF(this, c, 0, 0, 0, t1, o, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o,
                        maxZ: i,
                        wrap: t1,
                        fullyVisible: !1
                    };
                }, I = [];
                let C = [];
                const R = i, A = t1.reparseOverscaled ? o : i, L = (m - this._centerAltitude) * f, D = (e)=>{
                    if (!this._elevation || !e.tileID || !n) return;
                    const t1 = this._elevation.getMinMaxForTile(e.tileID), i = e.aabb;
                    t1 ? (i.min[2] = t1.min, i.max[2] = t1.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = O(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }, P = (e, t1)=>{
                    if (.707 * t1 < e) return 1;
                    const i = t1 / e;
                    return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                }, O = (t1)=>{
                    if (t1.zoom < x) return !0;
                    if (t1.zoom === R) return !1;
                    if (null != t1.shouldSplit) return t1.shouldSplit;
                    const i = t1.aabb.distanceX(g), s = t1.aabb.distanceY(g);
                    let a = L, c = 1;
                    if (d) {
                        a = t1.aabb.distanceZ(g);
                        const i = Math.pow(2, t1.zoom), o = e.a$((t1.y + 1) / i), s = e.a$(t1.y / i), r = Math.min(Math.max(l, o), s), n = e.d1(r) / e.d1(l);
                        if (c = r === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, n / this._mercatorScaleRatio), this.zoom <= e.c_ && t1.zoom === R - 1 && n >= .9) return !0;
                    } else if (r && (a = t1.aabb.distanceZ(g) * f), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t1.zoom), o = E(new e.ae((t1.x + .5) / i, (t1.y + .5) / i));
                        c = o > .85 ? 1 : o;
                    }
                    if (!n && !d) {
                        const e = Math.sqrt(i * i + s * s + a * a);
                        let o = (1 << R - t1.zoom) * y * c;
                        return o *= P(Math.max(a, L), e), e < o;
                    }
                    let u = Number.MAX_VALUE, _ = 0;
                    const p = t1.aabb.getCorners(), m = [];
                    for (const t1 of p){
                        e.av(m, t1, g), d || (r ? m[2] *= f : m[2] = L);
                        const i = e.bJ(m, this._camera.forward());
                        i < u && (u = i, _ = Math.abs(m[2]));
                    }
                    let v = (1 << R - t1.zoom) * y * c;
                    if (v *= P(Math.max(_, L), u), u < v) return !0;
                    const b = t1.aabb.closestPoint(h);
                    return b[0] === h[0] && b[1] === h[1];
                };
                if (this.renderWorldCopies) for(let e = 1; e <= 3; e++)I.push(S(-e)), I.push(S(e));
                for(I.push(S(0)); I.length > 0;){
                    const o = I.pop(), s = o.x, a = o.y;
                    let l = o.fullyVisible;
                    const u = ()=>"globe" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);
                    if (!l) {
                        let t1 = v ? o.aabb.intersects(_) : o.aabb.intersectsFlat(_);
                        if (0 === t1 && u()) {
                            const i = new e.cD(o.zoom, s, a);
                            t1 = e.cE(this, c, i, !0).intersects(_);
                        }
                        if (0 === t1) continue;
                        l = 2 === t1;
                    }
                    if (o.zoom === R || !O(o)) {
                        const r = o.zoom === R ? A : o.zoom;
                        if (t1.minzoom && t1.minzoom > r) continue;
                        let n = 0;
                        if (!l) {
                            let i = v ? o.aabb.intersectsPrecise(_) : o.aabb.intersectsPreciseFlat(_);
                            if (0 === i && u()) {
                                const t1 = new e.cD(o.zoom, s, a);
                                i = e.cE(this, c, t1, !0).intersectsPrecise(_);
                            }
                            if (0 === i) continue;
                            if (t1.calculateQuadrantVisibility) if (_.containsPoint(o.aabb.center)) n = 15;
                            else for(let e = 0; e < 4; e++)0 !== o.aabb.quadrant(e).intersects(_) && (n |= 1 << e);
                        }
                        const d = h[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom), p = h[1] - .5 - a, f = o.tileID ? o.tileID : new e.aQ(r, o.wrap, o.zoom, s, a);
                        t1.calculateQuadrantVisibility && (f.visibleQuadrants = n), C.push({
                            tileID: f,
                            distanceSq: d * d + p * p
                        });
                        continue;
                    }
                    for(let t1 = 0; t1 < 4; t1++){
                        const i = (s << 1) + t1 % 2, h = (a << 1) + (t1 >> 1), u = {
                            aabb: n ? o.aabb.quadrant(t1) : e.cF(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),
                            zoom: o.zoom + 1,
                            x: i,
                            y: h,
                            wrap: o.wrap,
                            fullyVisible: l,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o.minZ,
                            maxZ: o.maxZ
                        };
                        r && !d && (u.tileID = new e.aQ(o.zoom + 1 === R ? A : o.zoom + 1, o.wrap, o.zoom + 1, i, h), D(u)), I.push(u);
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq, o = this.horizonLineFromTop();
                    C = C.filter((s)=>{
                        const r = [
                            0,
                            0,
                            0,
                            1
                        ], n = [
                            e.al,
                            e.al,
                            0,
                            1
                        ], a = this.calculateFogTileMatrix(s.tileID.toUnwrapped());
                        e.aC(r, r, a), e.aC(n, n, a);
                        const l = e.cG([], r, n), c = e.cH([], r, n), h = e.c$(l, c);
                        if (0 === h) return !0;
                        let d = !1;
                        const u = this._elevation;
                        if (u && h > i && 0 !== o) {
                            const i = this.calculateProjMatrix(s.tileID.toUnwrapped());
                            let r;
                            t1.isTerrainDEM || (r = u.getMinMaxForTile(s.tileID)), r || (r = {
                                min: w,
                                max: b
                            });
                            const n = e.cI(this.rotation), a = [
                                n[0] * e.al,
                                n[1] * e.al,
                                r.max
                            ];
                            e.af(a, a, i), d = (1 - a[1]) * this.height * .5 < o;
                        }
                        return h < i || d;
                    });
                }
                return C.sort((e, t1)=>e.distanceSq - t1.distanceSq).map((e)=>e.tileID);
            }
            resize(e, t1) {
                this.width = e, this.height = t1, this.pixelsToGLUnits = [
                    2 / e,
                    -2 / t1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e) {
                return Math.pow(2, e);
            }
            scaleZoom(e) {
                return Math.log2(e);
            }
            project(t1) {
                const i = e.aA(t1.lat, -e.cJ, e.cJ), o = this.projection.project(t1.lng, i);
                return new e.P(o.x * this.worldSize, o.y * this.worldSize);
            }
            unproject(e) {
                return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            get pointMerc() {
                return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e.cf(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t1, i) {
                let o, s;
                const r = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e = this.worldSize;
                    o = (i.x - r.x) / e, s = (i.y - r.y) / e;
                } else {
                    const e = this.pointCoordinate(i), t1 = this.pointCoordinate(r);
                    o = e.x - t1.x, s = e.y - t1.y;
                }
                const n = this.locationCoordinate(t1);
                this.setLocation(new e.ae(n.x - o, n.y - s));
            }
            setLocation(e) {
                this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e, t1) {
                return this.projection.locationPoint(this, e, t1);
            }
            locationPoint3D(e, t1) {
                return this.projection.locationPoint(this, e, t1, !0);
            }
            pointLocation(e) {
                return this.coordinateLocation(this.pointCoordinate(e));
            }
            pointLocation3D(e, t1) {
                return this.coordinateLocation(this.pointCoordinate3D(e, t1));
            }
            locationCoordinate(t1, i) {
                const o = i ? e.cf(i, t1.lat) : void 0, s = this.projection.project(t1.lng, t1.lat);
                return new e.ae(s.x, s.y, o);
            }
            coordinateLocation(e) {
                return this.projection.unproject(e.x, e.y);
            }
            pointRayIntersection(t1, i) {
                const o = null != i ? i : this._centerAltitude, s = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], r = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.aC(s, s, this.pixelMatrixInverse), e.aC(r, r, this.pixelMatrixInverse);
                const n = r[3];
                e.cK(s, s, 1 / s[3]), e.cK(r, r, 1 / n);
                const a = s[2], l = r[2];
                return {
                    p0: s,
                    p1: r,
                    t: a === l ? 0 : (o - a) / (l - a)
                };
            }
            screenPointToMercatorRay(t1) {
                const i = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                return e.aC(i, i, this.pixelMatrixInverse), e.aC(o, o, this.pixelMatrixInverse), e.cK(i, i, 1 / i[3]), e.cK(o, o, 1 / o[3]), i[2] = e.cf(i[2], this._center.lat) * this.worldSize, o[2] = e.cf(o[2], this._center.lat) * this.worldSize, e.cK(i, i, 1 / this.worldSize), e.cK(o, o, 1 / this.worldSize), new e.ax([
                    i[0],
                    i[1],
                    i[2]
                ], e.aw([], e.av([], o, i)));
            }
            rayIntersectionCoordinate(t1) {
                const { p0: i, p1: o, t: s } = t1, r = e.cf(i[2], this._center.lat), n = e.cf(o[2], this._center.lat);
                return new e.ae(e.ak(i[0], o[0], s) / this.worldSize, e.ak(i[1], o[1], s) / this.worldSize, e.ak(r, n, s));
            }
            pointCoordinate(e, t1 = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e.x, e.y, t1);
            }
            pointCoordinate3D(t1, i) {
                if (!this.elevation) return this.pointCoordinate(t1, i);
                let o = this.projection.pointCoordinate3D(this, t1.x, t1.y);
                if (o) return new e.ae(o[0], o[1], o[2]);
                let s = 0, r = this.horizonLineFromTop();
                if (t1.y > r) return this.pointCoordinate(t1, i);
                const n = .02 * r, a = t1.clone();
                for(let t1 = 0; t1 < 10 && r - s > n; t1++){
                    a.y = e.ak(s, r, .66);
                    const t1 = this.projection.pointCoordinate3D(this, a.x, a.y);
                    t1 ? (r = a.y, o = t1) : s = a.y;
                }
                return o ? new e.ae(o[0], o[1], o[2]) : this.pointCoordinate(t1);
            }
            isPointAboveHorizon(e) {
                return this.projection.isPointAboveHorizon(this, e);
            }
            isPointOnSurface(t1) {
                if (t1.y < 0 || t1.y > this.height || t1.x < 0 || t1.x > this.width) return !1;
                if (this.elevation || this.zoom >= e.cL) return !this.isPointAboveHorizon(t1);
                const i = this.pointCoordinate(t1);
                return i.y >= 0 && i.y <= 1;
            }
            _coordinatePoint(t1, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t1, this._centerAltitude) : this._centerAltitude, s = [
                    t1.x * this.worldSize,
                    t1.y * this.worldSize,
                    o + t1.toAltitude(),
                    1
                ];
                return e.aC(s, s, this.pixelMatrix), s[3] > 0 ? new e.P(s[0] / s[3], s[1] / s[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
                const { top: t1, left: i } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, s = this.width - this._edgeInsets.right, r = this.pointLocation3D(new e.P(i, t1)), n = this.pointLocation3D(new e.P(s, t1)), a = this.pointLocation3D(new e.P(s, o)), l = this.pointLocation3D(new e.P(i, o));
                let c = Math.min(r.lng, n.lng, a.lng, l.lng), h = Math.max(r.lng, n.lng, a.lng, l.lng), d = Math.min(r.lat, n.lat, a.lat, l.lat), u = Math.max(r.lat, n.lat, a.lat, l.lat);
                const _ = Math.pow(2, -this.zoom) / 16 * 270, p = "globe" === this.projection.name ? 1 : 4, f = (t1, i, o, s, r)=>{
                    const n = (t1 + o) / 2, a = (i + s) / 2, l = new e.P(n, a), { lng: m, lat: g } = this.pointLocation3D(l), v = Math.max(0, c - m, d - g, m - h, g - u);
                    c = Math.min(c, m), h = Math.max(h, m), d = Math.min(d, g), u = Math.max(u, g), (r < p || v > _) && (f(t1, i, n, a, r + 1), f(n, a, o, s, r + 1));
                };
                if (f(i, t1, s, t1, 1), f(s, t1, s, o, 1), f(s, o, i, o, 1), f(i, o, i, t1, 1), "globe" === this.projection.name) {
                    const [t1, i] = e.cM(this);
                    t1 ? (u = 90, h = 180, c = -180) : i && (d = -90, h = 180, c = -180);
                }
                return new e.aI(new e.aT(c, d), new e.aT(h, u));
            }
            _getBoundsRectangular(t1, i) {
                const { top: o, left: s } = this._edgeInsets, r = this.height - this._edgeInsets.bottom, n = this.width - this._edgeInsets.right, a = new e.P(s, o), l = new e.P(n, o), c = new e.P(n, r), h = new e.P(s, r);
                let d = this.pointCoordinate(a, t1), u = this.pointCoordinate(l, t1);
                const _ = this.pointCoordinate(c, i), p = this.pointCoordinate(h, i), f = (e, t1)=>(t1.y - e.y) / (t1.x - e.x);
                return d.y > 1 && u.y >= 0 ? d = new e.ae((1 - p.y) / f(p, d) + p.x, 1) : d.y < 0 && u.y <= 1 && (d = new e.ae(-p.y / f(p, d) + p.x, 0)), u.y > 1 && d.y >= 0 ? u = new e.ae((1 - _.y) / f(_, u) + _.x, 1) : u.y < 0 && d.y <= 1 && (u = new e.ae(-_.y / f(_, u) + _.x, 0)), (new e.aI).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_));
            }
            _getBoundsRectangularTerrain() {
                const e = this.elevation;
                if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                const t1 = e.visibleDemTiles.reduce((e, t1)=>{
                    if (t1.dem) {
                        const i = t1.dem.tree;
                        e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
                    }
                    return e;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBoundsRectangular(t1.min * e.exaggeration(), t1.max * e.exaggeration());
            }
            getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e = !0) {
                const t1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y, i = this.height / 2 - t1 * (1 - this._horizonShift);
                return e ? Math.max(0, i) : i;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t1) {
                this.maxBounds = t1, this.minLat = -e.cJ, this.maxLat = e.cJ, this.minLng = -180, this.maxLng = 180, t1 && (this.minLat = t1.getSouth(), this.maxLat = t1.getNorth(), this.minLng = t1.getWest(), this.maxLng = t1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.aF(this.minLng) * this.tileSize, this.worldMaxX = e.aF(this.maxLng) * this.tileSize, this.worldMinY = e.aJ(this.maxLat) * this.tileSize, this.worldMaxY = e.aJ(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e, t1) {
                return this.projection.createTileMatrix(this, t1, e);
            }
            calculateDistanceTileData(t1) {
                const i = t1.key, o = this._distanceTileDataCache;
                if (o[i]) return o[i];
                const s = t1.canonical, r = 1 / this.height, n = this.cameraWorldSize, a = n / this.zoomScale(s.z), l = (s.x + Math.pow(2, s.z) * t1.wrap) * a, c = s.y * a, h = this.point;
                h.x *= n / this.worldSize, h.y *= n / this.worldSize;
                const d = this.angle, u = Math.sin(-d), _ = -Math.cos(-d);
                return o[i] = {
                    bearing: [
                        u,
                        _
                    ],
                    center: [
                        (h.x - l) * r,
                        (h.y - c) * r
                    ],
                    scale: a / e.al * r
                }, o[i];
            }
            calculateFogTileMatrix(t1) {
                const i = t1.key, o = this._fogTileMatrixCache;
                if (o[i]) return o[i];
                const s = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t1);
                return e.aB(s, this.worldToFogMatrix, s), o[i] = new Float32Array(s), o[i];
            }
            calculateProjMatrix(t1, i = !1, o = !1) {
                const s = t1.key;
                let r;
                if (r = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, r[s]) return r[s];
                const n = this.calculatePosMatrix(t1, this.worldSize);
                let a;
                return a = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.aB(n, a, n), r[s] = new Float32Array(n), r[s];
            }
            calculatePixelsToTileUnitsMatrix(t1) {
                const i = t1.tileID.key, o = this._pixelsToTileUnitsCache;
                if (o[i]) return o[i];
                const s = e.cN(t1, this);
                return o[i] = s, o[i];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t1 = 1 / this.worldSize, i = e.bq([], [
                        t1,
                        t1,
                        t1
                    ]);
                    return e.aB(i, i, this.globeMatrix), i;
                }
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t1 = this._elevation;
                this._updateCameraState();
                const i = e.cf(1, this._center.lat) * this.worldSize, o = this._computeCameraPosition(i), s = this._camera.forward(), r = e.cf(1, this._center.lat);
                o[2] /= r, s[2] /= r, e.aw(s, s);
                const n = t1.raycast(o, s, t1.exaggeration());
                if (n) {
                    const t1 = e.bH([], o, s, n), i = new e.ae(t1[0], t1[1], e.cf(t1[2], e.a$(t1[1]))), a = (i.z + e.ag([
                        i.x - o[0],
                        i.y - o[1],
                        i.z - o[2] * r
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t1 = !1) {
                if (!this._elevation) return;
                const i = this._elevation, o = e.cf(1, this._center.lat) * this.worldSize, s = this._computeCameraPosition(o), r = i.getAtPointOrZero(new e.ae(...s)), n = this.pixelsPerMeter / this.worldSize * r, a = this._minimumHeightOverTerrain(), l = s[2] - n;
                if (l <= a) if (l < 0 || t1) {
                    const t1 = this.locationCoordinate(this._center, this._centerAltitude), i = [
                        s[0],
                        s[1],
                        t1.z - s[2]
                    ], o = e.ag(i);
                    i[2] -= (a - l) / this._pixelsPerMercatorPixel;
                    const r = e.ag(i);
                    if (0 === r) return;
                    e.c5(i, i, o / r * this._pixelsPerMercatorPixel), this._camera.position = [
                        s[0],
                        s[1],
                        t1.z * this._pixelsPerMercatorPixel - i[2]
                    ], this._updateStateFromCamera();
                } else this._isCameraConstrained = !0;
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t1 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t1) {
                    const i = this.center;
                    return i.lat = e.aA(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t1) && (i.lng = e.aA(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }
                const i = this._unmodified, { x: o, y: s } = this.point;
                let r = 0, n = o, a = s;
                const l = this.width / 2, c = this.height / 2, h = this.worldMinY * this.scale, d = this.worldMaxY * this.scale;
                if (s - c < h && (a = h + c), s + c > d && (a = d - c), d - h < this.height && (r = Math.max(r, this.height / (d - h)), a = (d + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e = this.worldMinX * this.scale, t1 = this.worldMaxX * this.scale, i = this.worldSize / 2 - (e + t1) / 2;
                    n = (o + i + this.worldSize) % this.worldSize - i, n - l < e && (n = e + l), n + l > t1 && (n = t1 - l), t1 - e < this.width && (r = Math.max(r, this.width / (t1 - e)), n = (t1 + e) / 2);
                }
                n === o && a === s || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n, a))), r && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e = Math.max(0, this.scaleZoom(Math.max(0, this.height) / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t1 = this.centerOffset, i = "globe" === this.projection.name, o = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e.cf(1, this.center.lat) / e.cf(1, e.d2));
                const s = e.cO(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const r = "meters" === this.projection.zAxisUnit ? o : 1, n = this._camera.getWorldToCamera(this.worldSize, r);
                let a;
                const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                if (l[8] = 2 * -t1.x / this.width, l[9] = 2 * t1.y / this.height, this.isOrthographic) {
                    let i = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov), o = i * this.aspect, s = -o, r = -i;
                    o -= t1.x, s -= t1.x, i += t1.y, r += t1.y, a = this._camera.getCameraToClipOrthographic(s, o, r, i, this._nearZ, this._farZ), ((t1, i, o, s)=>{
                        for(let r = 0; r < 16; r++)t1[r] = e.ak(i[r], o[r], s);
                    })(a, a, l, e.d0(this.pitch >= ao ? 1 : this.pitch / ao));
                } else a = l;
                const c = e.cP([], l, n);
                let h = e.cP([], a, n);
                if (this.projection.isReprojectedInTileSpace) {
                    const t1 = this.locationCoordinate(this.center), i = e.bA([]);
                    e.br(i, i, [
                        t1.x * this.worldSize,
                        t1.y * this.worldSize,
                        0
                    ]), e.aB(i, i, e.cQ(this)), e.br(i, i, [
                        -t1.x * this.worldSize,
                        -t1.y * this.worldSize,
                        0
                    ]), e.aB(h, h, i), e.aB(c, c, i), this.inverseAdjustmentMatrix = e.cR(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                if (this.mercatorMatrix = e.cS([], h, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / r,
                    1
                ]), this.projMatrix = h, this.invProjMatrix = e.bl(new Float64Array(16), this.projMatrix), i) {
                    const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                    i[8] = 2 * -t1.x / this.width, i[9] = 2 * t1.y / this.height, this.expandedFarZProjMatrix = e.cP([], i, n);
                } else this.expandedFarZProjMatrix = this.projMatrix;
                const d = e.bl([], a);
                this.frustumCorners = e.cT.fromInvProjectionMatrix(d, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);
                const u = new Float32Array(16);
                e.bA(u), e.cS(u, u, [
                    1,
                    -1,
                    1
                ]), e.cU(u, u, this._pitch), e.bB(u, u, this.angle);
                const _ = e.cd(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
                this.starsProjMatrix = e.bz(_);
                const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                _[8] = 2 * -t1.x / this.width, _[9] = 2 * (t1.y + p) / this.height, this.skyboxMatrix = e.aB(u, _, u);
                const f = this.point, m = f.x, g = f.y, v = this.width % 2 / 2, y = this.height % 2 / 2, x = Math.cos(this.angle), b = Math.sin(this.angle), w = m - Math.round(m) + x * v + b * y, T = g - Math.round(g) + x * y + b * v, E = new Float64Array(h);
                if (e.br(E, E, [
                    w > .5 ? w - 1 : w,
                    T > .5 ? T - 1 : T,
                    0
                ]), this.alignedProjMatrix = E, h = e.bC(), e.cS(h, h, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e.br(h, h, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = h, h = e.bC(), e.cS(h, h, [
                    1,
                    -1,
                    1
                ]), e.br(h, h, [
                    -1,
                    -1,
                    0
                ]), e.cS(h, h, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = h, this.pixelMatrix = e.aB(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.bl(new Float64Array(16), this.pixelMatrix), !h) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = h, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e.cV(this);
                    const t1 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e.af(t1, t1, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = h;
                this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const t1 = this.cameraWorldSizeForFog, i = this.cameraPixelsPerMeter, o = this._camera.position, s = 1 / this.height / this._pixelsPerMercatorPixel, r = [
                    t1,
                    t1,
                    i
                ];
                e.c5(r, r, s), e.c5(o, o, -1), e.cW(o, o, r);
                const n = e.bC();
                e.br(n, n, o), e.cS(n, n, r), this.mercatorFogMatrix = n, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t1, i, s);
            }
            _computeCameraPosition(e) {
                const t1 = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, i = this._camera.forward(), o = this.point, s = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t1 - e / this.worldSize * this._centerAltitude;
                return [
                    o.x / this.worldSize - i[0] * s,
                    o.y / this.worldSize - i[1] * s,
                    e / this.worldSize * this._centerAltitude - i[2] * s
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t1) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o = this._camera.position[2], s = t1[2];
                let r = 1;
                this.projection.wrap && (this.center = this.center.wrap()), s > 0 && (r = Math.min((i - o) / s, 1)), this._camera.position = e.bH([], this._camera.position, t1, r), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t1 = this._camera.position, i = this._camera.forward(), { pitch: o, bearing: s } = this._camera.getPitchBearing(), r = e.cf(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.an(this._maxPitch)), a = Math.max((t1[2] - r) / Math.cos(o), n), l = this._zoomFromMercatorZ(a);
                e.bH(t1, t1, i, a), this._pitch = e.aA(o, e.an(this.minPitch), e.an(this.maxPitch)), this.angle = e.bT(s, -Math.PI, Math.PI), this._setZoom(e.aA(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ae(t1[0], t1[1], t1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e) {
                return Math.pow(2, e) * this.tileSize;
            }
            _mercatorZfromZoom(e) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
            }
            _minimumHeightOverTerrain() {
                const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
                return this._mercatorZfromZoom(e);
            }
            _zoomFromMercatorZ(e) {
                return this.scaleZoom(this.cameraToCenterDistance / (Math.max(0, e) * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t1) {
                let i = 0, o = e.cL, s = 0, r = 1 / 0;
                for(; o - i > 1e-6 && o > i;){
                    const e = i + .5 * (o - i), n = this.tileSize * Math.pow(2, e), a = this.getCameraToCenterDistance(this.projection, e, n), l = this.scaleZoom(a / (Math.max(0, t1) * this.tileSize)), c = Math.abs(e - l);
                    c < r && (r = c, s = e), e < l ? i = e : o = e;
                }
                return s;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t1, i) {
                const o = Math.min(t1.x, i.x), s = Math.max(t1.x, i.x), r = Math.min(t1.y, i.y), n = Math.max(t1.y, i.y);
                if (r < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const a = [
                    new e.P(o, r),
                    new e.P(s, n),
                    new e.P(o, n),
                    new e.P(s, r)
                ], l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                for (const e of a){
                    const t1 = this.pointRayIntersection(e);
                    if (t1.t < 0) return !0;
                    const i = this.rayIntersectionCoordinate(t1);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e.cX(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
            }
            zoomDeltaToMovement(t1, i) {
                const o = e.ag(e.av([], this._camera.position, t1)), s = this._zoomFromMercatorZ(o) + i;
                return o - this._mercatorZfromZoom(s);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t1 = function([t1, i, o], s) {
                        const r = [
                            t1,
                            i,
                            o,
                            1
                        ];
                        e.aC(r, r, s);
                        const n = r[3] = Math.max(r[3], 1e-6);
                        return r[0] /= n, r[1] /= n, r[2] /= n, r;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e.P(t1[0], t1[1]);
                }
                {
                    const t1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e.P(0, t1));
                }
            }
            getCameraToCenterDistance(t1, i = this.zoom, o = this.worldSize) {
                const s = e.cO(t1, i, this.width, this.height, 1024), r = t1.pixelSpaceConversion(this.center.lat, o, s);
                let n = .5 / Math.tan(.5 * this._fov) * this.height * r;
                return this.isOrthographic && (n = e.ak(1, n, e.d0(this.pitch >= ao ? 1 : this.pitch / ao))), n;
            }
            getWorldToCameraMatrix() {
                const t1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e.aB(t1, t1, this.globeMatrix), t1;
            }
            getFrustum(t1) {
                return e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t1, "meters" === this.projection.zAxisUnit);
            }
        }
        const co = (t1, i)=>{
            if (i > 0 && t1.terrain && e.w("Cutoff is currently disabled on terrain"), i <= 0 || t1.terrain) return {
                shouldRenderCutoff: !1,
                uniformValues: {
                    u_cutoff_params: [
                        0,
                        0,
                        0,
                        1
                    ]
                }
            };
            const o = t1.transform, s = Math.max(Math.abs(o._zoom - (t1.minCutoffZoom - 1)), 1), r = o.isLODDisabled(!1) ? e.ah(60, 45, o.pitch) : e.ah(30, 15, o.pitch), n = o._farZ - o._nearZ, a = i * o.height, l = ((1 - (c = r)) * o.cameraToCenterDistance + c * (o._farZ + a)) * s;
            var c;
            return {
                shouldRenderCutoff: r < 1,
                uniformValues: {
                    u_cutoff_params: [
                        o._nearZ,
                        o._farZ,
                        (l - o._nearZ) / n,
                        (l - a - o._nearZ) / n
                    ]
                }
            };
        }, ho = 2048;
        class uo {
            constructor(e, t1){
                this.aabb = e, this.lastCascade = t1;
            }
        }
        class _o {
            add(e, t1) {
                const i = this.receivers[e.key];
                void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t1.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t1.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t1.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t1.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t1.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t1.max[2])) : this.receivers[e.key] = new uo(t1, null);
            }
            clear() {
                this.receivers = {};
            }
            get(e) {
                return this.receivers[e.key];
            }
            computeRequiredCascades(t1, i, o) {
                const s = e.d9.fromPoints(t1.points);
                let r = 0;
                for(const t1 in this.receivers){
                    const n = this.receivers[t1];
                    if (!n) continue;
                    if (!s.intersectsAabb(n.aabb)) continue;
                    n.aabb.min = s.closestPoint(n.aabb.min), n.aabb.max = s.closestPoint(n.aabb.max);
                    const a = n.aabb.getCorners();
                    for(let t1 = 0; t1 < o.length; t1++){
                        let s = !0;
                        for (const r of a){
                            const n = [
                                r[0] * i,
                                r[1] * i,
                                r[2]
                            ];
                            if (e.af(n, n, o[t1].matrix), n[0] < -1 || n[0] > 1 || n[1] < -1 || n[1] > 1) {
                                s = !1;
                                break;
                            }
                        }
                        if (n.lastCascade = t1, r = Math.max(r, t1), s) break;
                    }
                }
                return r + 1;
            }
        }
        class po {
            constructor(e){
                this.painter = e, this._enabled = !1, this._drawShadowAfterLayer = -1, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new _o, this._depthMode = new $i(e.context.gl.LEQUAL, $i.ReadWrite, [
                    0,
                    1
                ]), this._uniformValues = {
                    u_light_matrix_0: new Float32Array(16),
                    u_light_matrix_1: new Float32Array(16),
                    u_shadow_intensity: 0,
                    u_fade_range: [
                        0,
                        0
                    ],
                    u_shadow_normal_offset: [
                        1,
                        1,
                        1
                    ],
                    u_shadow_texel_size: 1,
                    u_shadow_map_resolution: 1,
                    u_shadow_direction: [
                        0,
                        0,
                        1
                    ],
                    u_shadow_bias: [
                        36e-5,
                        .0012,
                        .012
                    ],
                    u_shadowmap_0: 0,
                    u_shadowmap_1: 0
                }, this._forceDisable = !1, this.useNormalOffset = !1;
            }
            destroy() {
                for (const e of this._cascades)e.texture.destroy(), e.framebuffer.destroy();
                this._cascades = [];
            }
            updateShadowParameters(t1, i) {
                const o = this.painter;
                if (this._enabled = !1, this._drawShadowAfterLayer = -1, this._receivers.clear(), !i || !i.properties) return;
                const s = i.properties.get("shadow-intensity"), r = i.properties.get("shadow-draw-before-layer");
                if (!i.shadowsEnabled() || s <= 0) return;
                let n = -1, a = 0;
                for (const e of o.style.order){
                    const i = o.style._mergedLayers[e];
                    i.hasShadowPass() && !i.isHidden(t1.zoom) && (n = a), r && r === e && (this._drawShadowAfterLayer = a > 0 ? a - 1 : 0), a += 1;
                }
                if (this._enabled = n >= 0, !this.enabled) return;
                this._drawShadowAfterLayer < 0 && (this._drawShadowAfterLayer = n);
                const l = o.context, c = ho, h = ho;
                if (0 === this._cascades.length || ho !== this._cascades[0].texture.size[0]) {
                    this._cascades = [];
                    for(let t1 = 0; t1 < 2; ++t1){
                        const t1 = o._shadowMapDebug, i = l.gl, s = l.createFramebuffer(c, h, t1 ? 1 : 0, "texture"), r = new e.T(l, {
                            width: c,
                            height: h,
                            data: null
                        }, i.DEPTH_COMPONENT16);
                        if (s.depthAttachment.set(r.texture), t1) {
                            const t1 = new e.T(l, {
                                width: c,
                                height: h,
                                data: null
                            }, i.RGBA8);
                            s.colorAttachment0.set(t1.texture);
                        }
                        this._cascades.push({
                            framebuffer: s,
                            texture: r,
                            matrix: [],
                            far: 0,
                            boundingSphereRadius: 0,
                            frustum: new e.cB,
                            scale: 0
                        });
                    }
                }
                this.shadowDirection = mo(i);
                let d = 0;
                if (t1.elevation) {
                    const e = t1.elevation, i = [
                        1e4,
                        -1e4
                    ];
                    e.visibleDemTiles.filter((e)=>e.dem).forEach((e)=>{
                        const t1 = e.dem.tree;
                        i[0] = Math.min(i[0], t1.minimums[0]), i[1] = Math.max(i[1], t1.maximums[0]);
                    }), 1e4 !== i[0] && (d = (i[1] - i[0]) * e.exaggeration());
                }
                const u = 1.5 * t1.cameraToCenterDistance, _ = 3 * u, p = new Float64Array(16);
                for(let i = 0; i < this._cascades.length; ++i){
                    const o = this._cascades[i];
                    let s = t1.height / 50, r = 1;
                    0 === i ? r = u : (s = u, r = _);
                    const [n, a] = vo(t1, this.shadowDirection, s, r, ho, d);
                    o.scale = t1.scale, o.matrix = n, o.boundingSphereRadius = a, e.bl(p, o.matrix), o.frustum = e.cB.fromInvProjectionMatrix(p, 1, 0, !0), o.far = r;
                }
                const f = this._cascades.length - 1;
                this._uniformValues.u_fade_range = [
                    .75 * this._cascades[f].far,
                    this._cascades[f].far
                ], this._uniformValues.u_shadow_intensity = s, this._uniformValues.u_shadow_direction = [
                    this.shadowDirection[0],
                    this.shadowDirection[1],
                    this.shadowDirection[2]
                ], this._uniformValues.u_shadow_texel_size = .00048828125, this._uniformValues.u_shadow_map_resolution = ho, this._uniformValues.u_shadowmap_0 = 11, this._uniformValues.u_shadowmap_1 = 12, this._groundShadowTiles = o.transform.coveringTiles({
                    tileSize: 512,
                    renderWorldCopies: !0
                });
                const m = o.transform.elevation;
                for (const e of this._groundShadowTiles){
                    let t1 = {
                        min: 0,
                        max: 0
                    };
                    if (m) {
                        const i = m.getMinMaxForTile(e);
                        i && (t1 = i);
                    }
                    this.addShadowReceiver(e.toUnwrapped(), t1.min, t1.max);
                }
            }
            get enabled() {
                return this._enabled && !this._forceDisable;
            }
            set enabled(e) {
                this._enabled = e;
            }
            drawShadowPass(t1, i) {
                if (!this.enabled) return;
                const o = this.painter, s = o.context;
                this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), s.viewport.set([
                    0,
                    0,
                    ho,
                    ho
                ]);
                for(let r = 0; r < this._numCascadesToRender; ++r){
                    o.currentShadowCascade = r, s.bindFramebuffer.set(this._cascades[r].framebuffer.framebuffer), s.clear({
                        color: e.ao.white,
                        depth: 1
                    });
                    for (const e of t1.order){
                        const s = t1._mergedLayers[e];
                        if (!s.hasShadowPass() || s.isHidden(o.transform.zoom)) continue;
                        const r = t1.getLayerSourceCache(s), n = r ? i[r.id] : void 0;
                        ("model" === s.type || n && n.length) && o.renderLayer(o, r, s, n);
                    }
                }
                o.currentShadowCascade = 0;
            }
            drawGroundShadows() {
                if (!this.enabled) return;
                const e = this.painter, t1 = e.style, i = e.context, o = i.gl, s = t1.directionalLight, r = t1.ambientLight;
                if (!s || !r) return;
                const n = [], a = co(e, e.longestCutoffRange);
                a.shouldRenderCutoff && n.push("RENDER_CUTOFF"), n.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && n.push("NORMAL_OFFSET");
                const l = go(t1, s, r), c = new $i(o.LEQUAL, $i.ReadOnly, e.depthRangeFor3D), h = new Yi({
                    func: o.EQUAL,
                    mask: 255
                }, 0, 255, o.KEEP, o.KEEP, o.KEEP);
                for (const t1 of this._groundShadowTiles){
                    const s = t1.toUnwrapped(), r = e.isTileAffectedByFog(t1), d = e.getOrCreateProgram("groundShadow", {
                        defines: n,
                        overrideFog: r
                    });
                    this.setupShadows(s, d), e.uploadCommonUniforms(i, d, s, null, a);
                    const u = ro(e.transform.calculateProjMatrix(s), l);
                    d.draw(e, o.TRIANGLES, c, h, Wi.multiply, Qi.disabled, u, "ground_shadow", e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments, null, e.transform.zoom, null, null);
                }
            }
            getShadowPassColorMode() {
                return this.painter._shadowMapDebug ? Wi.unblended : Wi.disabled;
            }
            getShadowPassDepthMode() {
                return this._depthMode;
            }
            getGroundShadowLayerIndex() {
                return this._drawShadowAfterLayer;
            }
            calculateShadowPassMatrixFromTile(t1) {
                const i = this.painter.transform, o = i.calculatePosMatrix(t1, i.worldSize);
                return e.aB(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);
            }
            calculateShadowPassMatrixFromMatrix(t1) {
                const i = e.bz(t1);
                return e.aB(i, this._cascades[this.painter.currentShadowCascade].matrix, t1), i;
            }
            setupShadows(t1, i, o) {
                if (!this.enabled) return;
                const s = this.painter.transform, r = this.painter.context, n = r.gl, a = this._uniformValues, l = new Float64Array(16), c = s.calculatePosMatrix(t1, s.worldSize);
                for(let t1 = 0; t1 < this._cascades.length; t1++)e.aB(l, this._cascades[t1].matrix, c), a[0 === t1 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(l), r.activeTexture.set(n.TEXTURE0 + 11 + t1), this._cascades[t1].texture.bindExtraParam(n.LINEAR, n.LINEAR, n.CLAMP_TO_EDGE, n.CLAMP_TO_EDGE, n.GREATER);
                if (this.useNormalOffset = !!o, this.useNormalOffset) {
                    const i = e.d7(t1.canonical), r = 2 / s.tileSize * e.al / ho, n = r * this._cascades[0].boundingSphereRadius, l = r * this._cascades[this._cascades.length - 1].boundingSphereRadius, c = ("vector-tile" === o ? 1 : 3) * function(t1) {
                        const i = e.aA((t1 - 22) / -22, 0, 1);
                        return .125 * (1 - i) + 4 * i;
                    }(s.zoom);
                    a.u_shadow_normal_offset = [
                        i,
                        n * c,
                        l * c
                    ], a.u_shadow_bias = [
                        1e-4,
                        .0012,
                        .012
                    ];
                } else a.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(r, a);
            }
            setupShadowsFromMatrix(t1, i, o = !1) {
                if (!this.enabled) return;
                const s = this.painter.context, r = s.gl, n = this._uniformValues, a = new Float64Array(16);
                for(let i = 0; i < 2; i++)e.aB(a, this._cascades[i].matrix, t1), n[0 === i ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a), s.activeTexture.set(r.TEXTURE0 + 11 + i), this._cascades[i].texture.bindExtraParam(r.LINEAR, r.LINEAR, r.CLAMP_TO_EDGE, r.CLAMP_TO_EDGE, r.GREATER);
                this.useNormalOffset = o, o ? (n.u_shadow_normal_offset = [
                    1,
                    3,
                    3
                ], n.u_shadow_bias = [
                    6e-5,
                    .0012,
                    .012
                ]) : n.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ], i.setShadowUniformValues(s, n);
            }
            getShadowUniformValues() {
                return this._uniformValues;
            }
            getCurrentCascadeFrustum() {
                return this._cascades[this.painter.currentShadowCascade].frustum;
            }
            computeSimplifiedTileShadowVolume(t1, i, o, s) {
                if (s[2] >= 0) return {};
                const r = (function(t1, i, o) {
                    const s = o / (1 << t1.canonical.z);
                    return new e.d9([
                        t1.canonical.x * s + t1.wrap * o,
                        t1.canonical.y * s + t1.wrap * o,
                        0
                    ], [
                        (t1.canonical.x + 1) * s + t1.wrap * o,
                        (t1.canonical.y + 1) * s + t1.wrap * o,
                        i
                    ]);
                })(t1, i, o).getCorners(), n = i / -s[2];
                s[0] < 0 ? (e.d8(r[0], r[0], [
                    s[0] * n,
                    0,
                    0
                ]), e.d8(r[3], r[3], [
                    s[0] * n,
                    0,
                    0
                ])) : s[0] > 0 && (e.d8(r[1], r[1], [
                    s[0] * n,
                    0,
                    0
                ]), e.d8(r[2], r[2], [
                    s[0] * n,
                    0,
                    0
                ])), s[1] < 0 ? (e.d8(r[0], r[0], [
                    0,
                    s[1] * n,
                    0
                ]), e.d8(r[1], r[1], [
                    0,
                    s[1] * n,
                    0
                ])) : s[1] > 0 && (e.d8(r[2], r[2], [
                    0,
                    s[1] * n,
                    0
                ]), e.d8(r[3], r[3], [
                    0,
                    s[1] * n,
                    0
                ]));
                const a = {};
                return a.vertices = r, a.planes = [
                    fo(r[1], r[0], r[4]),
                    fo(r[2], r[1], r[5]),
                    fo(r[3], r[2], r[6]),
                    fo(r[0], r[3], r[7])
                ], a;
            }
            addShadowReceiver(t1, i, o) {
                this._receivers.add(t1, e.d9.fromTileIdAndHeight(t1, i, o));
            }
            getMaxCascadeForTile(e) {
                const t1 = this._receivers.get(e);
                return t1 && t1.lastCascade ? t1.lastCascade : 0;
            }
        }
        function fo(t1, i, o) {
            const s = e.av([], o, i), r = e.av([], t1, i), n = e.bI([], s, r), a = e.ag(n);
            return 0 === a ? [
                0,
                0,
                1,
                0
            ] : (e.c5(n, n, 1 / a), [
                n[0],
                n[1],
                n[2],
                -e.bJ(n, i)
            ]);
        }
        function mo(t1) {
            const i = t1.properties.get("direction"), o = e.d4(i.x, i.y, i.z);
            o[2] = e.aA(o[2], 0, 75);
            const s = e.d6([
                o[0],
                o[1],
                o[2]
            ]);
            return e.d5(s.x, s.y, s.z);
        }
        function go(t1, i, o) {
            const s = "none" === i.properties.get("color-use-theme"), r = i.properties.get("color"), n = i.properties.get("intensity"), a = i.properties.get("direction"), l = [
                a.x,
                a.y,
                a.z
            ], c = "none" === o.properties.get("color-use-theme"), h = o.properties.get("color"), d = o.properties.get("intensity"), u = Math.max(e.bJ([
                0,
                0,
                1
            ], l), 0), _ = [
                0,
                0,
                0
            ];
            e.c5(_, h.toPremultipliedRenderColor(c ? null : t1.getLut(i.scope)).toArray01Linear().slice(0, 3), d);
            const p = [
                0,
                0,
                0
            ];
            return e.c5(p, r.toPremultipliedRenderColor(s ? null : t1.getLut(o.scope)).toArray01Linear().slice(0, 3), u * n), e.db([
                _[0] > 0 ? _[0] / (_[0] + p[0]) : 0,
                _[1] > 0 ? _[1] / (_[1] + p[1]) : 0,
                _[2] > 0 ? _[2] / (_[2] + p[2]) : 0
            ]);
        }
        function vo(t1, i, o, s, r, n) {
            const a = t1.zoom, l = t1.scale, c = t1.worldSize, h = 1 / c, d = t1.aspect, u = Math.sqrt(1 + d * d) * Math.tan(.5 * t1.fovX), _ = u * u, p = s - o, f = s + o;
            let m, g;
            _ > p / f ? (m = s, g = s * u) : (m = .5 * f * (1 + _), g = .5 * Math.sqrt(p * p + 2 * (s * s + o * o) * _ + f * f * _ * _));
            const v = t1.projection.pixelsPerMeter(t1.center.lat, c), y = t1._camera.getCameraToWorldMercator(), x = [
                0,
                0,
                -m * h
            ];
            e.af(x, x, y);
            let b = g * h;
            const w = function(i) {
                return i[0] /= l, i[1] /= l, i[2] = e.cf(i[2], t1._center.lat), i;
            }, T = t1._edgeInsets;
            if (!(0 === T.left && 0 === T.top && 0 === T.right && 0 === T.bottom || T.left === T.right && T.top === T.bottom)) {
                const i = t1._camera.getWorldToCamera(t1.worldSize, "meters" === t1.projection.zAxisUnit ? v : 1), r = t1._camera.getCameraToClipPerspective(t1._fov, t1.width / t1.height, o, s);
                r[8] = 2 * -t1.centerOffset.x / t1.width, r[9] = 2 * t1.centerOffset.y / t1.height;
                const n = new Float64Array(16);
                e.cP(n, r, i);
                const l = new Float64Array(16);
                e.bl(l, n);
                const h = e.cB.fromInvProjectionMatrix(l, c, a, !0);
                for (const t1 of h.points){
                    const i = w(t1);
                    b = Math.max(b, e.c6(e.da([], x, i)));
                }
            }
            b *= r / (r - 1);
            const E = Math.acos(i[2]), S = Math.atan2(-i[0], -i[1]), I = new so;
            I.position = x, I.setPitchBearing(E, S);
            const C = I.getWorldToCamera(c, v), R = b * c, A = Math.min(t1._mercatorZfromZoom(17) * c * -2, -2 * R), L = I.getCameraToClipOrthographic(-R, R, -R, R, A, (R + n * v) / i[2]), D = new Float64Array(16);
            e.aB(D, L, C);
            const P = e.d5(Math.floor(1e6 * x[0]) / 1e6 * c, Math.floor(1e6 * x[1]) / 1e6 * c, 0), O = .5 * r, z = [
                0,
                0,
                0
            ];
            e.af(z, P, D), e.c5(z, z, O);
            const M = [
                Math.floor(z[0]),
                Math.floor(z[1]),
                Math.floor(z[2])
            ], F = [
                0,
                0,
                0
            ];
            e.av(F, z, M), e.c5(F, F, -1 / O);
            const B = new Float64Array(16);
            return e.bA(B), e.br(B, B, F), e.aB(D, B, D), [
                D,
                R
            ];
        }
        class yo extends e.E {
            constructor(e){
                super(), this.requestManager = e, this.models = {
                    "": {}
                }, this.modelUris = {
                    "": {}
                }, this.modelByURL = {}, this.numModelsLoading = {};
            }
            loadModel(t1, i) {
                return e.dc(this.requestManager.transformRequest(i, e.R.Model).url).then((o)=>{
                    if (!o) return;
                    const s = e.dd(o), r = new e.de(t1, i, void 0, void 0, s);
                    return r.computeBoundsAndApplyParent(), r;
                }).catch((o)=>{
                    if (o && 404 === o.status) return null;
                    this.fire(new e.y(new Error(`Could not load model ${t1} from ${i}: ${o.message}`)));
                });
            }
            load(t1, i, o = {
                forceReload: !1
            }) {
                this.models[i] || (this.models[i] = {});
                const s = Object.keys(t1), r = [], n = [];
                for (const e of s){
                    const s = t1[e];
                    this.hasURLBeenRequested(s) && !o.forceReload || (this.modelByURL[s] = {
                        modelId: e,
                        scope: i
                    }, r.push(this.loadModel(e, s)), n.push(e)), this.models[i][e] || (this.models[i][e] = {
                        model: null,
                        numReferences: 1
                    });
                }
                this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + n.length, Promise.allSettled(r).then((t1)=>{
                    for(let e = 0; e < t1.length; e++){
                        const { status: o } = t1[e];
                        if ("rejected" === o) continue;
                        const { value: s } = t1[e];
                        this.models[i][n[e]] || (this.models[i][n[e]] = {
                            model: null,
                            numReferences: 1
                        }), this.models[i][n[e]].model = s;
                    }
                    this.numModelsLoading[i] -= n.length, this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                }).catch((t1)=>{
                    this.fire(new e.y(new Error(`Could not load models: ${t1.message}`)));
                });
            }
            isLoaded() {
                for(const e in this.numModelsLoading)if (this.numModelsLoading[e] > 0) return !1;
                return !0;
            }
            hasModel(e, t1, i = {
                exactIdMatch: !1
            }) {
                return !!(i.exactIdMatch ? this.getModel(e, t1) : this.getModelByURL(this.modelUris[t1][e]));
            }
            getModel(e, t1) {
                return this.models[t1] || (this.models[t1] = {}), this.models[t1][e] ? this.models[t1][e].model : void 0;
            }
            getModelByURL(e) {
                if (!e) return null;
                const t1 = this.modelByURL[e];
                return t1 ? this.models[t1.scope][t1.modelId].model : null;
            }
            hasModelBeenAdded(e, t1) {
                return this.models[t1] && void 0 !== this.models[t1][e];
            }
            getModelURIs(e) {
                return this.modelUris[e] || {};
            }
            addModel(e, t1, i) {
                this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {});
                const o = this.requestManager.normalizeModelURL(t1);
                if ((this.hasModel(e, i, {
                    exactIdMatch: !0
                }) || this.hasModelBeenAdded(e, i)) && this.modelUris[i][e] === o) this.models[i][e].numReferences++;
                else if (this.hasURLBeenRequested(o)) {
                    const { scope: e, modelId: t1 } = this.modelByURL[o];
                    this.models[e][t1].numReferences++;
                } else this.modelUris[i][e] = o, this.load({
                    [e]: this.modelUris[i][e]
                }, i);
            }
            addModelURLs(e, t1) {
                this.models[t1] || (this.models[t1] = {}), this.modelUris[t1] || (this.modelUris[t1] = {});
                const i = this.modelUris[t1];
                for(const t1 in e)i[t1] = this.requestManager.normalizeModelURL(e[t1]);
            }
            reloadModels(e) {
                this.load(this.modelUris[e], e, {
                    forceReload: !0
                });
            }
            addModelsFromBucket(t1, i) {
                this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {});
                const o = {};
                for (const s of t1)this.hasModel(s, i, {
                    exactIdMatch: !0
                }) || this.hasURLBeenRequested(s) ? this.models[i][s].numReferences++ : this.modelUris[i][s] && !this.hasURLBeenRequested(s) ? o[s] = this.modelUris[i][s] : !this.hasURLBeenRequested(s) && e.df(s, !1) && (this.modelUris[i][s] = this.requestManager.normalizeModelURL(s), o[s] = this.modelUris[i][s]);
                this.load(o, i);
            }
            hasURLBeenRequested(e) {
                return void 0 !== this.modelByURL[e];
            }
            removeModel(e, t1, i = !1, o = !1) {
                if (this.models[t1] && this.models[t1][e] && (this.models[t1][e].numReferences--, 0 === this.models[t1][e].numReferences || o)) {
                    const o = this.modelUris[t1][e];
                    i || delete this.modelUris[t1][e], delete this.modelByURL[o];
                    const s = this.models[t1][e].model;
                    if (!s) return;
                    delete this.models[t1][e], s.destroy();
                }
            }
            destroy() {
                for (const e of Object.keys(this.models))for (const t1 of Object.keys(this.models[e])){
                    const i = this.models[e][t1].model;
                    delete this.models[e][t1], i && i.destroy();
                }
                this.models = {
                    "": {}
                }, this.modelUris = {
                    "": {}
                }, this.modelByURL = {}, this.numModelsLoading = {};
            }
            listModels(e) {
                return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);
            }
            upload(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                for(const i in this.models[t1])this.models[t1][i].model && this.models[t1][i].model.upload(e.context);
            }
        }
        const xo = e.a6.colorTheme, bo = new e.a9({
            data: new e.aa(xo.data)
        });
        function wo(t1) {
            if (!t1.metadata || !t1.metadata.content_area) return;
            const i = e.o.devicePixelRatio, { left: o, top: s, width: r, height: n } = t1.metadata.content_area, a = o * i, l = s * i;
            return [
                a,
                l,
                a + r * i,
                l + n * i
            ];
        }
        function To(t1) {
            if (t1) return t1.map(([t1, i])=>[
                    t1 * e.o.devicePixelRatio,
                    i * e.o.devicePixelRatio
                ]);
        }
        class Eo {
            constructor(e, t1, i){
                this.id = e, this.scope = t1, this.sourceCache = i, this.pendingRequests = new Set, this.missingRequests = new Set;
            }
            addPendingRequest(e) {
                this.missingRequests.has(e.name) || this.pendingRequests.has(e.name) || this.pendingRequests.add(e.name);
            }
            hasPendingRequests() {
                return this.pendingRequests.size > 0;
            }
            resolvePendingRequests() {
                const t1 = new Map;
                if (!this.sourceCache.loaded()) return t1;
                const i = this.sourceCache.getVisibleCoordinates();
                if (0 === i.length) return t1;
                const o = this.sourceCache.getSource();
                if (!(o instanceof pt)) return t1;
                const s = i.map((e)=>this.sourceCache.getTile(e)), r = o.getImages(s, Array.from(this.pendingRequests));
                for (const [i, o] of r)t1.set(e.I.from({
                    name: i,
                    iconsetId: this.id
                }), o), this.pendingRequests.delete(i);
                for (const e of this.pendingRequests)this.missingRequests.add(e);
                return this.pendingRequests.clear(), t1;
            }
        }
        class So {
            constructor(){
                e.aY([
                    "_onIndoorUpdate"
                ], this);
            }
            onAdd(e) {
                return this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._map.style && this._map.style.indoorManager.on("selector-update", (e)=>this._onIndoorUpdate(e)), this._container;
            }
            _createButton(e, t1) {
                const i = l("button", e, this._container);
                return i.type = "button", i.addEventListener("click", t1), i;
            }
            _createSeparator() {
                return l("div", "mapboxgl-ctrl-separator", this._container);
            }
            _setButtonTitle(e, t1) {
                this._map && (e.setAttribute("aria-label", t1), e.textContent = t1);
            }
            onRemove() {
                this._container && this._container.remove(), this._map && this._map.style && (this._map.style.indoorManager.off("selector-update", this._onIndoorUpdate), this._map = null);
            }
            getDefaultPosition() {
                return "right";
            }
            _onIndoorUpdate(e) {
                if (!e || !e.floors) return this._model = e, void (this._container.style.display = "none");
                const t1 = this._model;
                this._model = e, this._container.style.display = "inline-block", this._container.style.borderRadius = "8px", t1 && Array.from(this._container.children).forEach((e)=>e.remove()), e.floors.length > 0 && (this.addBuildingsToggleButton(), this.addCurrentFloors(e.floors, e.activeFloorsVisible), this._updateBuildingsButtonState());
            }
            addBuildingsToggleButton() {
                const e = this._createButton("mapboxgl-ctrl-buildings-toggle", ()=>{
                    const e = this._map;
                    this._model && e && e._setIndoorActiveFloorsVisibility(!this._model.activeFloorsVisible);
                });
                l("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.classList.add("mapboxgl-ctrl-level-button", "mapboxgl-ctrl-buildings-toggle"), this._model && !this._model.activeFloorsVisible && e.classList.add("mapboxgl-ctrl-level-button-selected"), this._container.append(e), this._createSeparator();
            }
            _updateBuildingsButtonState() {
                const e = this._container.querySelector(".mapboxgl-ctrl-buildings-toggle");
                e && this._model && (this._model.activeFloorsVisible ? e.classList.remove("mapboxgl-ctrl-level-button-selected") : e.classList.add("mapboxgl-ctrl-level-button-selected"));
            }
            addCurrentFloors(e, t1) {
                for(let i = 0; i < e.length; i++){
                    const o = e[i], s = this._createButton("mapboxgl-ctrl-level-button", ()=>{
                        this._map._selectIndoorFloor(o.id);
                    });
                    this._setButtonTitle(s, o.zIndex.toString()), this._model && o.id === this._model.selectedFloorId && t1 && s.classList.add("mapboxgl-ctrl-level-button-selected"), this._container.append(s), i < e.length - 1 && this._createSeparator();
                }
            }
        }
        class Io extends e.E {
            constructor(t1){
                super(), this._style = t1, this._buildings = {}, this._indoorControl = null, this._activeFloors = new Set, this._activeFloorsVisible = !0, this._indoorState = {
                    selectedFloorId: null,
                    lastActiveFloors: null,
                    activeFloorsVisible: !0
                }, e.aY([
                    "_updateUI"
                ], this), this._style.on("style.load", ()=>{
                    this._style.isIndoorEnabled() && (this._style.map.on("load", this._updateUI), this._style.map.on("move", this._updateUI), this._style.map.on("idle", this._updateUI), this._updateUI());
                });
            }
            destroy() {
                this._buildings = {}, this._activeFloors = new Set, this._indoorState = null, this._removeIndoorControl();
            }
            selectFloor(e) {
                e === this._selectedFloorId && this._activeFloorsVisible || (this._selectedFloorId = e, this._activeFloorsVisible = !0, this._updateActiveFloors());
            }
            setActiveFloorsVisibility(e) {
                this._activeFloorsVisible = e, this._updateActiveFloors(), this._updateIndoorSelector();
            }
            setIndoorData(e) {
                for (const [t1, i] of Object.entries(e.buildings))if (this._buildings[t1]) for (const e of i.floorIds)this._buildings[t1].floors[e] || (this._buildings[t1].floors[e] = i.floors[e]);
                else this._buildings[t1] = i;
                for (const t1 of e.activeFloors)this._activeFloors.add(t1);
                this._updateIndoorSelector();
            }
            getIndoorTileOptions(e, t1) {
                const i = this._style.getIndoorSourceLayers(e, t1);
                return i && this._indoorState ? {
                    sourceLayers: i,
                    indoorState: this._indoorState
                } : null;
            }
            _addIndoorControl() {
                this._indoorControl || (this._indoorControl = new So, this._style.map.addControl(this._indoorControl, "right"));
            }
            _removeIndoorControl() {
                this._indoorControl && (this._indoorControl.onRemove(), this._indoorControl = null);
            }
            _updateUI() {
                const t1 = this._style.map.transform, i = function(t1, i, o, s) {
                    let r = null, n = Number.MAX_SAFE_INTEGER;
                    if (s < 16) return null;
                    for (const [s, a] of Object.entries(t1)){
                        const t1 = a.center;
                        if (t1) {
                            const a = i.distanceTo(e.aT.convert(t1));
                            a < n && o.contains(t1) && (n = a, r = s);
                        }
                    }
                    return r;
                }(this._buildings, t1.center, t1.getBounds(), t1.zoom);
                i !== this._closestBuildingId && (this._closestBuildingId = i, this._updateIndoorSelector());
            }
            _updateIndoorSelector() {
                const t1 = this._buildings, i = this._closestBuildingId, o = i && t1 ? t1[i] : void 0;
                if (!o) return this._removeIndoorControl(), void this.fire(new e.z("selector-update", {
                    selectedFloorId: null,
                    activeFloorsVisible: this._activeFloorsVisible,
                    floors: []
                }));
                this._addIndoorControl();
                let s = null;
                for (const e of o.floorIds)if (this._activeFloors && this._activeFloors.has(e)) {
                    s = e;
                    break;
                }
                const r = Array.from(o.floorIds).map((e)=>({
                        id: e,
                        name: o.floors[e].name,
                        zIndex: o.floors[e].zIndex
                    })).sort((e, t1)=>t1.zIndex - e.zIndex);
                this.fire(new e.z("selector-update", {
                    selectedFloorId: s,
                    activeFloorsVisible: this._activeFloorsVisible,
                    floors: r
                }));
            }
            _updateActiveFloors() {
                const e = this._activeFloors;
                this._activeFloors = new Set, this._indoorState = {
                    selectedFloorId: this._selectedFloorId,
                    lastActiveFloors: e,
                    activeFloorsVisible: this._activeFloorsVisible
                }, this._style.updateIndoorDependentLayers();
            }
        }
        const Co = (e, t1)=>Fe(e, t1 && t1.filter((e)=>"source.canvas" !== e.identifier)), Ro = e.aH(Gt, [
            "addLayer",
            "removeLayer",
            "setLights",
            "setPaintProperty",
            "setLayoutProperty",
            "setLayerProperty",
            "setSlot",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setSnow",
            "setRain",
            "setProjection",
            "setCamera",
            "addImport",
            "removeImport",
            "updateImport",
            "addIconset",
            "removeIconset"
        ]), Ao = e.aH(Gt, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), Lo = new Set([
            "background",
            "sky",
            "slot",
            "custom"
        ]), Do = {
            version: 8,
            layers: [],
            sources: {}
        }, Po = {
            duration: 300,
            delay: 0
        };
        class Oo extends e.E {
            constructor(t1, i = {}){
                super(), this.map = t1, this.scope = i.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map, this.resolvedImports = i.resolvedImports || new Set, this.transition = Object.assign({}, Po), this._buildingIndex = new Ut(this), this.crossTileSymbolIndex = new qi, this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedIndoor = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._hasAppearances = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._importedAsBasemap = !1, this._changes = i.styleChanges || new W, this._hasDataDrivenEmissive = !1, this.indoorManager = new Io(this), this.dispatcher = i.dispatcher ? i.dispatcher : new e.D(e.dh(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new X(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.di(t1._requestManager, i.localFontFamily ? e.dj.all : i.localIdeographFontFamily ? e.dj.ideographs : e.dj.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new yo(t1._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = !1, this.options = i.configOptions ? i.configOptions : new Map, this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set, this._indoorDependentLayers = i.indoorDependentLayers ? i.indoorDependentLayers : new Set, this._config = i.config, this._styleColorTheme = {
                    lut: null,
                    lutLoading: !1,
                    lutLoadingCorrelationID: 0,
                    colorTheme: null,
                    colorThemeOverride: i.colorThemeOverride
                }, this._styleColorThemeForScope = {}, this._initialConfig = i.initialConfig, this.dispatcher.broadcast("setReferrer", e.dk());
                const o = this;
                this._rtlTextPluginCallback = Oo.registerForPluginStateChange((t1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t1.pluginStatus,
                        pluginURL: t1.pluginURL
                    }, (t1, i)=>{
                        if (e.dl(t1), i && i.every((e)=>e)) for(const e in o._sourceCaches){
                            const t1 = o._sourceCaches[e], i = t1.getSource().type;
                            "vector" !== i && "geojson" !== i || t1.reload();
                        }
                    });
                }), this.on("data", (e)=>{
                    if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
                    const t1 = this.getOwnSource(e.sourceId);
                    if (t1 && t1.vectorLayerIds) for(const e in this._layers){
                        const i = this._layers[e];
                        i.source === t1.id && this._validateLayer(i);
                    }
                });
            }
            load(e) {
                return e ? ("string" == typeof e ? this.loadURL(e) : this.loadJSON(e), this) : this;
            }
            _getGlobalId(t1) {
                if (!t1) return null;
                if ("string" == typeof t1) {
                    if (e.h(t1)) return t1;
                    const i = e.dm(t1);
                    if (!i.startsWith("http")) try {
                        return new URL(i, location.href).toString();
                    } catch (e) {
                        return i;
                    }
                    return i;
                }
                return `json://${e.dn(JSON.stringify(t1))}`;
            }
            _diffStyle(t1, i, o) {
                this.globalId = this._getGlobalId(t1);
                const s = (e, t1)=>{
                    try {
                        t1(null, this.setState(e, o));
                    } catch (e) {
                        t1(e, !1);
                    }
                };
                if ("string" == typeof t1) {
                    const o = this.map._requestManager.normalizeStyleURL(t1), r = this.map._requestManager.transformRequest(o, e.R.Style);
                    e.m(r, (t1, o)=>{
                        t1 ? this.fire(new e.y(t1)) : o && s(o, i);
                    });
                } else "object" == typeof t1 && s(t1, i);
            }
            loadURL(t1, i = {}) {
                this.fire(new e.z("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" == typeof i.validate ? i.validate : !e.h(t1);
                this.globalId = this._getGlobalId(t1), t1 = this.map._requestManager.normalizeStyleURL(t1, i.accessToken), this.resolvedImports.add(t1);
                const s = this.importsCache.get(t1);
                if (s) return this._load(s, o);
                const r = this.map._requestManager.transformRequest(t1, e.R.Style);
                this._request = e.m(r, (i, s)=>{
                    if (this._request = null, i) this.fire(new e.y(i));
                    else if (s) return this.importsCache.set(t1, s), this._load(s, o);
                });
            }
            loadJSON(t1, i = {}) {
                this.fire(new e.z("dataloading", {
                    dataType: "style"
                })), this.globalId = this._getGlobalId(t1), this._request = e.o.frame(()=>{
                    this._request = null, this._load(t1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e.z("dataloading", {
                    dataType: "style"
                })), this._load(Do, !1);
            }
            _loadImports(t1, i, o) {
                if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
                const s = [];
                for (const e of t1){
                    const t1 = this._createFragmentStyle(e), r = new Promise((e)=>{
                        t1.once("style.import.load", e), t1.once("error", e);
                    }).then(()=>this.mergeAll());
                    if (s.push(r), this.resolvedImports.has(e.url)) {
                        t1.loadEmpty();
                        continue;
                    }
                    const n = e.data || this.importsCache.get(e.url);
                    n ? (t1.loadJSON(n, {
                        validate: i
                    }), this._isInternalStyle(n) && (t1.globalId = null)) : e.url ? t1.loadURL(e.url, {
                        validate: i
                    }) : t1.loadEmpty();
                    const a = {
                        style: t1,
                        id: e.id,
                        config: e.config
                    };
                    if (o) {
                        const e = this.fragments.findIndex(({ id: e })=>e === o);
                        this.fragments = this.fragments.slice(0, e).concat(a).concat(this.fragments.slice(e));
                    } else this.fragments.push(a);
                }
                return Promise.allSettled(s);
            }
            getImportGlobalIds(e = this, t1 = new Set) {
                for (const i of e.fragments)i.style.globalId && t1.add(i.style.globalId), this.getImportGlobalIds(i.style, t1);
                return [
                    ...t1.values()
                ];
            }
            _createFragmentStyle(t1) {
                const i = this.scope ? e.B(t1.id, this.scope) : t1.id;
                let o;
                const s = this._initialConfig && this._initialConfig[i];
                (t1.config || s) && (o = Object.assign({}, t1.config, s));
                const r = new Oo(this.map, {
                    scope: i,
                    styleChanges: this._changes,
                    importDepth: this.importDepth + 1,
                    importsCache: this.importsCache,
                    resolvedImports: new Set(this.resolvedImports),
                    dispatcher: this.dispatcher,
                    imageManager: this.imageManager,
                    glyphManager: this.glyphManager,
                    modelManager: this.modelManager,
                    config: o,
                    configOptions: this.options,
                    colorThemeOverride: t1["color-theme"],
                    configDependentLayers: this._configDependentLayers,
                    indoorDependentLayers: this._indoorDependentLayers
                });
                return r.setEventedParent(this.map, {
                    style: r
                }), r;
            }
            _reloadImports() {
                this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this._updateLayers(this._indoorDependentLayers), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
            }
            _isInternalStyle(e) {
                return this.isRootStyle() && (e.fragment || !!e.schema && !1 !== e.fragment);
            }
            _load(t1, i) {
                if (this._isInternalStyle(t1)) {
                    const e = Object.assign({}, Do, {
                        imports: [
                            {
                                id: "basemap",
                                data: t1,
                                url: ""
                            }
                        ]
                    }, t1.center ? {
                        center: t1.center
                    } : {}, t1.bearing ? {
                        bearing: t1.bearing
                    } : {}, t1.pitch ? {
                        pitch: t1.pitch
                    } : {}, t1.zoom ? {
                        zoom: t1.zoom
                    } : {}, t1.light ? {
                        light: t1.light
                    } : {});
                    return this._importedAsBasemap = !0, void this._load(e, i);
                }
                if (this.updateConfig(this._config, t1.schema), i && Co(this, we(t1))) return;
                this._loaded = !0, this.stylesheet = e.dp(t1);
                const o = ()=>{
                    for(const e in t1.sources)this.addSource(e, t1.sources[e], {
                        validate: !1,
                        isInitialLoad: !0
                    });
                    if (t1.iconsets) for(const e in t1.iconsets)this.addIconset(e, t1.iconsets[e]);
                    t1.sprite ? this._loadIconset(t1.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    })), !this.glyphManager.url && t1.glyphs && this.glyphManager.setURL(t1.glyphs);
                    const o = Vt(this.stylesheet.layers);
                    if (this._order = o.map((e)=>e.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                        const e = this.stylesheet.lights[0];
                        this.light = new Ne(e.properties, e.id);
                    } else this.setLights(this.stylesheet.lights);
                    this.light || (this.light = new Ne(this.stylesheet.light)), this._layers = {};
                    for (const t1 of o){
                        const i = e.du(t1, this.scope, this._styleColorTheme.lut, this.options);
                        0 !== i.expressionDependencies.configDependencies.size && this._configDependentLayers.add(i.fqid), i.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(i.fqid), this._hasAppearances = this._hasAppearances || 0 !== i.getAppearances().length, i.setEventedParent(this, {
                            layer: {
                                id: i.id
                            }
                        }), this._layers[i.id] = i;
                        const o = this.getOwnLayerSourceCache(i), s = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                        o && i.canCastShadows() && s && (o.castsShadows = !0);
                    }
                    this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
                    const s = this.stylesheet.terrain;
                    s && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                    const r = this.isRootStyle();
                    t1.imports ? this._loadImports(t1.imports, i).then(()=>{
                        this._reloadImports(), this.fire(new e.z(r ? "style.load" : "style.import.load"));
                    }).catch((t1)=>{
                        this.fire(new e.y(new Error("Failed to load imports", t1))), this.fire(new e.z(r ? "style.load" : "style.import.load"));
                    }) : (this._reloadImports(), this.fire(new e.z(r ? "style.load" : "style.import.load")));
                };
                this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
                const s = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                if (s) {
                    const t1 = this._evaluateColorThemeData(s);
                    this._loadColorTheme(t1).then(()=>{
                        o();
                    }).catch((t1)=>{
                        e.w(`Couldn't load color theme from the stylesheet: ${t1}`), o();
                    });
                } else this._styleColorTheme.lut = null, o();
            }
            isRootStyle() {
                return 0 === this.importDepth;
            }
            hasAppearances() {
                return this._hasAppearances || this.fragments.some((e)=>e.style.hasAppearances());
            }
            mergeAll() {
                let e, t1, i, o, s, r, n, a, l, c;
                const h = {};
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((d)=>{
                    if (d.stylesheet) {
                        if (null != d.light && (e = d.light), d.stylesheet.lights) for (const e of d.stylesheet.lights)"ambient" === e.type && null != d.ambientLight && (t1 = d.ambientLight), "directional" === e.type && null != d.directionalLight && (i = d.directionalLight);
                        o = this._prioritizeTerrain(o, d.terrain, d.stylesheet.terrain), d.stylesheet.fog && null != d.fog && (s = d.fog), d.stylesheet.snow && null != d.snow && (r = d.snow), d.stylesheet.rain && null != d.rain && (n = d.rain), null != d.stylesheet.camera && (c = d.stylesheet.camera), null != d.stylesheet.projection && (a = d.stylesheet.projection), null != d.stylesheet.transition && (l = d.stylesheet.transition), h[d.scope] = d._styleColorTheme;
                    }
                }), this.light = e, this.ambientLight = t1, this.directionalLight = i, this.fog = s, this.snow = r, this.rain = n, this._styleColorThemeForScope = h, null === o ? delete this.terrain : this.terrain = o, this.camera = c || {
                    "camera-projection": "perspective"
                }, this.projection = a || {
                    name: "mercator"
                }, this.transition = Object.assign({}, Po, l), this.mergeSources(), this.mergeLayers(), this.mergeIndoor();
            }
            forEachFragmentStyle(e) {
                const t1 = (i)=>{
                    for (const e of i.fragments)t1(e.style);
                    e(i);
                };
                t1(this);
            }
            _prioritizeTerrain(e, t1, i) {
                const o = e && 0 === e.drapeRenderMode;
                return null === i ? t1 && 0 === t1.drapeRenderMode ? t1 : o ? e : null : null != t1 && (!e || o || t1 && 1 === t1.drapeRenderMode) ? t1 : e;
            }
            mergeTerrain() {
                let e;
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t1)=>{
                    e = this._prioritizeTerrain(e, t1.terrain, t1.stylesheet.terrain);
                }), null === e ? delete this.terrain : this.terrain = e;
            }
            mergeProjection() {
                let e;
                this.forEachFragmentStyle((t1)=>{
                    null != t1.stylesheet.projection && (e = t1.stylesheet.projection);
                }), this.projection = e || {
                    name: "mercator"
                };
            }
            mergeSources() {
                const t1 = {}, i = {}, o = {};
                this.forEachFragmentStyle((s)=>{
                    for(const i in s._sourceCaches){
                        const o = e.B(i, s.scope);
                        t1[o] = s._sourceCaches[i];
                    }
                    for(const t1 in s._otherSourceCaches){
                        const o = e.B(t1, s.scope);
                        i[o] = s._otherSourceCaches[t1];
                    }
                    for(const t1 in s._symbolSourceCaches){
                        const i = e.B(t1, s.scope);
                        o[i] = s._symbolSourceCaches[t1];
                    }
                }), this._mergedSourceCaches = t1, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;
            }
            mergeIndoor() {
                this.forEachFragmentStyle((t1)=>{
                    if (t1.stylesheet && t1.stylesheet.indoor) for (const i of Object.values(t1.stylesheet.indoor)){
                        const o = i, s = e.B(o.sourceId, t1.scope);
                        this._mergedIndoor[s] = new Set(o.sourceLayers || []);
                    }
                });
            }
            mergeLayers() {
                const t1 = {}, i = [], o = {};
                this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((o)=>{
                    for (const s of o._order){
                        const r = o._layers[s];
                        if ("slot" === r.type) {
                            const i = e.dq(s);
                            if (t1[i]) continue;
                            t1[i] = [];
                        }
                        r.slot && t1[r.slot] ? t1[r.slot].push(r) : i.push(r);
                    }
                }), this._mergedOrder = [];
                let s = -1;
                const r = (i = [])=>{
                    for (const n of i)if ("slot" === n.type) {
                        const i = e.dq(n.id);
                        t1[i] && r(t1[i]), this._mergedSlots.push(i);
                    } else {
                        const t1 = e.B(n.id, n.scope);
                        this._mergedOrder.push(t1), o[t1] = n, n.is3D(!!this.terrain) && (this._has3DLayers = !0, s = this._mergedOrder.length - 1), "circle" === n.type && (this._hasCircleLayers = !0), "symbol" === n.type && (this._hasSymbolLayers = !0), "clip" === n.type && (this._clipLayerPresent = !0);
                    }
                };
                if (r(i), this._has3DLayers) {
                    const e = {};
                    for(let t1 = 0; t1 < this._mergedOrder.length; ++t1){
                        const i = this._mergedOrder[t1];
                        e[i] = t1 === s ? 1 : t1 < s ? o[i].hasOcclusionOpacityProperties ? 2 : 0 : 4;
                    }
                    this._mergedOrder.sort((t1, i)=>e[t1] - e[i]);
                }
                this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged(), this._updateDataDrivenEmissiveStrength();
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            getCamera() {
                return this.stylesheet.camera;
            }
            setCamera(e) {
                return this.stylesheet.camera = Object.assign({}, this.stylesheet.camera, e), this.camera = this.stylesheet.camera, this;
            }
            _evaluateColorThemeData(t1) {
                return t1.data ? (function(t1, i, o) {
                    const s = Object.assign({}, i);
                    for (const e of Object.keys(xo))void 0 === s[e] && (s[e] = xo[e].default);
                    const r = new e.a8(bo, t1, new Map(o));
                    return r.setTransitionOrValue(s, o), r.untransitioned().possiblyEvaluate(new e.ac(0, {
                        worldview: void 0
                    }));
                })(this.scope, t1, this.options).get("data") : null;
            }
            _loadColorTheme(t1) {
                this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
                const i = this._styleColorTheme.lutLoadingCorrelationID;
                return new Promise((o, s)=>{
                    const r = "data:image/png;base64,";
                    if (!t1 || 0 === t1.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o();
                    let n = t1;
                    n.startsWith(r) || (n = r + n);
                    const a = e.I.from("mapbox-reserved-lut"), l = new Image;
                    l.src = n, l.onerror = ()=>{
                        this._styleColorTheme.lutLoading = !1, s(new Error("Failed to load image data"));
                    }, l.onload = ()=>{
                        if (this._styleColorTheme.lutLoadingCorrelationID !== i) return void o();
                        this._styleColorTheme.lutLoading = !1;
                        const { width: r, height: n, data: c } = e.o.getImageData(l);
                        if (n > 32) return void s(new Error("The height of the image must be less than or equal to 32 pixels."));
                        if (r !== n * n) return void s(new Error("The width of the image must be equal to the height squared."));
                        this.getImage(a) && this.removeImage(a), this.addImage(a, {
                            data: new e.q({
                                width: r,
                                height: n
                            }, c),
                            pixelRatio: 1,
                            sdf: !1,
                            usvg: !1,
                            version: 0
                        });
                        const h = this.imageManager.getImage(a, this.scope);
                        h ? (this._styleColorTheme.lut = {
                            image: h.data,
                            data: t1
                        }, o()) : s(new Error("Missing LUT image."));
                    };
                });
            }
            getLut(e) {
                const t1 = this._styleColorThemeForScope[e];
                return t1 ? t1.lut : null;
            }
            setProjection(e) {
                e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
            }
            _updateMapProjection() {
                this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
            }
            _loadSprite(t1) {
                this._spriteRequest = function(t1, i, o) {
                    let s, r, n;
                    const a = e.o.devicePixelRatio > 1 ? "@2x" : "";
                    let l = e.m(i.transformRequest(i.normalizeSpriteURL(t1, a, ".json"), e.R.SpriteJSON), (e, t1)=>{
                        l = null, n || (n = e, s = t1, h());
                    }), c = e.n(i.transformRequest(i.normalizeSpriteURL(t1, a, ".png"), e.R.SpriteImage), (e, t1)=>{
                        c = null, n || (n = e, r = t1, h());
                    });
                    function h() {
                        if (n) o(n);
                        else if (s && r) {
                            const t1 = e.o.getImageData(r), i = {};
                            for(const o in s){
                                const { width: r, height: n, x: a, y: l, sdf: c, pixelRatio: h, stretchX: d, stretchY: u, content: _ } = s[o], p = new e.q({
                                    width: r,
                                    height: n
                                });
                                e.q.copy(t1, p, {
                                    x: a,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: r,
                                    height: n
                                }, null), i[o] = {
                                    data: p,
                                    pixelRatio: void 0 !== h ? h : 1,
                                    sdf: void 0 !== c && c,
                                    stretchX: d,
                                    stretchY: u,
                                    content: _,
                                    usvg: !1,
                                    version: 0
                                };
                            }
                            o(null, i);
                        }
                    }
                    return {
                        cancel () {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        }
                    };
                }(t1, this.map._requestManager, (t1, i)=>{
                    if (this._spriteRequest = null, t1) this.fire(new e.y(t1));
                    else if (i) {
                        const t1 = new Map;
                        for(const o in i)t1.set(e.I.from(o), i[o]);
                        this.addImages(t1);
                    }
                    this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                });
            }
            addIconset(t1, i) {
                if ("sprite" === i.type) return void this._loadSprite(i.url);
                const o = this.getOwnSourceCache(i.source);
                if (!o) return void this.fire(new e.y(new Error(`Source "${i.source}" as specified by iconset "${t1}" does not exist and cannot be used as an iconset source`)));
                const s = o.getSource();
                if ("raster-array" !== s.type) return void this.fire(new e.y(new Error(`Source "${i.source}" as specified by iconset "${t1}" is not a "raster-array" source and cannot be used as an iconset source`)));
                s.partial = !1;
                const r = new Eo(t1, this.scope, o);
                this.imageManager.addImageProvider(r, this.scope);
            }
            removeIconset(e) {
                this.imageManager.removeImageProvider(e, this.scope);
            }
            _loadIconset(t1) {
                if (!e.h(t1) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t1);
                const i = "auto" === this.map._spriteFormat;
                var o, s;
                this._spriteRequest = (s = (o, s)=>{
                    if (this._spriteRequest = null, o) i ? this._loadSprite(t1) : this.fire(new e.y(o));
                    else if (s) {
                        const t1 = new Map;
                        for(const i in s)t1.set(e.I.from(i), s[i]);
                        this.addImages(t1);
                    }
                    this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                }, e.bu((o = this.map._requestManager).transformRequest(o.normalizeIconsetURL(t1), e.R.Iconset), (t1, i)=>{
                    if (t1) return void s(t1);
                    const o = {}, r = e.dg(new e.bt(i));
                    for (const t1 of r.icons){
                        const i = {
                            version: 1,
                            pixelRatio: e.o.devicePixelRatio,
                            content: wo(t1),
                            stretchX: t1.metadata ? To(t1.metadata.stretch_x_areas) : void 0,
                            stretchY: t1.metadata ? To(t1.metadata.stretch_y_areas) : void 0,
                            sdf: !1,
                            usvg: !0,
                            icon: t1
                        };
                        o[t1.name] = i;
                    }
                    s(null, o);
                }));
            }
            _validateLayer(t1) {
                const i = this.getOwnSource(t1.source);
                if (!i) return;
                const o = t1.sourceLayer;
                o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.y(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t1.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
                for(const e in this._sourceCaches)if (!this._sourceCaches[e].loaded()) return !1;
                if (!this.imageManager.isLoaded()) return !1;
                if (this.imageManager.hasPatternsInFlight()) return !1;
                if (!this.modelManager.isLoaded()) return !1;
                if (this._styleColorTheme.lutLoading) return !1;
                for (const { style: e } of this.fragments)if (!e.loaded()) return !1;
                return !0;
            }
            _serializeImports() {
                if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t1)=>{
                    const i = this.fragments[t1];
                    return i && i.style && (e.data = i.style.serialize()), e;
                });
            }
            _serializeSources() {
                const e = {};
                for(const t1 in this._sourceCaches){
                    const i = this._sourceCaches[t1].getSource();
                    e[i.id] || (e[i.id] = i.serialize());
                }
                return e;
            }
            _serializeLayers(e) {
                const t1 = [];
                for (const i of e){
                    const e = this._layers[i];
                    e && "custom" !== e.type && t1.push(e.serialize());
                }
                return t1;
            }
            hasLightTransitions() {
                return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
            }
            hasFogTransition() {
                return !!this.fog && this.fog.hasTransition();
            }
            hasSnowTransition() {
                return !!this.snow && this.snow.hasTransition();
            }
            hasRainTransition() {
                return !!this.rain && this.rain.hasTransition();
            }
            hasTransitions() {
                if (this.hasLightTransitions()) return !0;
                if (this.hasFogTransition()) return !0;
                if (this.hasSnowTransition()) return !0;
                if (this.hasRainTransition()) return !0;
                for(const e in this._sourceCaches)if (this._sourceCaches[e].hasTransition()) return !0;
                for(const e in this._layers)if (this._layers[e].hasTransition()) return !0;
                return !1;
            }
            _updateDataDrivenEmissiveStrength() {
                for(const e in this._mergedLayers){
                    const t1 = this._mergedLayers[e];
                    if (t1._transitionablePaint && t1._transitionablePaint._values) {
                        const e = t1._transitionablePaint._values["line-emissive-strength"];
                        if (e && e.value && e.value.isDataDriven()) return void (this._hasDataDrivenEmissive = !0);
                    }
                }
                this._hasDataDrivenEmissive = !1;
            }
            hasDataDrivenEmissiveStrength() {
                return this._hasDataDrivenEmissive;
            }
            get order() {
                return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
            }
            _getOrder(e) {
                return e ? this.order : this._mergedOrder;
            }
            isLayerDraped(e) {
                return !!this.terrain && e.isDraped(this.getLayerSourceCache(e));
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            _checkLayer(t1) {
                const i = this.getOwnLayer(t1);
                if (i) return i;
                this.fire(new e.y(new Error(`The layer '${t1}' does not exist in the map's style.`)));
            }
            _checkSource(t1) {
                const i = this.getOwnSource(t1);
                if (i) return i;
                this.fire(new e.y(new Error(`The source '${t1}' does not exist in the map's style.`)));
            }
            precompilePrograms(e, t1) {
                const i = this.map.painter;
                if (i) for(let o = e.minzoom || 0; o < (e.maxzoom || 25.5); o++){
                    const o = e.getProgramIds();
                    if (o) for (const s of o){
                        const o = e.getDefaultProgramParams(s, t1.zoom, this._styleColorTheme.lut);
                        o && (i.style = this, this.fog && (i._fogVisible = !0, o.overrideFog = !0, i.getOrCreateProgram(s, o)), i._fogVisible = !1, o.overrideFog = !1, i.getOrCreateProgram(s, o), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o.overrideRtt = !0, i.getOrCreateProgram(s, o)));
                    }
                }
            }
            update(t1) {
                if (!this._loaded) return;
                this.ambientLight && this.ambientLight.recalculate(t1), this.directionalLight && this.directionalLight.recalculate(t1);
                const i = this.calculateLightsBrightness();
                t1.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast("setBrightness", i)), t1.worldview !== this._worldview && (this._worldview = t1.worldview, this.dispatcher.broadcast("setWorldview", this._worldview));
                const o = this._changes.isDirty();
                let s = !1;
                if (this._changes.isDirty()) {
                    const e = this._changes.getLayerUpdatesByScope();
                    for(const t1 in e){
                        const { updatedIds: i, removedIds: o } = e[t1];
                        (i || o) && (this._updateWorkerLayers(t1, i, o), s = !0);
                    }
                    this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t1), this.light && this.light.updateTransitions(t1), this.ambientLight && this.ambientLight.updateTransitions(t1), this.directionalLight && this.directionalLight.updateTransitions(t1), this.fog && this.fog.updateTransitions(t1), this.snow && this.snow.updateTransitions(t1), this.rain && this.rain.updateTransitions(t1), this._changes.reset();
                }
                const r = {};
                for(const e in this._mergedSourceCaches){
                    const t1 = this._mergedSourceCaches[e];
                    r[e] = t1.used, t1.used = !1, t1.tileCoverLift = 0;
                }
                for (const e of this._mergedOrder){
                    const i = this._mergedLayers[e];
                    if ("none" !== i.visibility && i.recalculate(t1, this._availableImages), !i.isHidden(t1.zoom)) {
                        const e = this.getLayerSourceCache(i);
                        e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));
                    }
                    !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(()=>{
                        this.precompilePrograms(i, t1);
                    }) : this.precompilePrograms(i, t1));
                }
                this._shouldPrecompile && (this._precompileDone = !0), this.terrain && s && this.mergeLayers();
                const n = this.imageManager.getPendingImageProviders();
                for (const e of n)e.sourceCache.used = !0;
                for(const t1 in r){
                    const i = this._mergedSourceCaches[t1];
                    r[t1] !== i.used && i.getSource().fire(new e.z("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light && this.light.recalculate(t1), this.terrain && this.terrain.recalculate(t1), this.fog && this.fog.recalculate(t1), this.snow && this.snow.recalculate(t1), this.rain && this.rain.recalculate(t1), this.z = t1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), o && this.fire(new e.z("data", {
                    dataType: "style"
                }));
            }
            updateImageProviders() {
                const e = this.imageManager.getPendingImageProviders();
                for (const t1 of e){
                    const e = t1.resolvePendingRequests(), i = this.getFragmentStyle(t1.scope);
                    i && i.addImages(e);
                }
            }
            _updateTilesForChangedImages() {
                const e = {};
                for(const t1 in this._mergedSourceCaches){
                    const i = this._mergedSourceCaches[t1].getSource().scope;
                    e[i] = e[i] || this._changes.getUpdatedImages(i), 0 !== e[i].length && this._mergedSourceCaches[t1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e[i]);
                }
                for(const t1 in e)this._changes.resetUpdatedImages(t1);
            }
            _updateWorkerLayers(e, t1, i) {
                const o = this.getFragmentStyle(e);
                o && this.dispatcher.broadcast("updateLayers", {
                    layers: t1 ? o._serializeLayers(t1) : [],
                    scope: e,
                    removedIds: i || [],
                    options: o.options
                });
            }
            setState(t1, i) {
                if (this._checkLoaded(), Co(this, we(t1))) return !1;
                (t1 = e.dp(t1)).layers = Vt(t1.layers);
                const o = (function(t1, i) {
                    if (!t1) return [
                        {
                            command: Gt.setStyle,
                            args: [
                                i
                            ]
                        }
                    ];
                    let o = [];
                    try {
                        if (!e.by(t1.version, i.version)) return [
                            {
                                command: Gt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        if (e.by(t1.center, i.center) || o.push({
                            command: Gt.setCenter,
                            args: [
                                i.center
                            ]
                        }), e.by(t1.zoom, i.zoom) || o.push({
                            command: Gt.setZoom,
                            args: [
                                i.zoom
                            ]
                        }), e.by(t1.bearing, i.bearing) || o.push({
                            command: Gt.setBearing,
                            args: [
                                i.bearing
                            ]
                        }), e.by(t1.pitch, i.pitch) || o.push({
                            command: Gt.setPitch,
                            args: [
                                i.pitch
                            ]
                        }), e.by(t1.sprite, i.sprite) || o.push({
                            command: Gt.setSprite,
                            args: [
                                i.sprite
                            ]
                        }), e.by(t1.glyphs, i.glyphs) || o.push({
                            command: Gt.setGlyphs,
                            args: [
                                i.glyphs
                            ]
                        }), e.by(t1.imports, i.imports) || function(t1 = [], i = [], o) {
                            i = i || [];
                            const s = (t1 = t1 || []).map(Xt), r = i.map(Xt), n = t1.reduce(Yt, {}), a = i.reduce(Yt, {}), l = s.slice();
                            let c, h, d, u;
                            for(c = 0, h = 0; c < s.length; c++)d = s[c], a.hasOwnProperty(d) ? h++ : (o.push({
                                command: Gt.removeImport,
                                args: [
                                    d
                                ]
                            }), l.splice(l.indexOf(d, h), 1));
                            for(c = 0, h = 0; c < r.length; c++)d = r[r.length - 1 - c], l[l.length - 1 - c] !== d && (n.hasOwnProperty(d) ? (o.push({
                                command: Gt.removeImport,
                                args: [
                                    d
                                ]
                            }), l.splice(l.lastIndexOf(d, l.length - h), 1)) : h++, u = l[l.length - c], o.push({
                                command: Gt.addImport,
                                args: [
                                    a[d],
                                    u
                                ]
                            }), l.splice(l.length - c, 0, d));
                            for (const t1 of i){
                                const i = n[t1.id];
                                i && (delete i.data, e.by(i, t1) || o.push({
                                    command: Gt.updateImport,
                                    args: [
                                        t1.id,
                                        t1
                                    ]
                                }));
                            }
                        }(t1.imports, i.imports, o), e.by(t1.transition, i.transition) || o.push({
                            command: Gt.setTransition,
                            args: [
                                i.transition
                            ]
                        }), e.by(t1.light, i.light) || o.push({
                            command: Gt.setLight,
                            args: [
                                i.light
                            ]
                        }), e.by(t1.fog, i.fog) || o.push({
                            command: Gt.setFog,
                            args: [
                                i.fog
                            ]
                        }), e.by(t1.snow, i.snow) || o.push({
                            command: Gt.setSnow,
                            args: [
                                i.snow
                            ]
                        }), e.by(t1.rain, i.rain) || o.push({
                            command: Gt.setRain,
                            args: [
                                i.rain
                            ]
                        }), e.by(t1.projection, i.projection) || o.push({
                            command: Gt.setProjection,
                            args: [
                                i.projection
                            ]
                        }), e.by(t1.lights, i.lights) || o.push({
                            command: Gt.setLights,
                            args: [
                                i.lights
                            ]
                        }), e.by(t1.camera, i.camera) || o.push({
                            command: Gt.setCamera,
                            args: [
                                i.camera
                            ]
                        }), e.by(t1.iconsets, i.iconsets) || function(t1, i, o) {
                            let s;
                            for(s in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(s) && (i.hasOwnProperty(s) || o.push({
                                command: Gt.removeIconset,
                                args: [
                                    s
                                ]
                            }));
                            for(s in i){
                                if (!i.hasOwnProperty(s)) continue;
                                const r = i[s];
                                t1.hasOwnProperty(s) ? e.by(t1[s], r) || (o.push({
                                    command: Gt.removeIconset,
                                    args: [
                                        s
                                    ]
                                }), o.push({
                                    command: Gt.addIconset,
                                    args: [
                                        s,
                                        r
                                    ]
                                })) : o.push({
                                    command: Gt.addIconset,
                                    args: [
                                        s,
                                        r
                                    ]
                                });
                            }
                        }(t1.iconsets, i.iconsets, o), !e.by(t1["color-theme"], i["color-theme"])) return [
                            {
                                command: Gt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        const s = {}, r = [];
                        !function(t1, i, o, s) {
                            let r;
                            for(r in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(r) && (i.hasOwnProperty(r) || qt(r, o, s));
                            for(r in i){
                                if (!i.hasOwnProperty(r)) continue;
                                const n = i[r];
                                t1.hasOwnProperty(r) ? e.by(t1[r], n) || ("geojson" === t1[r].type && "geojson" === n.type && Wt(t1, i, r) ? o.push({
                                    command: Gt.setGeoJSONSourceData,
                                    args: [
                                        r,
                                        n.data
                                    ]
                                }) : Zt(r, i, o, s)) : Ht(r, i, o);
                            }
                        }(t1.sources, i.sources, r, s);
                        const n = [];
                        t1.layers && t1.layers.forEach((e)=>{
                            e.source && s[e.source] ? o.push({
                                command: Gt.removeLayer,
                                args: [
                                    e.id
                                ]
                            }) : n.push(e);
                        });
                        let a = t1.terrain;
                        a && s[a.source] && (o.push({
                            command: Gt.setTerrain,
                            args: [
                                void 0
                            ]
                        }), a = void 0), o = o.concat(r), e.by(a, i.terrain) || o.push({
                            command: Gt.setTerrain,
                            args: [
                                i.terrain
                            ]
                        }), function(t1, i, o) {
                            i = i || [];
                            const s = (t1 = t1 || []).map(Xt), r = i.map(Xt), n = t1.reduce(Yt, {}), a = i.reduce(Yt, {}), l = s.slice(), c = Object.create(null);
                            let h, d, u, _, p, f, m;
                            for(h = 0, d = 0; h < s.length; h++)u = s[h], a.hasOwnProperty(u) ? d++ : (o.push({
                                command: Gt.removeLayer,
                                args: [
                                    u
                                ]
                            }), l.splice(l.indexOf(u, d), 1));
                            for(h = 0, d = 0; h < r.length; h++)u = r[r.length - 1 - h], l[l.length - 1 - h] !== u && (n.hasOwnProperty(u) ? (o.push({
                                command: Gt.removeLayer,
                                args: [
                                    u
                                ]
                            }), l.splice(l.lastIndexOf(u, l.length - d), 1)) : d++, f = l[l.length - h], o.push({
                                command: Gt.addLayer,
                                args: [
                                    a[u],
                                    f
                                ]
                            }), l.splice(l.length - h, 0, u), c[u] = !0);
                            for(h = 0; h < r.length; h++)if (u = r[h], _ = n[u], p = a[u], !c[u] && !e.by(_, p)) if (e.by(_.source, p.source) && e.by(_["source-layer"], p["source-layer"]) && e.by(_.type, p.type)) {
                                for(m in $t(_.layout, p.layout, o, u, null, Gt.setLayoutProperty), $t(_.paint, p.paint, o, u, null, Gt.setPaintProperty), e.by(_.slot, p.slot) || o.push({
                                    command: Gt.setSlot,
                                    args: [
                                        u,
                                        p.slot
                                    ]
                                }), e.by(_.filter, p.filter) || o.push({
                                    command: Gt.setFilter,
                                    args: [
                                        u,
                                        p.filter
                                    ]
                                }), e.by(_.minzoom, p.minzoom) && e.by(_.maxzoom, p.maxzoom) || o.push({
                                    command: Gt.setLayerZoomRange,
                                    args: [
                                        u,
                                        p.minzoom,
                                        p.maxzoom
                                    ]
                                }), _)_.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? $t(_[m], p[m], o, u, m.slice(6), Gt.setPaintProperty) : e.by(_[m], p[m]) || o.push({
                                    command: Gt.setLayerProperty,
                                    args: [
                                        u,
                                        m,
                                        p[m]
                                    ]
                                }));
                                for(m in p)p.hasOwnProperty(m) && !_.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? $t(_[m], p[m], o, u, m.slice(6), Gt.setPaintProperty) : e.by(_[m], p[m]) || o.push({
                                    command: Gt.setLayerProperty,
                                    args: [
                                        u,
                                        m,
                                        p[m]
                                    ]
                                }));
                            } else o.push({
                                command: Gt.removeLayer,
                                args: [
                                    u
                                ]
                            }), f = l[l.lastIndexOf(u) + 1], o.push({
                                command: Gt.addLayer,
                                args: [
                                    p,
                                    f
                                ]
                            });
                        }(n, i.layers, o);
                    } catch (e) {
                        console.warn("Unable to compute style diff:", e), o = [
                            {
                                command: Gt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                    }
                    return o;
                })(this.serialize(), t1).filter((e)=>!(e.command in Ao));
                if (0 === o.length) return !1;
                const s = o.filter((e)=>!(e.command in Ro));
                if (s.length > 0) throw new Error(`Unimplemented: ${s.map((e)=>e.command).join(", ")}.`);
                const r = [];
                return o.forEach((e)=>{
                    r.push(this[e.command](...e.args));
                }), i && Promise.all(r).then(i).catch(i), this.stylesheet = t1, this.mergeAll(), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), !0;
            }
            _updateWorkerImages() {
                this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
                    scope: this.scope,
                    images: this._availableImages
                });
            }
            _updateWorkerModels() {
                this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", {
                    scope: this.scope,
                    models: this._availableModels
                });
            }
            addImages(t1) {
                if (0 === t1.size) return this;
                for (const [i, o] of t1.entries()){
                    if (this.getImage(i)) return this.fire(new e.y(new Error(`An image with the name "${i.name}" already exists.`)));
                    this.imageManager.addImage(i, this.scope, o), this._changes.updateImage(i, this.scope);
                }
                return this._updateWorkerImages(), this.fire(new e.z("data", {
                    dataType: "style"
                })), this;
            }
            addImage(t1, i) {
                return this.getImage(t1) ? this.fire(new e.y(new Error(`An image with the name "${t1.name}" already exists.`))) : (this.imageManager.addImage(t1, this.scope, i), this._changes.updateImage(t1, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", {
                    dataType: "style"
                })), this);
            }
            updateImage(t1, i, o = !1) {
                this.imageManager.updateImage(t1, this.scope, i), o && (this._changes.updateImage(t1, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", {
                    dataType: "style"
                })));
            }
            getImage(e) {
                return this.imageManager.getImage(e, this.scope);
            }
            removeImage(t1) {
                return this.getImage(t1) ? (this.imageManager.removeImage(t1, this.scope), this._changes.updateImage(t1, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", {
                    dataType: "style"
                })), this) : this.fire(new e.y(new Error("No image with this name exists.")));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            getActualScope() {
                return this._importedAsBasemap ? "basemap" : this.scope;
            }
            addModelURLs(t1) {
                return this.modelManager.addModelURLs(t1, this.getActualScope()), this._updateWorkerModels(), this.fire(new e.z("data", {
                    dataType: "style"
                })), this;
            }
            addModel(t1, i, o = {}) {
                return this._checkLoaded(), this._validate(ze, `models.${t1}`, i, null, o) || (this.modelManager.addModel(t1, i, this.getActualScope()), this.fire(new e.z("data", {
                    dataType: "style"
                }))), this;
            }
            hasModel(e) {
                return this.modelManager.hasModel(e, this.getActualScope());
            }
            removeModel(t1) {
                return this.hasModel(t1) ? (this.modelManager.removeModel(t1, this.getActualScope(), !1, !0), this.fire(new e.z("data", {
                    dataType: "style"
                })), this) : this.fire(new e.y(new Error("No model with this ID exists.")));
            }
            listModels() {
                return this._checkLoaded(), this.modelManager.listModels(this.getActualScope());
            }
            addSource(t1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getOwnSource(t1)) throw new Error(`There is already a source with ID "${t1}".`);
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(Te, `sources.${t1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const s = mt(t1, i, this.dispatcher, this);
                s.scope = this.scope, s.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(s.id),
                        source: s.serialize(),
                        sourceId: s.id
                    }));
                const r = (t1)=>{
                    const i = (t1 ? "symbol:" : "other:") + s.id, o = e.B(i, this.scope), r = this._sourceCaches[i] = new Ft(o, s, t1);
                    (t1 ? this._symbolSourceCaches : this._otherSourceCaches)[s.id] = r, r.onAdd(this.map);
                };
                r(!1), "vector" !== i.type && "geojson" !== i.type || r(!0), s.onAdd && s.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
            }
            removeSource(t1) {
                this._checkLoaded();
                const i = this.getOwnSource(t1);
                if (!i) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === t1) return this.fire(new e.y(new Error(`Source "${t1}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t1) return this.fire(new e.y(new Error(`Source "${t1}" cannot be removed while terrain is using it.`)));
                if (this.stylesheet.iconsets) {
                    const i = Object.entries(this.stylesheet.iconsets).find(([e, i])=>"source" === i.type && i.source === t1);
                    if (i) return this.fire(new e.y(new Error(`Source "${t1}" cannot be removed while iconset "${i[0]}" is using it.`)));
                }
                const o = this.getOwnSourceCaches(t1);
                for (const t1 of o){
                    const i = e.dq(t1.id);
                    delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t1.id), t1.fire(new e.z("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: t1.getSource().id
                    })), t1.setEventedParent(null), t1.clearTiles();
                }
                return delete this._otherSourceCaches[t1], delete this._symbolSourceCaches[t1], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;
            }
            setGeoJSONSourceData(e, t1) {
                this._checkLoaded(), this.getOwnSource(e).setData(t1), this._changes.setDirty();
            }
            getOwnSource(e) {
                const t1 = this.getOwnSourceCache(e);
                return t1 && t1.getSource();
            }
            getOwnSources() {
                const e = [];
                for(const t1 in this._otherSourceCaches){
                    const i = this.getOwnSourceCache(t1);
                    i && e.push(i.getSource());
                }
                return e;
            }
            areTilesLoaded() {
                const e = this._mergedSourceCaches;
                for(const t1 in e){
                    const i = e[t1]._tiles;
                    for(const e in i){
                        const t1 = i[e];
                        if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                    }
                }
                return !0;
            }
            setLights(t1) {
                if (this._checkLoaded(), !t1) return delete this.ambientLight, void delete this.directionalLight;
                const i = this._getTransitionParameters();
                for (const e of t1){
                    if (this._validate(Se, "lights", e)) return;
                    switch(e.type){
                        case "ambient":
                            if (this.ambientLight) {
                                const t1 = this.ambientLight;
                                t1.set(e), t1.updateTransitions(i);
                            } else this.ambientLight = new et(e, tt(), this.scope, this.options);
                            break;
                        case "directional":
                            if (this.directionalLight) {
                                const t1 = this.directionalLight;
                                t1.set(e), t1.updateTransitions(i);
                            } else this.directionalLight = new et(e, ot(), this.scope, this.options);
                    }
                }
                const o = Object.assign(i, {
                    worldview: this.map.getWorldview()
                }), s = new e.ac(this.z || 0, o);
                this.ambientLight && this.ambientLight.recalculate(s), this.directionalLight && this.directionalLight.recalculate(s), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
            }
            calculateLightsBrightness() {
                const t1 = this.directionalLight, i = this.ambientLight;
                if (!t1 || !i) return;
                const o = (e)=>.2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)), s = t1.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), r = t1.properties.get("intensity"), n = t1.properties.get("direction"), a = 1 - e.d4(n.x, n.y, n.z)[2] / 90, l = o(s) * r * a, c = i.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), h = i.properties.get("intensity"), d = o(c) * h;
                return Number(((l + d) / 2).toFixed(6));
            }
            getBrightness() {
                return this._brightness;
            }
            getLights() {
                if (!this.enable3dLights()) return null;
                const e = [];
                return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;
            }
            enable3dLights() {
                return !!this.ambientLight && !!this.directionalLight;
            }
            getFragmentStyle(t1) {
                if (null == t1 || "" === t1 && this.isRootStyle()) return this;
                if (e.dr(t1)) {
                    const i = e.ds(t1), o = this.fragments.find(({ id: e })=>e === i);
                    if (!o) return;
                    const s = e.dq(t1);
                    return o.style.getFragmentStyle(s);
                }
                {
                    const e = this.fragments.find(({ id: e })=>e === t1);
                    return e ? e.style : void 0;
                }
            }
            setFeaturesetSelectors(t1) {
                if (!t1) return;
                const i = {}, o = (e, t1 = "")=>`${e}::${t1}`;
                this._featuresetSelectors = {};
                for(const s in t1){
                    const r = this._featuresetSelectors[s] = [];
                    for (const n of t1[s].selectors){
                        if (n.featureNamespace) {
                            const t1 = this.getOwnLayer(n.layer);
                            if (!t1) {
                                e.w(`Layer is undefined for selector: ${n.layer}`);
                                continue;
                            }
                            const r = o(t1.source, t1.sourceLayer);
                            if (r in i && i[r] !== n.featureNamespace) {
                                e.w(`"featureNamespace ${n.featureNamespace} of featureset ${s}'s selector is not associated to the same source, skip this selector`);
                                continue;
                            }
                            i[r] = n.featureNamespace;
                        }
                        let t1;
                        if (n.properties) for(const i in n.properties){
                            const o = e.U(n.properties[i]);
                            "success" === o.result && (t1 = t1 || {}, t1[i] = o.value);
                        }
                        r.push({
                            layerId: n.layer,
                            namespace: n.featureNamespace,
                            properties: t1,
                            uniqueFeatureID: n._uniqueFeatureID
                        });
                    }
                }
            }
            getFeaturesetDescriptors(e) {
                const t1 = this.getFragmentStyle(e);
                if (!t1 || !t1.stylesheet.featuresets) return [];
                const i = [];
                for(const e in t1.stylesheet.featuresets)i.push({
                    featuresetId: e,
                    importId: t1.scope ? t1.scope : void 0
                });
                return i;
            }
            getFeaturesetLayers(t1, i) {
                const o = this.getFragmentStyle(i), s = o.stylesheet.featuresets;
                if (!s || !s[t1]) return this.fire(new e.y(new Error(`The featureset '${t1}' does not exist in the map's style and cannot be queried.`))), [];
                const r = [];
                for (const e of s[t1].selectors){
                    const t1 = o.getOwnLayer(e.layer);
                    t1 && r.push(t1);
                }
                return r;
            }
            getConfigProperty(t1, i) {
                const o = this.getFragmentStyle(t1);
                if (!o) return null;
                const s = e.B(i, o.scope), r = o.options.get(s), n = r ? r.value || r.default : null;
                return n ? n.serialize() : null;
            }
            isIndoorEnabled() {
                return Object.keys(this._mergedIndoor).length > 0;
            }
            getIndoorSourceLayers(t1, i) {
                const o = e.B(t1, i);
                return this._mergedIndoor[o];
            }
            setIndoorData(e, t1) {
                this.indoorManager.setIndoorData(t1);
            }
            updateIndoorDependentLayers() {
                this._updateLayers(this._indoorDependentLayers), this.map._styleDirty = !0, this.map.triggerRepaint();
            }
            setConfigProperty(t1, i, o) {
                const s = this.getFragmentStyle(t1);
                if (!s) return;
                const r = s.stylesheet.schema;
                if (!r || !r[i]) return;
                const n = e.U(o);
                if ("success" !== n.result) return void Co(this, n.value);
                const a = n.value.expression, l = e.B(i, s.scope), c = s.options.get(l);
                if (!c) return;
                let h;
                const { minValue: d, maxValue: u, stepValue: _, type: p, values: f } = r[i], m = e.U(r[i].default);
                "success" === m.result && (h = m.value.expression), h ? (this.options.set(l, Object.assign({}, c, {
                    value: a,
                    default: h,
                    minValue: d,
                    maxValue: u,
                    stepValue: _,
                    type: p,
                    values: f
                })), this.updateConfigDependencies(i)) : this.fire(new e.y(new Error(`No schema defined for the config option "${i}" in the "${t1}" fragment.`)));
            }
            getConfig(t1) {
                const i = this.getFragmentStyle(t1);
                if (!i) return null;
                const o = i.stylesheet.schema;
                if (!o) return null;
                const s = {};
                for(const t1 in o){
                    const o = e.B(t1, i.scope), r = i.options.get(o), n = r ? r.value || r.default : null;
                    s[t1] = n ? n.serialize() : null;
                }
                return s;
            }
            setConfig(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.updateConfig(t1, i.stylesheet.schema), this.updateConfigDependencies());
            }
            getSchema(e) {
                const t1 = this.getFragmentStyle(e);
                return t1 ? t1.stylesheet.schema : null;
            }
            setSchema(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.stylesheet.schema = t1, i.updateConfig(i._config, t1), this.updateConfigDependencies());
            }
            updateConfig(t1, i) {
                if (this._config = t1, t1 || i) if (i) for(const o in i){
                    let s, r;
                    const n = e.U(i[o].default);
                    if ("success" === n.result && (s = n.value.expression), t1 && void 0 !== t1[o]) {
                        const i = e.U(t1[o]);
                        "success" === i.result && (r = i.value.expression);
                    }
                    const { minValue: a, maxValue: l, stepValue: c, type: h, values: d } = i[o];
                    if (s) {
                        const t1 = e.B(o, this.scope);
                        this.options.set(t1, {
                            default: s,
                            value: r,
                            minValue: a,
                            maxValue: l,
                            stepValue: c,
                            type: h,
                            values: d
                        });
                    } else this.fire(new e.y(new Error(`No schema defined for config option "${o}".`)));
                }
                else this.fire(new e.y(new Error("Attempting to set config for a style without schema.")));
            }
            _updateLayers(e, t1 = ()=>!0) {
                for (const i of e){
                    const e = this.getLayer(i);
                    e && t1(e) && (e.possiblyEvaluateVisibility(), this._updateLayer(e), this._changes.setDirty());
                }
            }
            updateConfigDependencies(e) {
                this._updateLayers(this._configDependentLayers, (t1)=>!e || t1.expressionDependencies.configDependencies.has(e)), this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((e)=>{
                    const t1 = e._styleColorTheme.colorThemeOverride ? e._styleColorTheme.colorThemeOverride : e._styleColorTheme.colorTheme;
                    if (t1) {
                        const i = e._evaluateColorThemeData(t1);
                        (!e._styleColorTheme.lut && "" !== i || e._styleColorTheme.lut && i !== e._styleColorTheme.lut.data) && e.setColorTheme(t1);
                    }
                }), this._changes.setDirty();
            }
            addLayer(t1, i, o = {}) {
                this._checkLoaded();
                const s = t1.id;
                if (this._layers[s]) return void this.fire(new e.y(new Error(`Layer with id "${s}" already exists on this map`)));
                let r;
                if ("custom" === t1.type) {
                    if (Co(this, e.dt(t1))) return;
                    r = e.du(t1, this.scope, this._styleColorTheme.lut, this.options);
                } else {
                    if ("object" == typeof t1.source && (this.addSource(s, t1.source), t1 = e.dp(t1), t1 = Object.assign(t1, {
                        source: s
                    })), this._validate(Le, `layers.${s}`, t1, {
                        arrayIndex: -1
                    }, o)) return;
                    r = e.du(t1, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r), r.setEventedParent(this, {
                        layer: {
                            id: s
                        }
                    });
                }
                const n = e.B(r.source, r.scope);
                0 !== r.expressionDependencies.configDependencies.size && this._configDependentLayers.add(n), r.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(n);
                let a = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.y(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    r.slot && r.slot !== this._layers[i].slot ? e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`) : a = t1;
                }
                this._order.splice(a, 0, s), this._handleLayerOrderChange(), this._layers[s] = r;
                const l = this.getOwnLayerSourceCache(r), c = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                l && r.canCastShadows() && c && (l.castsShadows = !0);
                const h = this._changes.getRemovedLayer(r);
                if (h && r.source && l && "custom" !== r.type) {
                    this._changes.discardLayerRemoval(r);
                    const t1 = e.B(r.source, r.scope);
                    h.type !== r.type ? this._changes.updateSourceCache(t1, "clear") : (this._changes.updateSourceCache(t1, "reload"), l.pause());
                }
                this._updateLayer(r), r.onAdd && r.onAdd(this.map), r.scope = this.scope, this.mergeLayers();
            }
            moveLayer(t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(t1);
                if (!o) return;
                if (t1 === i) return;
                const s = this._order.indexOf(t1);
                this._order.splice(s, 1);
                let r = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.y(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    o.slot && o.slot !== this._layers[i].slot ? e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`) : r = t1;
                }
                this._order.splice(r, 0, t1), this._changes.setDirty(), this._handleLayerOrderChange(), this.mergeLayers();
            }
            removeLayer(e) {
                this._checkLoaded();
                const t1 = this._checkLayer(e);
                if (!t1) return;
                t1.setEventedParent(null);
                const i = this._order.indexOf(e);
                this._order.splice(i, 1), delete this._layers[e], this._changes.setDirty(), this._handleLayerOrderChange(), this._configDependentLayers.delete(t1.fqid), this._indoorDependentLayers.delete(t1.fqid), this._changes.removeLayer(t1);
                const o = this.getOwnLayerSourceCache(t1);
                if (o && o.castsShadows) {
                    let e = !1;
                    for(const i in this._layers)if (this._layers[i].source === t1.source && this._layers[i].canCastShadows()) {
                        e = !0;
                        break;
                    }
                    o.castsShadows = e;
                }
                t1.onRemove && t1.onRemove(this.map), this.mergeLayers();
            }
            getOwnLayer(e) {
                return this._layers[e];
            }
            hasLayer(e) {
                return e in this._mergedLayers;
            }
            hasLayerType(e) {
                for(const t1 in this._layers)if (this._layers[t1].type === e) return !0;
                return !1;
            }
            setLayerZoomRange(e, t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(e);
                o && (o.minzoom === t1 && o.maxzoom === i || (null != t1 && (o.minzoom = t1), null != i && (o.maxzoom = i), this._updateLayer(o)));
            }
            getSlots() {
                return this._checkLoaded(), this._mergedSlots;
            }
            setSlot(e, t1) {
                this._checkLoaded();
                const i = this._checkLayer(e);
                i && i.slot !== t1 && (i.slot = t1, this._updateLayer(i));
            }
            setFilter(t1, i, o = {}) {
                this._checkLoaded();
                const s = this._checkLayer(t1);
                if (s && !e.by(s.filter, i)) return null == i ? (s.filter = void 0, void this._updateLayer(s)) : void (this._validate(De, `layers.${s.id}.filter`, i, {
                    layerType: s.type
                }, o) || (s.filter = e.dp(i), this._updateLayer(s)));
            }
            getFilter(t1) {
                const i = this._checkLayer(t1);
                if (i) return e.dp(i.filter);
            }
            setLayoutProperty(t1, i, o, s = {}) {
                this._checkLoaded();
                const r = this._checkLayer(t1);
                if (r && !e.by(r.getLayoutProperty(i), o)) {
                    if (null != o && (!s || !1 !== s.validate) && Co(r, Oe.call(we, {
                        key: `layers.${t1}.layout.${i}`,
                        layerType: r.type,
                        objectKey: i,
                        value: o,
                        styleSpec: e.a6,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        }
                    }))) return;
                    r.setLayoutProperty(i, o), 0 !== r.expressionDependencies.configDependencies.size && this._configDependentLayers.add(r.fqid), r.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(r.fqid), this._updateLayer(r);
                }
            }
            setLayerProperty(e, t1, i, o = {}) {
                this._checkLoaded();
                const s = this._checkLayer(e);
                s && ("appearances" === t1 ? (s.setAppearances(i), this._changes.setDirty()) : s.isPaintProperty(t1) ? this.setPaintProperty(e, t1, i, o) : this.setLayoutProperty(e, t1, i, o));
            }
            getLayoutProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getLayoutProperty(t1);
            }
            setPaintProperty(t1, i, o, s = {}) {
                this._checkLoaded();
                const r = this._checkLayer(t1);
                if (!r) return;
                if (e.by(r.getPaintProperty(i), o)) return;
                if (null != o && (!s || !1 !== s.validate) && Co(r, Pe.call(we, {
                    key: `layers.${t1}.paint.${i}`,
                    layerType: r.type,
                    objectKey: i,
                    value: o,
                    styleSpec: e.a6
                }))) return;
                const n = r.setPaintProperty(i, o);
                0 !== r.expressionDependencies.configDependencies.size && this._configDependentLayers.add(r.fqid), r.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(r.fqid), n && this._updateLayer(r), this._changes.updatePaintProperties(r);
            }
            getPaintProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getPaintProperty(t1);
            }
            setFeatureState(t1, i) {
                if (this._checkLoaded(), "target" in t1) {
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: e, importId: o } = t1.target, s = this.getFragmentStyle(o), r = s.getFeaturesetLayers(e);
                        for (const { source: e, sourceLayer: o } of r)s.setFeatureState({
                            id: t1.id,
                            source: e,
                            sourceLayer: o
                        }, i);
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        this.setFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        }, i);
                    }
                    return;
                }
                const o = t1.source, s = t1.sourceLayer, r = this._checkSource(o);
                if (!r) return;
                const n = r.type;
                if ("geojson" === n && s) return void this.fire(new e.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === n && !s) return void this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === t1.id && this.fire(new e.y(new Error("The feature id parameter must be provided.")));
                const a = this.getOwnSourceCaches(o);
                for (const e of a)e.setFeatureState(s, t1.id, i);
            }
            removeFeatureState(t1, i) {
                if (this._checkLoaded(), "target" in t1) {
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: e, importId: o } = t1.target, s = this.getFragmentStyle(o), r = s.getFeaturesetLayers(e);
                        for (const { source: e, sourceLayer: o } of r)s.removeFeatureState({
                            id: t1.id,
                            source: e,
                            sourceLayer: o
                        }, i);
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        this.removeFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        }, i);
                    }
                    return;
                }
                const o = t1.source, s = this._checkSource(o);
                if (!s) return;
                const r = s.type, n = "vector" === r ? t1.sourceLayer : void 0;
                if ("vector" === r && !n) return void this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t1.id && "number" != typeof t1.id) return void this.fire(new e.y(new Error("A feature id is required to remove its specific state property.")));
                const a = this.getOwnSourceCaches(o);
                for (const e of a)e.removeFeatureState(n, t1.id, i);
            }
            getFeatureState(t1) {
                if (this._checkLoaded(), "target" in t1) {
                    let i;
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: o, importId: s } = t1.target, r = this.getFragmentStyle(s), n = r.getFeaturesetLayers(o);
                        for (const { source: o, sourceLayer: s } of n){
                            const n = r.getFeatureState({
                                id: t1.id,
                                source: o,
                                sourceLayer: s
                            });
                            if (n && !i) i = n;
                            else if (!e.by(i, n)) return void this.fire(new e.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                        }
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        i = this.getFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        });
                    }
                    return i;
                }
                const i = t1.source, o = t1.sourceLayer, s = this._checkSource(i);
                if (s) {
                    if ("vector" !== s.type || o) return void 0 === t1.id && this.fire(new e.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t1.id);
                    this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                }
            }
            setTransition(e) {
                return this.stylesheet.transition = Object.assign({}, this.stylesheet.transition, e), this.transition = this.stylesheet.transition, this;
            }
            getTransition() {
                return Object.assign({}, this.stylesheet.transition);
            }
            serialize() {
                this._checkLoaded();
                const t1 = this.getTerrain(), i = t1 && this.terrain && this.terrain.scope === this.scope ? t1 : this.stylesheet.terrain;
                return e.dv({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    fragment: this.stylesheet.fragment,
                    iconsets: this.stylesheet.iconsets,
                    featuresets: this.stylesheet.featuresets,
                    imports: this._serializeImports(),
                    schema: this.stylesheet.schema,
                    camera: this.stylesheet.camera,
                    light: this.stylesheet.light,
                    lights: this.stylesheet.lights,
                    terrain: i,
                    fog: this.stylesheet.fog,
                    snow: this.stylesheet.snow,
                    rain: this.stylesheet.rain,
                    indoor: this.stylesheet.indoor,
                    center: this.stylesheet.center,
                    "color-theme": this.stylesheet["color-theme"],
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: this._serializeSources(),
                    layers: this._serializeLayers(this._order)
                }, (e)=>void 0 !== e);
            }
            _updateFilteredLayers(e) {
                for (const t1 of Object.values(this._mergedLayers))e(t1) && this._updateLayer(t1);
            }
            _updateLayer(t1) {
                this._changes.updateLayer(t1);
                const i = this.getLayerSourceCache(t1), o = e.B(t1.source, t1.scope), s = this._changes.getUpdatedSourceCaches();
                t1.source && !s[o] && i && "raster" !== i.getSource().type && (this._changes.updateSourceCache(o, "reload"), i.pause()), t1.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e) {
                const t1 = (e)=>this._mergedLayers[e].is3D(!!this.terrain), i = this.order, o = {}, s = [];
                for(let r = i.length - 1; r >= 0; r--){
                    const n = i[r];
                    if (t1(n)) {
                        o[n] = r;
                        for (const t1 of e){
                            const e = t1[n];
                            if (e) for (const t1 of e)s.push(t1);
                        }
                    }
                }
                s.sort((e, t1)=>t1.intersectionZ - e.intersectionZ);
                const r = [];
                for(let n = i.length - 1; n >= 0; n--){
                    const a = i[n];
                    if (t1(a)) for(let e = s.length - 1; e >= 0; e--){
                        const t1 = s[e].feature;
                        if (t1.layer && o[t1.layer.id] < n) break;
                        r.push(t1), s.pop();
                    }
                    else for (const t1 of e){
                        const e = t1[a];
                        if (e) for (const t1 of e)r.push(t1.feature);
                    }
                }
                return r;
            }
            queryRasterValue(t1, i, o) {
                const s = this.getOwnSource(t1);
                return s ? "raster-array" !== s.type ? (this.fire(new e.y(new Error('queryRasterValue support only "raster-array" sources.'))), Promise.resolve(null)) : s.queryRasterArrayValue(i, o) : (this.fire(new e.y(new Error(`Source with id "${t1}" does not exist in the style.`))), Promise.resolve(null));
            }
            queryRenderedFeatures(t1, i, o) {
                let s;
                i && !Array.isArray(i) && i.filter && (this._validate(De, "queryRenderedFeatures.filter", i.filter, null, i), s = e.b6(i.filter));
                const r = {}, n = (e)=>{
                    if (Lo.has(e.type)) return;
                    const t1 = this.getOwnLayerSourceCache(e), i = r[t1.id] = r[t1.id] || {
                        sourceCache: t1,
                        layers: {},
                        has3DLayers: !1
                    };
                    e.is3D(!!this.terrain) && (i.has3DLayers = !0), i.layers[e.fqid] = i.layers[e.fqid] || {
                        styleLayer: e,
                        targets: []
                    }, i.layers[e.fqid].targets.push({
                        filter: s
                    });
                };
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e.y(new Error("parameters.layers must be an Array."))), [];
                    for (const t1 of i.layers){
                        const i = this._layers[t1];
                        if (!i) return this.fire(new e.y(new Error(`The layer '${t1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        n(i);
                    }
                } else for(const e in this._layers)n(this._layers[e]);
                const a = this._queryRenderedFeatures(t1, r, o), l = this._flattenAndSortRenderedFeatures(a), c = [];
                for (const t1 of l)e.dw(t1.layer.id) === this.scope && c.push(t1);
                return c;
            }
            queryRenderedFeatureset(t1, i, o) {
                let s;
                i && !Array.isArray(i) && i.filter && (this._validate(De, "queryRenderedFeatures.filter", i.filter, null, i), s = e.b6(i.filter));
                const r = "mock", n = [];
                if (i && i.target) n.push(Object.assign({}, i, {
                    targetId: r,
                    filter: s
                }));
                else {
                    const e = this.getFeaturesetDescriptors();
                    for (const t1 of e)n.push({
                        targetId: r,
                        filter: s,
                        target: t1
                    });
                    for (const { style: e } of this.fragments){
                        const t1 = e.getFeaturesetDescriptors();
                        for (const e of t1)n.push({
                            targetId: r,
                            filter: s,
                            target: e
                        });
                    }
                }
                const a = this.queryRenderedTargets(t1, n, o), l = [], c = new Set;
                for (const t1 of a)for (const i of t1.variants[r])vt(i, t1, c) || l.push(new e.dx(t1, i));
                return l;
            }
            queryRenderedTargets(t1, i, o) {
                const s = {}, r = (e, t1, i, o)=>{
                    const r = s[t1.id] = s[t1.id] || {
                        sourceCache: t1,
                        layers: {},
                        has3DLayers: !1
                    };
                    if (r.layers[e.fqid] = r.layers[e.fqid] || {
                        styleLayer: e,
                        targets: []
                    }, e.is3D(!!this.terrain) && (r.has3DLayers = !0), !o) return i.uniqueFeatureID = !1, void r.layers[e.fqid].targets.push(i);
                    r.layers[e.fqid].targets.push(Object.assign({}, i, {
                        namespace: o.namespace,
                        properties: o.properties,
                        uniqueFeatureID: o.uniqueFeatureID
                    }));
                };
                for (const t1 of i)if ("featuresetId" in t1.target) {
                    const { featuresetId: i, importId: o } = t1.target, s = this.getFragmentStyle(o);
                    if (!s || !s._featuresetSelectors) continue;
                    const n = s._featuresetSelectors[i];
                    if (!n) {
                        this.fire(new e.y(new Error(`The featureset '${i}' does not exist in the map's style and cannot be queried for features.`)));
                        continue;
                    }
                    for (const e of n){
                        const i = s.getOwnLayer(e.layerId);
                        i && !Lo.has(i.type) && r(i, s.getOwnLayerSourceCache(i), t1, e);
                    }
                } else if ("layerId" in t1.target) {
                    const { layerId: e } = t1.target, i = this.getLayer(e);
                    if (!i || Lo.has(i.type)) continue;
                    r(i, this.getLayerSourceCache(i), t1);
                }
                const n = this._queryRenderedFeatures(t1, s, o);
                return this._flattenAndSortRenderedFeatures(n);
            }
            _queryRenderedFeatures(e, t1, i) {
                const o = [], s = !!this.map._showQueryGeometry, r = st.createFromScreenPoints(e, i);
                for(const e in t1){
                    const n = yt(r, t1[e], this._availableImages, i, s, this.getActualScope());
                    Object.keys(n).length && o.push(n);
                }
                if (this.placement) for(const e in t1){
                    if (!t1[e].sourceCache._onlySymbols) continue;
                    const i = xt(r.screenGeometry, t1[e], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData, this.map.getWorldview());
                    Object.keys(i).length && o.push(i);
                }
                return o;
            }
            querySourceFeatures(e, t1) {
                const i = t1 && t1.filter;
                i && this._validate(De, "querySourceFeatures.filter", i, null, t1);
                let o = [];
                const s = this.getOwnSourceCaches(e);
                for (const e of s)o = o.concat(bt(e, t1));
                return o;
            }
            addSourceType(e, t1, i) {
                return Oo.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (Oo.setSourceType(e, t1), t1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e,
                    url: t1.workerSourceURL
                }, i) : i(null, null));
            }
            getFlatLight() {
                return this.light.getLight();
            }
            setFlatLight(t1, i, o = {}) {
                this._checkLoaded();
                const s = this.light.getLight();
                let r = !1;
                for(const i in t1)if (!e.by(t1[i], s[i])) {
                    r = !0;
                    break;
                }
                if (!r) return;
                const n = this._getTransitionParameters();
                this.light.setLight(t1, i, o), this.light.updateTransitions(n);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            checkCanvasFingerprintNoise() {
                void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.o.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
            }
            setTerrain(t1, i = 1) {
                if (this._checkLoaded(), !t1) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i && delete this.terrain, null === t1 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                this.checkCanvasFingerprintNoise();
                let o = t1;
                const s = !("source" in t1) || null == t1.source;
                if (1 === i) {
                    if (this.disableElevatedTerrain) return;
                    if ("source" in o && "object" == typeof o.source) {
                        const t1 = "terrain-dem-src";
                        this.addSource(t1, o.source), o = e.dp(o), o = Object.assign(o, {
                            source: t1
                        });
                    }
                    const t1 = Object.assign({}, o), i = {};
                    if (this.terrain && s) {
                        t1.source = this.terrain.get().source;
                        const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                        e && (i.style = e.serialize());
                    }
                    if (this._validate(Ie, "terrain", t1, i)) return;
                }
                if (!this.terrain || this.terrain.scope !== this.scope && !s || this.terrain && i !== this.terrain.drapeRenderMode) {
                    if (!o) return;
                    this._createTerrain(o, i), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                } else {
                    const i = this.terrain, s = i.get();
                    for (const t1 of Object.keys(e.a6.terrain))!o.hasOwnProperty(t1) && e.a6.terrain[t1].default && (o[t1] = e.a6.terrain[t1].default);
                    for(const o in t1)if (!e.by(t1[o], s[o])) {
                        i.set(t1, this.options), this.stylesheet.terrain = t1;
                        const o = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(o), this.fire(new e.z("data", {
                            dataType: "style"
                        }));
                        break;
                    }
                }
                this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e) {
                const t1 = this.fog = new $e(e, this.map.transform, this.scope, this.options);
                this.stylesheet.fog = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _createSnow(e) {
                const t1 = this.snow = new Je(e, this.map.transform, this.scope, this.options);
                this.stylesheet.snow = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _createRain(e) {
                const t1 = this.rain = new Qe(e, this.map.transform, this.scope, this.options);
                this.stylesheet.rain = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e of this.map._markers)e._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(t1) {
                if (this._checkLoaded(), !t1) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog;
                    if (!e.by(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.fog = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createFog(t1);
                this._markersNeedUpdate = !0;
            }
            getSnow() {
                return this.snow ? this.snow.get() : null;
            }
            setSnow(t1) {
                if (this._checkLoaded(), !t1) return delete this.snow, void delete this.stylesheet.snow;
                if (this.snow) {
                    const i = this.snow;
                    if (!e.by(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.snow = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createSnow(t1);
                this._markersNeedUpdate = !0;
            }
            getRain() {
                return this.rain ? this.rain.get() : null;
            }
            setRain(t1) {
                if (this._checkLoaded(), !t1) return delete this.rain, void delete this.stylesheet.rain;
                if (this.rain) {
                    const i = this.rain;
                    if (!e.by(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.rain = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createRain(t1);
                this._markersNeedUpdate = !0;
            }
            _reloadColorTheme() {
                const t1 = ()=>{
                    for(const e in this._layers)this._layers[e].lut = this._styleColorTheme.lut;
                    for(const e in this._sourceCaches)this._sourceCaches[e].clearTiles();
                }, i = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                if (!i) return this._styleColorTheme.lut = null, void t1();
                const o = this._evaluateColorThemeData(i);
                this._loadColorTheme(o).then(()=>{
                    this.fire(new e.z("colorthemeset")), t1();
                }).catch((t1)=>{
                    e.w(`Couldn't set color theme: ${t1}`);
                });
            }
            setColorTheme(t1) {
                this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t1, this._reloadColorTheme();
            }
            setImportColorTheme(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i._styleColorTheme.colorThemeOverride = t1, i._reloadColorTheme());
            }
            _getTransitionParameters(t1) {
                return {
                    now: e.o.now(),
                    transition: Object.assign(this.transition, t1)
                };
            }
            updateDrapeFirstLayers() {
                if (!this.terrain) return;
                const e = [], t1 = [];
                for (const i of this._mergedOrder)this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t1.push(i);
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t1);
            }
            _createTerrain(e, t1) {
                const i = this.terrain = new je(e, t1, this.scope, this.options, this.map.getWorldview());
                1 === t1 && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
                const o = this._getTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(o);
            }
            _force3DLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "fill-extrusion" === t1.type && this._updateLayer(t1);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "symbol" === t1.type && this._updateLayer(t1);
                }
            }
            _validate(t1, i, o, s, r = {}) {
                if (r && !1 === r.validate) return !1;
                const n = Object.assign({}, this.serialize());
                return Co(this, t1.call(we, Object.assign({
                    key: i,
                    style: n,
                    value: o,
                    styleSpec: e.a6
                }, s)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.dy.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e in this._mergedLayers)this._mergedLayers[e].setEventedParent(null);
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);
                this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.indoorManager.destroy(), this.isRootStyle() && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());
            }
            clearSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.clearTiles();
            }
            clearSources() {
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles();
            }
            clearLayers() {
                for(const e in this._mergedLayers){
                    const t1 = this._mergedLayers[e];
                    t1._clear && t1._clear();
                }
            }
            reloadSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.resume(), e.reload();
            }
            reloadSources() {
                for (const e of this.getSources())e.reload && e.reload();
            }
            reloadModels() {
                this.modelManager.reloadModels(""), this.forEachFragmentStyle((e)=>{
                    e.modelManager.reloadModels(e.scope);
                });
            }
            updateSources(e) {
                let t1;
                this.directionalLight && (t1 = mo(this.directionalLight));
                const i = new Set, o = new Set;
                for(const e in this._mergedLayers){
                    const t1 = this._mergedLayers[e];
                    "building" === t1.type && i.add(t1.source), t1.hasElevation() && !o.has(t1.source) && o.add(t1.source);
                }
                for(const s in this._mergedSourceCaches){
                    const r = this._mergedSourceCaches[s], n = o.has(r._source.id);
                    i.has(r._source.id) && (r._source.reparseOverscaled = !1), r.update(e, void 0, void 0, t1, n);
                }
            }
            _generateCollisionBoxes() {
                for(const e in this._sourceCaches){
                    const t1 = this._sourceCaches[e];
                    t1.resume(), t1.reload();
                }
            }
            _handleLayerOrderChange() {
                this._requestFullLabelPlacement(), this.fire(new e.z("neworder"));
            }
            _requestFullLabelPlacement() {
                this.pauseablePlacement || (this.pauseablePlacement = new Ui), this.pauseablePlacement.requestFullPlacement();
            }
            _setLabelPlacementStale() {
                this.placement && this.placement.setStale();
            }
            _updatePlacement(t1, i, o, s, r) {
                this.pauseablePlacement || (this.pauseablePlacement = new Ui);
                let n = !1, a = !1;
                const l = {}, c = {};
                for (const i of this._mergedOrder){
                    const o = this._mergedLayers[i];
                    if ("symbol" !== o.type) continue;
                    const s = e.B(o.source, o.scope);
                    let r = l[s];
                    if (!r) {
                        const e = this.getLayerSourceCache(o);
                        if (!e) continue;
                        const t1 = e.getRenderableIds(!0).map((t1)=>e.getTileByID(t1));
                        c[s] = t1.slice(), r = l[s] = t1.sort((e, t1)=>t1.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t1.tileID) ? -1 : 1));
                    }
                    const a = this.crossTileSymbolIndex.addLayer(o, r, t1.center.lng, t1.projection);
                    n = n || a;
                }
                this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder);
                const h = Boolean(this.placement && !t1.equals(this.placement.transform)), d = Boolean(this.placement && (0 !== this.placement.lastReplacementSourceUpdateTime && !r || this.placement.lastReplacementSourceUpdateTime !== r.updateTime)), u = h || d || n, _ = (u || this.pauseablePlacement.isStale()) && 0 === o, p = this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.o.now(), t1.zoom) && 0 !== o;
                if ((this.pauseablePlacement.isFullPlacementRequested() || !this.pauseablePlacement.placement || _ || p) && (this.pauseablePlacement = this.pauseablePlacement.startNewPlacement(t1, this._mergedOrder, i, o, s, this.placement, this.fog && t1.projection.supportsFog ? this.fog.state : null, this._buildingIndex)), this.pauseablePlacement.isDone() ? u && 0 !== o && this.pauseablePlacement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l, c, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.o.now()), a = !0), n && this.pauseablePlacement.setStale()), a || n) {
                    this._buildingIndex.onNewFrame(t1.zoom);
                    for(let t1 = 0; t1 < this._mergedOrder.length; t1++){
                        const i = this._mergedLayers[this._mergedOrder[t1]];
                        if ("symbol" !== i.type) continue;
                        if ("none" === i.visibility) continue;
                        const o = this.isLayerClipped(i);
                        this.placement.updateLayerOpacities(i, l[e.B(i.source, i.scope)], t1, o ? r : null);
                    }
                }
                return !this.pauseablePlacement.isDone() || this.placement.isStale() || this.placement.hasTransitions(e.o.now());
            }
            _releaseSymbolFadeTiles() {
                for(const e in this._sourceCaches)this._sourceCaches[e].releaseSymbolFadeTiles();
            }
            addImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports = this.stylesheet.imports || [];
                if (-1 !== o.findIndex(({ id: e })=>e === t1.id)) return void this.fire(new e.y(new Error(`Import with id '${t1.id}' already exists in the map's style.`)));
                if (!i) return o.push(t1), this._loadImports([
                    t1
                ], !0);
                const s = o.findIndex(({ id: e })=>e === i);
                return -1 === s && this.fire(new e.y(new Error(`Import with id "${i}" does not exist on this map.`))), this.stylesheet.imports = o.slice(0, s).concat(t1).concat(o.slice(s)), this._loadImports([
                    t1
                ], !0, i);
            }
            updateImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports || [], s = this.getImportIndex(t1);
                return -1 === s ? this : "string" == typeof i ? (this.setImportUrl(t1, i), this) : (i.url && i.url !== o[s].url && this.setImportUrl(t1, i.url), e.by(i.config, o[s].config) || this.setImportConfig(t1, i.config, i.data.schema), e.by(i.data, o[s].data) || this.setImportData(t1, i.data), this);
            }
            moveImport(e, t1) {
                this._checkLoaded();
                let i = this.stylesheet.imports || [];
                const o = this.getImportIndex(e);
                if (-1 === o) return this;
                const s = this.getImportIndex(t1);
                if (-1 === s) return this;
                const r = i[o], n = this.fragments[o];
                return i = i.filter(({ id: t1 })=>t1 !== e), this.fragments = this.fragments.filter(({ id: t1 })=>t1 !== e), this.stylesheet.imports = i.slice(0, s).concat(r).concat(i.slice(s)), this.fragments = this.fragments.slice(0, s).concat(n).concat(this.fragments.slice(s)), this.mergeLayers(), this;
            }
            setImportUrl(e, t1) {
                this._checkLoaded();
                const i = this.stylesheet.imports || [], o = this.getImportIndex(e);
                if (-1 === o) return this;
                i[o].url = t1;
                const s = this.fragments[o];
                return s.style = this._createFragmentStyle(i[o]), s.style.on("style.import.load", ()=>this.mergeAll()), s.style.loadURL(t1), this;
            }
            setImportData(e, t1) {
                this._checkLoaded();
                const i = this.getImportIndex(e), o = this.stylesheet.imports || [];
                return -1 === i ? this : t1 ? (this.fragments[i].style.setState(t1), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));
            }
            setImportConfig(e, t1, i) {
                this._checkLoaded();
                const o = this.getImportIndex(e), s = this.stylesheet.imports || [];
                if (-1 === o) return this;
                t1 ? s[o].config = t1 : delete s[o].config;
                const r = this.fragments[o];
                i && r.style.stylesheet && (r.style.stylesheet.schema = i);
                const n = r.style.stylesheet && r.style.stylesheet.schema;
                return r.config = t1, r.style.updateConfig(t1, n), this.updateConfigDependencies(), this;
            }
            removeImport(e) {
                this._checkLoaded();
                const t1 = this.stylesheet.imports || [], i = this.getImportIndex(e);
                -1 !== i && (t1.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports());
            }
            getImportIndex(t1) {
                const i = (this.stylesheet.imports || []).findIndex((e)=>e.id === t1);
                return -1 === i && this.fire(new e.y(new Error(`Import '${t1}' does not exist in the map's style and cannot be updated.`))), i;
            }
            getLayer(e) {
                return this._mergedLayers[e];
            }
            getSources() {
                const e = [];
                for(const t1 in this._mergedOtherSourceCaches){
                    const i = this._mergedOtherSourceCaches[t1];
                    i && e.push(i.getSource());
                }
                return e;
            }
            getSource(e, t1) {
                const i = this.getSourceCache(e, t1);
                return i && i.getSource();
            }
            getLayerSource(e) {
                const t1 = this.getLayerSourceCache(e);
                return t1 && t1.getSource();
            }
            getSourceCache(t1, i) {
                const o = e.B(t1, i);
                return this._mergedOtherSourceCaches[o];
            }
            getLayerSourceCache(t1) {
                const i = e.B(t1.source, t1.scope);
                return "symbol" === t1.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];
            }
            getSourceCaches(e) {
                if (null == e) return Object.values(this._mergedSourceCaches);
                const t1 = [];
                return this._mergedOtherSourceCaches[e] && t1.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t1.push(this._mergedSymbolSourceCaches[e]), t1;
            }
            updateSourceCaches() {
                const e = this._changes.getUpdatedSourceCaches();
                for(const t1 in e){
                    const i = e[t1];
                    "reload" === i ? this.reloadSource(t1) : "clear" === i && this.clearSource(t1);
                }
            }
            updateLayers(e) {
                const t1 = this._changes.getUpdatedPaintProperties();
                for (const i of t1){
                    const t1 = this.getLayer(i);
                    t1 && t1.updateTransitions(e);
                }
            }
            getGlyphsUrl() {
                return this.stylesheet.glyphs;
            }
            setGlyphsUrl(e) {
                this.stylesheet.glyphs = e, this.glyphManager.setURL(e);
            }
            getImages(t1, i, o) {
                this.imageManager.getImages(i.images, i.scope, o), this._updateTilesForChangedImages();
                const s = (t1)=>{
                    if (t1) {
                        const o = i.images.map((t1)=>e.I.toString(t1));
                        t1.setDependencies(i.tileID.key, i.type, o);
                    }
                }, r = e.B(i.source, i.scope);
                s(this._mergedOtherSourceCaches[r]), s(this._mergedSymbolSourceCaches[r]), i.images.some((e)=>e.iconsetId) && this.fire(new e.z("data", {
                    dataType: "style"
                }));
            }
            rasterizeImages(e, t1, i) {
                this.imageManager.rasterizeImages(t1, i);
            }
            getGlyphs(e, t1, i) {
                this.glyphManager.getGlyphs(t1.stacks, i);
            }
            getResource(t1, i, o) {
                return e.dz(i, o);
            }
            getOwnSourceCache(e) {
                return this._otherSourceCaches[e];
            }
            getOwnLayerSourceCache(e) {
                return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
            }
            getOwnSourceCaches(e) {
                const t1 = [];
                return this._otherSourceCaches[e] && t1.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t1.push(this._symbolSourceCaches[e]), t1;
            }
            _isSourceCacheLoaded(t1) {
                const i = this.getOwnSourceCaches(t1);
                return 0 === i.length ? (this.fire(new e.y(new Error(`There is no source with ID '${t1}'`))), !1) : i.every((e)=>e.loaded());
            }
            has3DLayers() {
                return this._has3DLayers;
            }
            hasSymbolLayers() {
                return this._hasSymbolLayers;
            }
            hasCircleLayers() {
                return this._hasCircleLayers;
            }
            isLayerClipped(e, t1) {
                if (!this._clipLayerPresent && "fill-extrusion" !== e.type && "building" !== e.type) return !1;
                const i = "fill-extrusion" === e.type && ("building" === e.sourceLayer || "procedural_buildings" === e.sourceLayer), o = "building" === e.type;
                if (e.is3D(!!this.terrain)) {
                    if (i || o || t1 && "batched-model" === t1.type) return !0;
                    if ("model" === e.type) return !0;
                } else if ("symbol" === e.type) return !0;
                return !1;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.fragments.forEach((e)=>{
                    e.style._remove();
                }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        Oo.getSourceType = function(e) {
            return ft[e];
        }, Oo.setSourceType = function(e, t1) {
            ft[e] = t1;
        }, Oo.registerForPluginStateChange = e.dA;
        var zo = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Mo = "\n#ifdef DUAL_SOURCE_BLENDING\nlayout(location=0,index=0) out vec4 glFragColor;layout(location=0,index=1) out vec4 glFragColorSrc1;\n#else\nlayout(location=0) out vec4 glFragColor;\n#endif\n#ifdef USE_MRT1\nlayout(location=1) out vec4 out_Target1;\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb*col.a,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Fo = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifndef HAS_SHADER_STORAGE_BLOCK_material_buffer\n#define GET_ATTRIBUTE_float(attrib,matInfo,attrib_id) attrib\n#define GET_ATTRIBUTE_vec4(attrib,matInfo,attrib_id) attrib\n#define GET_ATTRIBUTE_vec2(attrib,matInfo,attrib_id) attrib\n#define DECLARE_MATERIAL_TABLE_INFO\n#endif", Bo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ko = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\nint NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\nhighp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif", No = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Uo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", jo = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", Vo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Go = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif", Ho = "#ifdef RENDER_SHADOWS\nprecision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {\n#ifdef CLIP_ZERO_TO_ONE\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z-bias);\n#else\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);\n#endif\nreturn texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;\n#ifdef SHADOWS_SINGLE_CASCADE\nvec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);\n#else\nlight_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const qo = /#include\s+"([^"]+)"/g, Zo = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g, Wo = /\b[A-Za-z_][A-Za-z0-9_]*\b/g, $o = new Set([
            "ifdef",
            "ifndef",
            "elif",
            "if",
            "defined"
        ]), Xo = new Set;
        os(zo, Xo), os(Fo, Xo), os(Mo, Xo);
        const Yo = {
            "_prelude_fog.vertex.glsl": No,
            "_prelude_terrain.vertex.glsl": ko,
            "_prelude_shadow.vertex.glsl": Go,
            "_prelude_material_table.vertex.glsl": "#ifdef HAS_SHADER_STORAGE_BLOCK_material_buffer\n#define MATERIAL_TABLE_DEBUG 0\nuniform int u_material_offset;uniform int u_vertex_offset;layout(std140,binding=0)readonly buffer material_buffer{uvec4 material_data[];};struct MaterialInfo{uint dataOffset;\n#if MATERIAL_TABLE_DEBUG\nvec4 colorDebug;\n#endif\n};uint read_buf_no_offset(uint iDword) {return material_data[iDword/4u][iDword % 4u];}uint read_buf(uint iDword) {iDword+=uint(u_material_offset/4);return read_buf_no_offset(iDword);}float read_buf_float(uint iDword){return uintBitsToFloat(read_buf(iDword));}uint read_buf_uint8(uint iDword,uint iUint8){uint dwordOffset=iDword+(iUint8/4u);uint byteOffset=iUint8 & 3u;uint bitOffset=8u*byteOffset;uint mask=0xffu << bitOffset;uint dwordVal=read_buf(dwordOffset);return (dwordVal & mask) >> bitOffset;}uint read_buf_uint16(uint iDword,uint iUint16){uint dwordOffset=iDword+(iUint16 >> 1u);uint bitOffset=(iUint16 & 1u)*16u;uint mask=0xffffu << bitOffset;uint dwordVal=read_buf(dwordOffset);return (dwordVal & mask) >> bitOffset;}uint nrDwordsForVertexIdEntries(uint nrMaterialLookupEntries) {return nrMaterialLookupEntries;}uint nrDwordsForMaterialIdEntries(uint nrMaterialLookupEntries) {return (nrMaterialLookupEntries*2u+3u)/4u;}uint findRangeBinarySearch(uint vertexId,uint numRanges,uint dwordOffset) {uint left=0u;uint right=numRanges-1u;for (uint i=0u; i < 16u; i++) { \nif (left > right) {break;}uint mid=(left+right)/2u;uint start=read_buf(dwordOffset+mid);uint nextStart=(mid+1u < numRanges) ? read_buf(dwordOffset+mid+1u) : 0xffffffffu;if (vertexId >=start && vertexId < nextStart) {return mid;} else if (vertexId < start) {if (mid==0u) {break;}right=mid-1u;} else {left=mid+1u;}}return 0u; \n}uint readVertexId(uint dwordOffset,uint iMaterialLookupEntry) {return read_buf(dwordOffset+iMaterialLookupEntry);}uint findRange(uint vertexId,uint numRanges,uint dwordOffset) {uint iRange;if(numRanges <=64u){uint vertexBegin;for(iRange=0u; iRange < numRanges;++iRange) {vertexBegin=readVertexId(dwordOffset,iRange);if(vertexBegin > vertexId) {break;}}iRange=iRange==0u? 0u : iRange-1u;} else { \niRange=findRangeBinarySearch(vertexId,numRanges,dwordOffset);}return iRange;}MaterialInfo read_material_info(uint vertex_id) {MaterialInfo info;\n#if MATERIAL_TABLE_DEBUG\nconst vec4 red=vec4(1.0,0.0,0.0,1.0);const vec4 orange=vec4(1.0,0.5,0.0,1.0);const vec4 yellow=vec4(1.0,1.0,0.0,1.0);const vec4 green=vec4(0.0,1.0,0.0,1.0);const vec4 indigo=vec4(0.294,0.0,0.510,1.0);const vec4 blue=vec4(0.0,0.0,1.0,1.0);const vec4 purple=vec4(0.5,0.0,0.5,1.0);const vec4 pink=vec4(1.0,0.0,1.0,1.0);info.colorDebug=green;\n#endif\nuint offset=0u;\n#if MATERIAL_TABLE_DEBUG\nbool keepFinding=true;uint magic=read_buf(offset);if(magic !=0xCAFEBABEu) {info.colorDebug=red;keepFinding=false;return info;}\n#endif\noffset++;\n#if MATERIAL_TABLE_DEBUG\nuint nrMaterials=read_buf(offset);uint nrVertices=read_buf(offset+1u);if(keepFinding && vertex_id >=nrVertices) {info.colorDebug=red;keepFinding=false;}\n#endif\noffset+=2u;uint nrMaterialLookupEntries=read_buf(offset++);uint perMaterialEntrySizeDwords=read_buf(offset++);\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding && perMaterialEntrySizeDwords !=1u) {info.colorDebug=red;keepFinding=false;}\n#endif\nuint iMaterialLookup=findRange(vertex_id,nrMaterialLookupEntries,offset);\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding)\n{uint vertexBeginCheck=readVertexId(offset,iMaterialLookup);if(vertexBeginCheck > vertex_id) {info.colorDebug=red;keepFinding=false;}if(iMaterialLookup < nrMaterialLookupEntries-1u) {uint vertexEndCheck=readVertexId(offset,iMaterialLookup+1u);if(vertexEndCheck <=vertex_id) {info.colorDebug=red;keepFinding=false;}}}\n#endif\noffset+=nrDwordsForVertexIdEntries(nrMaterialLookupEntries);uint materialId=iMaterialLookup;\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding) {if(materialId >=nrMaterialLookupEntries) {info.colorDebug=red;}}\n#endif\ninfo.dataOffset=offset+materialId*perMaterialEntrySizeDwords;return info;}uint get_data_location(const MaterialInfo matInfo,uint attribOffsetBytes)\n{uint attribFieldOffsetDwords=attribOffsetBytes/4u;return matInfo.dataOffset+attribFieldOffsetDwords;}vec4 read_material_vec4(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return vec4(read_buf_float(loc),read_buf_float(loc+1u),read_buf_float(loc+2u),read_buf_float(loc+3u));}vec2 read_material_vec2(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return vec2(read_buf_float(loc),read_buf_float(loc+1u));}float read_material_float(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return read_buf_float(loc);}\n#define GET_ATTRIBUTE_float(attrib,matInfo,attrib_offset) read_material_float(matInfo,attrib_offset)\n#define GET_ATTRIBUTE_vec4(attrib,matInfo,attrib_offset) read_material_vec4(matInfo,attrib_offset)\n#define GET_ATTRIBUTE_vec2(attrib,matInfo,attrib_offset) read_material_vec2(matInfo,attrib_offset)\n#define DECLARE_MATERIAL_TABLE_INFO MaterialInfo materialInfo=read_material_info(uint(gl_VertexID));\n#define DECLARE_MATERIAL_TABLE_INFO_DEBUG(dbgColor) MaterialInfo materialInfo=read_material_info(uint(gl_VertexID)); dbgColor=materialInfo.colorDebug;\n#endif",
            "_prelude_fog.fragment.glsl": Uo,
            "_prelude_shadow.fragment.glsl": Ho,
            "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif",
            "_prelude_raster_array.glsl": jo,
            "_prelude_raster_particle.glsl": Vo
        }, Ko = {};
        ss("", ko), ss(Uo, No), ss(Ho, Go), ss(jo, ""), ss(Vo, "");
        const Jo = ss(Mo, Fo), Qo = zo, es = [
            "\n#if defined(GL_EXT_blend_func_extended) && defined(DUAL_SOURCE_BLENDING)\n#extension GL_EXT_blend_func_extended : require\n#endif",
            "precision mediump float;",
            Qo,
            Jo.fragmentSource
        ].join("\n"), ts = [
            "precision highp float;",
            Qo,
            Jo.vertexSource
        ].join("\n");
        var is = {
            background: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;uniform mediump float u_emissive_strength;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform mediump float u_emissive_strength;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            backgroundPattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            building: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nconst float window_depth=0.5;const float ao_radius=0.2;in vec4 v_color;in highp vec3 v_normal;in highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nin lowp float v_faux_facade;in highp float v_faux_facade_ed;in highp vec2 v_faux_facade_window;in highp vec2 v_faux_facade_floor;in highp vec2 v_faux_facade_range;in highp float v_aspect;in highp vec3 v_tbn_0;in highp vec3 v_tbn_1;in highp vec3 v_tbn_2;in highp vec4 v_faux_color_emissive;uniform float u_faux_facade_ao_intensity;\n#endif\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\n#ifdef FLOOD_LIGHT\nin highp float v_flood_radius;in float v_has_flood_light;\n#endif\nuniform lowp float u_opacity;uniform vec3 u_camera_pos;uniform highp float u_tile_to_meter;uniform float u_facade_emissive_chance;uniform vec3 u_flood_light_color;uniform float u_flood_light_intensity;vec3 linearTosRGB(in vec3 color) {return pow(color,vec3(1./2.2));}\n#ifdef BUILDING_FAUX_FACADE\nfloat hash12(in vec2 p) {vec3 p3 =fract(vec3(p.xyx)*0.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float min3(in vec3 v) {return min(min(v.x,v.y),v.z);}vec2 get_uv_mask_id(in vec2 q,out float mask,out vec2 id) {vec2 p=q;mask=step(v_faux_facade_range.x,p.y)*step(p.y,v_faux_facade_range.y);p.y=p.y-v_faux_facade_range.x;vec2 uv=modf(p/v_faux_facade_floor,id);vec4 d=(v_faux_facade_floor.xyxy+vec4(-v_faux_facade_window,v_faux_facade_window))*0.5;vec4 edge=d/v_faux_facade_floor.xyxy;vec2 m=step(edge.xy,uv)*step(uv,edge.zw);mask*=m.x*m.y;uv-=vec2(0.5);uv*=vec2(0.5)/(vec2(0.5)-edge.xy);uv+=vec2(0.5);return uv;}float ray_unit_box(in vec3 ray_o,in vec3 ray_d,in vec3 bmin,in vec3 bmax) {vec3 planes=mix(bmin,bmax,step(0.0,ray_d));vec3 t=(planes-ray_o)/ray_d;return min3(t);}float get_emissive(in vec2 id) {if (u_facade_emissive_chance > 0.0) {return (step(hash12(id),u_facade_emissive_chance)+0.05)*v_faux_color_emissive.a;}return 0.0;}vec3 get_shade_info(in vec3 v,in vec3 v_normalized,in vec3 color,in vec2 id,in mat3 tbn,inout vec3 out_normal,inout float out_emissive) {vec3 out_color=color;vec3 abs_v=abs(v_normalized);bool x_major=abs_v.x >=abs_v.y && abs_v.x >=abs_v.z;bool y_major=abs_v.y >=abs_v.x && abs_v.y >=abs_v.z;bool z_major=abs_v.z >=abs_v.x && abs_v.z >=abs_v.y;\n#if 0\nif (x_major) {out_color=v.x > 0.0 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,1.0);} else if (y_major) {out_color=v.y > 0.0 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,1.0);} else if (z_major) {out_color=v.z > 0.0 ? vec3(0.0,0.0,1.0) : vec3(1.0,1.0,0.0);}out_emissive=1.0;\n#else\nif (x_major) {out_normal=sign(v.x)*tbn[0];} else if (y_major) {out_normal=vec3(0.0,0.0,-sign(v.y));} else if (z_major) {out_color=v_faux_color_emissive.rgb;out_emissive=v.z <=0.0 ? get_emissive(id) : out_emissive;}float ao=1.0;if (u_faux_facade_ao_intensity > 0.0) {vec4 ao_range=v_faux_facade_window.xxyy*0.5-vec4(0,ao_radius,0,ao_radius);vec2 ao_range_z=vec2(window_depth*0.5)-vec2(0.0,ao_radius);if (x_major || y_major) {ao*=smoothstep(-ao_range_z.x,-ao_range_z.y,v.z);} else if (z_major) {ao*=smoothstep(-ao_range.x,-ao_range.y,v.x)*(1.0-smoothstep(ao_range.y,ao_range.x,v.x));ao*=smoothstep(-ao_range.z,-ao_range.w,v.y)*(1.0-smoothstep(ao_range.w,ao_range.z,v.y));}ao=mix(1.0,min(1.0,ao+0.25),u_faux_facade_ao_intensity);}out_color*=ao;\n#endif\nreturn out_color;}\n#endif\nvec3 apply_lighting_linear(in vec3 color,in vec3 normal,in float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec3 normal=normalize(v_normal);vec3 base_color=v_color.rgb;float emissive=v_color.a;\n#ifdef BUILDING_FAUX_FACADE\nif (v_faux_facade > 0.0) {mat3 tbn=mat3(v_tbn_0,v_tbn_1,v_tbn_2);vec3 v=vec3(v_pos.xy,v_pos.z/u_tile_to_meter)-u_camera_pos;vec3 view_tangent=transpose(tbn)*v;vec2 q=vec2(v_faux_facade_ed,v_pos.z);float mask=0.0;vec2 id=vec2(0.0);vec2 uv=get_uv_mask_id(q,mask,id);uv*=v_faux_facade_window;vec3 bmin=vec3(0.0,0.0,-window_depth);vec3 bmax=bmin+vec3(v_faux_facade_window,window_depth);vec3 ray_o=vec3(uv,0.0);vec3 ray_d=normalize(view_tangent);float t_min=ray_unit_box(ray_o,ray_d,bmin,bmax);vec3 hit=ray_o+t_min*ray_d;vec3 r=vec3(v_faux_facade_window,-window_depth);hit-=r*0.5;vec3 normalized=hit/r;vec3 out_normal=normal;float out_emissive=emissive;vec3 room_color=get_shade_info(hit,normalized,base_color,id,tbn,out_normal,out_emissive);base_color=mix(base_color,room_color,mask);normal=mix(normal,out_normal,mask);emissive=mix(emissive,out_emissive,mask);}\n#endif\nvec4 color=vec4(base_color,1.0);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\n#ifdef RENDER_SHADOWS\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\n#else\nshadowed_lighting_factor=dot(xy_flipped_normal,u_lighting_directional_dir);\n#endif\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=linearTosRGB(color.rgb);\n#ifdef FLOOD_LIGHT\nfloat flood_radiance=(1.0-min(v_pos.z/v_flood_radius,1.0))*u_flood_light_intensity*v_has_flood_light;color.rgb=mix(color.rgb,u_flood_light_color,flood_radiance);\n#endif\ncolor.rgb=mix(color.rgb,linearTosRGB(base_color.rgb),emissive);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_pos.z));\n#endif\ncolor*=u_opacity;\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_pos.z);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color; \n#ifdef DEBUG_SHOW_NORMALS\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;in vec3 a_normal_3;in vec3 a_centroid_3;in float a_flood_light_wall_radius_1i16;in vec4 a_faux_facade_data;in vec2 a_faux_facade_vertical_range;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;uniform highp float u_tile_to_meter;out vec4 v_color;out vec3 v_normal;out highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nout lowp float v_faux_facade;out highp float v_faux_facade_ed;out highp vec2 v_faux_facade_window;out highp vec2 v_faux_facade_floor;out highp vec2 v_faux_facade_range;out highp float v_aspect;out highp vec3 v_tbn_0;out highp vec3 v_tbn_1;out highp vec3 v_tbn_2;out highp vec4 v_faux_color_emissive;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#ifdef FLOOD_LIGHT\nout highp float v_flood_radius;out float v_has_flood_light;\n#endif\nconst float MAX_UINT_16=65535.0;const float MAX_INT_16=32767.0;const float MAX_UINT_8=255.0;const float TWO_POW_8=256.0;const float FLOOD_LIGHT_MAX_RADIUS_METER=2048.0;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#ifdef BUILDING_FAUX_FACADE\nmat3 get_tbn(in vec3 normal) {const vec3 bitangent=vec3(0.0,0.0,1.0);vec3 tangent=normalize(vec3(normal.y,-normal.x,0.0));return mat3(tangent,bitangent,normal);}\n#endif\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 faux_facade_color_emissive\nvoid main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute-custom highp vec2 faux_facade_color_emissive\n#ifdef FLOOD_LIGHT\nv_flood_radius=(a_flood_light_wall_radius_1i16/MAX_INT_16*FLOOD_LIGHT_MAX_RADIUS_METER);v_has_flood_light=step(0.0,v_flood_radius);\n#endif\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);vec3 a_normal_3f=a_normal_3/MAX_INT_16;v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));float hidden=0.0;float depth_offset=0.0;\n#ifdef BUILDING_FAUX_FACADE\nv_faux_facade=a_faux_facade_data.x;if (v_faux_facade > 0.0) {v_faux_facade_ed=a_faux_facade_data.x *u_tile_to_meter;float window_x_perc=floor(a_faux_facade_data.y/TWO_POW_8);float window_y_perc=a_faux_facade_data.y-TWO_POW_8*window_x_perc;vec2 window_perc=vec2(window_x_perc,window_y_perc)/MAX_UINT_8;v_faux_facade_floor=(a_faux_facade_data.zw/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_faux_facade_window=window_perc*v_faux_facade_floor;v_faux_facade_range=(a_faux_facade_vertical_range/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_aspect=v_faux_facade_window.x/v_faux_facade_window.y;mat3 tbn=get_tbn(normalize(v_normal));v_tbn_0=tbn[0];v_tbn_1=tbn[1];v_tbn_2=tbn[2];v_faux_color_emissive=decode_color(faux_facade_color_emissive);v_faux_color_emissive.rgb=sRGBToLinear(v_faux_color_emissive.rgb);float height=a_centroid_3.z;depth_offset=min(1000.0,height)*0.0000002;}\n#endif\nv_pos=a_pos_3f;\n#ifdef RENDER_CUTOFF\nvec4 ground=u_matrix*vec4(a_centroid_3,1.0);v_cutoff_opacity=cutoff_opacity(u_cutoff_params,ground.z);hidden=float(v_cutoff_opacity==0.0);v_pos.z*=v_cutoff_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=v_pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(v_pos);\n#endif\ngl_Position=mix(u_matrix*vec4(v_pos,1),AWAY,hidden);gl_Position.z-=depth_offset*gl_Position.w;}'),
            buildingBloom: ss("in vec4 v_color_emissive;\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\nfloat saturate(float val) {return clamp(val,0.0,1.0);}void main() {float emission=v_color_emissive.a;float opacity=1.0;\n#ifdef HAS_ATTRIBUTE_a_bloom_attenuation\nfloat distance=length(vec2(1.3*max(0.0,abs(bloom_attenuation.x)-bloom_attenuation.z),bloom_attenuation.y));distance+= mix(0.5,0.0,clamp(emission-1.0,0.0,1.0));opacity*=saturate(1.0-distance*distance);\n#endif\n#ifdef RENDER_CUTOFF\nopacity*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(v_color_emissive.rgb,1.0)*opacity;}", "in vec3 a_pos_3f;\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\nout vec4 v_color_emissive;uniform mat4 u_matrix;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\n#ifdef HAS_ATTRIBUTE_a_part_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);float part_emissive=color_emissive.a*5.0;v_color_emissive=vec4(sRGBToLinear(color_emissive.rgb),part_emissive);\n#else\nv_color_emissive=vec4(1.0);\n#endif\ngl_Position=u_matrix*vec4(a_pos_3f,1.0);\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}"),
            buildingDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            circle: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\n#ifdef ELEVATED_ROADS\nin float a_circle_z_offset;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\n#ifdef ELEVATED_ROADS\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'),
            clippingMask: ss("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: ss('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            heatmapTexture: ss("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: ss("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform float u_zoom_transition;\n#endif\nout float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec3 proj_pos=a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation);\n#ifdef PROJECTION_GLOBE_VIEW\n#ifndef PROJECTED_POS_ON_VIEWPORT\nvec3 globe_pos=proj_pos;vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,a_anchor_pos,u_tile_id,u_merc_center);proj_pos=mix_globe_mercator(globe_pos,mercator_pos,u_zoom_transition);\n#endif\n#endif\nvec4 projectedPoint=u_matrix*vec4(proj_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),
            collisionCircle: ss("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: ss("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'),
            elevatedStructuresDepth: ss("void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=vec4(0.);\n#endif\n}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"),
            elevatedStructuresDepthReconstruct: ss("#ifdef DEPTH_RECONSTRUCTION\nin float v_height;\n#endif\nvoid main() {\n#ifdef DEPTH_RECONSTRUCTION\nif (v_height >=0.0)\ndiscard;\n#else\n#ifdef FEATURE_CUTOUT\napply_feature_cutout(vec4(0.0,0.0,0.0,1.0),gl_FragCoord);\n#endif\n#endif\nglFragColor=vec4(1.0,0.0,0.0,1.0);}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\n#ifdef DEPTH_RECONSTRUCTION\nout float v_height;\n#endif\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\n#ifdef DEPTH_RECONSTRUCTION\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\n#endif\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}"),
            elevatedStructures: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin vec3 v_normal;in float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)\n{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nvec3 color=structure_color.xyz;\n#ifdef LIGHTING_3D_MODE\nvec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);\n#ifdef RENDER_SHADOWS\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);\n#else\ncolor=apply_lighting(color,transformed_normal);\n#endif\ncolor=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\n#endif\n#ifdef FOG\ncolor=fog_apply(color,v_fog_pos);\n#endif\nvec4 out_color=vec4(color,1.0);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_height);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nv_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fill: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'),
            fillOutline: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef FLIP_Y\nv_pos=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillOutlinePattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nuniform float u_emissive_strength;\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FLIP_Y\nv_pos_world=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillPattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillExtrusion: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_material_table.vertex.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);\n#ifdef CLIP_ZERO_TO_ONE\ncutoff=cutoff_opacity(u_cutoff_params,ground.z*2.0-ground.w);\n#else\ncutoff=cutoff_opacity(u_cutoff_params,ground.z);\n#endif\nif (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            fillExtrusionDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_material_table.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),
            fillExtrusionPattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_material_table.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'),
            groundShadow: ss('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'),
            fillExtrusionGroundEffect: ss("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(1.0-texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size)).a,0.0,0.0,0.0);\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'),
            hillshadePrepare: ss("precision highp float;uniform highp sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            line: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform highp vec2 u_trim_gradient_mix_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef VARIABLE_LINE_WIDTH\nin float stub_side;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float side_z_offset\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\n#pragma mapbox: define lowp float emissive_strength\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float side_z_offset\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\n#pragma mapbox: initialize lowp float emissive_strength\nfloat dist=length(v_normal)*v_width2.s;\n#ifdef VARIABLE_LINE_WIDTH\nblur=mix(blur,0.0,stub_side);\n#endif\nfloat blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef VARIABLE_LINE_WIDTH\nalpha=mix(alpha,1.0,stub_side);\n#endif\nalpha=side_z_offset > 0.0 ? 1.0-alpha : alpha;\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);highp float gradient_trim_color_mix_factor=0.0;\n#ifdef RENDER_LINE_GRADIENT\ngradient_trim_color_mix_factor=smoothstep(u_trim_gradient_mix_range.x,u_trim_gradient_mix_range.y,line_progress);\n#endif\nhighp vec4 trim_color=mix(u_trim_color,out_color,gradient_trim_color_mix_factor);out_color=mix(u_trim_gradient_mix_range.x < 1.0 ? color : out_color,trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\n#ifndef VARIABLE_LINE_WIDTH\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef DUAL_SOURCE_BLENDING\nglFragColorSrc1=vec4(vec3(0.0),emissive_strength);\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec3 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec3 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef VARIABLE_LINE_WIDTH\nout float stub_side;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float side_z_offset\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float side_z_offset\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\n#pragma mapbox: initialize lowp float emissive_strength\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;offset=-1.0*offset*u_width_scale;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nbool left=normal.y==1.0;float left_width=a_z_offset_width.y;float right_width=a_z_offset_width.z;halfwidth=(u_width_scale*(left ? left_width : right_width))/2.0;a_z_offset+=left ? side_z_offset : 0.0;v_normal=side_z_offset > 0.0 && left ? vec2(0.0) : v_normal;offset=border_width > 0.0 ? (left_width+right_width)*u_width_scale*0.5 : offset;halfwidth=border_width > 0.0 ? border_width*u_width_scale*0.5 : halfwidth;bool zero_right_width=border_width==0.0 && right_width==0.0;stub_side=zero_right_width ?-normal.y : 0.0;v_normal=!left && zero_right_width ? vec2(0.0) : v_normal;ANTIALIASING=!left && zero_right_width ? 0.0 : ANTIALIASING;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\nfloat inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\n#else\nv_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
            linePattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef LINE_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\n#ifdef LINE_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef DUAL_SOURCE_BLENDING\nglFragColorSrc1=vec4(vec3(0.0),emissive_strength);\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec3 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize lowp float emissive_strength\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
            raster: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'),
            rasterParticle: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),1.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),
            rasterParticleDraw: ss("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),
            rasterParticleTexture: ss("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
            rasterParticleUpdate: ss('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
            symbol: ss('#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nin highp float v_z_offset;\n#endif\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef TERRAIN\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#else\nout_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#define USING_APPEARANCE 1.0\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef ELEVATED_ROADS\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nout highp float v_z_offset;\n#endif\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float a_size_max= floor(a_size[1]*0.5);float a_apperance=a_size[1]-2.0*a_size_max;vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (a_apperance==USING_APPEARANCE) {size=a_size_max/128.0;} else if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size_max,u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\n#ifdef PROJECTED_POS_ON_VIEWPORT\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\n#else\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \n#endif\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\n#else\nz+=u_pitch_with_map ? z_offset : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\n#ifdef Z_TEST_OCCLUSION\nout_fade_opacity*=occlusion_opacity;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\n#ifdef ELEVATED_ROADS\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\n#endif\n#endif\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#else\n#ifdef RENDER_SHADOWS\nv_z_offset=e;\n#endif\n#endif\n}'),
            terrainRaster: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nuniform sampler2D u_image1;uniform float u_emissive_texture_available;\n#endif\nin vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : image_color.a;vec3 unlit_base=image_color.rgb*(1.0-emissive_strength);vec3 emissive_base=image_color.rgb*emissive_strength;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : image_color.a;color.rgb=mix(color.rgb,image_color.rgb,emissive_strength);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'),
            terrainDepth: ss("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),
            skybox: ss('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Bo),
            skyboxGradient: ss('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Bo),
            skyboxCapture: ss("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nuniform sampler2D u_image1;uniform float u_emissive_texture_available;\n#endif\nuniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : raster.a;raster=apply_lighting_with_emission_ground(raster,emissive_strength);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : color.a;color=apply_lighting_with_emission_ground(color,emissive_strength);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'),
            globeAtmosphere: ss('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_atmosphere_fog_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_atmosphere_fog_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_atmosphere_fog_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
            model: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;\n#ifdef DITHERED_DISCARD\nuniform float u_dithered_discard_threshold;\n#endif\nuniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef FLIP_Y\ncoord.y=1.0-coord.y;\n#endif\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;\n#ifdef FLIP_Y\nT=-T;B=-B;\n#endif\nhighp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));\n#ifdef FLIP_Y\nn=normalize(cross(fdx,fdy));\n#else\nn=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef DITHERED_DISCARD\nif (abs(u_dithered_discard_threshold) < 1.0) {float ditherValue=fract(52.9829189*fract(0.06711056*gl_FragCoord.x+0.00583715*gl_FragCoord.y));float compareValue=mix(1.0-ditherValue,ditherValue,step(0.0,u_dithered_discard_threshold));if (abs(u_dithered_discard_threshold) < compareValue) {discard;}}\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\n#ifdef FEATURE_CUTOUT\nfinalColor=apply_feature_cutout(finalColor,gl_FragCoord);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#ifdef CLIP_ZERO_TO_ONE\nv_depth=-1.0+2.0*v_depth; \n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'),
            modelDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),
            stars: ss("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"),
            snowParticle: ss("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"),
            rainParticle: ss("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"),
            vignette: ss("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"),
            occlusion: ss("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')
        };
        function os(e, t1) {
            const i = e.split("\n");
            for (let e of i){
                if (e = e.trimStart(), "#" !== e[0]) continue;
                if (!e.includes("if")) continue;
                if (e.startsWith("#endif")) continue;
                const i = e.match(Wo);
                if (i) for (const e of i)$o.has(e) || t1.add(e);
            }
        }
        function ss(e, t1) {
            const i = new Set, o = [], s = [];
            e = e.replace(qo, (e, t1)=>(s.push(t1), "")), t1 = t1.replace(qo, (e, t1)=>(o.push(t1), ""));
            let r = new Set(Xo);
            os(e, r), os(t1, r);
            for (const e of [
                ...o,
                ...s
            ])Ko[e] || (Ko[e] = new Set, os(Yo[e], Ko[e])), r = new Set([
                ...r,
                ...Ko[e]
            ]);
            return {
                fragmentSource: e = e.replace(Zo, (e, t1, o, s, r)=>(i.add(r), "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nin ${o} ${s} ${r};\n#else\nuniform ${o} ${s} u_${r};\n#endif\n` : "initialize" === t1 ? `\n#ifdef HAS_UNIFORM_u_${r}\n    ${o} ${s} ${r} = u_${r};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${o} ${s} ${r};\n#endif\n` : "initialize-attribute" === t1 ? "" : void 0)),
                vertexSource: t1 = t1.replace(Zo, (e, t1, o, s, r)=>{
                    const n = `MATERIAL_ATTRIBUTE_OFFSET_${r}`, a = "float" === s ? "vec2" : s, l = `GET_ATTRIBUTE_${a}(a_${r}, materialInfo, ${n})`, c = r.match(/color/) ? "color" : a;
                    return "define-attribute-vertex-shader-only" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\nin ${o} ${s} a_${r};\n#endif\n` : i.has(r) ? "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\n    #if !defined(${n})\n        in ${o} ${a} a_${r};\n    #endif\nout ${o} ${s} ${r};\n#else\nuniform ${o} ${s} u_${r};\n#endif\n` : "initialize" === t1 ? "vec4" === c ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = a_${r};\n#else\n    ${o} ${s} ${r} = u_${r};\n#endif\n` : `\n#if !defined(HAS_UNIFORM_u_${r})\n    #ifdef ${n}\n        ${r} = unpack_mix_${c}(${l}, u_${r}_t);\n    #else\n        ${r} = unpack_mix_${c}(a_${r}, u_${r}_t);\n    #endif\n#else\n    ${o} ${s} ${r} = u_${r};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${o} ${s} a_${r};\n    out ${o} ${s} ${r};\n#endif\n` : "initialize-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${r} = a_${r};\n#endif\n` : void 0 : "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\n    #if !defined(${n})\n        in ${o} ${a} a_${r};\n    #endif\n#else\nuniform ${o} ${s} u_${r};\n#endif\n` : "define-instanced" === t1 ? "mat4" === c ? `\n#ifdef INSTANCED_ARRAYS\nin vec4 a_${r}0;\nin vec4 a_${r}1;\nin vec4 a_${r}2;\nin vec4 a_${r}3;\n#else\nuniform ${o} ${s} u_${r};\n#endif\n` : `\n#ifdef INSTANCED_ARRAYS\nin ${o} ${a} a_${r};\n#else\nuniform ${o} ${s} u_${r};\n#endif\n` : "initialize-attribute-custom" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${o} ${s} ${r} = a_${r};\n#endif\n` : "vec4" === c ? `\n#ifndef HAS_UNIFORM_u_${r}\n    #ifdef ${n}\n        ${o} ${s} ${r} = ${l};\n    #else\n        ${o} ${s} ${r} = a_${r};\n    #endif\n#else\n    ${o} ${s} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    #ifdef ${n}\n        ${o} ${s} ${r} = unpack_mix_${c}(${l}, u_${r}_t);\n    #else\n        ${o} ${s} ${r} = unpack_mix_${c}(a_${r}, u_${r}_t);\n    #endif\n#else\n    ${o} ${s} ${r} = u_${r};\n#endif\n`;
                }),
                usedDefines: r,
                vertexIncludes: o,
                fragmentIncludes: s
            };
        }
        class rs {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e, t1, i, o, s, r, n, a) {
                this.context = e;
                let l = this.boundPaintVertexBuffers.length !== o.length;
                for(let e = 0; !l && e < o.length; e++)this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);
                let c = this.boundDynamicVertexBuffers.length !== n.length;
                for(let e = 0; !c && e < n.length; e++)this.boundDynamicVertexBuffers[e] !== n[e] && (c = !0);
                if (!this.vao || this.boundProgram !== t1 || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== s || this.boundVertexOffset !== r) this.freshBind(t1, i, o, s, r, n, a);
                else {
                    e.bindVertexArrayOES.set(this.vao);
                    for (const i of n)i && (i.bind(), a && i.instanceCount && i.setVertexAttribDivisor(e.gl, t1, a));
                    s && s.dynamicDraw && s.bind();
                }
            }
            freshBind(e, t1, i, o, s, r, n) {
                const a = this.context, l = a.gl;
                this.vao && this.destroy(), this.vao = a.gl.createVertexArray(), a.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = s, this.boundDynamicVertexBuffers = r, t1.enableAttributes(l, e), t1.bind(), t1.setVertexAttribPointers(l, e, s);
                for (const t1 of i)t1.enableAttributes(l, e), t1.bind(), t1.setVertexAttribPointers(l, e, s);
                for (const t1 of r)t1 && (t1.enableAttributes(l, e), t1.bind(), t1.setVertexAttribPointers(l, e, s), n && t1.instanceCount && t1.setVertexAttribDivisor(l, e, n));
                o && o.bind();
            }
            destroy() {
                this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
            }
        }
        function ns(t1, i) {
            const o = Math.pow(2, i.canonical.z), s = i.canonical.y;
            return [
                new e.ae(0, s / o).toLngLat().lat,
                new e.ae(0, (s + 1) / o).toLngLat().lat
            ];
        }
        function as(t1, i, o, s, r, n, a) {
            const l = t1.context, c = l.gl, h = o.hillshadeFBO;
            if (!h) return;
            t1.prepareDrawTile();
            const d = t1.isTileAffectedByFog(i), u = [];
            t1.terrain && t1.terrain.renderingToTexture && "mrt-fallback" === t1.emissiveMode && u.push("USE_MRT1");
            const _ = t1.getOrCreateProgram("hillshade", {
                overrideFog: d,
                defines: u
            });
            l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment0.get());
            const p = ((t1, i, o, s)=>{
                const r = o.paint.get("hillshade-shadow-color"), n = "none" === o.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), a = o.paint.get("hillshade-highlight-color"), l = "none" === o.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c = o.paint.get("hillshade-accent-color"), h = "none" === o.paint.get("hillshade-accent-color-use-theme").constantOr("default"), d = o.paint.get("hillshade-emissive-strength");
                let u = e.an(o.paint.get("hillshade-illumination-direction"));
                if ("viewport" === o.paint.get("hillshade-illumination-anchor")) u -= t1.transform.angle;
                else if (t1.style && t1.style.enable3dLights() && t1.style.directionalLight) {
                    const i = t1.style.directionalLight.properties.get("direction"), o = e.d4(i.x, i.y, i.z);
                    u = e.an(o[1]);
                }
                const _ = !t1.options.moving;
                return {
                    u_matrix: s || t1.transform.calculateProjMatrix(i.tileID.toUnwrapped(), _),
                    u_image: 0,
                    u_latrange: ns(0, i.tileID),
                    u_light: [
                        o.paint.get("hillshade-exaggeration"),
                        u
                    ],
                    u_shadow: r.toPremultipliedRenderColor(n ? null : o.lut),
                    u_highlight: a.toPremultipliedRenderColor(l ? null : o.lut),
                    u_emissive_strength: d,
                    u_accent: c.toPremultipliedRenderColor(h ? null : o.lut)
                };
            })(t1, o, s, t1.terrain ? i.projMatrix : null);
            t1.uploadCommonUniforms(l, _, i.toUnwrapped());
            const { tileBoundsBuffer: f, tileBoundsIndexBuffer: m, tileBoundsSegments: g } = t1.getTileBoundsBuffers(o);
            _.draw(t1, c.TRIANGLES, r, n, a, Qi.disabled, p, s.id, f, m, g);
        }
        function ls(t1, i, o) {
            if (!i.needsDEMTextureUpload) return;
            const s = t1.context, r = s.gl;
            s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t1.getTileTexture(o.stride);
            const n = o.getPixels();
            i.demTexture ? i.demTexture.update(n, {
                premultiply: !1
            }) : i.demTexture = new e.T(s, n, r.R32F, {
                premultiply: !1
            }), i.needsDEMTextureUpload = !1;
        }
        function cs(t1, i, o) {
            const s = t1.context, r = s.gl;
            if (!i.dem) return;
            const n = i.dem;
            if (s.activeTexture.set(r.TEXTURE1), ls(t1, i, n), !i.demTexture) return;
            i.demTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE);
            const a = n.dim;
            s.activeTexture.set(r.TEXTURE0);
            let l = i.hillshadeFBO;
            if (!l) {
                const t1 = new e.T(s, {
                    width: a,
                    height: a,
                    data: null
                }, r.RGBA8);
                t1.bind(r.LINEAR, r.CLAMP_TO_EDGE), l = i.hillshadeFBO = s.createFramebuffer(a, a, 1, "renderbuffer"), l.colorAttachment0.set(t1.texture);
            }
            s.bindFramebuffer.set(l.framebuffer), s.viewport.set([
                0,
                0,
                a,
                a
            ]);
            const { tileBoundsBuffer: c, tileBoundsIndexBuffer: h, tileBoundsSegments: d } = t1.getMercatorTileBoundsBuffers(), u = [];
            t1.linearFloatFilteringSupported() && u.push("TERRAIN_DEM_FLOAT_FORMAT"), t1.terrain && t1.terrain.renderingToTexture && "mrt-fallback" === t1.emissiveMode && u.push("USE_MRT1"), t1.getOrCreateProgram("hillshadePrepare", {
                defines: u
            }).draw(t1, r.TRIANGLES, $i.disabled, Yi.disabled, Wi.unblended, Qi.disabled, ((t1, i)=>{
                const o = i.stride, s = e.bC();
                return e.ce(s, 0, e.al, -e.al, 0, 0, 1), e.br(s, s, [
                    0,
                    -e.al,
                    0
                ]), {
                    u_matrix: s,
                    u_image: 1,
                    u_dimension: [
                        o,
                        o
                    ],
                    u_zoom: t1.overscaledZ
                };
            })(i.tileID, n), o.id, c, h, d), i.needsHillshadePrepare = !1;
        }
        class hs {
            constructor(e){
                this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class ds extends hs {
            getDefault() {
                return e.ao.transparent.toNonPremultipliedRenderColor(null);
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class us extends hs {
            getDefault() {
                return 1;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
            }
        }
        class _s extends hs {
            getDefault() {
                return 0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
            }
        }
        class ps extends hs {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class fs extends hs {
            getDefault() {
                return !0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
            }
        }
        class ms extends hs {
            getDefault() {
                return 255;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
            }
        }
        class gs extends hs {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e) {
                const t1 = this.current;
                (e.func !== t1.func || e.ref !== t1.ref || e.mask !== t1.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
            }
        }
        class vs extends hs {
            getDefault() {
                const e = this.gl;
                return [
                    e.KEEP,
                    e.KEEP,
                    e.KEEP
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
            }
        }
        class ys extends hs {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.STENCIL_TEST) : t1.disable(t1.STENCIL_TEST), this.current = e, this.dirty = !1;
            }
        }
        class xs extends hs {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }
        class bs extends hs {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.DEPTH_TEST) : t1.disable(t1.DEPTH_TEST), this.current = e, this.dirty = !1;
            }
        }
        class ws extends hs {
            getDefault() {
                return this.gl.LESS;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
            }
        }
        class Ts extends hs {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.BLEND) : t1.disable(t1.BLEND), this.current = e, this.dirty = !1;
            }
        }
        class Es extends hs {
            getDefault() {
                const e = this.gl;
                return [
                    e.ONE,
                    e.ZERO,
                    e.ONE,
                    e.ZERO
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class Ss extends hs {
            getDefault() {
                return e.ao.transparent.toNonPremultipliedRenderColor(null);
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class Is extends hs {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);
            }
        }
        class Cs extends hs {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.CULL_FACE) : t1.disable(t1.CULL_FACE), this.current = e, this.dirty = !1;
            }
        }
        class Rs extends hs {
            getDefault() {
                return this.gl.BACK;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
            }
        }
        class As extends hs {
            getDefault() {
                return this.gl.CCW;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
            }
        }
        let Ls = class extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
            }
        };
        class Ds extends hs {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
            }
        }
        class Ps extends hs {
            getDefault() {
                const e = this.gl;
                return [
                    0,
                    0,
                    e.drawingBufferWidth,
                    e.drawingBufferHeight
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class Os extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindFramebuffer(t1.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class zs extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindRenderbuffer(t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Ms extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindTexture(t1.TEXTURE_2D, e), this.current = e, this.dirty = !1;
            }
        }
        class Fs extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindBuffer(t1.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Bs extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                const t1 = this.gl;
                t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class ks extends hs {
            getDefault() {
                return null;
            }
            set(e) {
                this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);
            }
        }
        class Ns extends hs {
            getDefault() {
                return 4;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
            }
        }
        class Us extends hs {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class js extends hs {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class Vs extends hs {
            constructor(e, t1){
                super(e), this.context = e, this.parent = t1;
            }
            getDefault() {
                return null;
            }
        }
        class Gs extends Vs {
            constructor(e, t1, i = 0){
                super(e, t1), this.attachmentPoint = e.gl.COLOR_ATTACHMENT0 + i;
            }
            setDirty() {
                this.dirty = !0;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, this.attachmentPoint, t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class Hs extends Vs {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferRenderbuffer(t1.FRAMEBUFFER, this.attachment(), t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class qs extends Vs {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, this.attachment(), t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class Zs extends Hs {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        const Ws = (e, t1, i, o)=>({
                u_matrix: e,
                u_image0: 0,
                u_image1: 1,
                u_skirt_height: t1,
                u_ground_shadow_factor: i,
                u_emissive_texture_available: o
            }), $s = (e, t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m)=>({
                u_proj_matrix: Float32Array.from(e),
                u_globe_matrix: t1,
                u_normalize_matrix: Float32Array.from(o),
                u_merc_matrix: i,
                u_zoom_transition: s,
                u_merc_center: r,
                u_image0: 0,
                u_image1: 1,
                u_frustum_tl: n,
                u_frustum_tr: a,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: d,
                u_viewport: u,
                u_grid_matrix: m ? Float32Array.from(m) : new Float32Array(9),
                u_skirt_height: _,
                u_far_z_cutoff: p,
                u_emissive_texture_available: f
            });
        function Xs(e, t1) {
            return null != e && null != t1 && !(!e.hasData() || !t1.hasData()) && null != e.demTexture && null != t1.demTexture && e.tileID.key !== t1.tileID.key;
        }
        const Ys = new class {
            constructor(){
                this.operations = {};
            }
            newMorphing(e, t1, i, o, s) {
                if (e in this.operations) {
                    const t1 = this.operations[e];
                    t1.to.tileID.key !== i.tileID.key && (t1.queued = i);
                } else this.operations[e] = {
                    startTime: o,
                    phase: 0,
                    duration: s,
                    from: t1,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e) {
                if (!(e in this.operations)) return null;
                const t1 = this.operations[e];
                return {
                    from: t1.from,
                    to: t1.to,
                    phase: t1.phase
                };
            }
            update(e) {
                for(const t1 in this.operations){
                    const i = this.operations[t1];
                    for(i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);)if (!this._nextOp(i, e)) {
                        delete this.operations[t1];
                        break;
                    }
                }
            }
            _nextOp(e, t1) {
                return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t1, !0);
            }
            _validOp(e) {
                return e.from.hasData() && e.to.hasData();
            }
        }, Ks = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING"
        };
        function Js(e, t1, i) {
            if (0 === t1) return 0;
            const o = t1 < 1 && 514 === i ? .25 / t1 : 1;
            return 6 * Math.pow(1.5, 22 - e) * Math.max(t1, 1) * o;
        }
        function Qs(e, t1) {
            const i = 1 << e.z;
            return !t1 && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
        }
        function er(e, t1) {
            if (!e.style || !e.style.enable3dLights()) return;
            const i = e.context, o = i.gl;
            i.activeTexture.set(o.TEXTURE1), t1 ? t1.bind(o.LINEAR, o.CLAMP_TO_EDGE) : e.emptyTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
        }
        const tr = (e)=>({
                u_matrix: e
            });
        function ir(t1, i, o, s, r) {
            if (r > 0) {
                const n = e.o.now(), a = (n - t1.timeAdded) / r, l = i ? (n - i.timeAdded) / r : -1, c = o.getSource(), h = s.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), d = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t1.tileID.overscaledZ - h), u = d && t1.refreshedUponExpiration ? 1 : e.aA(d ? a : 1 - l, 0, 1);
                return i ? {
                    opacity: 1,
                    mix: 1 - u,
                    isFading: a < 1
                } : {
                    opacity: u,
                    mix: 0,
                    isFading: a < 1
                };
            }
            return {
                opacity: 1,
                mix: 0,
                isFading: !1
            };
        }
        class or extends Ft {
            constructor(e){
                const t1 = mt("mock-dem", {
                    type: "raster-dem",
                    maxzoom: e.transform.maxZoom
                }, e.style.dispatcher, e.style);
                super("mock-dem", t1, !1), t1.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e, t1) {
                e.state = "loaded", t1(null);
            }
        }
        class sr extends Ft {
            constructor(e){
                const t1 = mt("proxy", {
                    type: "geojson",
                    maxzoom: e.transform.maxZoom
                }, e.style.dispatcher, e.style);
                super("proxy", t1, !1), t1.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(e, t1, i) {
                if (e.freezeTileCoverage) return;
                this.transform = e;
                const o = e.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((t1, i)=>{
                    if (t1[i.key] = "", !this._tiles[i.key]) {
                        const t1 = new Pt(i, this._source.tileSize * i.overscaleFactor(), e.tileZoom, void 0, void 0, this._source.worldview);
                        t1.state = "loaded", this._tiles[i.key] = t1;
                    }
                    return t1;
                }, {});
                for(const e in this._tiles)e in o || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
            }
            freeFBO(e) {
                const t1 = this.proxyCachedFBO[e];
                if (void 0 !== t1) {
                    const i = Object.values(t1);
                    this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e)=>e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }
        class rr extends e.aQ {
            constructor(e, t1, i){
                super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t1, this.projMatrix = i;
            }
        }
        class nr extends e.bV {
            constructor(t1, i){
                super(), this._debugParams = {
                    sortTilesHiZFirst: !0,
                    disableRenderCache: !1
                }, this.painter = t1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                const [o, s, r] = function() {
                    const t1 = new e.bd, i = new e.b0, o = 131;
                    t1.reserve(17161), i.reserve(33800);
                    const s = e.al / 128, r = e.al + s / 2, n = r + s;
                    for(let i = -s; i < n; i += s)for(let o = -s; o < n; o += s){
                        const s = o < 0 || o > r || i < 0 || i > r ? 24575 : 0, n = e.aA(Math.round(o), 0, e.al), a = e.aA(Math.round(i), 0, e.al);
                        t1.emplaceBack(n + s, a);
                    }
                    const a = (e, t1)=>{
                        const s = t1 * o + e;
                        i.emplaceBack(s + 1, s, s + o), i.emplaceBack(s + o, s + o + 1, s + 1);
                    };
                    for(let e = 1; e < 129; e++)for(let t1 = 1; t1 < 129; t1++)a(t1, e);
                    return [
                        0,
                        129
                    ].forEach((e)=>{
                        for(let t1 = 0; t1 < 130; t1++)a(t1, e), a(e, t1);
                    }), [
                        t1,
                        i,
                        32768
                    ];
                }(), n = t1.context;
                this.gridBuffer = n.createVertexBuffer(o, e.bf.members), this.gridIndexBuffer = n.createIndexBuffer(s), this.gridSegments = e.bg.simpleSegment(0, 0, o.length, s.length), this.gridNoSkirtSegments = e.bg.simpleSegment(0, 0, o.length, r), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new sr(i.map), this.orthoMatrix = e.bC(), e.ce(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.al, 0, e.al, 0, 1);
                const a = n.gl;
                this._overlapStencilMode = new Yi({
                    func: a.GEQUAL,
                    mask: 255
                }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new or(i.map), this._pendingGroundEffectLayers = [], this._emissiveTexture = !1;
            }
            set style(e) {
                e.on("data", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on("moveend", ()=>{
                    this._clearLineLayersFromRenderCache();
                });
            }
            update(t1, i, o) {
                if (t1 && t1.terrain) {
                    this._style !== t1 && (this.style = t1, this._evaluationZoom = void 0);
                    const s = t1.terrain.properties, r = 0 === t1.terrain.drapeRenderMode, n = t1.terrain.isZoomDependent();
                    this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.o.now();
                    const a = t1.terrain && t1.terrain.scope, l = s.get("source"), c = r ? this._mockSourceCache : t1.getSourceCache(l, a);
                    if (!c) return void e.w(`Couldn't find terrain source "${l}".`);
                    if (this.sourceCache = c, this._attenuationRange = t1.terrain.getAttenuationRange(), this._exaggeration = n ? this.calculateExaggeration(i) : s.get("exaggeration"), !i.projection.requiresDraping && n && 0 === this._exaggeration) return void this._disable();
                    this.enabled = !0;
                    const h = ()=>{
                        this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t1 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t1, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;
                } else this._disable();
            }
            calculateExaggeration(t1) {
                if (this._attenuationRange && t1.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t1.zoom);
                const i = this._previousCameraAltitude, o = t1.getFreeCameraOptions().position.z / t1.pixelsPerMeter * t1.worldSize;
                this._previousCameraAltitude = o;
                const s = null != i ? o - i : Number.MAX_VALUE;
                if (Math.abs(s) < 2) return this._exaggeration;
                const r = t1.zoom, n = this._style.terrain;
                if (!this._previousUpdateTimestamp) return n.getExaggeration(r);
                let a = r - this._previousZoom;
                const l = this._previousUpdateTimestamp;
                let c = r;
                null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(r - c) > .5 && (a = .5 * (r - c + a)), a * s < 0 && (c += a)), this._evaluationZoom = c;
                const h = n.getExaggeration(c), d = h === n.getExaggeration(Math.max(0, c - .1));
                if (d && Math.abs(h - this._exaggeration) < .01) return h;
                let u = Math.min(.1, .00375 * (this._updateTimestamp - l));
                return (d || h < .1 || Math.abs(a) < 1e-4) && (u = Math.min(.2, 4 * u)), e.ak(this._exaggeration, h, u);
            }
            resetTileLookupCache(e) {
                this._findCoveringTileCache[e] = {};
            }
            attenuationRange() {
                return this._attenuationRange;
            }
            getDemUpscale() {
                return this.proxySourceCache.getSource().tileSize / 128;
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _onStyleDataEvent(e) {
                "source" === e.dataType && e.coord ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e in this._style._mergedSourceCaches)this._style._mergedSourceCaches[e].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e)=>e.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this.enabled ? this._exaggeration : 0;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e,
                    e
                ];
            }
            set useVertexMorphing(e) {
                this._useVertexMorphing = e;
            }
            updateTileBinding(t1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache, o = this.painter.transform;
                this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.ae.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const s = this.proxyCoords = i.getIds().map((e)=>{
                    const t1 = i.getTileByID(e).tileID;
                    return t1.projMatrix = o.calculateProjMatrix(t1.toUnwrapped()), t1;
                });
                !function(t1, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()), s = new e.P(o.x, o.y);
                    t1.sort((t1, i)=>{
                        if (i.overscaledZ - t1.overscaledZ) return i.overscaledZ - t1.overscaledZ;
                        const o = new e.P(t1.canonical.x + (1 << t1.canonical.z) * t1.wrap, t1.canonical.y), r = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y), n = s.mult(1 << t1.canonical.z);
                        return n.x -= .5, n.y -= .5, n.distSqr(o) - n.distSqr(r);
                    });
                }(s, this.painter);
                const r = this.proxyToSource || {};
                this.proxyToSource = {}, s.forEach((e)=>{
                    this.proxyToSource[e.key] = {};
                }), this.terrainTileForTile = {};
                const n = this._style._mergedSourceCaches;
                for(const e in n){
                    const i = n[e];
                    if (!i.used) continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t1[e], r), i.usedForTerrain) continue;
                    const o = t1[e];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }
                this.proxiedCoords[i.id] = s.map((e)=>new rr(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(s), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r), this.renderingToTexture = !1;
                const a = {};
                this._visibleDemTiles = [];
                for (const e of this.proxyCoords){
                    const t1 = this.terrainTileForTile[e.key];
                    if (!t1) continue;
                    const i = t1.tileID.key;
                    i in a || (this._visibleDemTiles.push(t1), a[i] = i);
                }
            }
            _assignTerrainTiles(e) {
                this._initializing || e.forEach((e)=>{
                    if (this.terrainTileForTile[e.key]) return;
                    const t1 = this._findTileCoveringTileID(e, this.sourceCache);
                    t1 && (this.terrainTileForTile[e.key] = t1);
                });
            }
            _prepareDEMTextures() {
                const e = this.painter.context, t1 = e.gl;
                for(const i in this.terrainTileForTile){
                    const o = this.terrainTileForTile[i], s = o.dem;
                    !s || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t1.TEXTURE1), ls(this.painter, o, s));
                }
            }
            _prepareDemTileUniforms(e, t1, i, o) {
                if (!t1 || null == t1.demTexture) return !1;
                const s = e.tileID.canonical, r = Math.pow(2, t1.tileID.canonical.z - s.z), n = o || "";
                return i[`u_dem_tl${n}`] = [
                    s.x * r % 1,
                    s.y * r % 1
                ], i[`u_dem_scale${n}`] = r, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            _getLoadedAreaMinimum() {
                if (!this.enabled) return 0;
                let e = 0;
                const t1 = this._visibleDemTiles.reduce((t1, i)=>{
                    if (!i.dem) return t1;
                    const o = i.dem.tree.minimums[0];
                    return o > 0 && e++, t1 + o;
                }, 0);
                return e ? t1 / e : 0;
            }
            _updateEmptyDEMTexture() {
                const t1 = this.painter.context, i = t1.gl;
                t1.activeTexture.set(i.TEXTURE2);
                const o = this._getLoadedAreaMinimum(), s = new e.dL({
                    width: 1,
                    height: 1
                }, new Float32Array([
                    o
                ]));
                this._emptyDEMTextureDirty = !1;
                let r = this._emptyDEMTexture;
                return r ? r.update(s, {
                    premultiply: !1
                }) : r = this._emptyDEMTexture = new e.T(t1, s, i.R32F, {
                    premultiply: !1
                }), r;
            }
            setupElevationDraw(t1, i, o) {
                const s = this.painter.context, r = s.gl, n = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        0,
                        1
                    ],
                    u_occluder_half_size: 16,
                    u_occlusion_depth_offset: -1e-4,
                    u_exaggeration: 0
                };
                n.u_exaggeration = this.exaggeration();
                let a = null, l = null, c = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e = o.morphing.srcDemTile, i = o.morphing.dstDemTile;
                    c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t1, e, n, "_prev") && (l = e), this._prepareDemTileUniforms(t1, i, n) && (a = i));
                }
                const h = (e)=>e && e.demTexture && this.painter.linearFloatFilteringSupported() ? r.LINEAR : r.NEAREST;
                let d = null;
                var u;
                if (this.enabled ? l && a ? (d = a.demTexture, s.activeTexture.set(r.TEXTURE4), l.demTexture.bind(h(l), r.CLAMP_TO_EDGE), n.u_dem_lerp = c) : (a = this.terrainTileForTile[t1.tileID.key], d = this._prepareDemTileUniforms(t1, a, n) ? a.demTexture : this.emptyDEMTexture) : d = this.emptyDEMTexture, s.activeTexture.set(r.TEXTURE2), d && (n.u_dem_size = 1 === (u = d).size[0] ? 1 : u.size[0] - 2, d.bind(h(a), r.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o && o.useDepthForOcclusion, i, n), o && o.useMeterToDem && a) {
                    const t1 = (1 << a.tileID.canonical.z) * e.cf(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    n.u_meter_to_dem = t1;
                }
                if (o && o.labelPlaneMatrixInv && (n.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(s, n), "globe" === this.painter.transform.projection.name) {
                    const e = this.globeUniformValues(this.painter.transform, t1.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(s, e);
                }
            }
            globeUniformValues(t1, i, o) {
                const s = t1.projection;
                return {
                    u_tile_tl_up: s.upVector(i, 0, 0),
                    u_tile_tr_up: s.upVector(i, e.al, 0),
                    u_tile_br_up: s.upVector(i, e.al, e.al),
                    u_tile_bl_up: s.upVector(i, 0, e.al),
                    u_tile_up_scale: o ? e.dM(1) : s.upVectorScale(i, t1.center.lat, t1.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t1) {
                const i = this.painter, o = this.painter.context;
                0 !== t1.length && (o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t1, i, o, s, r) {
                    if ("globe" === t1.transform.projection.name) !function(t1, i, o, s, r) {
                        const n = t1.context, a = n.gl;
                        let l, c;
                        const h = t1.transform, d = e.dE(t1, n, h), u = (e, i)=>{
                            if (c === i) return;
                            const o = [
                                Ks[i],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            d && o.push("CUSTOM_ANTIALIASING");
                            const s = t1.isTileAffectedByFog(e);
                            l = t1.getOrCreateProgram("globeRaster", {
                                defines: o,
                                overrideFog: s
                            }), c = i;
                        }, _ = t1.colorModeForRenderPass(), p = new $i(a.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D);
                        Ys.update(r);
                        const f = e.dF(h), m = [
                            e.aF(h.center.lng),
                            e.aJ(h.center.lat)
                        ], g = t1.globeSharedBuffers, v = [
                            h.width * e.o.devicePixelRatio,
                            h.height * e.o.devicePixelRatio
                        ], y = Float32Array.from(h.globeMatrix), x = {
                            useDenormalizedUpVectorScale: !0
                        };
                        {
                            const h = t1.transform, d = Js(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                            c = -1;
                            const b = a.TRIANGLES;
                            for (const c of s){
                                const s = o.getTile(c), w = Yi.disabled, T = i.prevTerrainTileForTile[c.key], E = i.terrainTileForTile[c.key];
                                Xs(T, E) && Ys.newMorphing(c.key, T, E, r, 250), er(t1, s.emissiveTexture), n.activeTexture.set(a.TEXTURE0), s.texture && s.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                const S = Ys.getMorphValuesForProxy(c.key), I = S ? 1 : 0;
                                S && Object.assign(x, {
                                    morphing: {
                                        srcDemTile: S.from,
                                        dstDemTile: S.to,
                                        phase: e.dD(S.phase)
                                    }
                                });
                                const C = e.dG(c.canonical), R = e.dH(C.getCenter().lat), A = e.dI(c.canonical, C, R, h.worldSize / h._pixelsPerMercatorPixel), L = e.bk(e.dJ(c.canonical)), D = "mrt-fallback" === t1.emissiveMode ? 1 : 0, P = $s(h.expandedFarZProjMatrix, y, f, L, e.aj(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, d, h._farZ, D, A);
                                if (u(c, I), l && (i.setupElevationDraw(s, l, x), t1.uploadCommonUniforms(n, l, c.toUnwrapped()), g)) {
                                    const [e, i, o] = g.getGridBuffers(R, 0 !== d);
                                    l.draw(t1, b, p, w, _, Qi.backCCW, P, "globe_raster", e, i, o);
                                }
                            }
                        }
                        if (g && (t1.renderDefaultNorthPole || t1.renderDefaultSouthPole)) {
                            const r = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            d && r.push("CUSTOM_ANTIALIASING"), l = t1.getOrCreateProgram("globeRaster", {
                                defines: r
                            });
                            for (const r of s){
                                const { x: s, y: c, z: d } = r.canonical, u = 0 === c, f = c === (1 << d) - 1, [y, b, w, T] = g.getPoleBuffers(d, !1);
                                if (T && (u || f)) {
                                    const c = o.getTile(r);
                                    er(t1, c.emissiveTexture), n.activeTexture.set(a.TEXTURE0), c.texture && c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                    let g = e.dK(d, s, h);
                                    const E = e.bk(e.dJ(r.canonical)), S = "mrt-fallback" === t1.emissiveMode ? 1 : 0, I = (e, i)=>e.draw(t1, a.TRIANGLES, p, Yi.disabled, _, Qi.disabled, $s(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ, S), "globe_pole_raster", i, w, T);
                                    i.setupElevationDraw(c, l, x), t1.uploadCommonUniforms(n, l, r.toUnwrapped()), u && t1.renderDefaultNorthPole && I(l, y), f && t1.renderDefaultSouthPole && (g = e.cS(e.bC(), g, [
                                        1,
                                        -1,
                                        1
                                    ]), I(l, b));
                                }
                            }
                        }
                    }(t1, i, o, s, r);
                    else {
                        const n = t1.context, a = n.gl;
                        let l, c;
                        const h = t1.shadowRenderer, d = co(t1, t1.longestCutoffRange), u = (e)=>{
                            if (c === e) return;
                            const i = [];
                            i.push(Ks[e]), d.shouldRenderCutoff && i.push("RENDER_CUTOFF"), h && (i.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h.useNormalOffset && i.push("NORMAL_OFFSET")), l = t1.getOrCreateProgram("terrainRaster", {
                                defines: i
                            }), c = e;
                        }, _ = t1.colorModeForRenderPass(), p = new $i(a.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D);
                        Ys.update(r);
                        const f = t1.transform, m = Js(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                        let g = [
                            0,
                            0,
                            0
                        ];
                        if (h) {
                            const e = t1.style.directionalLight, i = t1.style.ambientLight;
                            e && i && (g = go(t1.style, e, i));
                        }
                        {
                            c = -1;
                            const v = a.TRIANGLES, [y, x] = [
                                i.gridIndexBuffer,
                                i.gridSegments
                            ];
                            for (const c of s){
                                const s = o.getTile(c), b = Yi.disabled, w = i.prevTerrainTileForTile[c.key], T = i.terrainTileForTile[c.key];
                                Xs(w, T) && Ys.newMorphing(c.key, w, T, r, 250), er(t1, s.emissiveTexture), n.activeTexture.set(a.TEXTURE0), s.texture && s.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                const E = Ys.getMorphValuesForProxy(c.key), S = E ? 1 : 0;
                                let I;
                                E && (I = {
                                    morphing: {
                                        srcDemTile: E.from,
                                        dstDemTile: E.to,
                                        phase: e.dD(E.phase)
                                    }
                                });
                                const C = "mrt-fallback" === t1.emissiveMode ? 1 : 0, R = Ws(c.projMatrix, Qs(c.canonical, f.renderWorldCopies) ? m / 10 : m, g, C);
                                if (u(S), !l) continue;
                                i.setupElevationDraw(s, l, I);
                                const A = c.toUnwrapped();
                                h && h.setupShadows(A, l), t1.uploadCommonUniforms(n, l, A, null, d), l.draw(t1, v, p, b, _, Qi.backCCW, R, "terrain_raster", i.gridBuffer, y, x);
                            }
                        }
                    }
                }(i, this, this.proxySourceCache, t1, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t1.splice(0, t1.length));
            }
            renderBatch(t1) {
                if (0 === this._drapedRenderBatches.length) return t1 + 1;
                this.renderingToTexture = !0;
                const i = this.painter, o = this.painter.context, s = this.proxySourceCache, r = this.proxiedCoords[s.id], n = this._drapedRenderBatches.shift(), a = i.style.order, l = [];
                this._updateFBOs("mrt-fallback" === i.emissiveMode);
                let c = 0;
                for (const h of r){
                    const r = s.getTileByID(h.proxyTileKey), d = s.proxyCachedFBO[h.key] ? s.proxyCachedFBO[h.key][t1] : void 0, u = void 0 !== d ? s.renderCache[d] : this.pool[c++], _ = void 0 !== d;
                    if (r.texture = u.tex, r.emissiveTexture = u.emissiveTex, _ && !u.dirty) {
                        l.push(r.tileID);
                        continue;
                    }
                    o.bindFramebuffer.set(u.fb.framebuffer);
                    const p = o.gl;
                    let f;
                    p.drawBuffers("mrt-fallback" === i.emissiveMode ? [
                        p.COLOR_ATTACHMENT0,
                        p.COLOR_ATTACHMENT1
                    ] : [
                        p.COLOR_ATTACHMENT0
                    ]), this.renderedToTile = !1, u.dirty && (o.clear({
                        color: e.ao.transparent,
                        stencil: 0
                    }), u.dirty = !1);
                    for(let e = n.start; e <= n.end; ++e){
                        const t1 = i.style._mergedLayers[a[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const s = i.style.getLayerSourceCache(t1), r = s ? this.proxyToSource[h.key][s.id] : [
                            h
                        ];
                        if (!r) continue;
                        const n = r;
                        o.viewport.set([
                            0,
                            0,
                            u.fb.width,
                            u.fb.height
                        ]), f !== (s ? s.id : null) && (this._setupStencil(u, r, t1, s), f = s ? s.id : null), i.renderLayer(i, s, t1, n);
                    }
                    if (p.drawBuffers([
                        p.COLOR_ATTACHMENT0
                    ]), 0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers){
                        const t1 = i.style._mergedLayers[a[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const s = i.style.getLayerSourceCache(t1), r = s ? this.proxyToSource[h.key][s.id] : [
                            h
                        ];
                        if (!r) continue;
                        const n = r;
                        o.viewport.set([
                            0,
                            0,
                            u.fb.width,
                            u.fb.height
                        ]), f !== (s ? s.id : null) && (this._setupStencil(u, r, t1, s), f = s ? s.id : null), i.renderLayer(i, s, t1, n);
                    }
                    this.renderedToTile ? (u.dirty = !0, l.push(r.tileID)) : _ || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));
                }
                return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), n.end + 1;
            }
            postRender() {}
            isLayerOrderingCorrect(e) {
                const t1 = e.order.length;
                let i = -1, o = t1;
                for(let s = 0; s < t1; ++s)this._style.isLayerDraped(e._mergedLayers[e.order[s]]) ? i = Math.max(i, s) : o = Math.min(o, s);
                return o > i;
            }
            getMinElevationBelowMSL() {
                let e = 0;
                return this._visibleDemTiles.filter((e)=>e.dem).forEach((t1)=>{
                    e = Math.min(e, t1.dem.tree.minimums[0]);
                }), 0 === e ? e : (e - 30) * this._exaggeration;
            }
            raycast(e, t1, i) {
                if (!this._visibleDemTiles) return null;
                const o = this._visibleDemTiles.filter((e)=>e.dem).map((o)=>{
                    const s = o.tileID, r = 1 << s.overscaledZ, { x: n, y: a } = s.canonical, l = n / r, c = (n + 1) / r, h = a / r, d = (a + 1) / r;
                    return {
                        minx: l,
                        miny: h,
                        maxx: c,
                        maxy: d,
                        t: o.dem.tree.raycastRoot(l, h, c, d, e, t1, i),
                        tile: o
                    };
                });
                o.sort((e, t1)=>(null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t1.t ? t1.t : Number.MAX_VALUE));
                for (const s of o){
                    if (null == s.t) return null;
                    const o = s.tile.dem.tree.raycast(s.minx, s.miny, s.maxx, s.maxy, e, t1, i);
                    if (null != o) return o;
                }
                return null;
            }
            _createFBO() {
                const t1 = this.painter.context, i = t1.gl, o = this.drapeBufferSize;
                t1.activeTexture.set(i.TEXTURE0);
                const s = new e.T(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.RGBA8);
                s.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const r = t1.createFramebuffer(o[0], o[1], 1, null);
                let n;
                return r.colorAttachment0.set(s.texture), this._emissiveTexture && (n = new e.T(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.R8), n.bind(i.LINEAR, i.CLAMP_TO_EDGE), r.createColorAttachment(t1, 1), r.colorAttachment1.set(n.texture)), r.depthAttachment = new Zs(t1, r.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t1.createRenderbuffer(t1.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, r.depthAttachment.set(this._sharedDepthStencil), t1.clear({
                    stencil: 0
                })) : r.depthAttachment.set(this._sharedDepthStencil), t1.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t1.extTextureFilterAnisotropicMax), {
                    fb: r,
                    tex: s,
                    emissiveTex: n,
                    dirty: !1
                };
            }
            _updateFBOs(e) {
                if (this._emissiveTexture !== e) {
                    for (const t1 of this.pool)this._updateFBO(t1, e);
                    for (const t1 of this.proxySourceCache.renderCache)this._updateFBO(t1, e);
                    this._emissiveTexture = e;
                }
            }
            _updateFBO(t1, i) {
                const o = t1.fb, s = this.painter.context, r = s.gl, n = this.drapeBufferSize;
                if (i) {
                    const i = new e.T(s, {
                        width: n[0],
                        height: n[1],
                        data: null
                    }, r.R8);
                    i.bind(r.LINEAR, r.CLAMP_TO_EDGE), t1.emissiveTex = i, o.createColorAttachment(s, 1), o.colorAttachment1.set(i.texture);
                } else t1.emissiveTex = void 0, o.removeColorAttachment(s, 1);
                t1.dirty = !0;
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._debugParams.disableRenderCache) return !0;
                if (this._style.hasLightTransitions()) return !0;
                for(const e in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[e].hasTransition()) return !0;
                return this._style.order.some((e)=>{
                    const t1 = this._style._mergedLayers[e], i = t1.isHidden(this.painter.transform.zoom);
                    return "hillshade" === t1.type || "custom" === t1.type ? !i && t1.shouldRedrape() : !i && t1.hasTransition();
                });
            }
            _clearLineLayersFromRenderCache() {
                let t1 = !1;
                for (const e of this._style.getSources())if (e instanceof dt) {
                    t1 = !0;
                    break;
                }
                if (!t1) return;
                const i = {};
                for(let t1 = 0; t1 < this._style.order.length; ++t1){
                    const o = this._style._mergedLayers[this._style.order[t1]], s = this._style.getLayerSourceCache(o);
                    if (!s || i[s.id]) continue;
                    if (o.isHidden(this.painter.transform.zoom) || "line" !== o.type) continue;
                    const r = o.widthExpression(), n = o.emissiveStrengthExpression();
                    if (r instanceof e.ad || n instanceof e.ad) {
                        i[s.id] = !0;
                        for (const e of this.proxyCoords){
                            const t1 = this.proxyToSource[e.key][s.id];
                            if (t1) for (const e of t1)this._clearRenderCacheForTile(s.id, e);
                        }
                    }
                }
            }
            _clearRasterLayersFromRenderCache() {
                let e = !1;
                for(const t1 in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[t1]._source instanceof ut) {
                    e = !0;
                    break;
                }
                if (!e) return;
                const t1 = {};
                for(let e = 0; e < this._style.order.length; ++e){
                    const i = this._style._mergedLayers[this._style.order[e]], o = this._style.getLayerSourceCache(i);
                    if (!o || t1[o.id]) continue;
                    if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
                    const s = i.paint.get("raster-fade-duration");
                    for (const e of this.proxyCoords){
                        const t1 = this.proxyToSource[e.key][o.id];
                        if (t1) for (const e of t1){
                            const t1 = ir(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, s);
                            (1 !== t1.opacity || 0 !== t1.mix) && this._clearRenderCacheForTile(o.id, e);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                this._style.updateDrapeFirstLayers();
                const t1 = this._style.order, i = t1.length;
                if (0 === i) return;
                const o = [];
                this._pendingGroundEffectLayers = [];
                let s, r = 0, n = this._style._mergedLayers[t1[r]];
                for(; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < i;)n = this._style._mergedLayers[t1[r]];
                for(; r < i; ++r){
                    const e = this._style._mergedLayers[t1[r]];
                    e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === s && (s = r) : ("fill-extrusion" === e.type && this._pendingGroundEffectLayers.push(r), void 0 !== s && (o.push({
                        start: s,
                        end: r - 1
                    }), s = void 0)));
                }
                if (void 0 !== s && o.push({
                    start: s,
                    end: r - 1
                }), 0 !== o.length) {
                    const t1 = o[o.length - 1];
                    this._pendingGroundEffectLayers.every((e)=>e > t1.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
                }
                this._drapedRenderBatches = o;
            }
            _setupRenderCache(e) {
                const t1 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                    if (this.invalidateRenderCache = !1, t1.renderCache.length > t1.renderCachePool.length) {
                        const e = Object.values(t1.proxyCachedFBO);
                        t1.proxyCachedFBO = {};
                        for(let i = 0; i < e.length; ++i){
                            const o = Object.values(e[i]);
                            t1.renderCachePool.push(...o);
                        }
                    }
                    return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords, o = this._tilesDirty;
                for(let s = i.length - 1; s >= 0; s--){
                    const r = i[s];
                    if (t1.getTileByID(r.key), void 0 !== t1.proxyCachedFBO[r.key]) {
                        const i = e[r.key], s = this.proxyToSource[r.key];
                        let n = 0;
                        for(const e in s){
                            const t1 = s[e], r = i[e];
                            if (!r || r.length !== t1.length || t1.some((t1, i)=>t1 !== r[i] || o[e] && o[e].hasOwnProperty(t1.key))) {
                                n = -1;
                                break;
                            }
                            ++n;
                        }
                        for(const e in t1.proxyCachedFBO[r.key])t1.renderCache[t1.proxyCachedFBO[r.key][e]].dirty = n < 0 || n !== Object.values(i).length;
                    }
                }
                const s = [
                    ...this._drapedRenderBatches
                ];
                s.sort((e, t1)=>t1.end - t1.start - (e.end - e.start));
                for (const e of s)for (const o of i){
                    if (t1.proxyCachedFBO[o.key]) continue;
                    let i = t1.renderCachePool.pop();
                    void 0 === i && t1.renderCache.length < 50 && (i = t1.renderCache.length, t1.renderCache.push(this._createFBO())), void 0 !== i && (t1.proxyCachedFBO[o.key] = {}, t1.proxyCachedFBO[o.key][e.start] = i, t1.renderCache[i].dirty = !0);
                }
                this._tilesDirty = {};
            }
            _setupStencil(e, t1, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const s = this.painter.context, r = s.gl;
                if (t1.length <= 1) return void (this._overlapStencilType = !1);
                let n;
                if (i.isTileClipped()) n = t1.length, this._overlapStencilMode.test = {
                    func: r.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t1[0].overscaledZ > t1[t1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    n = 1, this._overlapStencilMode.test = {
                        func: r.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + n > 255 && (s.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += n, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t1, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(e) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]), this._overlapStencilMode) : Yi.disabled;
            }
            _renderTileClippingMasks(e, t1) {
                const i = this.painter, o = this.painter.context, s = o.gl;
                i._tileClippingMaskIDs = {}, o.setColorMode(Wi.disabled), o.setDepthMode($i.disabled);
                const r = i.getOrCreateProgram("clippingMask");
                for (const o of e){
                    const e = i._tileClippingMaskIDs[o.key] = --t1;
                    r.draw(i, s.TRIANGLES, $i.disabled, new Yi({
                        func: s.ALWAYS,
                        mask: 0
                    }, e, 255, s.KEEP, s.KEEP, s.REPLACE), Wi.disabled, Qi.disabled, tr(o.projMatrix), "$clipping", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments);
                }
            }
            pointCoordinate(t1) {
                const i = this.painter.transform;
                if (t1.x < 0 || t1.x > i.width || t1.y < 0 || t1.y > i.height) return null;
                const o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.aC(o, o, i.pixelMatrixInverse), e.cK(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
                const s = i._camera.position, r = e.cf(1, i.center.lat), n = [
                    s[0],
                    s[1],
                    s[2] / r,
                    0
                ], a = e.da([], o.slice(0, 3), n);
                e.aw(a, a);
                const l = this.raycast(n, a, this._exaggeration);
                return null !== l && l ? (e.bH(n, n, a, l), n[3] = n[2], n[2] *= r, n) : null;
            }
            _setupProxiedCoordsForOrtho(t1, i, o) {
                if (t1.getSource() instanceof e.aU) return this._setupProxiedCoordsForImageSource(t1, i, o);
                this._findCoveringTileCache[t1.id] = this._findCoveringTileCache[t1.id] || {};
                const s = this.proxiedCoords[t1.id] = [], r = this.proxyCoords;
                for(let e = 0; e < r.length; e++){
                    const i = r[e], n = this._findTileCoveringTileID(i, t1);
                    if (n) {
                        const e = this._createProxiedId(i, n, o[i.key] && o[i.key][t1.id]);
                        s.push(e), this.proxyToSource[i.key][t1.id] = [
                            e
                        ];
                    }
                }
                let n = !1;
                const a = new Set;
                for(let e = 0; e < i.length; e++){
                    const r = t1.getTile(i[e]);
                    if (!r || !r.hasData()) continue;
                    const l = this._findTileCoveringTileID(r.tileID, this.proxySourceCache);
                    if (l && l.tileID.canonical.z !== r.tileID.canonical.z) {
                        const e = this.proxyToSource[l.tileID.key][t1.id], i = this._createProxiedId(l.tileID, r, o[l.tileID.key] && o[l.tileID.key][t1.id]);
                        e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t1.id] = [
                            i
                        ];
                        const c = this.proxyToSource[l.tileID.key][t1.id];
                        a.has(c) || a.add(c), s.push(i), n = !0;
                    }
                }
                if (this._sourceTilesOverlap[t1.id] = n, n && this._debugParams.sortTilesHiZFirst) for (const e of a)e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ);
            }
            _setupProxiedCoordsForImageSource(t1, i, o) {
                if (!t1.getSource().loaded()) return;
                const s = this.proxiedCoords[t1.id] = [], r = this.proxyCoords, n = t1.getSource(), a = n.tileID;
                if (!a) return;
                const l = new e.P(a.x, a.y)._div(1 << a.z), c = n.coordinates.map(e.ae.fromLngLat).reduce((e, t1)=>(e.min.x = Math.min(e.min.x, t1.x - l.x), e.min.y = Math.min(e.min.y, t1.y - l.y), e.max.x = Math.max(e.max.x, t1.x - l.x), e.max.y = Math.max(e.max.y, t1.y - l.y), e), {
                    min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), h = (t1, i)=>{
                    const o = t1.wrap + t1.canonical.x / (1 << t1.canonical.z), s = t1.canonical.y / (1 << t1.canonical.z), r = e.al / (1 << t1.canonical.z), n = i.wrap + i.canonical.x / (1 << i.canonical.z), a = i.canonical.y / (1 << i.canonical.z);
                    return o + r < n + c.min.x || o > n + c.max.x || s + r < a + c.min.y || s > a + c.max.y;
                };
                for(let e = 0; e < r.length; e++){
                    const n = r[e];
                    for(let e = 0; e < i.length; e++){
                        const r = t1.getTile(i[e]);
                        if (!r || !r.hasData()) continue;
                        if (h(n, r.tileID)) continue;
                        const a = this._createProxiedId(n, r, o[n.key] && o[n.key][t1.id]), l = this.proxyToSource[n.key][t1.id];
                        l ? l.push(a) : this.proxyToSource[n.key][t1.id] = [
                            a
                        ], s.push(a);
                    }
                }
            }
            _createProxiedId(t1, i, o) {
                let s = this.orthoMatrix;
                if (o) {
                    const e = o.find((e)=>e.key === i.tileID.key);
                    if (e) return e;
                }
                if (i.tileID.key !== t1.key) {
                    const o = t1.canonical.z - i.tileID.canonical.z;
                    let r, n, a;
                    s = e.bC();
                    const l = i.tileID.wrap - t1.wrap << t1.overscaledZ;
                    o > 0 ? (r = e.al >> o, n = r * ((i.tileID.canonical.x << o) - t1.canonical.x + l), a = r * ((i.tileID.canonical.y << o) - t1.canonical.y)) : (r = e.al << -o, n = e.al * (i.tileID.canonical.x - (t1.canonical.x + l << -o)), a = e.al * (i.tileID.canonical.y - (t1.canonical.y << -o))), e.ce(s, 0, r, 0, r, 0, 1), e.br(s, s, [
                        n,
                        a,
                        0
                    ]);
                }
                return new rr(i.tileID, t1.key, s);
            }
            _findTileCoveringTileID(t1, i) {
                let o = i.getTile(t1);
                if (o && o.hasData()) return o;
                const s = this._findCoveringTileCache[i.id], r = s[t1.key];
                if (o = r ? i.getTileByID(r) : null, o && o.hasData() || null === r) return o;
                let n = o ? o.tileID : t1, a = n.overscaledZ;
                const l = i.getSource().minzoom, c = [];
                if (!r) {
                    const s = i.getSource().maxzoom;
                    if (t1.canonical.z >= s) {
                        const o = t1.canonical.z - s;
                        i.getSource().reparseOverscaled ? (a = Math.max(t1.canonical.z + 2, i.transform.tileZoom), n = new e.aQ(a, t1.wrap, s, t1.canonical.x >> o, t1.canonical.y >> o)) : 0 !== o && (a = s, n = new e.aQ(a, t1.wrap, s, t1.canonical.x >> o, t1.canonical.y >> o));
                    }
                    n.key !== t1.key && (c.push(n.key), o = i.getTile(n));
                }
                const h = (e)=>{
                    c.forEach((t1)=>{
                        s[t1] = e;
                    }), c.length = 0;
                };
                for(a -= 1; a >= l && (!o || !o.hasData()); a--){
                    o && h(o.tileID.key);
                    const e = n.calculateScaledKey(a);
                    if (o = i.getTileByID(e), o && o.hasData()) break;
                    const t1 = s[e];
                    if (null === t1) break;
                    void 0 === t1 ? c.push(e) : o = i.getTileByID(t1);
                }
                return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }
            findDEMTileFor(e) {
                return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e, t1) {
                let i = this._tilesDirty[e];
                i || (i = this._tilesDirty[e] = {}), i[t1.key] = !0;
            }
        }
        function ar(t1, i, o) {
            const s = function(t1, i, o) {
                const s = e.bJ(i, t1), r = e.bJ(o, [
                    .2126,
                    .7152,
                    .0722
                ]), n = (e, t1, i)=>(1 - i) * e + i * t1, a = n(1 - .3 * Math.min(r, 1), 1, Math.min(s + 1, 1));
                return n(.92, 1, Math.asin(e.aA(i[2], -1, 1)) / Math.PI + .5) * a;
            }(t1, [
                0,
                0,
                1
            ], i), r = [
                0,
                0,
                0
            ];
            e.c5(r, o.slice(0, 3), s);
            const n = [
                0,
                0,
                0
            ];
            e.c5(n, i.slice(0, 3), t1[2]);
            const a = [
                0,
                0,
                0
            ];
            return e.d8(a, r, n), e.db(a);
        }
        const lr = [
            "fill",
            "fillOutline",
            "fillPattern",
            "line",
            "linePattern",
            "background",
            "backgroundPattern",
            "hillshade",
            "raster"
        ], cr = [
            "stars",
            "rainParticle",
            "snowParticle",
            "fillExtrusion",
            "fillExtrusionGroundEffect",
            "building",
            "buildingBloom",
            "elevatedStructures",
            "model",
            "symbol"
        ];
        class hr {
            static cacheKey(e, t1, i, o) {
                const s = [
                    t1
                ];
                o && s.push(o.cacheKey);
                for (const t1 of i)e.usedDefines.has(t1) && s.push(t1);
                return s.join("/");
            }
            constructor(t1, i, o, s, r, n){
                const a = t1.gl;
                this.program = a.createProgram(), this.configuration = s, this.name = i, this.fixedDefines = [
                    ...n
                ];
                const l = `#version 300 es\n${(s ? s.defines() : []).concat(n.map((e)=>`#define ${e}`)).join("\n")}`, c = [
                    l,
                    es
                ];
                for (const e of o.fragmentIncludes)c.push(Yo[e]);
                c.push(o.fragmentSource);
                const h = c.join("\n"), d = [
                    l,
                    ts
                ];
                for (const e of o.vertexIncludes)d.push(Yo[e]);
                this.forceManualRenderingForInstanceIDShaders = t1.forceManualRenderingForInstanceIDShaders && o.vertexSource.includes("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && d.push("uniform int u_instanceID;"), d.push(o.vertexSource);
                let u = d.join("\n");
                this.forceManualRenderingForInstanceIDShaders && (u = u.replaceAll("gl_InstanceID", "u_instanceID"));
                const _ = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost()) return void (this.failedToCreate = !0);
                a.shaderSource(_, h), a.compileShader(_), a.attachShader(this.program, _);
                const p = a.createShader(a.VERTEX_SHADER);
                a.isContextLost() ? this.failedToCreate = !0 : (a.shaderSource(p, u), a.compileShader(p), a.attachShader(this.program, p), this.attributes = {}, a.linkProgram(this.program), a.deleteShader(p), a.deleteShader(_), this.fixedUniforms = r(t1), this.fixedUniformsEntries = Object.entries(this.fixedUniforms), this.binderUniforms = s ? s.getUniforms(t1) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t1)=>({
                        u_instanceID: new e.ch(t1)
                    }))(t1)), (n.includes("TERRAIN") || i.includes("symbol") || i.includes("circle")) && (this.terrainUniforms = ((t1)=>({
                        u_dem: new e.ch(t1),
                        u_dem_prev: new e.ch(t1),
                        u_dem_tl: new e.ck(t1),
                        u_dem_scale: new e.cj(t1),
                        u_dem_tl_prev: new e.ck(t1),
                        u_dem_scale_prev: new e.cj(t1),
                        u_dem_size: new e.cj(t1),
                        u_dem_lerp: new e.cj(t1),
                        u_exaggeration: new e.cj(t1),
                        u_depth: new e.ch(t1),
                        u_depth_size_inv: new e.ck(t1),
                        u_depth_range_unpack: new e.ck(t1),
                        u_occluder_half_size: new e.cj(t1),
                        u_occlusion_depth_offset: new e.cj(t1),
                        u_meter_to_dem: new e.cj(t1),
                        u_label_plane_matrix_inv: new e.cl(t1)
                    }))(t1)), n.includes("GLOBE") && (this.globeUniforms = ((t1)=>({
                        u_tile_tl_up: new e.ci(t1),
                        u_tile_tr_up: new e.ci(t1),
                        u_tile_br_up: new e.ci(t1),
                        u_tile_bl_up: new e.ci(t1),
                        u_tile_up_scale: new e.cj(t1)
                    }))(t1)), n.includes("FOG") && (this.fogUniforms = ((t1)=>({
                        u_fog_matrix: new e.cl(t1),
                        u_fog_range: new e.ck(t1),
                        u_fog_color: new e.d3(t1),
                        u_fog_horizon_blend: new e.cj(t1),
                        u_fog_vertical_limit: new e.ck(t1),
                        u_fog_temporal_offset: new e.cj(t1),
                        u_frustum_tl: new e.ci(t1),
                        u_frustum_tr: new e.ci(t1),
                        u_frustum_br: new e.ci(t1),
                        u_frustum_bl: new e.ci(t1),
                        u_globe_pos: new e.ci(t1),
                        u_globe_radius: new e.cj(t1),
                        u_globe_transition: new e.cj(t1),
                        u_is_globe: new e.ch(t1),
                        u_viewport: new e.ck(t1)
                    }))(t1)), n.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t1)=>({
                        u_cutoff_params: new e.d3(t1)
                    }))(t1)), n.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t1)=>({
                        u_lighting_ambient_color: new e.ci(t1),
                        u_lighting_directional_dir: new e.ci(t1),
                        u_lighting_directional_color: new e.ci(t1),
                        u_ground_radiance: new e.ci(t1)
                    }))(t1)), n.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t1)=>({
                        u_light_matrix_0: new e.cl(t1),
                        u_light_matrix_1: new e.cl(t1),
                        u_fade_range: new e.ck(t1),
                        u_shadow_normal_offset: new e.ci(t1),
                        u_shadow_intensity: new e.cj(t1),
                        u_shadow_texel_size: new e.cj(t1),
                        u_shadow_map_resolution: new e.cj(t1),
                        u_shadow_direction: new e.ci(t1),
                        u_shadow_bias: new e.ci(t1),
                        u_shadowmap_0: new e.ch(t1),
                        u_shadowmap_1: new e.ch(t1)
                    }))(t1)));
            }
            getAttributeLocation(e, t1) {
                let i = this.attributes[t1];
                return void 0 === i && (i = this.attributes[t1] = e.getAttribLocation(this.program, t1)), i;
            }
            setTerrainUniformValues(e, t1) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setGlobeUniformValues(e, t1) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setFogUniformValues(e, t1) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setCutoffUniformValues(e, t1) {
                if (!this.cutoffUniforms) return;
                const i = this.cutoffUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setLightsUniformValues(e, t1) {
                if (!this.lightsUniforms) return;
                const i = this.lightsUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setShadowUniformValues(e, t1) {
                if (this.failedToCreate || !this.shadowUniforms) return;
                const i = this.shadowUniforms;
                e.program.set(this.program);
                for(const e in t1)i[e].set(this.program, e, t1[e]);
            }
            _drawDebugWireframe(t1, i, o, s, r, n, a, l, c, h) {
                const d = t1.options.wireframe;
                if (!1 === d.terrain && !1 === d.layers2D && !1 === d.layers3D) return;
                const u = t1.context;
                if (!(()=>!(!d.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!d.layers2D || t1._terrain && t1._terrain.renderingToTexture || !lr.includes(this.name)) || !(!d.layers3D || !cr.includes(this.name)))()) return;
                const _ = u.gl, p = t1.wireframeDebugCache.getLinesFromTrianglesBuffer(t1.frameCounter, r, u);
                if (!p) return;
                const f = [
                    ...this.fixedDefines,
                    "DEBUG_WIREFRAME"
                ], m = t1.getOrCreateProgram(this.name, {
                    config: this.configuration,
                    defines: f
                });
                u.program.set(m.program);
                const g = (e, t1, i)=>{
                    if (t1[e] && i[e]) for(const o in t1[e])i[e][o] && i[e][o].set(i.program, o, t1[e][o].current);
                };
                c && c.setUniforms(m.program, u, m.binderUniforms, a, {
                    zoom: l
                }), g("fixedUniforms", this, m), g("terrainUniforms", this, m), g("globeUniforms", this, m), g("fogUniforms", this, m), g("lightsUniforms", this, m), g("shadowUniforms", this, m), p.bind(), u.setColorMode(new Wi([
                    _.ONE,
                    _.ONE_MINUS_SRC_ALPHA,
                    _.ZERO,
                    _.ONE
                ], e.ao.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ])), u.setDepthMode(new $i(i.func === _.LESS ? _.LEQUAL : i.func, $i.ReadOnly, i.range)), u.setStencilMode(Yi.disabled);
                const v = 3 * n.primitiveLength * 2, y = 3 * n.primitiveOffset * 2 * 2;
                if (this.forceManualRenderingForInstanceIDShaders) {
                    const e = h || 1;
                    for(let t1 = 0; t1 < e; ++t1)m.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t1), _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);
                } else h && h > 1 ? _.drawElementsInstanced(_.LINES, v, _.UNSIGNED_SHORT, y, h) : _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);
                r.bind(), u.program.set(this.program), u.setDepthMode(i), u.setStencilMode(o), u.setColorMode(s);
            }
            checkUniforms(e, t1, i) {
                if (this.fixedDefines.includes(t1)) {
                    for (const o of Object.keys(i))if (!i[o].initialized) throw new Error(`Program '${this.name}', from draw '${e}': uniform ${o} not set but required by ${t1} being defined`);
                }
            }
            draw(e, t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f) {
                const m = e.context, g = m.gl;
                if (this.failedToCreate) return;
                m.program.set(this.program), m.setDepthMode(i), m.setStencilMode(o), m.setColorMode(s), m.setCullFace(r);
                for (const [e, t1] of this.fixedUniformsEntries)t1.set(this.program, e, n[e]);
                _ && _.setUniforms(this.program, m, this.binderUniforms, d, {
                    zoom: u
                });
                const v = {
                    [g.POINTS]: 1,
                    [g.LINES]: 2,
                    [g.TRIANGLES]: 3,
                    [g.LINE_STRIP]: 1
                }[t1];
                this.checkUniforms(a, "RENDER_SHADOWS", this.shadowUniforms);
                const y = p || [], x = _ ? _.getPaintVertexBuffers() : [], b = t1 === g.TRIANGLES && c, w = f && f > 0 ? 1 : void 0;
                for (const r of h.get()){
                    const n = r.vaos || (r.vaos = {});
                    if ((n[a] || (n[a] = new rs)).bind(m, this, l, x, c, r.vertexOffset, y, w), this.forceManualRenderingForInstanceIDShaders) {
                        const e = f || 1;
                        for(let i = 0; i < e; ++i)this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i), c ? g.drawElements(t1, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t1, r.vertexOffset, r.vertexLength);
                    } else f && f > 1 ? g.drawElementsInstanced(t1, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2, f) : c ? g.drawElements(t1, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t1, r.vertexOffset, r.vertexLength);
                    b && this._drawDebugWireframe(e, i, o, s, c, r, d, u, _, f);
                }
            }
        }
        function dr(t1, i, o = 0) {
            const s = Math.pow(2, i.tileID.overscaledZ), r = i.tileSize * Math.pow(2, t1.transform.tileZoom) / s, n = r * (i.tileID.canonical.x + i.tileID.wrap * s), a = r * i.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: 1 / e.ay(i, 1, t1.transform.tileZoom),
                u_pixel_coord_upper: [
                    n >> 16,
                    a >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & n,
                    65535 & a
                ],
                u_pattern_transition: o
            };
        }
        const ur = {
            terrain: 0,
            flat: 1
        }, _r = e.bC(), pr = (t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v)=>{
            const y = i.style.light, x = y.properties.get("position"), b = [
                x.x,
                x.y,
                x.z
            ], w = e.dO();
            "viewport" === y.properties.get("anchor") && (e.dP(w, -i.transform.angle), e.dQ(b, b, w));
            const T = y.properties.get("color").toPremultipliedRenderColor(null), E = i.transform, S = {
                u_matrix: t1,
                u_lightpos: b,
                u_lightintensity: y.properties.get("intensity"),
                u_lightcolor: [
                    T.r,
                    T.g,
                    T.b
                ],
                u_vertical_gradient: +o,
                u_opacity: s,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: _r,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_height_type: ur[h],
                u_base_type: ur[d],
                u_ao: r,
                u_edge_radius: n,
                u_width_scale: a,
                u_flood_light_color: f,
                u_vertical_scale: m,
                u_flood_light_intensity: g,
                u_ground_shadow_factor: v
            };
            return "globe" === E.projection.name && (S.u_tile_id = [
                l.canonical.x,
                l.canonical.y,
                1 << l.canonical.z
            ], S.u_zoom_transition = u, S.u_inv_rot_matrix = p, S.u_merc_center = _, S.u_up_dir = E.projection.upVector(new e.cD(0, 0, 0), _[0] * e.al, _[1] * e.al), S.u_height_lift = c), S;
        }, fr = (e, t1, i, o, s, r)=>({
                u_matrix: e,
                u_edge_radius: t1,
                u_width_scale: i,
                u_vertical_scale: o,
                u_height_type: ur[s],
                u_base_type: ur[r]
            }), mr = (e, t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g)=>{
            const v = pr(e, t1, i, o, s, r, n, a, c, h, d, u, _, p, f, m, 1, [
                0,
                0,
                0
            ]), y = {
                u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8
            };
            return Object.assign(v, dr(t1, l, g), y);
        }, gr = (e, t1, i)=>({
                u_matrix: e,
                u_emissive_strength: t1,
                u_ground_shadow_factor: i
            }), vr = (e, t1, i, o, s, r = 0)=>Object.assign(gr(e, t1, s), dr(i, o, r)), yr = (e, t1, i, o)=>({
                u_matrix: e,
                u_world: i,
                u_emissive_strength: t1,
                u_ground_shadow_factor: o
            }), xr = (e, t1, i, o, s, r, n = 0)=>Object.assign(vr(e, t1, i, o, r, n), {
                u_world: s
            }), br = (e, t1)=>({
                u_matrix: e,
                u_depth_bias: t1
            }), wr = (e, t1)=>({
                u_matrix: e,
                u_ground_shadow_factor: t1
            }), Tr = (e, t1, i, o, s)=>({
                u_matrix: e,
                u_camera_pos: [
                    t1[0],
                    t1[1],
                    t1[2]
                ],
                u_depth_bias: i,
                u_height_scale: o,
                u_reset_depth: s
            }), Er = (e, t1, i, o, s, r, n, a, l)=>({
                u_matrix: e,
                u_normal_matrix: t1,
                u_opacity: i,
                u_faux_facade_ao_intensity: o,
                u_camera_pos: s,
                u_tile_to_meter: r,
                u_facade_emissive_chance: n,
                u_flood_light_color: a,
                u_flood_light_intensity: l
            }), Sr = (e)=>({
                u_matrix: e
            }), Ir = (e)=>({
                u_matrix: e
            }), Cr = (t1, i, o, s, r, n, a, l)=>{
            const c = e.al / n.tileSize;
            return {
                u_matrix: t1,
                u_inv_rot_matrix: i,
                u_camera_to_center_distance: o.getCameraToCenterDistance(l),
                u_extrude_scale: [
                    o.pixelsToGLUnits[0] / c,
                    o.pixelsToGLUnits[1] / c
                ],
                u_zoom_transition: s,
                u_tile_id: a,
                u_merc_center: r
            };
        }, Rr = (e, t1, i, o)=>({
                u_matrix: e,
                u_inv_matrix: t1,
                u_camera_to_center_distance: i.getCameraToCenterDistance(o),
                u_viewport_size: [
                    i.width,
                    i.height
                ]
            }), Ar = (e, t1, i = 1)=>({
                u_matrix: e,
                u_color: t1,
                u_overlay: 0,
                u_overlay_scale: i
            }), Lr = e.bC(), Dr = (t1, i, o, s, r, n, a)=>{
            const l = t1.transform, c = "globe" === l.projection.name, h = c ? e.dR(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.ay(o, 1, n), d = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: a,
                u_inv_rot_matrix: Lr,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c) {
                d.u_inv_rot_matrix = s, d.u_merc_center = r, d.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], d.u_zoom_transition = e.aj(l.zoom);
                const t1 = r[0] * e.al, o = r[1] * e.al;
                d.u_up_dir = l.projection.upVector(new e.cD(0, 0, 0), t1, o);
            }
            return d;
        };
        function Pr(e, [t1, i, o, s], [r, n]) {
            if (r === n) return [
                0,
                0,
                0,
                0
            ];
            const a = 255 * (e - 1) / (e * (n - r));
            return [
                t1 * a,
                i * a,
                o * a,
                s * a
            ];
        }
        function Or(e, t1, [i, o]) {
            return i === o ? 0 : .5 / e + (t1 - i) * (e - 1) / (e * (o - i));
        }
        const zr = (t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b)=>({
                u_matrix: t1,
                u_normalize_matrix: i,
                u_globe_matrix: o,
                u_merc_matrix: s,
                u_grid_matrix: r,
                u_tl_parent: n,
                u_scale_parent: h,
                u_fade_t: d.mix,
                u_opacity: d.opacity * u.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: u.paint.get("raster-brightness-min"),
                u_brightness_high: u.paint.get("raster-brightness-max"),
                u_saturation_factor: e.dT(u.paint.get("raster-saturation")),
                u_contrast_factor: e.dS(u.paint.get("raster-contrast")),
                u_spin_weights: Mr(u.paint.get("raster-hue-rotate")),
                u_perspective_transform: _,
                u_raster_elevation: p,
                u_zoom_transition: a,
                u_merc_center: l,
                u_cutoff_params: c,
                u_colorization_mix: Pr(e.dU, m, v),
                u_colorization_offset: Or(e.dU, g, v),
                u_color_ramp: f,
                u_texture_offset: [
                    x / (y + 2 * x),
                    y / (y + 2 * x)
                ],
                u_texture_res: [
                    y + 2 * x,
                    y + 2 * x
                ],
                u_emissive_strength: b
            });
        function Mr(e) {
            e *= Math.PI / 180;
            const t1 = Math.sin(e), i = Math.cos(e);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t1 - i + 1) / 3,
                (Math.sqrt(3) * t1 - i + 1) / 3
            ];
        }
        const Fr = .05, Br = (e, t1, i, o, s, r, n, a, l, c, h, d)=>({
                u_matrix: e,
                u_normalize_matrix: t1,
                u_globe_matrix: i,
                u_merc_matrix: o,
                u_grid_matrix: s,
                u_tl_parent: r,
                u_scale_parent: c,
                u_fade_t: h.mix,
                u_opacity: h.opacity,
                u_image0: 0,
                u_image1: 1,
                u_raster_elevation: d,
                u_zoom_transition: n,
                u_merc_center: a,
                u_cutoff_params: l
            }), kr = (e, t1, i, o, s, r, n, a, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_tile_offset: i,
                u_velocity: o,
                u_color_ramp: r,
                u_velocity_res: s,
                u_max_speed: n,
                u_uv_offset: a,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    Fr,
                    Fr
                ]
            }), Nr = (e, t1, i, o, s, r, n, a, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_velocity: i,
                u_velocity_res: o,
                u_max_speed: s,
                u_speed_factor: r,
                u_reset_rate: n,
                u_rand_seed: Math.random(),
                u_uv_offset: a,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    Fr,
                    Fr
                ]
            }), Ur = e.bC(), jr = (t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b, w, T, E)=>{
            const S = r.transform, I = {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: S.getCameraToCenterDistance(y),
                u_rotate_symbol: +o,
                u_aspect_ratio: S.width / S.height,
                u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,
                u_matrix: n,
                u_label_plane_matrix: a,
                u_coord_matrix: l,
                u_is_text: +h,
                u_elevation_from_sea: c ? 1 : 0,
                u_pitch_with_map: +s,
                u_texsize: d,
                u_texsize_icon: u,
                u_texture: 0,
                u_texture_icon: 1,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Ur,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: Ur,
                u_up_vector: [
                    0,
                    -1,
                    0
                ],
                u_color_adj_mat: w,
                u_icon_transition: T || 0,
                u_gamma_scale: s ? r.transform.getCameraToCenterDistance(y) * Math.cos(r.terrain ? 0 : r.transform._pitch) : 1,
                u_device_pixel_ratio: e.o.devicePixelRatio,
                u_is_halo: 1,
                u_scale_factor: E || 1,
                u_ground_shadow_factor: x,
                u_inv_matrix: e.bl(e.bC(), a),
                u_normal_scale: b,
                u_lutTexture: 10
            };
            return "globe" === y.name && (I.u_tile_id = [
                p.canonical.x,
                p.canonical.y,
                1 << p.canonical.z
            ], I.u_zoom_transition = f, I.u_inv_rot_matrix = g, I.u_merc_center = m, I.u_camera_forward = S._camera.forward(), I.u_ecef_origin = e.dV(S.globeMatrix, p.toUnwrapped()), I.u_tile_matrix = Float32Array.from(S.globeMatrix), I.u_up_vector = v), I;
        }, Vr = (e, t1, i, o)=>({
                u_matrix: e,
                u_emissive_strength: t1,
                u_opacity: i,
                u_color: o
            }), Gr = (t1, i, o, s, r, n, a, l, c)=>Object.assign(function(t1, i, o, s, r, n) {
                const { width: a, height: l } = s.imageManager.getPixelSize(i), c = Math.pow(2, n.tileID.overscaledZ), h = n.tileSize * Math.pow(2, s.transform.tileZoom) / c, d = h * (n.tileID.canonical.x + n.tileID.wrap * c), u = h * n.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o.tl,
                    u_pattern_br: o.br,
                    u_texsize: [
                        a,
                        l
                    ],
                    u_pattern_size: o.displaySize,
                    u_pattern_units_to_pixels: r ? [
                        s.transform.width,
                        -1 * s.transform.height
                    ] : [
                        1 / e.ay(n, 1, s.transform.tileZoom),
                        1 / e.ay(n, 1, s.transform.tileZoom)
                    ],
                    u_pixel_coord_upper: [
                        d >> 16,
                        u >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & d,
                        65535 & u
                    ]
                };
            }(0, n, a, s, l, c), {
                u_matrix: t1,
                u_emissive_strength: i,
                u_opacity: o
            }), Hr = new Float32Array(e.bA([])), qr = (t1, i, o, s, r, n, a, l, c, h, d, u, _, p = [
            0,
            0,
            0
        ], f, m, g)=>{
            const v = r.style.light, y = v.properties.get("position"), x = [
                -y.x,
                -y.y,
                y.z
            ], b = e.dO();
            "viewport" === v.properties.get("anchor") && (e.dP(b, -r.transform.angle), e.dQ(x, x, b));
            const w = "MASK" === d.alphaMode, T = v.properties.get("color").toNonPremultipliedRenderColor(null), E = _.paint.get("model-ambient-occlusion-intensity"), S = _.paint.get("model-color").constantOr(e.ao.white).toNonPremultipliedRenderColor(null);
            return S.a = _.paint.get("model-color-mix-intensity").constantOr(0), g && (S.r = g[0], S.g = g[1], S.b = g[2], S.a = g[3]), m && (S.r = m.color.r, S.g = m.color.g, S.b = m.color.b, S.a = m.colorMix, u = m.emissionStrength, n *= m.opacity), {
                u_matrix: t1,
                u_lighting_matrix: i,
                u_normal_matrix: o,
                u_node_matrix: s || Hr,
                u_lightpos: x,
                u_lightintensity: v.properties.get("intensity"),
                u_lightcolor: [
                    T.r,
                    T.g,
                    T.b
                ],
                u_camera_pos: p,
                u_opacity: n,
                u_baseTextureIsAlpha: 0,
                u_alphaMask: +w,
                u_alphaCutoff: d.alphaCutoff,
                u_baseColorFactor: a.toNonPremultipliedRenderColor(null).toArray01(),
                u_emissiveFactor: l.toNonPremultipliedRenderColor(null).toArray01(),
                u_metallicFactor: c,
                u_roughnessFactor: h,
                u_baseColorTexture: 5,
                u_metallicRoughnessTexture: 6,
                u_normalTexture: 7,
                u_occlusionTexture: 8,
                u_emissionTexture: 9,
                u_lutTexture: 10,
                u_color_mix: S.toArray01(),
                u_aoIntensity: E,
                u_emissive_strength: u,
                u_occlusionTextureTransform: f || [
                    0,
                    0,
                    0,
                    0
                ]
            };
        }, Zr = (e, t1 = Hr, i = Hr)=>({
                u_matrix: e,
                u_instance: t1,
                u_node_matrix: i
            }), Wr = {
            fillExtrusion: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_lightpos: new e.ci(t1),
                    u_lightintensity: new e.cj(t1),
                    u_lightcolor: new e.ci(t1),
                    u_vertical_gradient: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_edge_radius: new e.cj(t1),
                    u_width_scale: new e.cj(t1),
                    u_ao: new e.ck(t1),
                    u_height_type: new e.ch(t1),
                    u_base_type: new e.ch(t1),
                    u_tile_id: new e.ci(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_inv_rot_matrix: new e.cl(t1),
                    u_merc_center: new e.ck(t1),
                    u_up_dir: new e.ci(t1),
                    u_height_lift: new e.cj(t1),
                    u_flood_light_color: new e.ci(t1),
                    u_vertical_scale: new e.cj(t1),
                    u_flood_light_intensity: new e.cj(t1),
                    u_ground_shadow_factor: new e.ci(t1)
                }),
            fillExtrusionDepth: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_edge_radius: new e.cj(t1),
                    u_width_scale: new e.cj(t1),
                    u_vertical_scale: new e.cj(t1),
                    u_height_type: new e.ch(t1),
                    u_base_type: new e.ch(t1)
                }),
            fillExtrusionPattern: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_lightpos: new e.ci(t1),
                    u_lightintensity: new e.cj(t1),
                    u_lightcolor: new e.ci(t1),
                    u_vertical_gradient: new e.cj(t1),
                    u_height_factor: new e.cj(t1),
                    u_edge_radius: new e.cj(t1),
                    u_width_scale: new e.cj(t1),
                    u_ao: new e.ck(t1),
                    u_height_type: new e.ch(t1),
                    u_base_type: new e.ch(t1),
                    u_tile_id: new e.ci(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_inv_rot_matrix: new e.cl(t1),
                    u_merc_center: new e.ck(t1),
                    u_up_dir: new e.ci(t1),
                    u_height_lift: new e.cj(t1),
                    u_image: new e.ch(t1),
                    u_texsize: new e.ck(t1),
                    u_pixel_coord_upper: new e.ck(t1),
                    u_pixel_coord_lower: new e.ck(t1),
                    u_tile_units_to_pixels: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_pattern_transition: new e.cj(t1)
                }),
            fillExtrusionGroundEffect: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_opacity: new e.cj(t1),
                    u_ao_pass: new e.cj(t1),
                    u_meter_to_tile: new e.cj(t1),
                    u_ao: new e.ck(t1),
                    u_flood_light_intensity: new e.cj(t1),
                    u_flood_light_color: new e.ci(t1),
                    u_attenuation: new e.cj(t1),
                    u_edge_radius: new e.cj(t1),
                    u_fb: new e.ch(t1),
                    u_fb_size: new e.cj(t1),
                    u_dynamic_offset: new e.cj(t1)
                }),
            fill: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_ground_shadow_factor: new e.ci(t1)
                }),
            fillPattern: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_image: new e.ch(t1),
                    u_texsize: new e.ck(t1),
                    u_pixel_coord_upper: new e.ck(t1),
                    u_pixel_coord_lower: new e.ck(t1),
                    u_tile_units_to_pixels: new e.cj(t1),
                    u_ground_shadow_factor: new e.ci(t1),
                    u_pattern_transition: new e.cj(t1)
                }),
            fillOutline: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_world: new e.ck(t1),
                    u_ground_shadow_factor: new e.ci(t1)
                }),
            fillOutlinePattern: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_world: new e.ck(t1),
                    u_image: new e.ch(t1),
                    u_texsize: new e.ck(t1),
                    u_pixel_coord_upper: new e.ck(t1),
                    u_pixel_coord_lower: new e.ck(t1),
                    u_tile_units_to_pixels: new e.cj(t1),
                    u_ground_shadow_factor: new e.ci(t1),
                    u_pattern_transition: new e.cj(t1)
                }),
            building: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_normal_matrix: new e.cl(t1),
                    u_opacity: new e.cj(t1),
                    u_faux_facade_ao_intensity: new e.cj(t1),
                    u_camera_pos: new e.ci(t1),
                    u_tile_to_meter: new e.cj(t1),
                    u_facade_emissive_chance: new e.cj(t1),
                    u_flood_light_color: new e.ci(t1),
                    u_flood_light_intensity: new e.cj(t1)
                }),
            buildingBloom: (t1)=>({
                    u_matrix: new e.cl(t1)
                }),
            buildingDepth: (t1)=>({
                    u_matrix: new e.cl(t1)
                }),
            elevatedStructuresDepth: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_depth_bias: new e.cj(t1)
                }),
            elevatedStructures: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_ground_shadow_factor: new e.ci(t1)
                }),
            elevatedStructuresDepthReconstruct: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_camera_pos: new e.ci(t1),
                    u_depth_bias: new e.cj(t1),
                    u_height_scale: new e.cj(t1),
                    u_reset_depth: new e.cj(t1)
                }),
            circle: e.dY,
            collisionBox: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_inv_rot_matrix: new e.cl(t1),
                    u_camera_to_center_distance: new e.cj(t1),
                    u_extrude_scale: new e.ck(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_merc_center: new e.ck(t1),
                    u_tile_id: new e.ci(t1)
                }),
            collisionCircle: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_inv_matrix: new e.cl(t1),
                    u_camera_to_center_distance: new e.cj(t1),
                    u_viewport_size: new e.ck(t1)
                }),
            debug: (t1)=>({
                    u_color: new e.dB(t1),
                    u_matrix: new e.cl(t1),
                    u_overlay: new e.ch(t1),
                    u_overlay_scale: new e.cj(t1)
                }),
            clippingMask: (t1)=>({
                    u_matrix: new e.cl(t1)
                }),
            heatmap: (t1)=>({
                    u_extrude_scale: new e.cj(t1),
                    u_intensity: new e.cj(t1),
                    u_matrix: new e.cl(t1),
                    u_inv_rot_matrix: new e.cl(t1),
                    u_merc_center: new e.ck(t1),
                    u_tile_id: new e.ci(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_up_dir: new e.ci(t1)
                }),
            heatmapTexture: (t1)=>({
                    u_image: new e.ch(t1),
                    u_color_ramp: new e.ch(t1),
                    u_opacity: new e.cj(t1)
                }),
            hillshade: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_image: new e.ch(t1),
                    u_latrange: new e.ck(t1),
                    u_light: new e.ck(t1),
                    u_shadow: new e.dB(t1),
                    u_highlight: new e.dB(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_accent: new e.dB(t1)
                }),
            hillshadePrepare: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_image: new e.ch(t1),
                    u_dimension: new e.ck(t1),
                    u_zoom: new e.cj(t1)
                }),
            line: e.dX,
            linePattern: e.dW,
            raster: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_normalize_matrix: new e.cl(t1),
                    u_globe_matrix: new e.cl(t1),
                    u_merc_matrix: new e.cl(t1),
                    u_grid_matrix: new e.dC(t1),
                    u_tl_parent: new e.ck(t1),
                    u_scale_parent: new e.cj(t1),
                    u_fade_t: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_image0: new e.ch(t1),
                    u_image1: new e.ch(t1),
                    u_brightness_low: new e.cj(t1),
                    u_brightness_high: new e.cj(t1),
                    u_saturation_factor: new e.cj(t1),
                    u_contrast_factor: new e.cj(t1),
                    u_spin_weights: new e.ci(t1),
                    u_perspective_transform: new e.ck(t1),
                    u_raster_elevation: new e.cj(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_merc_center: new e.ck(t1),
                    u_cutoff_params: new e.d3(t1),
                    u_colorization_mix: new e.d3(t1),
                    u_colorization_offset: new e.cj(t1),
                    u_color_ramp: new e.ch(t1),
                    u_texture_offset: new e.ck(t1),
                    u_texture_res: new e.ck(t1),
                    u_emissive_strength: new e.cj(t1)
                }),
            rasterParticle: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_normalize_matrix: new e.cl(t1),
                    u_globe_matrix: new e.cl(t1),
                    u_merc_matrix: new e.cl(t1),
                    u_grid_matrix: new e.dC(t1),
                    u_tl_parent: new e.ck(t1),
                    u_scale_parent: new e.cj(t1),
                    u_fade_t: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_image0: new e.ch(t1),
                    u_image1: new e.ch(t1),
                    u_raster_elevation: new e.cj(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_merc_center: new e.ck(t1),
                    u_cutoff_params: new e.d3(t1)
                }),
            rasterParticleTexture: (t1)=>({
                    u_texture: new e.ch(t1),
                    u_opacity: new e.cj(t1)
                }),
            rasterParticleDraw: (t1)=>({
                    u_particle_texture: new e.ch(t1),
                    u_particle_texture_side_len: new e.cj(t1),
                    u_tile_offset: new e.ck(t1),
                    u_velocity: new e.ch(t1),
                    u_color_ramp: new e.ch(t1),
                    u_velocity_res: new e.ck(t1),
                    u_max_speed: new e.cj(t1),
                    u_uv_offset: new e.ck(t1),
                    u_data_scale: new e.ck(t1),
                    u_data_offset: new e.cj(t1),
                    u_particle_pos_scale: new e.cj(t1),
                    u_particle_pos_offset: new e.ck(t1)
                }),
            rasterParticleUpdate: (t1)=>({
                    u_particle_texture: new e.ch(t1),
                    u_particle_texture_side_len: new e.cj(t1),
                    u_velocity: new e.ch(t1),
                    u_velocity_res: new e.ck(t1),
                    u_max_speed: new e.cj(t1),
                    u_speed_factor: new e.cj(t1),
                    u_reset_rate: new e.cj(t1),
                    u_rand_seed: new e.cj(t1),
                    u_uv_offset: new e.ck(t1),
                    u_data_scale: new e.ck(t1),
                    u_data_offset: new e.cj(t1),
                    u_particle_pos_scale: new e.cj(t1),
                    u_particle_pos_offset: new e.ck(t1)
                }),
            symbol: (t1)=>({
                    u_is_size_zoom_constant: new e.ch(t1),
                    u_is_size_feature_constant: new e.ch(t1),
                    u_size_t: new e.cj(t1),
                    u_size: new e.cj(t1),
                    u_camera_to_center_distance: new e.cj(t1),
                    u_rotate_symbol: new e.ch(t1),
                    u_aspect_ratio: new e.cj(t1),
                    u_fade_change: new e.cj(t1),
                    u_matrix: new e.cl(t1),
                    u_label_plane_matrix: new e.cl(t1),
                    u_coord_matrix: new e.cl(t1),
                    u_is_text: new e.ch(t1),
                    u_elevation_from_sea: new e.ch(t1),
                    u_pitch_with_map: new e.ch(t1),
                    u_texsize: new e.ck(t1),
                    u_texsize_icon: new e.ck(t1),
                    u_texture: new e.ch(t1),
                    u_texture_icon: new e.ch(t1),
                    u_gamma_scale: new e.cj(t1),
                    u_device_pixel_ratio: new e.cj(t1),
                    u_tile_id: new e.ci(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_inv_rot_matrix: new e.cl(t1),
                    u_merc_center: new e.ck(t1),
                    u_camera_forward: new e.ci(t1),
                    u_tile_matrix: new e.cl(t1),
                    u_up_vector: new e.ci(t1),
                    u_ecef_origin: new e.ci(t1),
                    u_is_halo: new e.ch(t1),
                    u_icon_transition: new e.cj(t1),
                    u_color_adj_mat: new e.cl(t1),
                    u_scale_factor: new e.cj(t1),
                    u_ground_shadow_factor: new e.ci(t1),
                    u_inv_matrix: new e.cl(t1),
                    u_normal_scale: new e.cj(t1),
                    u_lutTexture: new e.ch(t1)
                }),
            background: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_color: new e.dB(t1)
                }),
            backgroundPattern: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_image: new e.ch(t1),
                    u_pattern_tl: new e.ck(t1),
                    u_pattern_br: new e.ck(t1),
                    u_texsize: new e.ck(t1),
                    u_pattern_size: new e.ck(t1),
                    u_pixel_coord_upper: new e.ck(t1),
                    u_pixel_coord_lower: new e.ck(t1),
                    u_pattern_units_to_pixels: new e.ck(t1)
                }),
            terrainRaster: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_image0: new e.ch(t1),
                    u_image1: new e.ch(t1),
                    u_skirt_height: new e.cj(t1),
                    u_ground_shadow_factor: new e.ci(t1),
                    u_emissive_texture_available: new e.cj(t1)
                }),
            skybox: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_sun_direction: new e.ci(t1),
                    u_cubemap: new e.ch(t1),
                    u_opacity: new e.cj(t1),
                    u_temporal_offset: new e.cj(t1)
                }),
            skyboxGradient: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_color_ramp: new e.ch(t1),
                    u_center_direction: new e.ci(t1),
                    u_radius: new e.cj(t1),
                    u_opacity: new e.cj(t1),
                    u_temporal_offset: new e.cj(t1)
                }),
            skyboxCapture: (t1)=>({
                    u_matrix_3f: new e.dC(t1),
                    u_sun_direction: new e.ci(t1),
                    u_sun_intensity: new e.cj(t1),
                    u_color_tint_r: new e.d3(t1),
                    u_color_tint_m: new e.d3(t1),
                    u_luminance: new e.cj(t1)
                }),
            globeRaster: (t1)=>({
                    u_proj_matrix: new e.cl(t1),
                    u_globe_matrix: new e.cl(t1),
                    u_normalize_matrix: new e.cl(t1),
                    u_merc_matrix: new e.cl(t1),
                    u_zoom_transition: new e.cj(t1),
                    u_merc_center: new e.ck(t1),
                    u_image0: new e.ch(t1),
                    u_image1: new e.ch(t1),
                    u_grid_matrix: new e.dC(t1),
                    u_skirt_height: new e.cj(t1),
                    u_far_z_cutoff: new e.cj(t1),
                    u_frustum_tl: new e.ci(t1),
                    u_frustum_tr: new e.ci(t1),
                    u_frustum_br: new e.ci(t1),
                    u_frustum_bl: new e.ci(t1),
                    u_globe_pos: new e.ci(t1),
                    u_globe_radius: new e.cj(t1),
                    u_viewport: new e.ck(t1),
                    u_emissive_texture_available: new e.cj(t1)
                }),
            globeAtmosphere: (t1)=>({
                    u_frustum_tl: new e.ci(t1),
                    u_frustum_tr: new e.ci(t1),
                    u_frustum_br: new e.ci(t1),
                    u_frustum_bl: new e.ci(t1),
                    u_horizon: new e.cj(t1),
                    u_transition: new e.cj(t1),
                    u_fadeout_range: new e.cj(t1),
                    u_atmosphere_fog_color: new e.d3(t1),
                    u_high_color: new e.d3(t1),
                    u_space_color: new e.d3(t1),
                    u_temporal_offset: new e.cj(t1),
                    u_horizon_angle: new e.cj(t1)
                }),
            model: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_lighting_matrix: new e.cl(t1),
                    u_normal_matrix: new e.cl(t1),
                    u_node_matrix: new e.cl(t1),
                    u_lightpos: new e.ci(t1),
                    u_lightintensity: new e.cj(t1),
                    u_lightcolor: new e.ci(t1),
                    u_camera_pos: new e.ci(t1),
                    u_opacity: new e.cj(t1),
                    u_baseColorFactor: new e.d3(t1),
                    u_emissiveFactor: new e.d3(t1),
                    u_metallicFactor: new e.cj(t1),
                    u_roughnessFactor: new e.cj(t1),
                    u_baseTextureIsAlpha: new e.ch(t1),
                    u_alphaMask: new e.ch(t1),
                    u_alphaCutoff: new e.cj(t1),
                    u_baseColorTexture: new e.ch(t1),
                    u_metallicRoughnessTexture: new e.ch(t1),
                    u_normalTexture: new e.ch(t1),
                    u_occlusionTexture: new e.ch(t1),
                    u_emissionTexture: new e.ch(t1),
                    u_lutTexture: new e.ch(t1),
                    u_color_mix: new e.d3(t1),
                    u_aoIntensity: new e.cj(t1),
                    u_emissive_strength: new e.cj(t1),
                    u_occlusionTextureTransform: new e.d3(t1)
                }),
            modelDepth: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_instance: new e.cl(t1),
                    u_node_matrix: new e.cl(t1)
                }),
            groundShadow: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_ground_shadow_factor: new e.ci(t1)
                }),
            stars: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_up: new e.ci(t1),
                    u_right: new e.ci(t1),
                    u_intensity_multiplier: new e.cj(t1)
                }),
            snowParticle: (t1)=>({
                    u_modelview: new e.cl(t1),
                    u_projection: new e.cl(t1),
                    u_time: new e.cj(t1),
                    u_cam_pos: new e.ci(t1),
                    u_velocityConeAperture: new e.cj(t1),
                    u_velocity: new e.cj(t1),
                    u_horizontalOscillationRadius: new e.cj(t1),
                    u_horizontalOscillationRate: new e.cj(t1),
                    u_boxSize: new e.cj(t1),
                    u_billboardSize: new e.cj(t1),
                    u_simpleShapeParameters: new e.ck(t1),
                    u_screenSize: new e.ck(t1),
                    u_thinningCenterPos: new e.ck(t1),
                    u_thinningShape: new e.ci(t1),
                    u_thinningAffectedRatio: new e.cj(t1),
                    u_thinningParticleOffset: new e.cj(t1),
                    u_particleColor: new e.d3(t1),
                    u_direction: new e.ci(t1)
                }),
            rainParticle: (t1)=>({
                    u_modelview: new e.cl(t1),
                    u_projection: new e.cl(t1),
                    u_time: new e.cj(t1),
                    u_cam_pos: new e.ci(t1),
                    u_texScreen: new e.ch(t1),
                    u_velocityConeAperture: new e.cj(t1),
                    u_velocity: new e.cj(t1),
                    u_boxSize: new e.cj(t1),
                    u_rainDropletSize: new e.ck(t1),
                    u_distortionStrength: new e.cj(t1),
                    u_rainDirection: new e.ci(t1),
                    u_color: new e.d3(t1),
                    u_screenSize: new e.ck(t1),
                    u_thinningCenterPos: new e.ck(t1),
                    u_thinningShape: new e.ci(t1),
                    u_thinningAffectedRatio: new e.cj(t1),
                    u_thinningParticleOffset: new e.cj(t1),
                    u_shapeDirectionalPower: new e.cj(t1),
                    u_shapeNormalPower: new e.cj(t1),
                    u_mode: new e.cj(t1)
                }),
            vignette: (t1)=>({
                    u_vignetteShape: new e.ci(t1),
                    u_vignetteColor: new e.d3(t1)
                }),
            occlusion: (t1)=>({
                    u_matrix: new e.cl(t1),
                    u_anchorPos: new e.ci(t1),
                    u_screenSizePx: new e.ck(t1),
                    u_occluderSizePx: new e.ck(t1),
                    u_color: new e.d3(t1)
                })
        };
        class $r {
            constructor(e, t1, i, o){
                this.id = $r.uniqueIdxCounter, $r.uniqueIdxCounter++, this.context = e;
                const s = e.gl;
                this.buffer = s.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), s.bufferData(s.ELEMENT_ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? s.DYNAMIC_DRAW : s.STATIC_DRAW), this.dynamicDraw || o || t1.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e) {
                this.id = $r.uniqueIdxCounter, $r.uniqueIdxCounter++;
                const t1 = this.context.gl;
                this.context.unbindVAO(), this.bind(), t1.bufferSubData(t1.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        $r.uniqueIdxCounter = 0;
        const Xr = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class Yr {
            constructor(e, t1, i, o, s, r){
                this.length = t1.length, this.attributes = i, this.itemSize = t1.bytesPerElement, this.dynamicDraw = o, this.instanceCount = r, this.context = e;
                const n = e.gl;
                this.buffer = n.createBuffer(), e.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || s || t1.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e) {
                const t1 = this.context.gl;
                this.bind(), t1.bufferSubData(t1.ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            enableAttributes(e, t1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = t1.getAttributeLocation(e, this.attributes[i].name);
                    -1 !== o && e.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const s = this.attributes[o], r = t1.getAttributeLocation(e, s.name);
                    -1 !== r && e.vertexAttribPointer(r, s.components, e[Xr[s.type]], !1, this.itemSize, s.offset + this.itemSize * (i || 0));
                }
            }
            setVertexAttribDivisor(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const s = t1.getAttributeLocation(e, this.attributes[o].name);
                    -1 !== s && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(s, i);
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class Kr {
            constructor(e, t1, i, o, s){
                this.context = e, this.width = t1, this.height = i;
                const r = this.framebuffer = e.gl.createFramebuffer();
                o > 0 && (this.colorAttachment0 = new Gs(e, r, 0)), o > 1 && (this.colorAttachment1 = new Gs(e, r, 1)), s && (this.depthAttachmentType = s, this.depthAttachment = "renderbuffer" === s ? new Hs(e, r) : new qs(e, r));
            }
            createColorAttachment(e, t1) {
                0 === t1 ? this.colorAttachment0 = new Gs(e, this.framebuffer, 0) : 1 === t1 && (this.colorAttachment1 = new Gs(e, this.framebuffer, 1));
            }
            removeColorAttachment(e, t1) {
                const i = this.context.gl;
                let o;
                0 === t1 ? (o = this.colorAttachment0.get(), this.colorAttachment0 = void 0) : 1 === t1 && (o = this.colorAttachment1.get(), this.colorAttachment1 = void 0), o && i.deleteTexture(o);
            }
            destroy() {
                const e = this.context.gl;
                if (this.colorAttachment0) {
                    const t1 = this.colorAttachment0.get();
                    t1 && e.deleteTexture(t1);
                }
                if (this.colorAttachment1) {
                    const t1 = this.colorAttachment1.get();
                    t1 && e.deleteTexture(t1);
                }
                if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
                    const t1 = this.depthAttachment.get();
                    t1 && e.deleteRenderbuffer(t1);
                } else {
                    const t1 = this.depthAttachment.get();
                    t1 && e.deleteTexture(t1);
                }
                e.deleteFramebuffer(this.framebuffer);
            }
        }
        class Jr {
            constructor(e, t1){
                this.gl = e, this.clearColor = new ds(this), this.clearDepth = new us(this), this.clearStencil = new _s(this), this.colorMask = new ps(this), this.depthMask = new fs(this), this.stencilMask = new ms(this), this.stencilFunc = new gs(this), this.stencilOp = new vs(this), this.stencilTest = new ys(this), this.depthRange = new xs(this), this.depthTest = new bs(this), this.depthFunc = new ws(this), this.blend = new Ts(this), this.blendFunc = new Es(this), this.blendColor = new Ss(this), this.blendEquation = new Is(this), this.cullFace = new Cs(this), this.cullFaceSide = new Rs(this), this.frontFace = new As(this), this.program = new Ls(this), this.activeTexture = new Ds(this), this.viewport = new Ps(this), this.bindFramebuffer = new Os(this), this.bindRenderbuffer = new zs(this), this.bindTexture = new Ms(this), this.bindVertexBuffer = new Fs(this), this.bindElementBuffer = new Bs(this), this.bindVertexArrayOES = new ks(this), this.pixelStoreUnpack = new Ns(this), this.pixelStoreUnpackPremultiplyAlpha = new Us(this), this.pixelStoreUnpackFlipY = new js(this), this.options = t1 ? Object.assign({}, t1) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t1 && !!t1.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.extBlendFuncExtended = e.getExtension("WEBGL_blend_func_extended");
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(e, t1, i) {
                return new $r(this, e, t1, i);
            }
            createVertexBuffer(e, t1, i, o, s) {
                return new Yr(this, e, t1, i, o, s);
            }
            createRenderbuffer(e, t1, i) {
                const o = this.gl, s = o.createRenderbuffer();
                return this.bindRenderbuffer.set(s), o.renderbufferStorage(o.RENDERBUFFER, e, t1, i), this.bindRenderbuffer.set(null), s;
            }
            createFramebuffer(e, t1, i, o) {
                return new Kr(this, e, t1, i, o);
            }
            clear({ color: e, depth: t1, stencil: i, colorMask: o }) {
                const s = this.gl;
                let r = 0;
                e && (r |= s.COLOR_BUFFER_BIT, this.clearColor.set(e.toNonPremultipliedRenderColor(null)), this.colorMask.set(o || [
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== t1 && (r |= s.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t1), this.depthMask.set(!0)), void 0 !== i && (r |= s.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), s.clear(r);
            }
            setCullFace(e) {
                !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
            }
            setDepthMode(e) {
                e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e) {
                e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([
                    e.fail,
                    e.depthFail,
                    e.pass
                ]), this.stencilFunc.set({
                    func: e.test.func,
                    ref: e.ref,
                    mask: e.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(t1) {
                e.by(t1.blendFunction, Wi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t1.blendFunction), this.blendColor.set(t1.blendColor), t1.blendEquation ? this.blendEquation.set(t1.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t1.mask);
            }
            unbindVAO() {
                this.bindVertexArrayOES.set(null);
            }
        }
        let Qr;
        function en(t1, i, o, s, r, n, a) {
            const l = t1.context, c = l.gl, h = t1.transform, d = [
                e.aF(h.center.lng),
                e.aJ(h.center.lat)
            ], u = o.layout.get("symbol-placement"), _ = o.layout.get("text-variable-anchor"), p = "map" === o.layout.get("icon-rotation-alignment"), f = "map" === o.layout.get("text-rotation-alignment"), m = "point" !== u, g = [];
            let v = 0, y = 0;
            for(let l = 0; l < s.length; l++){
                const u = s[l], x = i.getTile(u), b = x.getBucket(o);
                if (!b) continue;
                const w = b.getProjection().createInversionMatrix(h, u.canonical), T = [], E = Jt(u, b, h), S = !a && p && m, I = a && f && m, C = _ && b.hasTextData(), R = b.hasIconTextFit() && C && b.hasIconData(), A = S || I || a && C || R, L = "globe" === b.projection.name, D = L ? e.aj(h.zoom) : 0;
                L && (T.push("PROJECTION_GLOBE_VIEW"), A && T.push("PROJECTED_POS_ON_VIEWPORT"));
                const P = t1.getOrCreateProgram("collisionBox", {
                    defines: T
                });
                let O = E;
                0 === r[0] && 0 === r[1] || (O = t1.translatePosMatrix(E, x, r, n));
                const z = a ? b.textCollisionBox : b.iconCollisionBox, M = b.collisionCircleArray;
                if (M.length > 0) {
                    const t1 = e.bC(), i = O;
                    e.cP(t1, b.placementInvProjMatrix, h.glCoordMatrix), e.cP(t1, t1, b.placementViewportMatrix), g.push({
                        circleArray: M,
                        circleOffset: y,
                        transform: i,
                        invTransform: t1,
                        projection: b.getProjection()
                    }), v += M.length / 4, y = v;
                }
                if (!z) continue;
                t1.terrain && t1.terrain.setupElevationDraw(x, P);
                const F = L ? [
                    u.canonical.x,
                    u.canonical.y,
                    1 << u.canonical.z
                ] : [
                    0,
                    0,
                    0
                ];
                P.draw(t1, c.LINES, $i.disabled, Yi.disabled, t1.colorModeForRenderPass(), Qi.disabled, Cr(O, w, h, D, d, x, F, b.getProjection()), o.id, z.layoutVertexBuffer, z.indexBuffer, z.segments, null, h.zoom, null, [
                    z.collisionVertexBuffer,
                    z.collisionVertexBufferExt
                ]);
            }
            if (!a || !g.length) return;
            const x = t1.getOrCreateProgram("collisionCircle"), b = new e.dZ;
            b.resize(4 * v), b._trim();
            let w = 0;
            for (const e of g)for(let t1 = 0; t1 < e.circleArray.length / 4; t1++){
                const i = 4 * t1, o = e.circleArray[i + 0], s = e.circleArray[i + 1], r = e.circleArray[i + 2], n = e.circleArray[i + 3];
                b.emplace(w++, o, s, r, n, 0), b.emplace(w++, o, s, r, n, 1), b.emplace(w++, o, s, r, n, 2), b.emplace(w++, o, s, r, n, 3);
            }
            (!Qr || Qr.length < 2 * v) && (Qr = function(t1) {
                const i = 2 * t1, o = new e.b0;
                o.resize(i), o._trim();
                for(let e = 0; e < i; e++){
                    const t1 = 6 * e;
                    o.uint16[t1 + 0] = 4 * e + 0, o.uint16[t1 + 1] = 4 * e + 1, o.uint16[t1 + 2] = 4 * e + 2, o.uint16[t1 + 3] = 4 * e + 2, o.uint16[t1 + 4] = 4 * e + 3, o.uint16[t1 + 5] = 4 * e + 0;
                }
                return o;
            }(v));
            const T = l.createIndexBuffer(Qr, !0), E = l.createVertexBuffer(b, e.d_.members, !0);
            for (const i of g){
                const s = Rr(i.transform, i.invTransform, h, i.projection);
                x.draw(t1, c.TRIANGLES, $i.disabled, Yi.disabled, t1.colorModeForRenderPass(), Qi.disabled, s, o.id, E, T, e.bg.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            E.destroy(), T.destroy();
        }
        const tn = e.bC();
        function on(t1) {
            const i = t1._camera.getWorldToCamera(t1.worldSize, 1), o = e.aB([], i, t1.globeMatrix);
            e.bl(o, o);
            const s = [
                0,
                0,
                0
            ], r = [
                0,
                1,
                0,
                0
            ];
            return e.aC(r, r, o), s[0] = r[0], s[1] = r[1], s[2] = r[2], e.aw(s, s), s;
        }
        function sn({ width: t1, height: i, anchor: o, textOffset: s, textScale: r }, n) {
            const { horizontalAlign: a, verticalAlign: l } = e.c1(o), c = -(a - .5) * t1, h = -(l - .5) * i, d = e.c2(o, s);
            return new e.P((c / r + d[0]) * n, (h / r + d[1]) * n);
        }
        function rn(t1, i, o, s, r, n, a, l, c, h) {
            const d = t1.text.placedSymbolArray, u = t1.text.dynamicLayoutVertexArray, _ = t1.icon.dynamicLayoutVertexArray, p = {}, f = t1.getProjection(), m = Qt(a, f, r), g = r.elevation, v = f.upVectorScale(a.canonical, r.center.lat, r.worldSize).metersToTile;
            u.clear();
            for(let _ = 0; _ < d.length; _++){
                const y = d.get(_), { tileAnchorX: x, tileAnchorY: b, numGlyphs: w } = y, T = y.hidden || !y.crossTileID || t1.allowVerticalPlacement && !y.placedOrientation ? null : s[y.crossTileID];
                if (T) {
                    let s = 0, d = 0, E = 0;
                    const S = "road" === t1.elevationType;
                    if (g || S) {
                        const i = S ? t1.getElevationFeatureForText(_) : null, o = e.bV.getAtTileOffset(a, new e.P(x, b), g, i), [r, n, l] = f.upVector(a.canonical, x, b);
                        s = o * r * v, d = o * n * v, E = o * l * v;
                    }
                    let [I, C, R, A] = ni(y.projectedAnchorX + s, y.projectedAnchorY + d, y.projectedAnchorZ + E, o ? m : n);
                    const L = ai(r.getCameraToCenterDistance(f), A);
                    let D = e.bM(t1.textSizeData, c, y) * L / e.bY;
                    o && (D *= t1.tilePixelRatio / l);
                    const P = sn(T, D);
                    o ? ({ x: I, y: C, z: R } = f.projectTilePoint(x + P.x, b + P.y, a.canonical), [I, C, R] = ni(I + s, C + d, R + E, n)) : (i && P._rotate(-r.angle), I += P.x, C += P.y, R = 0);
                    const O = t1.allowVerticalPlacement && y.placedOrientation === e.bL.vertical ? Math.PI / 2 : 0;
                    for(let t1 = 0; t1 < w; t1++)e.bO(u, I, C, R, O);
                    h && y.associatedIconIndex >= 0 && (p[y.associatedIconIndex] = {
                        x: I,
                        y: C,
                        z: R,
                        angle: O
                    });
                } else mi(w, u);
            }
            if (h) {
                _.clear();
                const i = t1.icon.placedSymbolArray;
                for(let t1 = 0; t1 < i.length; t1++){
                    const o = i.get(t1), { numGlyphs: s } = o, r = p[t1];
                    if (o.hidden || !r) mi(s, _);
                    else {
                        const { x: t1, y: i, z: o, angle: n } = r;
                        for(let r = 0; r < s; r++)e.bO(_, t1, i, o, n);
                    }
                }
                t1.icon.dynamicLayoutVertexBuffer.updateData(_);
            }
            t1.text.dynamicLayoutVertexBuffer.updateData(u);
        }
        function nn(t1, i, o, s, r, n, a = {}) {
            const l = o.paint.get("icon-translate"), c = o.paint.get("text-translate"), h = o.paint.get("icon-translate-anchor"), d = o.paint.get("text-translate-anchor"), u = o.layout.get("icon-rotation-alignment"), _ = o.layout.get("text-rotation-alignment"), p = o.layout.get("icon-pitch-alignment"), f = o.layout.get("text-pitch-alignment"), m = o.layout.get("icon-keep-upright"), g = o.layout.get("text-keep-upright"), v = o.paint.get("icon-color-saturation"), y = o.paint.get("icon-color-contrast"), x = o.paint.get("icon-color-brightness-min"), b = o.paint.get("icon-color-brightness-max"), w = "sea" === o.layout.get("symbol-elevation-reference"), T = "none" === o.layout.get("icon-image-use-theme"), E = t1.context, S = E.gl, I = t1.transform, C = "map" === u, R = "map" === _, A = "map" === p, L = "map" === f, D = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
            let P = !1;
            const O = t1.depthModeForSublayer(0, $i.ReadOnly), z = new $i(t1.context.gl.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D), M = [
                e.aF(I.center.lng),
                e.aJ(I.center.lat)
            ], F = o.layout.get("text-variable-anchor"), B = "globe" === I.projection.name, k = [], N = [
                0,
                -1,
                0
            ];
            for (const r of s){
                const s = i.getTile(r), n = s.getBucket(o);
                if (!n) continue;
                if ("mercator" === n.projection.name && B) continue;
                if (n.fullyClipped) continue;
                const u = "globe" === n.projection.name, _ = u ? e.aj(I.zoom) : 0, p = Qt(r, n.getProjection(), I), f = I.calculatePixelsToTileUnitsMatrix(s), U = F && n.hasTextData(), j = n.hasIconTextFit() && U && n.hasIconData(), V = n.getProjection().createInversionMatrix(I, r.canonical), G = (1 << s.tileID.canonical.z) * e.al / t1.transform.worldSize, H = (e)=>{
                    let i = [
                        0,
                        0,
                        0
                    ];
                    if (e) {
                        const e = t1.style.directionalLight, o = t1.style.ambientLight;
                        e && o && (i = go(t1.style, e, o));
                    }
                    return i;
                }, q = (e)=>{
                    I.depthOcclusionForSymbolsAndCircles && (o.hasOcclusionOpacityProperties || t1.terrain) && (e.push("DEPTH_D24"), e.push("DEPTH_OCCLUSION"));
                }, Z = (i)=>{
                    o.lut && !T && (o.lut.texture || (o.lut.texture = new e.d$(t1.context, o.lut.image, [
                        o.lut.image.height,
                        o.lut.image.height,
                        o.lut.image.height
                    ], E.gl.RGBA8)), E.activeTexture.set(E.gl.TEXTURE0 + 10), o.lut.texture && o.lut.texture.bind(E.gl.LINEAR, E.gl.CLAMP_TO_EDGE), i.push("APPLY_LUT_ON_GPU"));
                }, W = ()=>{
                    const i = C && "point" !== o.layout.get("symbol-placement"), a = [];
                    q(a), Z(a);
                    const c = i || j, d = "road" === n.elevationType, g = t1.shadowRenderer, T = d && A && !!g && g.enabled, E = H(T), R = d && A && !t1.terrain ? z : O, L = o.paint.get("icon-image-cross-fade");
                    t1.terrainRenderModeElevated() && A && a.push("PITCH_WITH_MAP_TERRAIN"), u && (a.push("PROJECTION_GLOBE_VIEW"), c && a.push("PROJECTED_POS_ON_VIEWPORT")), L > 0 && n.hasAnySecondaryIcon && a.push("ICON_TRANSITION"), !n.icon.zOffsetVertexBuffer || d && t1.terrain || a.push("Z_OFFSET"), 0 === v && 0 === y && 0 === x && 1 === b || a.push("COLOR_ADJUSTMENT"), n.sdfIcons && a.push("RENDER_SDF"), T && a.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), d && A && !t1.terrain && n.icon.orientationVertexBuffer && a.push("ELEVATED_ROADS");
                    const D = n.icon.programConfigurations.get(o.id), P = t1.getOrCreateProgram("symbol", {
                        config: D,
                        defines: a
                    }), F = s.imageAtlasTexture ? s.imageAtlasTexture.size : [
                        0,
                        0
                    ], k = n.iconSizeData, U = e.bK(k, I.zoom), W = A || !I.isOrthographic, $ = oi(p, s.tileID.canonical, A, C, I, n.getProjection(), f), X = ri(p, s.tileID.canonical, A, C, I, n.getProjection(), f), Y = t1.translatePosMatrix(X, s, l, h, !0), K = t1.translatePosMatrix(p, s, l, h), J = c ? tn : $, Q = C && !A && !i;
                    let ee = N;
                    !B && !I.mercatorFromTransition || C || (ee = on(I));
                    const te = u ? ee : N, ie = o.getColorAdjustmentMatrix(v, y, x, b), oe = jr(k.kind, U, Q, A, t1, K, J, Y, w, !1, F, [
                        0,
                        0
                    ], 0, r, _, M, V, te, n.getProjection(), E, G, ie, L, null), se = s.imageAtlasTexture ? s.imageAtlasTexture : null, re = 1 !== o.layout.get("icon-size").constantOr(0) || n.iconsNeedLinear, ne = n.sdfIcons || t1.options.rotating || t1.options.zooming || re || W ? S.LINEAR : S.NEAREST, ae = n.sdfIcons && 0 !== o.paint.get("icon-halo-width").constantOr(1), le = t1.terrain && A && i ? e.bl(e.bC(), $) : tn;
                    if (i && n.icon) {
                        const i = e.bV.getAtTileOffsetFunc(r, I.center.lat, I.worldSize, n.getProjection()), a = si(p, s.tileID.canonical, A, C, I, n.getProjection(), f), l = o.layout.get("icon-size-scale-range"), c = e.aA(t1.scaleFactor, l[0], l[1]);
                        ci(n, p, t1, !1, a, X, A, m, i, r, c);
                    }
                    return {
                        program: P,
                        buffers: n.icon,
                        uniformValues: oe,
                        atlasTexture: se,
                        atlasTextureIcon: null,
                        atlasInterpolation: ne,
                        atlasInterpolationIcon: null,
                        isSDF: n.sdfIcons,
                        hasHalo: ae,
                        depthMode: R,
                        tile: s,
                        renderWithShadows: T,
                        labelPlaneMatrixInv: le
                    };
                }, $ = ()=>{
                    const i = R && "point" !== o.layout.get("symbol-placement"), a = [], l = i || F || j, h = "road" === n.elevationType, m = t1.shadowRenderer, v = h && L && !!m && m.enabled, y = H(v), x = h && L && !t1.terrain ? z : O;
                    t1.terrainRenderModeElevated() && L && a.push("PITCH_WITH_MAP_TERRAIN"), u && (a.push("PROJECTION_GLOBE_VIEW"), l && a.push("PROJECTED_POS_ON_VIEWPORT")), !n.text.zOffsetVertexBuffer || h && t1.terrain || a.push("Z_OFFSET"), n.iconsInText && a.push("RENDER_TEXT_AND_SYMBOL"), a.push("RENDER_SDF"), v && a.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), h && L && !t1.terrain && n.text.orientationVertexBuffer && a.push("ELEVATED_ROADS"), q(a);
                    const b = n.text.programConfigurations.get(o.id), T = t1.getOrCreateProgram("symbol", {
                        config: b,
                        defines: a
                    });
                    let E, C = [
                        0,
                        0
                    ], A = null;
                    const D = n.textSizeData;
                    n.iconsInText && (C = s.imageAtlasTexture ? s.imageAtlasTexture.size : [
                        0,
                        0
                    ], A = s.imageAtlasTexture ? s.imageAtlasTexture : null, E = L || !I.isOrthographic || t1.options.rotating || t1.options.zooming || "composite" === D.kind || "camera" === D.kind ? S.LINEAR : S.NEAREST);
                    const P = s.glyphAtlasTexture ? s.glyphAtlasTexture.size : [
                        0,
                        0
                    ], k = o.layout.get("text-size-scale-range"), U = e.aA(t1.scaleFactor, k[0], k[1]), Z = e.bK(D, I.zoom, U), W = oi(p, s.tileID.canonical, L, R, I, n.getProjection(), f), $ = ri(p, s.tileID.canonical, L, R, I, n.getProjection(), f), X = t1.translatePosMatrix($, s, c, d, !0), Y = t1.translatePosMatrix(p, s, c, d), K = l ? tn : W, J = R && !L && !i;
                    let Q = N;
                    !B && !I.mercatorFromTransition || R || (Q = on(I));
                    const ee = jr(D.kind, Z, J, L, t1, Y, K, X, w, !0, P, C, 0, r, _, M, V, u ? Q : N, n.getProjection(), y, G, null, null, U), te = s.glyphAtlasTexture ? s.glyphAtlasTexture : null, ie = S.LINEAR, oe = 0 !== o.paint.get("text-halo-width").constantOr(1), se = t1.terrain && L && i ? e.bl(e.bC(), W) : tn;
                    if (i && n.text) {
                        const i = e.bV.getAtTileOffsetFunc(r, I.center.lat, I.worldSize, n.getProjection()), o = si(p, s.tileID.canonical, L, R, I, n.getProjection(), f);
                        ci(n, p, t1, !0, o, $, L, g, i, r, U);
                    }
                    return {
                        program: T,
                        buffers: n.text,
                        uniformValues: ee,
                        atlasTexture: te,
                        atlasTextureIcon: A,
                        atlasInterpolation: ie,
                        atlasInterpolationIcon: E,
                        isSDF: !0,
                        hasHalo: oe,
                        depthMode: x,
                        tile: s,
                        renderWithShadows: v,
                        labelPlaneMatrixInv: se
                    };
                }, X = n.icon.segments.get().length, Y = n.text.segments.get().length, K = X && !a.onlyText ? W() : null, J = Y && !a.onlyIcons ? $() : null, Q = o.paint.get("icon-opacity").constantOr(1), ee = o.paint.get("text-opacity").constantOr(1);
                if (D && n.canOverlap) {
                    P = !0;
                    const t1 = Q && !a.onlyText ? n.icon.segments.get() : [], i = ee && !a.onlyIcons ? n.text.segments.get() : [];
                    for (const i of t1)k.push({
                        segments: new e.bg([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: K
                    });
                    for (const t1 of i)k.push({
                        segments: new e.bg([
                            t1
                        ]),
                        sortKey: t1.sortKey,
                        state: J
                    });
                } else a.onlyText || k.push({
                    segments: Q ? n.icon.segments : new e.bg([]),
                    sortKey: 0,
                    state: K
                }), a.onlyIcons || k.push({
                    segments: ee ? n.text.segments : new e.bg([]),
                    sortKey: 0,
                    state: J
                });
            }
            P && k.sort((e, t1)=>e.sortKey - t1.sortKey);
            for (const e of k){
                const i = e.state;
                if (i) if (t1.terrain ? t1.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: I.depthOcclusionForSymbolsAndCircles,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }) : t1.setupDepthForOcclusion(I.depthOcclusionForSymbolsAndCircles, i.program), E.activeTexture.set(S.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, S.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (E.activeTexture.set(S.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, S.CLAMP_TO_EDGE, !0)), i.renderWithShadows && t1.shadowRenderer.setupShadows(i.tile.tileID.toUnwrapped(), i.program, "vector-tile"), t1.uploadCommonLightUniforms(t1.context, i.program), i.hasHalo) {
                    const s = i.uniformValues;
                    s.u_is_halo = 1, an(i.buffers, e.segments, o, t1, i.program, i.depthMode, r, n, s, 2), s.u_is_halo = 0;
                } else {
                    if (i.isSDF) {
                        const s = i.uniformValues;
                        i.hasHalo && (s.u_is_halo = 1, an(i.buffers, e.segments, o, t1, i.program, i.depthMode, r, n, s, 1)), s.u_is_halo = 0;
                    }
                    an(i.buffers, e.segments, o, t1, i.program, i.depthMode, r, n, i.uniformValues, 1);
                }
            }
        }
        function an(e, t1, i, o, s, r, n, a, l, c) {
            const h = [
                e.dynamicLayoutVertexBuffer,
                e.opacityVertexBuffer,
                e.iconTransitioningVertexBuffer,
                e.globeExtVertexBuffer,
                e.zOffsetVertexBuffer,
                e.orientationVertexBuffer
            ];
            s.draw(o, o.context.gl.TRIANGLES, r, n, a, Qi.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t1, i.paint, o.transform.zoom, e.programConfigurations.get(i.id), h, c);
        }
        function ln(t1, i) {
            const o = 1 << t1.canonical.z, s = (i.x * o - t1.canonical.x - t1.wrap * o) * e.al, r = (i.y * o - t1.canonical.y) * e.al, n = e.e8(i.z, i.y);
            return e.d5(s, r, n);
        }
        function cn(t1, i, o, s, r) {
            if (!o.layout || "none" === o.layout.get("fill-elevation-reference") || 0 === o.paint.get("fill-opacity").constantOr(1)) return;
            const n = t1.context.gl, a = new $i(t1.context.gl.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D), l = new $i(t1.context.gl.GREATER, $i.ReadWrite, t1.depthRangeFor3D), c = function(t1) {
                let i = .01;
                return t1.isOrthographic && (i = e.ak(1e-4, i, e.d0(t1.pitch >= ao ? 1 : t1.pitch / ao))), 2 * i;
            }(t1.transform), h = t1.transform.getFreeCameraOptions().position, d = "elevatedStructuresDepthReconstruct", u = t1.getOrCreateProgram(d, {
                defines: [
                    "DEPTH_RECONSTRUCTION"
                ]
            }), _ = t1.getOrCreateProgram(d);
            for (const e of s){
                const s = i.getTile(e), d = s.getBucket(o);
                if (!d) continue;
                const p = d.elevatedStructures;
                if (!p) continue;
                const f = d.elevationBufferData.heightRange, m = ln(e.toUnwrapped(), h), g = t1.translatePosMatrix(e.projMatrix, s, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
                let v, y, x, b;
                if ("initialize" === r) {
                    if (!f || f.min >= 1 || 0 === p.depthSegments.segments[0].primitiveLength) continue;
                    v = Tr(g, m, c, 1, 0), y = a, x = p.depthSegments, b = u;
                } else if ("reset" === r) {
                    if (!f || f.min >= 0 || 0 === p.maskSegments.segments[0].primitiveLength) continue;
                    v = Tr(g, m, 0, 0, 1), y = l, x = p.maskSegments, b = u;
                } else if ("geometry" === r) {
                    if (0 === p.depthSegments.segments[0].primitiveLength) continue;
                    v = Tr(g, m, c, 1, 0), y = a, x = p.depthSegments, b = _;
                }
                b.draw(t1, n.TRIANGLES, y, Yi.disabled, Wi.disabled, Qi.disabled, v, o.id, p.vertexBuffer, p.indexBuffer, x, o.paint, t1.transform.zoom);
            }
        }
        function hn(t1, i, o, s) {
            const { painter: r, sourceCache: n, layer: a, coords: l, colorMode: c, elevationType: h, terrainEnabled: d, pass: u } = t1, _ = r.context.gl, p = a.paint.get("fill-pattern"), f = a.paint.get("fill-pattern-cross-fade"), m = p.constantOr(null);
            let g = h;
            "road" !== h || i && !d || (g = "none");
            const v = "road" === g, y = t1.painter.shadowRenderer, x = v && !!y && y.enabled, b = new $i(r.context.gl.LEQUAL, $i.ReadOnly, r.depthRangeFor3D);
            let w = [
                0,
                0,
                0
            ];
            if (x) {
                const e = r.style.directionalLight, t1 = r.style.ambientLight;
                e && t1 && (w = go(r.style, e, t1));
            }
            const T = p && p.constantOr(1), E = r.terrain && r.terrain.renderingToTexture, S = (t1, u)=>{
                let p, g, S, I, C;
                u ? (p = T && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", S = _.LINES) : (p = T ? "fillPattern" : "fill", S = _.TRIANGLES);
                for (const R of l){
                    const l = n.getTile(R);
                    if (T && !l.patternsLoaded()) continue;
                    const A = l.getBucket(a);
                    if (!A) continue;
                    const L = i ? A.elevationBufferData : A.bufferData;
                    if (L.isEmpty()) continue;
                    r.prepareDrawTile();
                    const D = L.programConfigurations.get(a.id), P = r.isTileAffectedByFog(R), O = [], z = [];
                    v && (O.push("ELEVATED_ROADS"), z.push(L.elevatedLayoutVertexBuffer)), x && O.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), E && o && O.push("USE_MRT1"), T && (r.context.activeTexture.set(_.TEXTURE0), l.imageAtlasTexture && l.imageAtlasTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), D.updatePaintBuffers());
                    let M = !1;
                    if (m && l.imageAtlas) {
                        const t1 = l.imageAtlas, i = e.e3.from(m), o = i.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(), s = i.getSecondary(), r = t1.patternPositions.get(o), n = s ? t1.patternPositions.get(s.scaleSelf(e.o.devicePixelRatio).toString()) : null;
                        M = !!r && !!n, r && D.setConstantPatternPositions(r, n);
                    }
                    f > 0 && (M || D.getPatternTransitionVertexBuffer("fill-pattern")) && O.push("FILL_PATTERN_TRANSITION");
                    const F = r.getOrCreateProgram(p, {
                        config: D,
                        overrideFog: P,
                        defines: O
                    }), B = r.translatePosMatrix(R.projMatrix, l, a.paint.get("fill-translate"), a.paint.get("fill-translate-anchor"));
                    x && y.setupShadows(l.tileID.toUnwrapped(), F, "vector-tile");
                    const k = a.paint.get("fill-emissive-strength");
                    if (u) {
                        I = L.lineIndexBuffer, C = L.lineSegments;
                        const e = r.terrain && r.terrain.renderingToTexture ? r.terrain.drapeBufferSize : [
                            _.drawingBufferWidth,
                            _.drawingBufferHeight
                        ];
                        g = "fillOutlinePattern" === p && T ? xr(B, k, r, l, e, w, f) : yr(B, k, e, w);
                    } else I = L.indexBuffer, C = L.triangleSegments, g = T ? vr(B, k, r, l, w, f) : gr(B, k, w);
                    r.uploadCommonUniforms(r.context, F, R.toUnwrapped());
                    let N = t1;
                    ("road" === h && !d || "offset" === h) && (N = b), F.draw(r, S, N, s || r.stencilModeForClipping(R), c, Qi.disabled, g, a.id, L.layoutVertexBuffer, I, C, a.paint, r.transform.zoom, D, z);
                }
            };
            r.renderPass === u && S(r.depthModeForSublayer(1, "opaque" === r.renderPass ? $i.ReadWrite : $i.ReadOnly), !1), "none" === g && "translucent" === r.renderPass && a.paint.get("fill-antialias") && S(r.depthModeForSublayer(a.getPaintProperty("fill-outline-color") ? 2 : 0, $i.ReadOnly), !0);
        }
        function dn(t1, i, o, s, r, n, a, l) {
            o.resetLayerRenderingStats(t1);
            const c = t1.context, h = c.gl, d = t1.transform, u = o.paint.get("fill-extrusion-pattern"), _ = o.paint.get("fill-extrusion-pattern-cross-fade"), p = u.constantOr(null), f = u.constantOr(1), m = o.paint.get("fill-extrusion-opacity"), g = t1.style.enable3dLights(), v = o.paint.get(g && !f ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), y = [
                o.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                v
            ], x = o.layout.get("fill-extrusion-edge-radius"), b = x > 0 && !o.paint.get("fill-extrusion-rounded-roof"), w = b ? 0 : x, T = "globe" === d.projection.name ? e.eb() : 0, E = "globe" === d.projection.name, S = E ? e.aj(d.zoom) : 0, I = [
                e.aF(d.center.lng),
                e.aJ(d.center.lat)
            ], C = "none" === o.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), R = o.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(C ? null : o.lut).toArray01().slice(0, 3), A = o.paint.get("fill-extrusion-flood-light-intensity"), L = o.paint.get("fill-extrusion-vertical-scale"), D = 0 !== o.paint.get("fill-extrusion-line-width").constantOr(1), P = o.paint.get("fill-extrusion-height-alignment"), O = o.paint.get("fill-extrusion-base-alignment"), z = co(t1, o.paint.get("fill-extrusion-cutoff-fade-range")), M = [];
            let F;
            E && M.push("PROJECTION_GLOBE_VIEW"), y[0] > 0 && M.push("FAUX_AO"), b && M.push("ZERO_ROOF_RADIUS"), l && M.push("HAS_CENTROID"), A > 0 && M.push("FLOOD_LIGHT"), z.shouldRenderCutoff && M.push("RENDER_CUTOFF"), D && M.push("RENDER_WALL_MODE");
            const B = "shadow" === t1.renderPass, k = t1.shadowRenderer, N = B && !!k, U = B ? Qi.disabled : Qi.backCCW;
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !0);
            let j = [
                0,
                0,
                0
            ];
            if (k) {
                const e = t1.style.directionalLight, i = t1.style.ambientLight;
                e && i && (j = go(t1.style, e, i)), B || (M.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), k.useNormalOffset && M.push("NORMAL_OFFSET")), F = M.concat([
                    "SHADOWS_SINGLE_CASCADE"
                ]);
            }
            const V = N ? "fillExtrusionDepth" : f ? "fillExtrusionPattern" : "fillExtrusion", G = o.getLayerRenderingStats();
            for (const u of s){
                const s = i.getTile(u), g = s.getBucket(o);
                if (!g || g.projection.name !== d.projection.name) continue;
                let v = !1;
                k && (v = 0 === k.getMaxCascadeForTile(u.toUnwrapped()));
                const x = t1.isTileAffectedByFog(u), b = g.programConfigurations.get(o.id);
                let C = !1;
                if (p && s.imageAtlas) {
                    const t1 = s.imageAtlas, i = e.e3.from(p), o = i.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(), r = i.getSecondary(), n = t1.patternPositions.get(o), a = r ? t1.patternPositions.get(r.scaleSelf(e.o.devicePixelRatio).toString()) : null;
                    C = !!n && !!a, n && b.setConstantPatternPositions(n, a);
                }
                _ > 0 && (C || b.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && M.push("FILL_EXTRUSION_PATTERN_TRANSITION");
                const N = t1.getOrCreateProgram(V, {
                    config: b,
                    defines: v ? F : M,
                    overrideFog: x
                });
                if (t1.terrain && t1.terrain.setupElevationDraw(s, N, {
                    useMeterToDem: !0
                }), !g.centroidVertexBuffer) {
                    const e = N.getAttributeLocation(h, "a_centroid_pos");
                    -1 !== e && h.vertexAttrib2f(e, 0, 0);
                }
                !B && k && k.setupShadows(s.tileID.toUnwrapped(), N, "vector-tile"), f && (t1.context.activeTexture.set(h.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), b.updatePaintBuffers());
                const H = o.paint.get("fill-extrusion-vertical-gradient"), q = 1 / g.tileToMeter;
                let Z;
                if (B && k) {
                    if (vn(s.tileID, g.maxHeight, t1)) continue;
                    const e = k.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());
                    Z = fr(e, w, q, L, P, O);
                } else {
                    const e = t1.translatePosMatrix(u.expandedProjMatrix, s, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), i = d.projection.createInversionMatrix(d, u.canonical);
                    Z = f ? mr(e, t1, H, m, y, w, q, u, s, T, P, O, S, I, i, R, L, _) : pr(e, t1, H, m, y, w, q, u, T, P, O, S, I, i, R, L, A, j);
                }
                t1.uploadCommonUniforms(c, N, u.toUnwrapped(), null, z);
                let W = g.segments;
                if ("mercator" === d.projection.name && !B && (W = g.getVisibleSegments(s.tileID, t1.terrain, t1.transform.getFrustum(0)), !W.get().length)) continue;
                if (G) if (B) for (const e of W.get())G.numRenderedVerticesInShadowPass += e.primitiveLength;
                else for (const e of W.get())G.numRenderedVerticesInTransparentPass += e.primitiveLength;
                const $ = [];
                (t1.terrain || l) && $.push(g.centroidVertexBuffer), E && $.push(g.layoutVertexExtBuffer), D && $.push(g.wallVertexBuffer), N.draw(t1, c.gl.TRIANGLES, r, n, a, U, Z, o.id, g.layoutVertexBuffer, g.indexBuffer, W, o.paint, t1.transform.zoom, b, $);
            }
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !1);
        }
        class un {
            constructor(){
                this.translate = [
                    0,
                    0
                ], this.translateAnchor = "map", this.edgeRadius = 0, this.cutoffFadeRange = 0;
            }
        }
        function _n(t1, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {
            const b = i.context, w = b.gl, T = i.transform, E = i.transform.zoom, S = [], I = t1.translate, C = t1.translateAnchor, R = t1.edgeRadius, A = co(i, t1.cutoffFadeRange);
            "clear" === d ? (S.push("CLEAR_SUBPASS"), x && (S.push("CLEAR_FROM_TEXTURE"), b.activeTexture.set(w.TEXTURE0), x.bind(w.LINEAR, w.CLAMP_TO_EDGE))) : "sdf" === d ? S.push("SDF_SUBPASS") : "emissive" === d && (S.push("USE_MRT1"), b.activeTexture.set(w.TEXTURE0), x.bind(w.LINEAR, w.CLAMP_TO_EDGE)), v && S.push("HAS_CENTROID"), A.shouldRenderCutoff && S.push("RENDER_CUTOFF");
            const L = (e, t1, o, r, d)=>{
                let y = S;
                null != t1.groundRadiusBuffer && (y = S.concat("HAS_ATTRIBUTE_a_flood_light_ground_radius"));
                const w = t1.programConfigurations.get(s.id), T = i.isTileAffectedByFog(e), I = i.getOrCreateProgram("fillExtrusionGroundEffect", {
                    config: w,
                    defines: y,
                    overrideFog: T
                }), C = ((e, t1, i, o, s, r, n, a, l, c, h)=>({
                        u_matrix: t1,
                        u_opacity: i,
                        u_ao_pass: o ? 1 : 0,
                        u_meter_to_tile: s,
                        u_ao: r,
                        u_flood_light_intensity: n,
                        u_flood_light_color: a,
                        u_attenuation: l,
                        u_edge_radius: c,
                        u_fb: 0,
                        u_fb_size: h,
                        u_dynamic_offset: 1
                    }))(0, r, u, h, d, [
                    _,
                    p * d
                ], f, m, g, E >= 17 ? 0 : R * d, x ? x.size[0] : 0), L = [];
                v && L.push(t1.hiddenByLandmarkVertexBuffer), null != t1.groundRadiusBuffer && L.push(t1.groundRadiusBuffer), i.uploadCommonUniforms(b, I, e.toUnwrapped(), null, A), I.draw(i, b.gl.TRIANGLES, n, a, l, c, C, s.id, t1.vertexBuffer, t1.indexBuffer, o, s.paint, E, w, L);
            };
            for (const t1 of r){
                const r = o.getTile(t1), n = r.getBucket(s);
                if (!n || n.projection.name !== T.projection.name || !n.groundEffect || n.groundEffect && !n.groundEffect.hasData()) continue;
                const a = n.groundEffect, l = 1 / n.tileToMeter;
                {
                    const e = i.translatePosMatrix(t1.projMatrix, r, I, C), o = a.getDefaultSegment();
                    L(t1, a, o, e, l);
                }
                if (y) for(let n = 0; n < 4; n++){
                    const a = e.e9[n](t1), c = o.getTile(a);
                    if (!c) continue;
                    const h = c.getBucket(s);
                    if (!h || h.projection.name !== T.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;
                    const d = h.groundEffect;
                    let u, _;
                    0 === n ? (u = [
                        -e.al,
                        0,
                        0
                    ], _ = 1) : 1 === n ? (u = [
                        e.al,
                        0,
                        0
                    ], _ = 0) : 2 === n ? (u = [
                        0,
                        -e.al,
                        0
                    ], _ = 3) : (u = [
                        0,
                        e.al,
                        0
                    ], _ = 2);
                    const p = d.regionSegments[_];
                    if (!p) continue;
                    const f = new Float32Array(16);
                    e.br(f, t1.projMatrix, u), L(t1, d, p, i.translatePosMatrix(f, r, I, C), l);
                }
            }
        }
        function pn(t1, i, o, s, r, n, a) {
            0 === s.centroidVertexArray.length && s.createCentroidsBuffer();
            const l = n ? n.findDEMTileFor(o) : null;
            if (!(l && l.dem || a)) return;
            n && l && l.dem && s.selfDEMTileTimestamp !== l.dem._timestamp && (s.borderDoneWithNeighborZ = [
                -1,
                -1,
                -1,
                -1
            ], s.selfDEMTileTimestamp = l.dem._timestamp);
            const c = (t1, i)=>{
                (t1.flags | i.flags) & e.ec ? (t1.flags |= e.ec, i.flags |= e.ec) : (t1.flags &= ~e.ec, i.flags &= ~e.ec);
            }, h = (t1)=>new e.P(Math.ceil((t1 + e.ed) * e.ee), 0), d = (e)=>{
                const t1 = i.getSource().minzoom, o = (e)=>{
                    const t1 = i.getTileByID(e);
                    if (t1 && t1.hasData()) return t1.getBucket(r);
                }, s = [
                    0,
                    -1,
                    1
                ];
                for (const i of s){
                    if (e.overscaledZ + i < t1) continue;
                    const s = o(e.calculateScaledKey(e.overscaledZ + i));
                    if (s) return s;
                }
            }, u = [
                0,
                0,
                0
            ], _ = (t1, i)=>(u[0] = Math.min(t1.min.y, i.min.y), u[1] = Math.max(t1.max.y, i.max.y), u[2] = e.al - i.min.x > t1.max.x ? i.min.x - e.al : t1.max.x, u), p = (t1, i)=>(u[0] = Math.min(t1.min.x, i.min.x), u[1] = Math.max(t1.max.x, i.max.x), u[2] = e.al - i.min.y > t1.max.y ? i.min.y - e.al : t1.max.y, u), f = [
                (e, t1)=>_(e, t1),
                (e, t1)=>_(t1, e),
                (e, t1)=>p(e, t1),
                (e, t1)=>p(t1, e)
            ], m = (t1, i, s, r, a, c, h)=>{
                if (!n) return 0;
                const d = [
                    [
                        c ? s : t1,
                        c ? t1 : s,
                        0
                    ],
                    [
                        c ? s : i,
                        c ? i : s,
                        0
                    ]
                ], u = h < 0 ? e.al + h : h, _ = [
                    c ? u : (t1 + i) / 2,
                    c ? (t1 + i) / 2 : u,
                    0
                ];
                return 0 === s && h < 0 || 0 !== s && h > 0 ? n.getForTilePoints(a, [
                    _
                ], !0, r) : d.push(_), n.getForTilePoints(o, d, !0, l), Math.max(d[0][2], d[1][2], _[2]) / n.exaggeration();
            };
            for(let t1 = 0; t1 < 4; t1++){
                const i = s.borderFeatureIndices[t1];
                if (0 === i.length) continue;
                const r = e.e9[t1](o), l = d(r);
                if (!(l && l instanceof e.ea)) continue;
                const u = n ? n.findDEMTileFor(r) : null;
                if (!(u && u.dem || a)) continue;
                if (n && u && u.dem && s.borderDEMTileTimestamp[t1] !== u.dem._timestamp && (s.borderDoneWithNeighborZ[t1] = -1, s.borderDEMTileTimestamp[t1] = u.dem._timestamp), s.borderDoneWithNeighborZ[t1] === l.canonical.z) continue;
                0 === l.centroidVertexArray.length && l.createCentroidsBuffer();
                const _ = (t1 < 2 ? 1 : 5) - t1, p = l.borderDoneWithNeighborZ[_] !== s.canonical.z, g = l.borderFeatureIndices[_];
                let v = 0;
                if (s.canonical.z !== l.canonical.z) {
                    for (const e of i)s.showCentroid(s.featuresOnBorder[e]);
                    if (p) for (const e of g)l.showCentroid(l.featuresOnBorder[e]);
                    s.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[_] = s.canonical.z;
                }
                for (const o of i){
                    const i = s.featuresOnBorder[o], n = s.centroidData[i.centroidDataIndex], d = i.borders[t1];
                    let p;
                    for(; v < g.length;){
                        p = l.featuresOnBorder[g[v]];
                        const e = p.borders[_];
                        if (e[1] > d[0] + 3 || e[0] > d[0] - 3) break;
                        l.showCentroid(p), v++;
                    }
                    if (p && v < g.length) {
                        const o = v;
                        let y = 0;
                        for(; !(p.borders[_][0] > d[1] - 3) && (y++, ++v !== g.length);)p = l.featuresOnBorder[g[v]];
                        p = l.featuresOnBorder[g[o]];
                        let x = !1;
                        if (y >= 1) {
                            const e = p.borders[_];
                            Math.abs(d[0] - e[0]) < 3 && Math.abs(d[1] - e[1]) < 3 && (y = 1, x = !0, v = o + 1);
                        } else if (0 === y) {
                            s.showCentroid(i);
                            continue;
                        }
                        const b = l.centroidData[p.centroidDataIndex];
                        a && x && c(n, b);
                        const w = i.intersectsCount() > 1 || p.intersectsCount() > 1;
                        if (y > 1) v = o, n.centroidXY = b.centroidXY = new e.P(0, 0);
                        else if (u && u.dem && !w) {
                            const i = f[t1](n, b), o = t1 % 2 ? e.al - 1 : 0, s = m(i[0], Math.min(e.al - 1, i[1]), o, u, r, t1 < 2, i[2]);
                            n.centroidXY = b.centroidXY = h(s);
                        } else w ? n.centroidXY = b.centroidXY = new e.P(0, 0) : (n.centroidXY = s.encodeBorderCentroid(i), b.centroidXY = l.encodeBorderCentroid(p));
                        s.writeCentroidToBuffer(n), l.writeCentroidToBuffer(b);
                    } else s.showCentroid(i);
                }
                s.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[_] = s.canonical.z;
            }
            (s.needsCentroidUpdate || !s.centroidVertexBuffer && 0 !== s.centroidVertexArray.length) && s.uploadCentroid(t1);
        }
        const fn = [
            1,
            0,
            0
        ], mn = [
            0,
            1,
            0
        ], gn = [
            0,
            0,
            1
        ];
        function vn(t1, i, o) {
            const s = o.transform, r = o.shadowRenderer;
            if (!r) return !0;
            const n = t1.toUnwrapped(), a = s.tileSize * r._cascades[o.currentShadowCascade].scale;
            let l = i;
            if (s.elevation) {
                const e = s.elevation.getMinMaxForTile(t1);
                e && (l += e.max);
            }
            const c = [
                ...r.shadowDirection
            ];
            c[2] = -c[2];
            const h = r.computeSimplifiedTileShadowVolume(n, l, a, c);
            if (!h) return !1;
            const d = [
                fn,
                mn,
                gn,
                c,
                [
                    c[0],
                    0,
                    c[2]
                ],
                [
                    0,
                    c[1],
                    c[2]
                ]
            ], u = "globe" === s.projection.name, _ = s.scaleZoom(a), p = e.cB.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, _, !u), f = r.getCurrentCascadeFrustum();
            return 0 === p.intersectsPrecise(h.vertices, h.planes, d) || 0 === f.intersectsPrecise(h.vertices, h.planes, d);
        }
        function yn(t1) {
            const { painter: i, source: o, layer: s, coords: r } = t1;
            let n = t1.defines;
            const a = i.context, l = "shadow" === i.renderPass, c = "light-beam" === i.renderPass, h = i.shadowRenderer, d = e.ef(i.transform.center.lat, i.transform.zoom), u = co(i, s.paint.get("building-cutoff-fade-range"));
            u.shouldRenderCutoff && (n = n.concat("RENDER_CUTOFF")), t1.floodLightIntensity > 0 && (n = n.concat("FLOOD_LIGHT"));
            for (const _ of r){
                const r = o.getTile(_), p = r.getBucket(s);
                if (!p) continue;
                h && 0 === h.getMaxCascadeForTile(_.toUnwrapped()) && (n = n.concat("SHADOWS_SINGLE_CASCADE"));
                const f = p.programConfigurations.get(s.id);
                let m, g, v, y = i.translatePosMatrix(_.expandedProjMatrix, r, [
                    0,
                    0
                ], "map");
                if (y = e.cS(e.bC(), y, [
                    1,
                    1,
                    t1.verticalScale
                ]), l && h) {
                    if (vn(r.tileID, p.maxHeight * d, i)) continue;
                    let o = h.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());
                    o = e.cS(e.bC(), o, [
                        1,
                        1,
                        t1.verticalScale
                    ]), v = Ir(o), m = g = i.getOrCreateProgram("buildingDepth", {
                        config: f,
                        defines: n,
                        overrideFog: !1
                    });
                } else if (c) m = g = i.getOrCreateProgram("buildingBloom", {
                    config: f,
                    defines: n,
                    overrideFog: !1
                }), v = Sr(y);
                else {
                    const o = i.transform.calculatePosMatrix(_.toUnwrapped(), i.transform.worldSize);
                    e.cS(o, o, [
                        1,
                        1,
                        t1.verticalScale
                    ]);
                    const s = e.bC();
                    e.cS(s, o, [
                        1,
                        -1,
                        1 / d
                    ]), e.bl(s, s), e.eg(s, s);
                    const r = i.transform.getFreeCameraOptions().position, a = 1 << _.canonical.z;
                    if (v = Er(y, s, t1.opacity, t1.facadeAOIntensity, [
                        ((r.x - _.wrap) * a - _.canonical.x) * e.al,
                        (r.y * a - _.canonical.y) * e.al,
                        r.z * a * e.al
                    ], p.tileToMeter, t1.facadeEmissiveChance, t1.floodLightColor, t1.floodLightIntensity), g = i.getOrCreateProgram("building", {
                        config: f,
                        defines: n,
                        overrideFog: !1
                    }), !0 === t1.depthOnly) m = g;
                    else {
                        const e = n.concat([
                            "BUILDING_FAUX_FACADE",
                            "HAS_ATTRIBUTE_a_faux_facade_color_emissive"
                        ]);
                        m = i.getOrCreateProgram("building", {
                            config: f,
                            defines: e,
                            overrideFog: !1
                        });
                    }
                    h && (h.setupShadowsFromMatrix(o, g, !0), m !== g && h.setupShadowsFromMatrix(o, m, !0));
                }
                const x = (e, o)=>{
                    if (c) {
                        const r = e.entranceBloom;
                        o.draw(i, a.gl.TRIANGLES, t1.depthMode, Yi.disabled, t1.blendMode, Qi.disabled, v, s.id, r.layoutVertexBuffer, r.indexBuffer, r.segmentsBucket, s.paint, i.transform.zoom, f, [
                            r.layoutAttenuationBuffer,
                            r.layoutColorBuffer
                        ]);
                    } else {
                        const r = e.segmentsBucket;
                        let n = [
                            e.layoutNormalBuffer,
                            e.layoutCentroidBuffer,
                            e.layoutColorBuffer,
                            e.layoutFloodLightDataBuffer
                        ];
                        e.layoutFacadePaintBuffer && (n = n.concat([
                            e.layoutFacadeDataBuffer,
                            e.layoutFacadeVerticalRangeBuffer,
                            e.layoutFacadePaintBuffer
                        ])), o.draw(i, a.gl.TRIANGLES, t1.depthMode, Yi.disabled, t1.blendMode, l ? Qi.disabled : Qi.backCW, v, s.id, e.layoutVertexBuffer, e.indexBuffer, r, s.paint, i.transform.zoom, f, n);
                    }
                };
                i.uploadCommonUniforms(a, g, _.toUnwrapped(), null, u), p.buildingWithoutFacade && x(p.buildingWithoutFacade, g), p.buildingWithFacade && (m !== g && i.uploadCommonUniforms(a, m, _.toUnwrapped(), null, u), x(p.buildingWithFacade, m));
            }
        }
        function xn(t1, i, o, s, r, n, a, l, c, h, d, u, _) {
            const p = t1.context.gl, f = t1.depthModeForSublayer(1, $i.ReadOnly, p.LEQUAL, !0), m = .1 * (1 - (g = d)) + 3 * g;
            var g;
            const v = t1._showOverdrawInspector, y = u, x = new un;
            v || _n(x, t1, i, o, s, f, new Yi({
                func: p.ALWAYS,
                mask: 255
            }, 255, 255, p.KEEP, p.KEEP, p.REPLACE), new Wi([
                p.ONE,
                p.ONE,
                p.ONE,
                p.ONE
            ], e.ao.transparent, [
                !1,
                !1,
                !1,
                !0
            ], p.MIN), Qi.disabled, r, "sdf", n, a, l, c, h, m, y, !1);
            {
                const d = v ? Yi.disabled : new Yi({
                    func: p.EQUAL,
                    mask: 255
                }, 255, 255, p.KEEP, p.DECR, p.DECR), u = v ? t1.colorModeForRenderPass() : new Wi([
                    p.ONE_MINUS_DST_ALPHA,
                    p.DST_ALPHA,
                    p.ONE,
                    p.ONE
                ], e.ao.transparent, [
                    !0,
                    !0,
                    !0,
                    !0
                ]);
                _n(x, t1, i, o, s, f, d, u, Qi.disabled, r, "color", n, a, l, c, h, m, y, !1);
            }
        }
        function bn(t1) {
            return [
                t1[0] * e.eh,
                t1[1] * e.eh,
                t1[2] * e.eh,
                0
            ];
        }
        function wn(t1, i, o, s, r, n, a, l, c) {
            const h = s.getSource(), d = o.globeSharedBuffers;
            if (!d) return;
            let u, _, p;
            if (i && (u = s.getTile(i)), h instanceof e.aU ? (_ = h.texture, p = e.dK(0, 0, o.transform)) : u && i && (_ = u.texture, p = e.dK(i.canonical.z, i.canonical.x, o.transform)), !_ || !p) return;
            t1 || (p = e.cS(e.bC(), p, [
                1,
                -1,
                1
            ]));
            const f = o.context, m = f.gl, g = "nearest" === r.paint.get("raster-resampling") ? m.NEAREST : m.LINEAR, v = o.colorModeForDrapableLayerRenderPass(n), y = a.defines;
            y.push("GLOBE_POLES");
            const x = new $i(m.LEQUAL, $i.ReadWrite, o.depthRangeFor3D), b = Float32Array.from(o.transform.expandedFarZProjMatrix), w = Float32Array.from(e.bk(e.dJ(new e.cD(0, 0, 0))));
            o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), _.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), _.bind(g, m.CLAMP_TO_EDGE), "useMipmap" in _ && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);
            const [T, E, S, I] = i ? d.getPoleBuffers(i.canonical.z, !1) : d.getPoleBuffers(0, !0), C = r.paint.get("raster-elevation");
            let R;
            t1 ? (R = T, o.renderDefaultNorthPole = 0 !== C) : (R = E, o.renderDefaultSouthPole = 0 !== C);
            const A = bn(a.mix), L = ((e, t1, i, o, s, r, n, a, l, c, h, d, u)=>zr(e, t1, i, new Float32Array(16), new Float32Array(9), [
                    0,
                    0
                ], o, [
                    0,
                    0
                ], [
                    0,
                    0,
                    0,
                    0
                ], 1, {
                    opacity: 1,
                    mix: 0
                }, r, [
                    0,
                    0
                ] || [
                    0,
                    0
                ], a, 2, c, h, d, 1, 0, u))(b, w, p, e.aj(o.transform.zoom), 0, r, 0, C, 0, A, a.offset, a.range, n), D = o.getOrCreateProgram("raster", {
                defines: y
            });
            o.uploadCommonUniforms(f, D, null), D.draw(o, m.TRIANGLES, x, c, v, l, L, r.id, R, S, I);
        }
        function Tn(e) {
            if (e.isOrthographic) return [
                0,
                0,
                0,
                0
            ];
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, s = .2 * e.height, r = t1 + s;
            return [
                t1,
                i,
                (r - s - t1) / o,
                (r - t1) / o
            ];
        }
        function En(e, t1, i, o) {
            if (e) return t1 instanceof pt && e instanceof Ot ? t1.getTextureDescriptor(e, i, !0) : {
                texture: e.texture,
                mix: bn(o.mix),
                offset: o.offset,
                buffer: 0,
                tileSize: 1
            };
        }
        var Sn = e.ei([
            {
                name: "a_index",
                type: "Int16",
                components: 1
            }
        ]);
        class In {
            constructor(t1, i, o, s){
                const r = {
                    width: o[0],
                    height: o[1],
                    data: null
                }, n = t1.gl;
                this.targetColorTexture = new e.T(t1, r, n.RGBA8, {
                    useMipmap: !1
                }), this.backgroundColorTexture = new e.T(t1, r, n.RGBA8, {
                    useMipmap: !1
                }), this.context = t1, this.updateParticleTexture(i, s), this.lastInvalidatedAt = 0;
            }
            updateParticleTexture(t1, i) {
                if (this.particleTextureDimension === i.width) return;
                (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
                const o = this.context.gl, s = i.width * i.height;
                this.particleTexture0 = new e.T(this.context, i, o.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1
                }), this.particleTexture1 = new e.T(this.context, i, o.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1
                });
                const r = new e.ej;
                r.reserve(s);
                for(let e = 0; e < s; e++)r.emplaceBack(e);
                this.particleIndexBuffer = this.context.createVertexBuffer(r, Sn.members, !0), this.particleSegment = e.bg.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i.width;
            }
            update(t1) {
                return !(this.lastInvalidatedAt < t1 && (this.lastInvalidatedAt = e.o.now(), 1));
            }
            destroy() {
                this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
            }
        }
        function Cn(t1, i, o) {
            if (!t1) return null;
            const s = i.getTextureDescriptor(t1, o, !0);
            if (!s) return null;
            let { texture: r, mix: n, offset: a, tileSize: l, buffer: c, format: h } = s;
            if (!r || !h) return null;
            let d = !1;
            return "uint32" === h && (d = !0, n[3] = 0, n = Pr(e.ek, n, [
                0,
                o.paint.get("raster-particle-max-speed")
            ]), a = Or(e.ek, a, [
                0,
                o.paint.get("raster-particle-max-speed")
            ])), {
                texture: r,
                textureOffset: [
                    c / (l + 2 * c),
                    l / (l + 2 * c)
                ],
                tileSize: l,
                scalarData: d,
                scale: n,
                offset: a,
                defines: [
                    "RASTER_ARRAY",
                    {
                        uint8: "DATA_FORMAT_UINT8",
                        uint16: "DATA_FORMAT_UINT16",
                        uint32: "DATA_FORMAT_UINT32"
                    }[h]
                ]
            };
        }
        function Rn(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, s = .2 * e.height, r = t1 + s;
            return [
                t1,
                i,
                (r - s - t1) / o,
                (r - t1) / o
            ];
        }
        const An = new e.ao(1, 0, 0, 1), Ln = new e.ao(0, 1, 0, 1), Dn = new e.ao(0, 0, 1, 1), Pn = new e.ao(1, 0, 1, 1), On = new e.ao(0, 1, 1, 1);
        function zn(t1, i, o, s, r, n) {
            for(let a = 0; a < o.length; a++)if (r) {
                const r = 1, l = .8, c = new e.ao(s.r * l, s.g * l, s.b * l, 1);
                Mn(t1, i, o[a], s, -r, -r, n), Mn(t1, i, o[a], s, -r, r, n), Mn(t1, i, o[a], s, r, r, n), Mn(t1, i, o[a], s, r, -r, n), Mn(t1, i, o[a], c, 0, 0, n);
            } else Mn(t1, i, o[a], s, 0, 0, n);
        }
        function Mn(t1, i, o, s, r, n, a) {
            const l = t1.context, c = t1.transform, h = l.gl, d = "globe" === c.projection.name, u = d ? [
                "PROJECTION_GLOBE_VIEW"
            ] : [];
            let _ = e.bz(o.projMatrix);
            if (d && e.aj(c.zoom) > 0) {
                const t1 = e.bj(o.canonical, c), i = e.el(t1);
                _ = e.aB(new Float32Array(16), c.globeMatrix, i), e.aB(_, c.projMatrix, _);
            }
            const p = e.bC();
            p[12] += 2 * r / (e.o.devicePixelRatio * c.width), p[13] += 2 * n / (e.o.devicePixelRatio * c.height), e.aB(_, p, _);
            const f = t1.getOrCreateProgram("debug", {
                defines: u
            }), m = i.getTileByID(o.key);
            t1.terrain && t1.terrain.setupElevationDraw(m, f);
            const g = $i.disabled, v = Yi.disabled, y = t1.colorModeForRenderPass(), x = "$debug";
            l.activeTexture.set(h.TEXTURE0), t1.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), d ? m._makeGlobeTileDebugBuffers(t1.context, c) : m._makeDebugTileBoundsBuffers(t1.context, c.projection);
            const b = m._tileDebugBuffer || t1.debugBuffer, w = m._tileDebugIndexBuffer || t1.debugIndexBuffer, T = m._tileDebugSegments || t1.debugSegments;
            if (f.draw(t1, h.LINE_STRIP, g, v, y, Qi.disabled, Ar(_, s.toPremultipliedRenderColor(null)), x, b, w, T, null, null, null, [
                m._globeTileDebugBorderBuffer
            ]), a) {
                const e = m.latestRawTileData, i = Math.floor((e && e.byteLength || 0) / 1024);
                let s = o.canonical.toString();
                o.overscaledZ !== o.canonical.z && (s += ` => ${o.overscaledZ}`), s += ` ${m.state}`, s += ` ${i}kb`, function(e, t1) {
                    e.initDebugOverlayCanvas();
                    const i = e.debugOverlayCanvas, o = e.context.gl, s = e.debugOverlayCanvas.getContext("2d");
                    s.clearRect(0, 0, i.width, i.height), s.shadowColor = "white", s.shadowBlur = 2, s.lineWidth = 1.5, s.strokeStyle = "white", s.textBaseline = "top", s.font = "bold 36px Open Sans, sans-serif", s.fillText(t1, 5, 5), s.strokeText(t1, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
                }(t1, s);
            }
            const E = i.getTile(o).tileSize, S = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5, I = m._tileDebugTextBuffer || t1.debugBuffer, C = m._tileDebugTextIndexBuffer || t1.quadTriangleIndexBuffer, R = m._tileDebugTextSegments || t1.debugSegments;
            f.draw(t1, h.TRIANGLES, g, v, Wi.alphaBlended, Qi.disabled, Ar(_, e.ao.transparent.toPremultipliedRenderColor(null), S), x, I, C, R, null, null, null, [
                m._globeTileDebugTextBuffer
            ]);
        }
        function Fn(e, t1, i, o) {
            kn(e, 0, t1 + i / 2, e.transform.width, i, o);
        }
        function Bn(e, t1, i, o) {
            kn(e, t1 - i / 2, 0, i, e.transform.height, o);
        }
        function kn(t1, i, o, s, r, n) {
            const a = t1.context, l = a.gl;
            l.enable(l.SCISSOR_TEST), l.scissor(i * e.o.devicePixelRatio, o * e.o.devicePixelRatio, s * e.o.devicePixelRatio, r * e.o.devicePixelRatio), a.clear({
                color: n
            }), l.disable(l.SCISSOR_TEST);
        }
        const Nn = e.ei([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: Un } = Nn;
        function jn(e, t1, i, o) {
            e.emplaceBack(t1, i, o);
        }
        class Vn {
            constructor(t1){
                this.vertexArray = new e.em, this.indices = new e.b0, jn(this.vertexArray, -1, -1, 1), jn(this.vertexArray, 1, -1, 1), jn(this.vertexArray, -1, 1, 1), jn(this.vertexArray, 1, 1, 1), jn(this.vertexArray, -1, -1, -1), jn(this.vertexArray, 1, -1, -1), jn(this.vertexArray, -1, 1, -1), jn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, Un), this.indexBuffer = t1.createIndexBuffer(this.indices), this.segment = e.bg.simpleSegment(0, 0, 36, 12);
            }
        }
        function Gn(t1, i, o, s, r, n) {
            const a = t1.context.gl, l = i.paint.get("sky-atmosphere-color"), c = i.paint.get("sky-atmosphere-halo-color"), h = i.paint.get("sky-atmosphere-sun-intensity"), d = ((e, t1, i, o, s)=>({
                    u_matrix_3f: e,
                    u_sun_direction: t1,
                    u_sun_intensity: i,
                    u_color_tint_r: [
                        o.r,
                        o.g,
                        o.b,
                        o.a
                    ],
                    u_color_tint_m: [
                        s.r,
                        s.g,
                        s.b,
                        s.a
                    ],
                    u_luminance: 5e-5
                }))(e.eo(e.dO(), s), r, h, l.toPremultipliedRenderColor(null), c.toPremultipliedRenderColor(null));
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + n, i.skyboxTexture, 0), o.draw(t1, a.TRIANGLES, $i.disabled, Yi.disabled, Wi.unblended, Qi.frontCW, d, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const Hn = e.ei([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class qn {
            constructor(t1){
                const i = new e.ep;
                i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
                const o = new e.b0;
                o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t1.createVertexBuffer(i, Hn.members), this.indexBuffer = t1.createIndexBuffer(o), this.segments = e.bg.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const Zn = e.ei([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_size_scale",
                components: 1
            },
            {
                type: "Float32",
                name: "a_fade_opacity",
                components: 1
            }
        ]);
        class Wn {
            constructor(){
                this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;
            }
        }
        class $n {
            constructor(t1){
                this.colorModeAlphaBlendedWriteRGB = new Wi([
                    1,
                    Zi,
                    1,
                    Zi
                ], e.ao.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ]), this.colorModeWriteAlpha = new Wi([
                    1,
                    0,
                    1,
                    0
                ], e.ao.transparent, [
                    !1,
                    !1,
                    !1,
                    !0
                ]), this.params = new Wn, this.updateNeeded = !0;
            }
            update(t1) {
                const i = t1.context;
                if (!this.atmosphereBuffer || this.updateNeeded) {
                    this.updateNeeded = !1, this.atmosphereBuffer = new qn(i);
                    const t1 = this.params.sizeRange, o = this.params.intensityRange, s = function(t1) {
                        const i = e.eq(30), o = [];
                        for(let s = 0; s < t1; ++s){
                            const t1 = 2 * Math.PI * i(), s = Math.acos(1 - 2 * i()) - .5 * Math.PI;
                            o.push(e.d5(Math.cos(s) * Math.cos(t1), Math.cos(s) * Math.sin(t1), Math.sin(s)));
                        }
                        return o;
                    }(this.params.starsCount), r = e.eq(300), n = new e.er, a = new e.b0;
                    let l = 0;
                    for(let i = 0; i < s.length; ++i){
                        const c = e.c5([], s[i], 200), h = Math.max(0, 1 + .01 * t1 * (1 * r() - .5)), d = Math.max(0, 1 + .01 * o * (1 * r() - .5));
                        n.emplaceBack(c[0], c[1], c[2], -1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, 1, h, d), n.emplaceBack(c[0], c[1], c[2], -1, 1, h, d), a.emplaceBack(l + 0, l + 1, l + 2), a.emplaceBack(l + 0, l + 2, l + 3), l += 4;
                    }
                    this.starsVx = i.createVertexBuffer(n, Zn.members), this.starsIdx = i.createIndexBuffer(a), this.starsSegments = e.bg.simpleSegment(0, 0, n.length, a.length);
                }
            }
            destroy() {
                this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
            }
            drawAtmosphereGlow(t1, i) {
                const o = t1.context, s = o.gl, r = t1.transform, n = new $i(s.LEQUAL, $i.ReadOnly, [
                    0,
                    1
                ]), a = e.aj(r.zoom), l = t1.style.getLut(i.scope), c = "none" === i.properties.get("color-use-theme"), h = i.properties.get("color").toNonPremultipliedRenderColor(c ? null : l), d = "none" === i.properties.get("high-color-use-theme"), u = i.properties.get("high-color").toNonPremultipliedRenderColor(d ? null : l), _ = "none" === i.properties.get("space-color-use-theme"), p = i.properties.get("space-color").toNonPremultipliedRenderColor(_ ? null : l), f = 5e-4, m = e.es(i.properties.get("horizon-blend"), 0, 1, f, .25), g = e.dE(t1, o, r) && m === f ? r.worldSize / (2 * Math.PI * 1.025) - 1 : r.globeRadius, v = t1.frameCounter / 1e3 % 1, y = e.ag(r.globeCenterInViewSpace), x = Math.sqrt(Math.pow(y, 2) - Math.pow(g, 2)), b = Math.acos(x / y), w = (e)=>{
                    const i = "globe" === r.projection.name ? [
                        "PROJECTION_GLOBE_VIEW",
                        "FOG"
                    ] : [
                        "FOG"
                    ];
                    e && i.push("ALPHA_PASS");
                    const l = t1.getOrCreateProgram("globeAtmosphere", {
                        defines: i
                    }), c = ((e, t1, i, o, s, r, n, a, l, c, h, d)=>({
                            u_frustum_tl: e,
                            u_frustum_tr: t1,
                            u_frustum_br: i,
                            u_frustum_bl: o,
                            u_horizon: s,
                            u_transition: r,
                            u_fadeout_range: n,
                            u_atmosphere_fog_color: a.toArray01(),
                            u_high_color: l.toArray01(),
                            u_space_color: c.toArray01(),
                            u_temporal_offset: h,
                            u_horizon_angle: d
                        }))(r.frustumCorners.TL, r.frustumCorners.TR, r.frustumCorners.BR, r.frustumCorners.BL, r.frustumCorners.horizon, a, m, h, u, p, v, b);
                    t1.uploadCommonUniforms(o, l);
                    const d = this.atmosphereBuffer;
                    d && l.draw(t1, s.TRIANGLES, n, Yi.disabled, e ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Qi.backCW, c, e ? "atmosphere_glow_alpha" : "atmosphere_glow", d.vertexBuffer, d.indexBuffer, d.segments);
                };
                w(!1), w(!0);
            }
            drawStars(t1, i) {
                const o = e.aA(i.properties.get("star-intensity"), 0, 1);
                if (0 === o) return;
                const s = t1.context, r = s.gl, n = t1.transform, a = t1.getOrCreateProgram("stars"), l = e.c7([]);
                e.c9(l, l, -n._pitch), e.c8(l, l, -n.angle), e.c9(l, l, e.an(n._center.lat)), e.et(l, l, -e.an(n._center.lng));
                const c = e.cc(new Float32Array(16), l), h = e.aB([], n.starsProjMatrix, c), d = e.eo([], c), u = e.eu([], d), _ = [
                    0,
                    1,
                    0
                ];
                e.dQ(_, _, u), e.c5(_, _, this.params.sizeMultiplier);
                const p = [
                    1,
                    0,
                    0
                ];
                e.dQ(p, p, u), e.c5(p, p, this.params.sizeMultiplier);
                const f = (m = _, g = p, v = o, {
                    u_matrix: Float32Array.from(h),
                    u_up: m,
                    u_right: g,
                    u_intensity_multiplier: v
                });
                var m, g, v;
                t1.uploadCommonUniforms(s, a), this.starsVx && this.starsIdx && a.draw(t1, r.TRIANGLES, $i.disabled, Yi.disabled, this.colorModeAlphaBlendedWriteRGB, Qi.disabled, f, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
            }
        }
        class Xn {
            constructor(){
                this.visibleTiles = [];
            }
            updateBorders(t1, i) {
                const o = [], s = [], r = t1._getRenderableCoordinates(!1, !0);
                for (const e of r){
                    const r = t1.getTile(e);
                    if (!r.hasData()) continue;
                    const n = r.getBucket(i);
                    n && (n.isEmpty() || (o.push(e.key), s.push({
                        bucket: n,
                        tileID: e.canonical
                    })));
                }
                let n = o.length !== this.visibleTiles.length;
                if (!n) {
                    o.sort();
                    for(let e = 0; e < o.length; e++)if (o[e] !== this.visibleTiles[e]) {
                        n = !0;
                        break;
                    }
                }
                if (!n) return;
                const a = new Set;
                this.visibleTiles = o, s.sort((e, t1)=>e.tileID.z - t1.tileID.z || e.tileID.x - t1.tileID.x || e.tileID.y - t1.tileID.y);
                for (const t1 of s){
                    const i = new Array, o = new Array, s = t1.bucket;
                    for (const e of s.featuresOnBorder)a.has(e.featureId) ? o.push(e.footprintIndex) : (a.add(e.featureId), i.push(e.footprintIndex));
                    s.updateFootprintHiddenFlags(i, e.ev, !1), s.updateFootprintHiddenFlags(o, e.ev, !0);
                }
            }
        }
        function Yn(t1, i) {
            const o = [
                ...t1
            ], s = i.cameraWorldSizeForFog / i.worldSize, r = e.bA([]);
            return e.cS(r, r, [
                s,
                s,
                1
            ]), e.aB(o, r, o), e.aB(o, i.worldToFogMatrix, o), o;
        }
        function Kn(t1, i, o, s, r) {
            const n = o.material, a = s.context, { baseColorTexture: l, metallicRoughnessTexture: c } = n.pbrMetallicRoughness, { normalTexture: h, occlusionTexture: d, emissionTexture: u } = n;
            function _(e, i, o) {
                if (e && (t1.push(i), a.activeTexture.set(a.gl.TEXTURE0 + o), e.gfxTexture)) {
                    const { minFilter: t1, magFilter: i, wrapS: o, wrapT: s } = e.sampler;
                    e.gfxTexture.bindExtraParam(t1, i, o, s);
                }
            }
            _(l, "HAS_TEXTURE_u_baseColorTexture", 5), _(c, "HAS_TEXTURE_u_metallicRoughnessTexture", 6), _(h, "HAS_TEXTURE_u_normalTexture", 7), _(d, "HAS_TEXTURE_u_occlusionTexture", 8), _(u, "HAS_TEXTURE_u_emissionTexture", 9), r && (r.texture || (r.texture = new e.d$(s.context, r.image, [
                r.image.height,
                r.image.height,
                r.image.height
            ], a.gl.RGBA8)), a.activeTexture.set(a.gl.TEXTURE0 + 10), r.texture && r.texture.bind(a.gl.LINEAR, a.gl.CLAMP_TO_EDGE), t1.push("APPLY_LUT_ON_GPU")), o.texcoordBuffer && (t1.push("HAS_ATTRIBUTE_a_uv_2f"), i.push(o.texcoordBuffer)), o.colorBuffer && (t1.push(12 === o.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i.push(o.colorBuffer)), o.normalBuffer && (t1.push("HAS_ATTRIBUTE_a_normal_3f"), i.push(o.normalBuffer)), o.pbrBuffer && (t1.push("HAS_ATTRIBUTE_a_pbr"), t1.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i.push(o.pbrBuffer)), "OPAQUE" !== n.alphaMode && "MASK" !== n.alphaMode || t1.push("UNPREMULT_TEXTURE_IN_SHADER"), n.defined || t1.push("DIFFUSE_SHADED");
            const p = s.shadowRenderer;
            p && (t1.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p.useNormalOffset && t1.push("NORMAL_OFFSET"));
        }
        function Jn(t1, i, o, s, r, n) {
            const a = t1.modelOpacity, l = i.context, c = new $i(i.context.gl.LEQUAL, t1.isLightMesh ? $i.ReadOnly : $i.ReadWrite, i.depthRangeFor3D), h = i.transform, d = t1.mesh, u = d.material, _ = u.pbrMetallicRoughness, p = i.style.fog;
            let f;
            f = "pixels" === i.transform.projection.zAxisUnit ? [
                ...t1.nodeModelMatrix
            ] : e.aB([], s.zScaleMatrix, t1.nodeModelMatrix), e.aB(f, s.negCameraPosMatrix, f);
            const m = e.bl([], f);
            e.eg(m, m);
            const g = "none" === o.paint.get("model-color-use-theme").constantOr("default"), v = o.paint.get("model-emissive-strength").constantOr(0), y = qr(new Float32Array(t1.worldViewProjection), new Float32Array(f), new Float32Array(m), null, i, a, _.baseColorFactor, u.emissiveFactor, _.metallicFactor, _.roughnessFactor, u, v, o, void 0, void 0, t1.materialOverride, t1.modelColor), x = {
                defines: []
            }, b = [], w = i.shadowRenderer;
            w && (w.useNormalOffset = !1), Kn(x.defines, b, d, i, g ? null : o.lut);
            let T = null;
            if (p) {
                const e = Yn(t1.nodeModelMatrix, i.transform);
                if (T = new Float32Array(e), "globe" !== h.projection.name) {
                    const t1 = d.aabb.min, i = d.aabb.max, [o, s] = p.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                    x.overrideFog = o >= Ve || s >= Ve;
                }
            }
            const E = co(i, o.paint.get("model-cutoff-fade-range"));
            E.shouldRenderCutoff && x.defines.push("RENDER_CUTOFF");
            const S = i.getOrCreateProgram("model", x);
            i.uploadCommonUniforms(l, S, null, T, E), "shadow" !== i.renderPass && w && w.setupShadowsFromMatrix(t1.nodeModelMatrix, S), S.draw(i, l.gl.TRIANGLES, c, r, n, d.material.doubleSided ? Qi.disabled : Qi.backCCW, y, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, i.transform.zoom, void 0, b);
        }
        function Qn(e, t1) {
            return e.style._importedAsBasemap ? "basemap" : t1.scope;
        }
        function ea(t1, i, o, s, r, n, a, l, c, h) {
            const d = t1.transform, u = !!i.isGeometryBloom && i.isGeometryBloom;
            if (u && "shadow" === t1.renderPass) return;
            const _ = "globe" === d.projection.name ? e.eD(o, d) : [
                ...o
            ];
            e.aB(_, _, i.globalMatrix);
            const p = e.aB([], s, _);
            if (i.meshes) for (const t1 of i.meshes){
                const i = l.get(t1.material.name);
                if (i && i.opacity <= 0) continue;
                if ("BLEND" !== t1.material.alphaMode) {
                    a.push({
                        mesh: t1,
                        depth: 0,
                        modelIndex: r,
                        worldViewProjection: p,
                        nodeModelMatrix: _,
                        isLightMesh: u,
                        materialOverride: i,
                        modelOpacity: c,
                        modelColor: h
                    });
                    continue;
                }
                const o = e.af([], t1.centroid, p);
                !d.isOrthographic && o[2] <= 0 || n.push({
                    mesh: t1,
                    depth: o[2],
                    modelIndex: r,
                    worldViewProjection: p,
                    nodeModelMatrix: _,
                    isLightMesh: u,
                    materialOverride: i,
                    modelOpacity: c,
                    modelColor: h
                });
            }
            if (i.children) for (const e of i.children)ea(t1, e, o, s, r, n, a, l, c, h);
        }
        function ta(e, t1, i, o) {
            const s = i.shadowRenderer;
            if (!s) return;
            const r = s.getShadowPassDepthMode(), n = s.getShadowPassColorMode(), a = s.calculateShadowPassMatrixFromMatrix(t1), l = Zr(a);
            i.getOrCreateProgram("modelDepth", {
                defines: i._shadowMapDebug ? [] : [
                    "DEPTH_TEXTURE"
                ]
            }).draw(i, i.context.gl.TRIANGLES, r, Yi.disabled, n, Qi.disabled, l, o.id, e.vertexBuffer, e.indexBuffer, e.segments, o.paint, i.transform.zoom, void 0, void 0);
        }
        function ia(e, t1, i, o, s, r) {
            for (const n of s){
                const s = Object.assign({}, o);
                s.part = n;
                const a = {
                    type: "Unknown",
                    id: t1,
                    properties: s
                }, l = {
                    orientation: e.paint.get("model-rotation").evaluate(a, i)
                };
                r.set(n, l);
            }
        }
        function oa(e, t1, i, o, s, r) {
            for (const n of s){
                const s = Object.assign({}, o);
                s.part = n;
                const a = {
                    type: "Unknown",
                    id: t1,
                    properties: s
                }, l = {
                    color: e.paint.get("model-color").evaluate(a, i),
                    colorMix: e.paint.get("model-color-mix-intensity").evaluate(a, i),
                    opacity: e.paint.get("model-opacity").evaluate(a, i),
                    emissionStrength: e.paint.get("model-emissive-strength").evaluate(a, i)
                };
                r.set(n, l);
            }
        }
        function sa(e, t1, i, o, s) {
            let r = !1;
            for (const i of o)1 !== i.modelOpacity && (Jn(i, e, t1, s[i.modelIndex], Yi.disabled, Wi.disabled), r = !0);
            for (const i of o)Jn(i, e, t1, s[i.modelIndex], 1 !== i.modelOpacity ? e.stencilModeFor3D() : Yi.disabled, e.colorModeForRenderPass());
            r && e.resetStencilClippingMasks();
            const n = Wi.additive;
            for (const o of i)Jn(o, e, t1, s[o.modelIndex], Yi.disabled, o.isLightMesh ? n : e.colorModeForRenderPass());
        }
        function ra(t1, i, o) {
            const s = i.updateZoomBasedPaintProperties(), r = function(t1, i, o) {
                let s, r, n, a = t1.terrain ? t1.terrain.exaggeration() : 0;
                if (t1.terrain && a > 0) {
                    const i = t1.terrain, r = i.findDEMTileFor(o);
                    r && r.dem ? s = e.eF.create(i, o, r) : a = 0;
                }
                if (0 === a && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), a === i.validForExaggeration && (0 === a || s && s._demTile && s._demTile.tileID === i.validForDEMTile.id && s._dem._timestamp === i.validForDEMTile.timestamp)) return !1;
                for(const e in i.instancesPerModel){
                    const t1 = i.instancesPerModel[e];
                    for(let e = 0; e < t1.instancedDataArray.length; ++e){
                        const o = (s ? a * s.getElevationAt(0 | t1.instancedDataArray.float32[16 * e], 0 | t1.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t1.instancesEvaluatedElevation[e];
                        t1.instancedDataArray.float32[16 * e + 6] = o, r = r ? Math.min(i.terrainElevationMin, o) : o, n = n ? Math.max(i.terrainElevationMax, o) : o;
                    }
                }
                return i.terrainElevationMin = r || 0, i.terrainElevationMax = n || 0, i.validForExaggeration = a, i.validForDEMTile = s && s._demTile ? {
                    id: s._demTile.tileID,
                    timestamp: s._dem._timestamp
                } : {
                    id: void 0,
                    timestamp: 0
                }, !0;
            }(t1, i, o);
            (s || r) && (i.uploaded = !1, i.upload(t1.context));
        }
        const na = {
            shadowUniformsInitialized: !1,
            useSingleShadowCascade: !1,
            tileMatrix: new Float64Array(16),
            shadowTileMatrix: new Float32Array(16),
            aabb: new e.d9([
                0,
                0,
                0
            ], [
                e.al,
                e.al,
                0
            ])
        };
        function aa(t1, i) {
            const o = 1 << t1.canonical.z, s = i.getFreeCameraOptions().position, r = i.elevation, n = t1.canonical.x / o, a = (t1.canonical.x + 1) / o, l = t1.canonical.y / o, c = (t1.canonical.y + 1) / o;
            let h = i._centerAltitude;
            if (r) {
                const e = r.getMinMaxForTile(t1);
                e && e.max > h && (h = e.max);
            }
            const d = e.aA(s.x, n, a) - s.x, u = e.aA(s.y, l, c) - s.y, _ = e.cf(h, i.center.lat) - s.z;
            return i._zoomFromMercatorZ(Math.sqrt(d * d + u * u + _ * _));
        }
        function la(e, t1, i, o, s, r, n) {
            const a = e.context, l = "shadow" === e.renderPass, c = e.shadowRenderer, h = l && c ? c.getShadowPassDepthMode() : new $i(a.gl.LEQUAL, $i.ReadWrite, e.depthRangeFor3D), d = e.isTileAffectedByFog(r), u = "globe" === e.transform.projection.name;
            if (i.meshes) for (const _ of i.meshes){
                const p = u ? [] : [
                    "MODEL_POSITION_ON_GPU"
                ], f = [];
                let m, g, v;
                const y = !u && o.instancedDataArray.length > 20;
                y && p.push("INSTANCED_ARRAYS");
                const x = co(e, t1.paint.get("model-cutoff-fade-range"));
                if (x.shouldRenderCutoff && p.push("RENDER_CUTOFF"), l && c) m = e.getOrCreateProgram("modelDepth", {
                    defines: p
                }), g = Zr(n.shadowTileMatrix, n.shadowTileMatrix, Float32Array.from(i.globalMatrix)), v = c.getShadowPassColorMode();
                else {
                    Kn(p, f, _, e, "none" === t1.paint.get("model-color-use-theme").constantOr("default") ? null : t1.lut), m = e.getOrCreateProgram("model", {
                        defines: p,
                        overrideFog: d
                    });
                    const o = _.material, l = o.pbrMetallicRoughness, h = t1.paint.get("model-opacity").constantOr(1), u = t1.paint.get("model-emissive-strength").constantOr(0);
                    g = qr(r.expandedProjMatrix, Float32Array.from(i.globalMatrix), new Float32Array(16), null, e, h, l.baseColorFactor, o.emissiveFactor, l.metallicFactor, l.roughnessFactor, o, u, t1, s), c && (n.shadowUniformsInitialized ? m.setShadowUniformValues(a, c.getShadowUniformValues()) : (c.setupShadows(r.toUnwrapped(), m, "model-tile"), n.shadowUniformsInitialized = !0)), v = x.shouldRenderCutoff || h < 1 || "OPAQUE" !== o.alphaMode ? Wi.alphaBlended : Wi.unblended;
                }
                e.uploadCommonUniforms(a, m, r.toUnwrapped(), null, x);
                const b = _.material.doubleSided ? Qi.disabled : Qi.backCCW;
                if (y) f.push(o.instancedDataBuffer), m.draw(e, a.gl.TRIANGLES, h, Yi.disabled, v, b, g, t1.id, _.vertexBuffer, _.indexBuffer, _.segments, t1.paint, e.transform.zoom, void 0, f, o.instancedDataArray.length);
                else {
                    const i = l ? "u_instance" : "u_normal_matrix";
                    for(let s = 0; s < o.instancedDataArray.length; ++s)g[i] = new Float32Array(o.instancedDataArray.arrayBuffer, 64 * s, 16), m.draw(e, a.gl.TRIANGLES, h, Yi.disabled, v, b, g, t1.id, _.vertexBuffer, _.indexBuffer, _.segments, t1.paint, e.transform.zoom, void 0, f);
                }
            }
            if (i.children) for (const a of i.children)la(e, t1, a, o, s, r, n);
        }
        const ca = [
            1,
            -1,
            1
        ];
        function ha(t1, i, o, s) {
            if (!o.modelManager) return !0;
            const r = o.modelManager;
            if (!o.shadowRenderer) return !0;
            const n = o.shadowRenderer, a = i.aabb;
            let l = !0, c = t1.maxHeight;
            if (0 === c) {
                let e = 0;
                for(const i in t1.instancesPerModel){
                    const t1 = r.getModel(i, s);
                    t1 ? e = Math.max(e, Math.max(Math.max(t1.aabb.max[0], t1.aabb.max[1]), t1.aabb.max[2])) : l = !1;
                }
                c = t1.maxScale * e * 1.41 + t1.maxVerticalOffset, l && (t1.maxHeight = c);
            }
            a.max[2] = c, a.min[2] += t1.terrainElevationMin, a.max[2] += t1.terrainElevationMax, e.af(a.min, a.min, i.tileMatrix), e.af(a.max, a.max, i.tileMatrix);
            const h = a.intersects(n.getCurrentCascadeFrustum());
            return 0 === o.currentShadowCascade && (t1.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;
        }
        function da(t1, i) {
            const o = t1.uniformValues.u_cutoff_params[0], s = t1.uniformValues.u_cutoff_params[1], r = t1.uniformValues.u_cutoff_params[2], n = t1.uniformValues.u_cutoff_params[3];
            return s === o || n === r ? 1 : e.aA(((i - o) / (s - o) - r) / (n - r), 0, 1);
        }
        function ua(t1, i, o, s) {
            if (i.pitch < 20) return 1;
            const r = i.getWorldToCameraMatrix();
            e.aB(r, r, t1);
            const n = e.bU(o.min[0], o.min[1], o.min[2], 1);
            let a = e.aC(e.eG(), n, r), l = a, c = a;
            n[1] = o.max[1], a = e.aC(e.eG(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[0] = o.max[0], a = e.aC(e.eG(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[1] = o.min[1], a = e.aC(e.eG(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c;
            const h = e.aA(s[0], 0, 1), d = 100 * i.pixelsPerMeter * e.aA(s[1], 0, 1), u = e.aA(s[2], 0, 1), _ = e.eH(e.eG(), l, c, h), p = Math.tan(.5 * i.fovX), f = -_[2] * p;
            if (0 === d) return _[1] < -Math.abs(f) ? u : 1;
            const m = (-Math.abs(f) - _[1]) / d, g = (e, t1, i)=>(1 - i) * e + i * t1, v = e.aA(g(1, u, m), u, 1);
            return g(1, v, e.aA((i.pitch - 20) / 20, 0, 1));
        }
        class _a {
        }
        class pa {
            constructor(){
                this._storage = new Map;
            }
            getLinesFromTrianglesBuffer(t1, i, o) {
                {
                    const e = this._storage.get(i.id);
                    if (e) return e.lastUsedFrameIdx = t1, e.buf;
                }
                const s = o.gl, r = s.getBufferParameter(s.ELEMENT_ARRAY_BUFFER, s.BUFFER_SIZE), n = new ArrayBuffer(r), a = new Int16Array(n);
                s.getBufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n));
                const l = new e.eJ;
                for(let e = 0; e < r / 2; e += 3){
                    const t1 = a[e], i = a[e + 1], o = a[e + 2];
                    l.emplaceBack(t1, i), l.emplaceBack(i, o), l.emplaceBack(o, t1);
                }
                const c = o.bindVertexArrayOES.current, h = new _a;
                return h.buf = new $r(o, l), h.lastUsedFrameIdx = t1, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;
            }
            update(e) {
                for (const [t1, i] of this._storage)e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t1));
            }
            destroy() {
                for (const [e, t1] of this._storage)t1.buf.destroy(), this._storage.delete(e);
            }
        }
        class fa {
            constructor(){
                this.occluderSize = 30, this.depthOffset = -1e-4;
            }
        }
        const ma = e.ei([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_rainParticleData",
                components: 4
            }
        ]);
        class ga {
            constructor(e){
                this.revealStart = 11, this.revealRange = 2;
            }
        }
        const va = e.ei([
            {
                type: "Float32",
                name: "a_pos_2f",
                components: 2
            }
        ]);
        class ya {
            destroy() {
                this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
            }
            draw(t1, i) {
                const o = t1.getOrCreateProgram("vignette");
                if (!this.vignetteVx || !this.vignetteIdx) {
                    const i = new e.eK, o = new e.b0;
                    i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1), o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), this.vignetteVx = t1.context.createVertexBuffer(i, va.members), this.vignetteIdx = t1.context.createIndexBuffer(o);
                }
                const s = e.bg.simpleSegment(0, 0, 4, 6);
                if (this.vignetteVx && this.vignetteIdx) {
                    t1.uploadCommonUniforms(t1.context, o);
                    const e = {
                        u_vignetteShape: (r = {
                            vignetteShape: [
                                i.start,
                                i.range,
                                Math.pow(10, i.fadePower)
                            ],
                            vignetteColor: [
                                i.color.r,
                                i.color.g,
                                i.color.b,
                                i.color.a * i.strength
                            ]
                        }).vignetteShape,
                        u_vignetteColor: r.vignetteColor
                    };
                    o.draw(t1, t1.context.gl.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, e, "vignette", this.vignetteVx, this.vignetteIdx, s);
                }
                var r;
            }
        }
        class xa {
            constructor(){
                this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            }
            update(t1, i) {
                const o = t1.getFreeCameraOptions().position, s = o.toAltitude(), r = o.toLngLat(), n = e.an(r.lng), a = e.an(r.lat), l = t1.pixelsPerMeter / i, c = n * e.eM, h = e.eM * Math.log(Math.tan(Math.PI / 4 + a / 2));
                if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
                else {
                    const e = -this._offsetYPrev + h, t1 = -this._elevationPrev + s;
                    this._accumulatedOffsetX += (-this._offsetXPrev + c) * l, this._accumulatedOffsetY += e * l, this._accumulatedElevation += t1 * l, this._offsetXPrev = c, this._offsetYPrev = h, this._elevationPrev = s;
                }
            }
            getPosition() {
                return [
                    this._accumulatedOffsetX,
                    this._accumulatedOffsetY,
                    this._accumulatedElevation
                ];
            }
        }
        function ba(e, t1) {
            return [
                -(e[0] - Math.floor(e[0] / t1) * t1),
                -(e[1] - Math.floor(e[1] / t1) * t1),
                -(e[2] - Math.floor(e[2] / t1) * t1)
            ];
        }
        function wa(t1) {
            const i = e.eq(1323123451230), o = [];
            for(let s = 0; s < t1; ++s){
                const t1 = 2 * i() - 1, s = 2 * i() - 1, r = 2 * i() - 1;
                o.push(e.d5(t1, s, r));
            }
            return o;
        }
        function Ta(t1, i, o, s, r) {
            const n = e.aA((r - o) / (s - o), 0, 1);
            return (1 - n) * t1 + n * i;
        }
        class Ea {
            constructor(e){
                this._movement = new xa, this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new ya, this._ppmScaleFactor = e;
            }
            destroy() {
                this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
            }
            updateOnRender(t1, i) {
                const o = t1.transform;
                this._movement.update(o, this._ppmScaleFactor);
                const s = o.starsProjMatrix, r = e.c7([]);
                e.c9(r, r, e.an(90) - o._pitch), e.c8(r, r, -o.angle);
                const n = e.cc(new Float32Array(16), r), a = e.eL(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l = e.eg([], a), c = e.aB([], l, n), h = Date.now() / 1e3;
                return this._accumulatedTimeFromStart += (h - this._prevTime) * i, this._prevTime = h, {
                    projectionMatrix: s,
                    modelviewMatrix: c
                };
            }
        }
        class Sa extends Ea {
            constructor(e){
                super(4.25), this._params = {
                    overrideStyleParameters: !1,
                    intensity: .5,
                    timeFactor: 1,
                    velocityConeAperture: 0,
                    velocity: 300,
                    boxSize: 2500,
                    dropletSizeX: 1,
                    dropletSizeYScale: 10,
                    distortionStrength: 70,
                    screenThinning: {
                        intensity: .57,
                        start: .46,
                        range: 1.17,
                        fadePower: .17,
                        affectedRatio: 1,
                        particleOffset: -.2
                    },
                    color: {
                        r: .66,
                        g: .68,
                        b: .74,
                        a: .7
                    },
                    direction: {
                        x: -50,
                        y: -35
                    },
                    shapeDirPower: 2,
                    shapeNormalPower: 1
                }, this._revealParams = new ga("Precipitation > Rain"), this._vignetteParams = {
                    strength: 1,
                    start: .7,
                    range: 1,
                    fadePower: .4,
                    color: {
                        r: .27,
                        g: .27,
                        b: .27,
                        a: 1
                    }
                }, this.particlesCount = 16e3;
            }
            update(t1) {
                const i = t1.context;
                if (!this.particlesVx) {
                    const t1 = wa(this.particlesCount), o = new e.eN, s = new e.b0;
                    let r = 0;
                    const n = e.eq(1323123451230);
                    for(let e = 0; e < t1.length; ++e){
                        const i = t1[e], a = [
                            2 * n() - 1,
                            n(),
                            n(),
                            n()
                        ];
                        o.emplaceBack(i[0], i[1], i[2], -1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...a), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...a), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;
                    }
                    this.particlesVx = i.createVertexBuffer(o, ma.members), this.particlesIdx = i.createIndexBuffer(s);
                }
            }
            draw(t1) {
                if (!this._params.overrideStyleParameters && !t1.style.rain) return;
                const i = this._params.overrideStyleParameters ? this._revealParams : {
                    revealStart: 0,
                    revealRange: .01
                }, o = t1.transform.zoom;
                if (i.revealStart > o) return;
                const s = Ta(0, 1, i.revealStart, i.revealStart + i.revealRange, o);
                if (!this.particlesVx || !this.particlesIdx) return;
                const r = structuredClone(this._params);
                let n = [
                    -r.direction.x,
                    r.direction.y,
                    -100
                ];
                e.aw(n, n);
                const a = structuredClone(this._vignetteParams);
                a.strength *= s, r.overrideStyleParameters || (r.intensity = t1.style.rain.state.density, r.timeFactor = t1.style.rain.state.intensity, r.color = structuredClone(t1.style.rain.state.color), n = structuredClone(t1.style.rain.state.direction), r.screenThinning.intensity = t1.style.rain.state.centerThinning, r.dropletSizeX = t1.style.rain.state.dropletSize[0], r.dropletSizeYScale = t1.style.rain.state.dropletSize[1] / t1.style.rain.state.dropletSize[0], r.distortionStrength = 100 * t1.style.rain.state.distortionStrength, a.strength = 1, a.color = structuredClone(t1.style.rain.state.vignetteColor));
                const l = this.updateOnRender(t1, r.timeFactor), c = t1.context, h = c.gl, d = t1.transform;
                this.screenTexture && this.screenTexture.size[0] === t1.width && this.screenTexture.size[1] === t1.height || (this.screenTexture = new e.T(c, {
                    width: t1.width,
                    height: t1.height,
                    data: null
                }, h.RGBA8)), r.distortionStrength > 0 && (c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0, 0, 0, 0, t1.width, t1.height));
                const u = t1.getOrCreateProgram("rainParticle");
                t1.uploadCommonUniforms(c, u), c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
                const _ = [
                    r.color.r,
                    r.color.g,
                    r.color.b,
                    r.color.a
                ], p = (i, o)=>{
                    const s = ba(this._movement.getPosition(), i), a = r.dropletSizeX, c = r.dropletSizeX * r.dropletSizeYScale, p = t1.width / 2, f = t1.height / 2, m = Ta(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity), g = Ta(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity), v = Ta(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity), y = (x = {
                        modelview: l.modelviewMatrix,
                        projection: l.projectionMatrix,
                        time: this._accumulatedTimeFromStart,
                        camPos: s,
                        velocityConeAperture: r.velocityConeAperture,
                        velocity: r.velocity,
                        boxSize: i,
                        rainDropletSize: [
                            a,
                            c
                        ],
                        distortionStrength: r.distortionStrength,
                        rainDirection: n,
                        color: _,
                        screenSize: [
                            d.width,
                            d.height
                        ],
                        thinningCenterPos: [
                            p,
                            f
                        ],
                        thinningShape: [
                            m,
                            g,
                            Math.pow(10, r.screenThinning.fadePower)
                        ],
                        thinningAffectedRatio: r.screenThinning.affectedRatio,
                        thinningParticleOffset: v,
                        shapeDirectionalPower: r.shapeDirPower,
                        shapeNormalPower: r.shapeNormalPower,
                        mode: o ? 0 : 1
                    }, {
                        u_modelview: Float32Array.from(x.modelview),
                        u_projection: Float32Array.from(x.projection),
                        u_time: x.time,
                        u_cam_pos: x.camPos,
                        u_texScreen: 0,
                        u_velocityConeAperture: x.velocityConeAperture,
                        u_velocity: x.velocity,
                        u_boxSize: x.boxSize,
                        u_rainDropletSize: x.rainDropletSize,
                        u_distortionStrength: x.distortionStrength,
                        u_rainDirection: x.rainDirection,
                        u_color: x.color,
                        u_screenSize: x.screenSize,
                        u_thinningCenterPos: x.thinningCenterPos,
                        u_thinningShape: x.thinningShape,
                        u_thinningAffectedRatio: x.thinningAffectedRatio,
                        u_thinningParticleOffset: x.thinningParticleOffset,
                        u_shapeDirectionalPower: x.shapeDirectionalPower,
                        u_shapeNormalPower: x.shapeNormalPower,
                        u_mode: x.mode
                    });
                    var x;
                    const b = Math.round(r.intensity * this.particlesCount), w = e.bg.simpleSegment(0, 0, 4 * b, 2 * b);
                    u.draw(t1, h.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, y, "rain_particles", this.particlesVx, this.particlesIdx, w);
                };
                r.distortionStrength > 0 && p(r.boxSize, !0), p(r.boxSize, !1), this._vignette.draw(t1, a);
            }
        }
        const Ia = e.ei([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_snowParticleData",
                components: 4
            },
            {
                type: "Float32",
                name: "a_snowParticleDataHorizontalOscillation",
                components: 2
            }
        ]);
        class Ca extends Ea {
            constructor(e){
                super(2.25), this._params = {
                    overrideStyleParameters: !1,
                    intensity: .85,
                    timeFactor: .75,
                    velocityConeAperture: 70,
                    velocity: 40,
                    horizontalOscillationRadius: 4,
                    horizontalOscillationRate: 1.5,
                    boxSize: 2e3,
                    billboardSize: 2,
                    shapeFadeStart: .27,
                    shapeFadePower: .21,
                    screenThinning: {
                        intensity: .4,
                        start: .15,
                        range: 1.4,
                        fadePower: .24,
                        affectedRatio: 1,
                        particleOffset: -.2
                    },
                    color: {
                        r: 1,
                        g: 1,
                        b: 1,
                        a: 1
                    },
                    direction: {
                        x: -50,
                        y: -35
                    }
                }, this._revealParams = new ga("Precipitation > Snow"), this._vignetteParams = {
                    strength: .3,
                    start: .78,
                    range: .46,
                    fadePower: .2,
                    color: {
                        r: 1,
                        g: 1,
                        b: 1,
                        a: 1
                    }
                }, this.particlesCount = 16e3;
            }
            update(t1) {
                const i = t1.context;
                if (!this.particlesVx) {
                    const t1 = wa(this.particlesCount), o = new e.eO, s = new e.b0;
                    let r = 0;
                    const n = e.eq(1323123451230);
                    for(let e = 0; e < t1.length; ++e){
                        const i = t1[e], a = n(), l = n(), c = n(), h = [
                            e / t1.length,
                            a,
                            l,
                            c
                        ], d = [
                            n(),
                            n()
                        ];
                        o.emplaceBack(i[0], i[1], i[2], -1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...h, ...d), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;
                    }
                    this.particlesVx = i.createVertexBuffer(o, Ia.members), this.particlesIdx = i.createIndexBuffer(s);
                }
            }
            draw(t1) {
                if (!this._params.overrideStyleParameters && !t1.style.snow) return;
                const i = structuredClone(this._params);
                let o = [
                    -i.direction.x,
                    i.direction.y,
                    -100
                ];
                e.aw(o, o);
                const s = structuredClone(this._vignetteParams), r = i.overrideStyleParameters ? this._revealParams : {
                    revealStart: 0,
                    revealRange: .01
                }, n = t1.transform.zoom;
                if (r.revealStart > n) return;
                const a = Ta(0, 1, r.revealStart, r.revealStart + r.revealRange, n);
                s.strength *= a, i.overrideStyleParameters || (i.intensity = t1.style.snow.state.density, i.timeFactor = t1.style.snow.state.intensity, i.color = structuredClone(t1.style.snow.state.color), o = structuredClone(t1.style.snow.state.direction), i.screenThinning.intensity = t1.style.snow.state.centerThinning, i.billboardSize = 2.79 * t1.style.snow.state.flakeSize, s.strength = 1, s.color = structuredClone(t1.style.snow.state.vignetteColor));
                const l = this.updateOnRender(t1, i.timeFactor);
                if (!this.particlesVx || !this.particlesIdx) return;
                const c = t1.context, h = c.gl, d = t1.transform, u = t1.getOrCreateProgram("snowParticle");
                t1.uploadCommonUniforms(c, u), ((i, s, r)=>{
                    const n = ba(this._movement.getPosition(), i), a = d.width / 2, c = d.height / 2, _ = Ta(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity), p = Ta(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity), f = Ta(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity), m = (g = {
                        modelview: l.modelviewMatrix,
                        projection: l.projectionMatrix,
                        time: this._accumulatedTimeFromStart,
                        camPos: n,
                        velocityConeAperture: r.velocityConeAperture,
                        velocity: r.velocity,
                        horizontalOscillationRadius: r.horizontalOscillationRadius,
                        horizontalOscillationRate: r.horizontalOscillationRate,
                        boxSize: i,
                        billboardSize: 1 * r.billboardSize,
                        simpleShapeParameters: [
                            r.shapeFadeStart,
                            r.shapeFadePower
                        ],
                        screenSize: [
                            d.width,
                            d.height
                        ],
                        thinningCenterPos: [
                            a,
                            c
                        ],
                        thinningShape: [
                            _,
                            p,
                            Math.pow(10, r.screenThinning.fadePower)
                        ],
                        thinningAffectedRatio: r.screenThinning.affectedRatio,
                        thinningParticleOffset: f,
                        color: [
                            r.color.r,
                            r.color.g,
                            r.color.b,
                            r.color.a
                        ],
                        direction: o
                    }, {
                        u_modelview: Float32Array.from(g.modelview),
                        u_projection: Float32Array.from(g.projection),
                        u_time: g.time,
                        u_cam_pos: g.camPos,
                        u_velocityConeAperture: g.velocityConeAperture,
                        u_velocity: g.velocity,
                        u_horizontalOscillationRadius: g.horizontalOscillationRadius,
                        u_horizontalOscillationRate: g.horizontalOscillationRate,
                        u_boxSize: g.boxSize,
                        u_billboardSize: g.billboardSize,
                        u_simpleShapeParameters: g.simpleShapeParameters,
                        u_screenSize: g.screenSize,
                        u_thinningCenterPos: g.thinningCenterPos,
                        u_thinningShape: g.thinningShape,
                        u_thinningAffectedRatio: g.thinningAffectedRatio,
                        u_thinningParticleOffset: g.thinningParticleOffset,
                        u_particleColor: g.color,
                        u_direction: g.direction
                    });
                    var g;
                    const v = Math.round(r.intensity * this.particlesCount), y = e.bg.simpleSegment(0, 0, 4 * v, 2 * v);
                    this.particlesVx && this.particlesIdx && u.draw(t1, h.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, m, "snow_particles", this.particlesVx, this.particlesIdx, y);
                })(i.boxSize, 0, i), this._vignette.draw(t1, s);
            }
        }
        const Ra = {
            symbol: function(t1, i, o, s, r) {
                if ("translucent" !== t1.renderPass) return;
                const n = Yi.disabled, a = t1.colorModeForRenderPass(), l = o.layout.get("text-variable-anchor"), c = o.layout.get("text-size-scale-range"), h = e.aA(t1.scaleFactor, c[0], c[1]);
                l && function(t1, i, o, s, r, n, a, l) {
                    const c = i.transform, h = "map" === r, d = "map" === n;
                    for (const i of t1){
                        const t1 = s.getTile(i), r = t1.getBucket(o);
                        if (!r || !r.text || !r.text.segments.get().length) continue;
                        const n = e.bK(r.textSizeData, c.zoom, l), u = Qt(i, r.getProjection(), c), _ = c.calculatePixelsToTileUnitsMatrix(t1), p = oi(u, t1.tileID.canonical, d, h, c, r.getProjection(), _), f = r.hasIconTextFit() && r.hasIconData();
                        n && rn(r, h, d, a, c, p, i, Math.pow(2, c.zoom - t1.tileID.overscaledZ), n, f);
                    }
                }(s, t1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), r, h);
                const d = 0 !== o.paint.get("icon-opacity").constantOr(1), u = 0 !== o.paint.get("text-opacity").constantOr(1);
                void 0 !== o.layout.get("symbol-sort-key").constantOr(1) && (d || u) ? nn(t1, i, o, s, n, a) : (d && nn(t1, i, o, s, n, a, {
                    onlyIcons: !0
                }), u && nn(t1, i, o, s, n, a, {
                    onlyText: !0
                })), i.map.showCollisionBoxes && (en(t1, i, o, s, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), en(t1, i, o, s, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t1, i, o, s) {
                if ("translucent" !== t1.renderPass) return;
                const r = o.paint.get("circle-opacity"), n = o.paint.get("circle-stroke-width"), a = o.paint.get("circle-stroke-opacity"), l = void 0 !== o.layout.get("circle-sort-key").constantOr(1), c = o.paint.get("circle-emissive-strength");
                if (0 === r.constantOr(1) && (0 === n.constantOr(1) || 0 === a.constantOr(1))) return;
                const h = t1.context, d = h.gl, u = t1.transform, _ = !(!t1.terrain || !t1.terrain.enabled), p = o.layout.get("circle-elevation-reference"), f = t1.depthModeForSublayer(0, $i.ReadOnly), m = new $i(t1.context.gl.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D), g = "none" === p || _ ? f : m, v = Yi.disabled, y = t1.colorModeForDrapableLayerRenderPass(c), x = "globe" === u.projection.name, b = [
                    e.aF(u.center.lng),
                    e.aJ(u.center.lat)
                ], w = [];
                for(let r = 0; r < s.length; r++){
                    const n = s[r], a = i.getTile(n), c = a.getBucket(o);
                    if (!c || c.projection.name !== u.projection.name) continue;
                    const h = c.programConfigurations.get(o.id), d = c.layoutVertexBuffer, _ = c.globeExtVertexBuffer, p = c.indexBuffer, f = e.e0(o), m = [
                        _
                    ], g = t1.isTileAffectedByFog(n);
                    x && f.push("PROJECTION_GLOBE_VIEW"), f.push("DEPTH_D24"), t1.terrain && u.depthOcclusionForSymbolsAndCircles && f.push("DEPTH_OCCLUSION"), c.hasElevation && !t1.terrain && (f.push("ELEVATED_ROADS"), m.push(c.elevatedLayoutVertexBuffer));
                    const v = t1.getOrCreateProgram("circle", {
                        config: h,
                        defines: f,
                        overrideFog: g
                    }), y = u.projection.createInversionMatrix(u, n.canonical), T = {
                        programConfiguration: h,
                        program: v,
                        layoutVertexBuffer: d,
                        dynamicBuffers: m,
                        indexBuffer: p,
                        uniformValues: e.e1(t1, n, a, y, b, o),
                        tile: a
                    };
                    if (l) {
                        const t1 = c.segments.get();
                        for (const i of t1)w.push({
                            segments: new e.bg([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: T
                        });
                    } else w.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: T
                    });
                }
                l && w.sort((e, t1)=>e.sortKey - t1.sortKey);
                const T = {
                    useDepthForOcclusion: u.depthOcclusionForSymbolsAndCircles
                };
                for (const e of w){
                    const { programConfiguration: i, program: s, layoutVertexBuffer: r, dynamicBuffers: n, indexBuffer: a, uniformValues: l, tile: c } = e.state, _ = e.segments;
                    t1.terrain && t1.terrain.setupElevationDraw(c, s, T), t1.uploadCommonUniforms(h, s, c.tileID.toUnwrapped()), s.draw(t1, d.TRIANGLES, g, v, y, Qi.disabled, l, o.id, r, a, _, o.paint, u.zoom, i, n);
                }
            },
            heatmap: function(t1, i, o, s) {
                if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === t1.renderPass) {
                    const r = t1.context, n = r.gl, a = Yi.disabled, l = new Wi([
                        n.ONE,
                        n.ONE,
                        n.ONE,
                        n.ONE
                    ], e.ao.transparent, [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                    !function(e, t1, i, o) {
                        const s = e.gl, r = t1.width * o, n = t1.height * o;
                        e.activeTexture.set(s.TEXTURE1), e.viewport.set([
                            0,
                            0,
                            r,
                            n
                        ]);
                        let a = i.heatmapFbo;
                        if (!a || a && (a.width !== r || a.height !== n)) {
                            a && a.destroy();
                            const t1 = s.createTexture();
                            s.bindTexture(s.TEXTURE_2D, t1), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), a = i.heatmapFbo = e.createFramebuffer(r, n, 1, null), function(e, t1, i, o, s, r) {
                                const n = e.gl;
                                n.texImage2D(n.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? n.RGBA16F : n.RGBA, s, r, 0, n.RGBA, e.extRenderToTextureHalfFloat ? n.HALF_FLOAT : n.UNSIGNED_BYTE, null), o.colorAttachment0.set(i);
                            }(e, 0, t1, a, r, n);
                        } else s.bindTexture(s.TEXTURE_2D, a.colorAttachment0.get()), e.bindFramebuffer.set(a.framebuffer);
                    }(r, t1, o, "globe" === t1.transform.projection.name ? .5 : .25), r.clear({
                        color: e.ao.transparent
                    });
                    const c = t1.transform, h = "globe" === c.projection.name, d = h ? [
                        "PROJECTION_GLOBE_VIEW"
                    ] : [], u = h ? Qi.frontCCW : Qi.disabled, _ = [
                        e.aF(c.center.lng),
                        e.aJ(c.center.lat)
                    ];
                    for(let e = 0; e < s.length; e++){
                        const p = s[e];
                        if (i.hasRenderableParent(p)) continue;
                        const f = i.getTile(p), m = f.getBucket(o);
                        if (!m || m.projection.name !== c.projection.name) continue;
                        const g = t1.isTileAffectedByFog(p), v = m.programConfigurations.get(o.id), y = t1.getOrCreateProgram("heatmap", {
                            config: v,
                            defines: d,
                            overrideFog: g
                        }), { zoom: x } = t1.transform;
                        t1.terrain && t1.terrain.setupElevationDraw(f, y), t1.uploadCommonUniforms(r, y, p.toUnwrapped());
                        const b = c.projection.createInversionMatrix(c, p.canonical);
                        y.draw(t1, n.TRIANGLES, $i.disabled, a, l, u, Dr(t1, p, f, b, _, x, o.paint.get("heatmap-intensity")), o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t1.transform.zoom, v, h ? [
                            m.globeExtVertexBuffer
                        ] : null);
                    }
                    r.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                } else "translucent" === t1.renderPass && (t1.context.setColorMode(t1.colorModeForRenderPass()), function(t1, i) {
                    const o = t1.context, s = o.gl, r = i.heatmapFbo;
                    if (!r) return;
                    o.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, r.colorAttachment0.get()), o.activeTexture.set(s.TEXTURE1);
                    let n = i.colorRampTexture;
                    n || (n = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), n.bind(s.LINEAR, s.CLAMP_TO_EDGE), t1.getOrCreateProgram("heatmapTexture").draw(t1, s.TRIANGLES, $i.disabled, Yi.disabled, t1.colorModeForRenderPass(), Qi.disabled, ((e, t1)=>({
                            u_image: 0,
                            u_color_ramp: 1,
                            u_opacity: t1.paint.get("heatmap-opacity")
                        }))(0, i), i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments, i.paint, t1.transform.zoom);
                }(t1, o));
            },
            line: function(t1, i, o, s) {
                if ("translucent" !== t1.renderPass) return;
                const r = o.paint.get("line-opacity"), n = o.paint.get("line-width");
                if (0 === r.constantOr(1) || 0 === n.constantOr(1)) return;
                const a = o.paint.get("line-emissive-strength").isConstant(), l = o.paint.get("line-emissive-strength").constantOr(0), c = o.paint.get("line-occlusion-opacity"), h = o.layout.get("line-elevation-reference"), d = "meters" === o.layout.get("line-width-unit"), u = "sea" === h, _ = !(!t1.terrain || !t1.terrain.enabled), p = t1.context, f = p.gl;
                if (o.hasElevatedBuckets && "globe" === t1.transform.projection.name) return;
                const m = o.layout.get("line-cross-slope"), g = void 0 !== m, v = m < 1, y = t1.colorModeForDrapableLayerRenderPass(a ? l : null), x = t1.terrain && t1.terrain.renderingToTexture, b = x ? 1 : e.o.devicePixelRatio, w = o.paint.get("line-dasharray"), T = w.constantOr(1), E = o.layout.get("line-cap"), S = w.constantOr(null), I = E.constantOr(null), C = o.paint.get("line-pattern"), R = C.constantOr(1), A = o.paint.get("line-pattern-cross-fade"), L = C.constantOr(null), D = o.paint.get("line-opacity").constantOr(1);
                let P = !R && 1 !== D || t1.depthOcclusion && c > 0 && c < 1;
                const O = o.paint.get("line-gradient"), z = R ? "linePattern" : "line", M = e.e2(o);
                let F;
                if (x && t1.terrain && t1.terrain.clipOrMaskOverlapStencilType() && (P = !1), 0 !== c && t1.depthOcclusion) {
                    const t1 = o.paint._values["line-opacity"];
                    t1 && t1.value && "constant" === t1.value.kind ? F = t1.value : e.w(`Occlusion opacity for layer ${o.id} is supported only when line-opacity isn't data-driven.`);
                }
                "constant" !== n.value.kind && !1 === n.value.isLineProgressConstant && M.push("VARIABLE_LINE_WIDTH"), x && ("dual-source-blending" !== t1.emissiveMode || a ? "mrt-fallback" === t1.emissiveMode && M.push("USE_MRT1") : M.push("DUAL_SOURCE_BLENDING"));
                const B = (s, r, n, a, l, h)=>{
                    for (const _ of s){
                        const s = i.getTile(_);
                        if (R && !s.patternsLoaded()) continue;
                        const m = s.getBucket(o);
                        if (!m) continue;
                        if ("none" !== m.elevationType && !l || "none" === m.elevationType && l) continue;
                        t1.prepareDrawTile();
                        const g = [
                            ...r
                        ], v = t1.shadowRenderer, w = "road" === m.elevationType && !!v && v.enabled;
                        let E = [
                            0,
                            0,
                            0
                        ];
                        if (w) {
                            const e = t1.style.directionalLight, i = t1.style.ambientLight;
                            e && i && (E = go(t1.style, e, i)), g.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                        }
                        const C = m.programConfigurations.get(o.id);
                        let M = !1;
                        if (L && s.imageAtlas) {
                            const t1 = e.e3.from(L), i = t1.getPrimary().scaleSelf(b).toString(), o = s.imageAtlas.patternPositions.get(i), r = t1.getSecondary(), n = r ? s.imageAtlas.patternPositions.get(r.scaleSelf(b).toString()) : null;
                            M = !!o && !!n, o && C.setConstantPatternPositions(o, n);
                        }
                        A > 0 && (M || C.getPatternTransitionVertexBuffer("line-pattern")) && g.push("LINE_PATTERN_TRANSITION");
                        const B = t1.isTileAffectedByFog(_), k = t1.getOrCreateProgram(z, {
                            config: C,
                            defines: g,
                            overrideFog: B
                        });
                        if (!R && S && I && s.lineAtlas) {
                            const e = s.lineAtlas.getDash(S, I);
                            e && C.setConstantPatternPositions(e);
                        }
                        w && v.setupShadows(s.tileID.toUnwrapped(), k, "vector-tile");
                        let [N, U] = o.paint.get("line-trim-offset");
                        if ("round" === I || "square" === I) {
                            const e = 1;
                            N !== U && (0 === N && (N -= e), 1 === U && (U += e));
                        }
                        const j = x ? _.projMatrix : null, V = d ? 1 / m.tileToMeter / e.ay(s, 1, t1.transform.zoom) : 1, G = d ? 1 / m.tileToMeter / e.ay(s, 1, Math.floor(t1.transform.zoom)) : 1, H = R ? e.e4(t1, s, o, j, b, V, G, [
                            N,
                            U
                        ], E, A) : e.e5(t1, s, o, j, m.lineClipsArray.length, b, V, G, [
                            N,
                            U
                        ], E);
                        if (O) {
                            const s = m.gradients[o.id];
                            let r = s.texture;
                            if (o.gradientVersion !== s.version) {
                                let n = 256;
                                if (o.stepInterpolant) {
                                    const o = i.getSource().maxzoom, s = _.canonical.z === o ? Math.ceil(1 << t1.transform.maxZoom - _.canonical.z) : 1;
                                    n = e.aA(e.e6(m.maxLineLength / e.al * 1024 * s), 256, p.maxTextureSize);
                                }
                                s.gradient = e.e7({
                                    expression: o.gradientExpression(),
                                    evaluationKey: "lineProgress",
                                    resolution: n,
                                    image: s.gradient || void 0,
                                    clips: m.lineClipsArray
                                }), s.texture ? s.texture.update(s.gradient) : s.texture = new e.T(p, s.gradient, f.RGBA8), s.version = o.gradientVersion, r = s.texture;
                            }
                            p.activeTexture.set(f.TEXTURE1), r.bind(o.stepInterpolant ? f.NEAREST : f.LINEAR, f.CLAMP_TO_EDGE);
                        }
                        T && (p.activeTexture.set(f.TEXTURE0), s.lineAtlasTexture && s.lineAtlasTexture.bind(f.LINEAR, f.REPEAT), C.updatePaintBuffers()), R && (p.activeTexture.set(f.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE), C.updatePaintBuffers()), l && !u && t1.terrain.setupElevationDraw(s, k), t1.uploadCommonUniforms(p, k, _.toUnwrapped());
                        const q = (e)=>{
                            null != F && (F.value = D * c), k.draw(t1, f.TRIANGLES, n, e, y, Qi.disabled, H, o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t1.transform.zoom, C, [
                                m.layoutVertexBuffer2,
                                m.patternVertexBuffer,
                                m.zOffsetVertexBuffer
                            ]), null != F && (F.value = D);
                        };
                        if (P && !l) {
                            const e = t1.stencilModeForClipping(_).ref;
                            0 === e && x && p.clear({
                                stencil: 0
                            });
                            const i = {
                                func: f.EQUAL,
                                mask: 255
                            };
                            H.u_alpha_discard_threshold = .8, q(new Yi(i, e, 255, f.KEEP, f.KEEP, f.INVERT)), H.u_alpha_discard_threshold = 0, q(new Yi(i, e, 255, f.KEEP, f.KEEP, f.KEEP));
                        } else H.u_alpha_discard_threshold = P && l && h ? .8 : 0, q(l ? a : t1.stencilModeForClipping(_));
                    }
                };
                let k = t1.depthModeForSublayer(0, $i.ReadOnly);
                const N = new $i(t1.depthOcclusion ? f.GREATER : f.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D);
                if (o.hasNonElevatedBuckets) {
                    const i = !x && t1.terrain;
                    0 !== c && i ? e.w(`Occlusion opacity for layer ${o.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i ? e.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o.id}.`) : B(s, M, k, Yi.disabled, !1, !0);
                }
                if (o.hasElevatedBuckets) {
                    "hd-road-markup" === h ? _ || (k = N, M.push("ELEVATED_ROADS")) : (M.push("ELEVATED"), k = N, g && M.push(v ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), u && M.push("ELEVATION_REFERENCE_SEA"));
                    const e = P ? t1.stencilModeFor3D() : Yi.disabled;
                    t1.forceTerrainMode = !0, B(s, M, k, e, !0, !0), P && B(s, M, k, e, !0, !1), t1.forceTerrainMode = !1;
                }
                P && (t1.resetStencilClippingMasks(), x && p.clear({
                    stencil: 0
                })), 0 === c || t1.depthOcclusion || x || t1.layersWithOcclusionOpacity.push(t1.currentLayer);
            },
            fill: function(t1, i, o, s) {
                const r = o.paint.get("fill-color"), n = o.paint.get("fill-opacity");
                if (0 === n.constantOr(1)) return;
                const a = o.paint.get("fill-emissive-strength"), l = t1.colorModeForDrapableLayerRenderPass(a), c = o.paint.get("fill-pattern"), h = t1.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === r.constantOr(e.ao.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";
                let d = "none";
                "none" !== o.layout.get("fill-elevation-reference") ? d = "road" : 0 !== o.paint.get("fill-z-offset").constantOr(1) && (d = "offset");
                const u = !(!t1.terrain || !t1.terrain.enabled), _ = {
                    painter: t1,
                    sourceCache: i,
                    layer: o,
                    coords: s,
                    colorMode: l,
                    elevationType: d,
                    terrainEnabled: u,
                    pass: h
                };
                if ("shadow" === t1.renderPass) return void (t1.shadowRenderer && "road" === d && !u && function(e) {
                    const { painter: t1, sourceCache: i, layer: o, coords: s } = e, r = t1.context.gl, n = e.painter.shadowRenderer;
                    for (const e of s){
                        const s = i.getTile(e), a = s.getBucket(o);
                        if (!a) continue;
                        const l = a.elevatedStructures;
                        if (!l) continue;
                        if (!l.shadowCasterSegments || 0 === l.shadowCasterSegments.segments[0].primitiveLength) continue;
                        t1.prepareDrawTile();
                        const c = a.bufferData.programConfigurations.get(o.id), h = t1.isTileAffectedByFog(e), d = t1.getOrCreateProgram("elevatedStructuresDepth", {
                            config: c,
                            overrideFog: h
                        }), u = n.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());
                        t1.uploadCommonUniforms(t1.context, d, e.toUnwrapped());
                        const _ = br(u, 0);
                        d.draw(t1, r.TRIANGLES, n.getShadowPassDepthMode(), Yi.disabled, n.getShadowPassColorMode(), Qi.disabled, _, o.id, l.vertexBuffer, l.indexBuffer, l.shadowCasterSegments, o.paint, t1.transform.zoom, c);
                    }
                }(_));
                const p = "mrt-fallback" === t1.emissiveMode;
                if ("offset" !== d) {
                    if (hn(_, !1, p), "road" === d) {
                        const e = !u && "translucent" === t1.renderPass;
                        e && cn(t1, i, o, s, "geometry"), hn(_, !0, p, Yi.disabled), e && function(e) {
                            const { painter: t1, sourceCache: i, layer: o, coords: s, colorMode: r } = e, n = t1.context.gl, a = e.painter.shadowRenderer, l = !!a && a.enabled, c = new $i(t1.context.gl.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D);
                            let h = [
                                0,
                                0,
                                0
                            ];
                            if (l) {
                                const e = t1.style.directionalLight, i = t1.style.ambientLight;
                                e && i && (h = go(t1.style, e, i));
                            }
                            const d = (e)=>{
                                for (const d of s){
                                    const s = i.getTile(d), u = s.getBucket(o);
                                    if (!u) continue;
                                    const _ = u.elevatedStructures;
                                    if (!_) continue;
                                    let p, f;
                                    if (e ? (p = _.renderableBridgeSegments, f = _.bridgeProgramConfigurations.get(o.id)) : (p = _.renderableTunnelSegments, f = _.tunnelProgramConfigurations.get(o.id)), !p || 0 === p.segments[0].primitiveLength) continue;
                                    f.updatePaintBuffers(), t1.prepareDrawTile();
                                    const m = t1.isTileAffectedByFog(d), g = [];
                                    l && g.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                                    const v = t1.getOrCreateProgram("elevatedStructures", {
                                        config: f,
                                        overrideFog: m,
                                        defines: g
                                    }), y = t1.translatePosMatrix(d.projMatrix, s, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
                                    l && a.setupShadows(s.tileID.toUnwrapped(), v, "vector-tile");
                                    const x = wr(y, h);
                                    t1.uploadCommonUniforms(t1.context, v, d.toUnwrapped()), v.draw(t1, n.TRIANGLES, c, Yi.disabled, r, Qi.backCCW, x, o.id, _.vertexBuffer, _.indexBuffer, p, o.paint, t1.transform.zoom, f, [
                                        _.vertexBufferNormal
                                    ]);
                                }
                            };
                            d(!0), d(!1);
                        }(_);
                    }
                } else hn(_, !1, p, t1.stencilModeFor3D());
            },
            "fill-extrusion": function(t1, i, o, s) {
                const r = o.paint.get("fill-extrusion-opacity"), n = t1.context, a = n.gl, l = t1.terrain, c = l && l.renderingToTexture;
                if (0 === r) return;
                const h = "mrt-fallback" === t1.emissiveMode, d = t1.conflationActive && t1.style.isLayerClipped(o, i.getSource()), u = t1.style.order.indexOf(o.fqid);
                if (d && function(e, t1, i, o, s) {
                    for (const r of o){
                        const o = t1.getTile(r).getBucket(i);
                        o && (o.updateReplacement(r, e.replacementSource, s), o.uploadCentroid(e.context));
                    }
                }(t1, i, o, s, u), l || d) for (const e of s){
                    const s = i.getTile(e).getBucket(o);
                    s && pn(t1.context, i, e, s, o, l, d);
                }
                if ("shadow" === t1.renderPass && t1.shadowRenderer) {
                    const n = t1.shadowRenderer;
                    if (l && r < .65 && o._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.ad) return;
                    const a = n.getShadowPassDepthMode(), c = n.getShadowPassColorMode();
                    dn(t1, i, o, s, a, Yi.disabled, c, d);
                } else if ("translucent" === t1.renderPass) {
                    const u = !o.paint.get("fill-extrusion-pattern").constantOr(1), _ = o.paint.get("fill-extrusion-color").constantOr(e.ao.white);
                    if (!c && 0 !== _.a) {
                        const e = new $i(t1.context.gl.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D);
                        1 === r && u ? dn(t1, i, o, s, e, Yi.disabled, Wi.unblended, d) : (dn(t1, i, o, s, e, Yi.disabled, Wi.disabled, d), dn(t1, i, o, s, e, t1.stencilModeFor3D(), t1.colorModeForRenderPass(), d), t1.resetStencilClippingMasks());
                    }
                    if (t1.style.enable3dLights() && u && (!l && "globe" !== t1.transform.projection.name || c)) {
                        const r = o.paint.get("fill-extrusion-opacity"), u = o.paint.get("fill-extrusion-ambient-occlusion-intensity"), _ = o.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), p = o.paint.get("fill-extrusion-flood-light-intensity"), f = "none" === o.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), m = o.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(f ? null : o.lut).toArray01().slice(0, 3), g = u > 0 && _ > 0, v = p > 0, y = (e, t1, i)=>(1 - i) * e + i * t1, x = new un;
                        x.translate = o.paint.get("fill-extrusion-translate"), x.translateAnchor = o.paint.get("fill-extrusion-translate-anchor"), x.edgeRadius = o.layout.get("fill-extrusion-edge-radius"), x.cutoffFadeRange = o.paint.get("fill-extrusion-cutoff-fade-range");
                        const b = (n)=>{
                            const l = t1.depthModeForSublayer(1, $i.ReadOnly, a.LEQUAL, !0), c = o.paint.get(n ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), h = y(.1, 3, c), f = t1._showOverdrawInspector;
                            if (!f) {
                                const c = new Yi({
                                    func: a.ALWAYS,
                                    mask: 255
                                }, 255, 255, a.KEEP, a.KEEP, a.REPLACE), f = new Wi([
                                    a.ONE,
                                    a.ONE,
                                    a.ONE,
                                    a.ONE
                                ], e.ao.transparent, [
                                    !1,
                                    !1,
                                    !1,
                                    !0
                                ], a.MIN);
                                _n(x, t1, i, o, s, l, c, f, Qi.disabled, n, "sdf", r, u, _, p, m, h, d, !1);
                            }
                            {
                                const c = f ? Yi.disabled : new Yi({
                                    func: a.EQUAL,
                                    mask: 255
                                }, 255, 255, a.KEEP, a.DECR, a.DECR), g = f ? t1.colorModeForRenderPass() : new Wi([
                                    a.ONE_MINUS_DST_ALPHA,
                                    a.DST_ALPHA,
                                    a.ONE,
                                    a.ONE
                                ], e.ao.transparent, [
                                    !0,
                                    !0,
                                    !0,
                                    !0
                                ]);
                                _n(x, t1, i, o, s, l, c, g, Qi.disabled, n, "color", r, u, _, p, m, h, d, !1);
                            }
                        };
                        if (c) {
                            const c = ()=>{
                                const t1 = l.drapeBufferSize[0], i = l.drapeBufferSize[1];
                                let o = l.framebufferCopyTexture;
                                return o && (!o || o.size[0] === t1 && o.size[1] === i) || (o && o.destroy(), o = l.framebufferCopyTexture = new e.T(n, new e.q({
                                    width: t1,
                                    height: i
                                }), a.RGBA8)), o.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.copyTexSubImage2D(a.TEXTURE_2D, 0, 0, 0, 0, 0, t1, i), o;
                            }, f = (n, l, f)=>{
                                const g = t1.depthModeForSublayer(1, $i.ReadOnly, a.LEQUAL, !1), v = o.paint.get(n ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), b = y(.1, 3, v);
                                {
                                    const c = new Wi([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        a.ONE
                                    ], e.ao.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ]);
                                    _n(x, t1, i, o, s, g, Yi.disabled, c, Qi.disabled, n, "clear", r, u, _, p, m, b, d, l);
                                }
                                {
                                    const c = new Yi({
                                        func: a.ALWAYS,
                                        mask: 255
                                    }, 255, 255, a.KEEP, a.KEEP, a.REPLACE), h = new Wi([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        a.ONE
                                    ], e.ao.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], a.MIN);
                                    _n(x, t1, i, o, s, g, c, h, Qi.disabled, n, "sdf", r, u, _, p, m, b, d, l);
                                }
                                h && !n && (f = c());
                                {
                                    const c = n ? a.ZERO : a.ONE_MINUS_DST_ALPHA, h = new Yi({
                                        func: a.EQUAL,
                                        mask: 255
                                    }, 255, 255, a.KEEP, a.DECR, a.DECR), f = new Wi([
                                        c,
                                        a.DST_ALPHA,
                                        a.ONE_MINUS_DST_ALPHA,
                                        a.ZERO
                                    ], e.ao.transparent, [
                                        !0,
                                        !0,
                                        !0,
                                        !0
                                    ]);
                                    _n(x, t1, i, o, s, g, h, f, Qi.disabled, n, "color", r, u, _, p, m, b, d, l);
                                }
                                if (!h || n) {
                                    const c = new Wi([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        n ? a.ZERO : a.ONE
                                    ], e.ao.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], n ? a.FUNC_ADD : a.MAX);
                                    _n(x, t1, i, o, s, g, Yi.disabled, c, Qi.disabled, n, "clear", r, u, _, p, m, b, d, l, f);
                                } else {
                                    a.drawBuffers([
                                        a.NONE,
                                        a.COLOR_ATTACHMENT1
                                    ]);
                                    const c = new Yi({
                                        func: a.EQUAL,
                                        mask: 255
                                    }, 254, 255, a.KEEP, a.DECR, a.DECR), h = new Wi([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        a.ONE
                                    ], e.ao.transparent, [
                                        !0,
                                        !1,
                                        !1,
                                        !1
                                    ], a.MAX);
                                    _n(x, t1, i, o, s, g, c, h, Qi.disabled, n, "emissive", r, u, _, p, m, b, d, l, f), a.drawBuffers([
                                        a.COLOR_ATTACHMENT0
                                    ]);
                                }
                            };
                            if (g || v) {
                                let e;
                                t1.prepareDrawTile(), h && !g || (e = c()), g && f(!0, !1, e), v && f(!1, !0, e);
                            }
                        } else g && b(!0), v && b(!1), (g || v) && t1.resetStencilClippingMasks();
                    }
                }
            },
            building: function(e, t1, i, o) {
                e.currentLayer < e.firstLightBeamLayer && (e.firstLightBeamLayer = e.currentLayer);
                const s = i.paint.get("building-ambient-occlusion-ground-intensity"), r = i.paint.get("building-ambient-occlusion-ground-radius"), n = i.paint.get("building-ambient-occlusion-ground-attenuation"), a = i.paint.get("building-opacity");
                if (a <= 0) return;
                let l = s > 0 && r > 0, c = !0;
                const h = i.paint.get("building-vertical-scale");
                if (h <= 0) return;
                e.shadowRenderer || (c = !1);
                const d = e.conflationActive && e.style.isLayerClipped(i, t1.getSource()), u = e.style.order.indexOf(i.fqid);
                if (function(e, t1, i, o, s, r) {
                    for (const n of r){
                        const r = t1.getTile(n).getBucket(i);
                        r && (s && r.updateReplacement(n, e.replacementSource, o), r.uploadUpdatedIndexBuffer(e.context));
                    }
                }(e, t1, i, u, d, o), function(e, t1, i, o) {
                    for (const s of o){
                        const o = t1.getTile(s).getBucket(i);
                        o && o.needsEvaluation() && o.uploadUpdatedColorBuffer(e.context);
                    }
                }(e, t1, i, o), i.resetLayerRenderingStats(e), e.shadowRenderer && (e.shadowRenderer.useNormalOffset = !0), "shadow" === e.renderPass && e.shadowRenderer) {
                    const s = e.shadowRenderer, r = [], n = s.getShadowPassDepthMode();
                    yn({
                        painter: e,
                        source: t1,
                        layer: i,
                        coords: o,
                        defines: r,
                        blendMode: s.getShadowPassColorMode(),
                        depthMode: n,
                        opacity: a,
                        verticalScale: h,
                        facadeEmissiveChance: 0,
                        facadeAOIntensity: 0,
                        floodLightIntensity: 0,
                        floodLightColor: [
                            0,
                            0,
                            0
                        ]
                    });
                } else if ("translucent" === e.renderPass) {
                    let u = [
                        "HAS_ATTRIBUTE_a_part_color_emissive",
                        "LIGHTING_3D_MODE"
                    ];
                    c && (u = u.concat("RENDER_SHADOWS", "DEPTH_TEXTURE")), e.shadowRenderer && e.shadowRenderer.useNormalOffset && (u = u.concat("NORMAL_OFFSET"));
                    const _ = i.paint.get("building-facade-emissive-chance"), p = i.paint.get("building-ambient-occlusion-intensity"), f = i.paint.get("building-flood-light-intensity"), m = "none" === i.paint.get("building-flood-light-color-use-theme").constantOr("default"), g = i.paint.get("building-flood-light-color").toNonPremultipliedRenderColor(m ? null : i.lut).toArray01().slice(0, 3), v = i.paint.get("building-flood-light-ground-attenuation"), y = f > 0, x = new $i(e.context.gl.LEQUAL, $i.ReadWrite, e.depthRangeFor3D);
                    a < 1 && yn({
                        painter: e,
                        source: t1,
                        layer: i,
                        coords: o,
                        defines: u,
                        blendMode: Wi.disabled,
                        depthMode: x,
                        opacity: a,
                        verticalScale: h,
                        facadeEmissiveChance: _,
                        facadeAOIntensity: p,
                        floodLightIntensity: f,
                        floodLightColor: g,
                        depthOnly: !0
                    });
                    const b = e.colorModeForRenderPass();
                    yn({
                        painter: e,
                        source: t1,
                        layer: i,
                        coords: o,
                        defines: u,
                        blendMode: b,
                        depthMode: x,
                        opacity: a,
                        verticalScale: h,
                        facadeEmissiveChance: _,
                        facadeAOIntensity: p,
                        floodLightIntensity: f,
                        floodLightColor: g
                    }), l && xn(e, t1, i, o, !0, a, s, r, f, g, n, d), y && xn(e, t1, i, o, !1, a, s, r, f, g, v, d);
                } else if ("light-beam" === e.renderPass) {
                    const s = [
                        "HAS_ATTRIBUTE_a_part_color_emissive",
                        "HAS_ATTRIBUTE_a_bloom_attenuation"
                    ], r = new $i(e.context.gl.LEQUAL, $i.ReadOnly, e.depthRangeFor3D);
                    yn({
                        painter: e,
                        source: t1,
                        layer: i,
                        coords: o,
                        defines: s,
                        blendMode: Wi.alphaBlended,
                        depthMode: r,
                        opacity: a,
                        verticalScale: h,
                        facadeEmissiveChance: 0,
                        facadeAOIntensity: 0,
                        floodLightIntensity: 0,
                        floodLightColor: [
                            0,
                            0,
                            0
                        ]
                    });
                }
                e.shadowRenderer && (e.shadowRenderer.useNormalOffset = !1), e.resetStencilClippingMasks();
            },
            hillshade: function(e, t1, i, o) {
                if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass) return;
                if (e.style.disableElevatedTerrain) return;
                const s = e.context, r = e.terrain && e.terrain.renderingToTexture, [n, a] = "translucent" !== e.renderPass || r ? [
                    {},
                    o
                ] : e.stencilConfigForOverlap(o);
                for (const o of a){
                    const s = t1.getTile(o);
                    if (s.needsHillshadePrepare && "offscreen" === e.renderPass) cs(e, s, i);
                    else if ("translucent" === e.renderPass) {
                        const t1 = e.depthModeForSublayer(0, $i.ReadOnly), a = i.paint.get("hillshade-emissive-strength"), l = e.colorModeForDrapableLayerRenderPass(a), c = r && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : n[o.overscaledZ];
                        as(e, o, s, i, t1, c, l);
                    }
                }
                s.viewport.set([
                    0,
                    0,
                    e.width,
                    e.height
                ]), e.resetStencilClippingMasks();
            },
            raster: function(t1, i, o, s, r, n) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === o.paint.get("raster-opacity")) return;
                const a = "globe" === t1.transform.projection.name, l = 0 !== o.paint.get("raster-elevation"), c = l && a;
                if (t1.renderElevatedRasterBackface && !c) return;
                const h = t1.context, d = h.gl, u = i.getSource(), _ = function(t1, i, o, s, r) {
                    const n = i.paint.get("raster-color"), a = "raster-array" === t1.type, l = [], c = i.paint.get("raster-resampling"), h = i.paint.get("raster-color-mix");
                    let d = i.paint.get("raster-color-range");
                    const u = [
                        h[0],
                        h[1],
                        h[2],
                        0
                    ], _ = h[3];
                    let p = "nearest" === c ? s.NEAREST : s.LINEAR;
                    if (a && (l.push("RASTER_ARRAY"), n || l.push("RASTER_COLOR"), "linear" === c && l.push("RASTER_ARRAY_LINEAR"), p = s.NEAREST, !d && t1.rasterLayers)) {
                        const e = t1.rasterLayers.find(({ id: e })=>e === i.sourceLayer);
                        e && e.fields && e.fields.range && (d = e.fields.range);
                    }
                    if (d = d || [
                        0,
                        1
                    ], n) {
                        l.push("RASTER_COLOR"), o.activeTexture.set(s.TEXTURE2), i.updateColorRamp(d);
                        let t1 = i.colorRampTexture;
                        t1 || (t1 = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), t1.bind(p, s.CLAMP_TO_EDGE);
                    }
                    return r && l.push("USE_MRT1"), {
                        mix: u,
                        range: d,
                        offset: _,
                        defines: l,
                        resampling: p
                    };
                }(u, o, h, d, t1.terrain && t1.terrain.renderingToTexture && "mrt-fallback" === t1.emissiveMode);
                if (u instanceof e.aU && !s.length && !a) return;
                const p = o.paint.get("raster-emissive-strength"), f = t1.colorModeForDrapableLayerRenderPass(p), m = t1.terrain && t1.terrain.renderingToTexture, g = !t1.options.moving, v = "nearest" === o.paint.get("raster-resampling") ? d.NEAREST : d.LINEAR;
                if (u instanceof e.aU && !s.length && (u.onNorthPole || u.onSouthPole)) {
                    const e = l ? t1.stencilModeFor3D() : Yi.disabled;
                    return void wn(!!u.onNorthPole, null, t1, i, o, p, _, Qi.disabled, e);
                }
                if (!s.length) return;
                const [y, x] = u instanceof e.aU || m ? [
                    {},
                    s
                ] : t1.stencilConfigForOverlap(s), b = x[x.length - 1].overscaledZ;
                c && _.defines.push("PROJECTION_GLOBE_VIEW"), l && _.defines.push("RENDER_CUTOFF");
                const w = (s, r, x)=>{
                    for (const w of s){
                        const s = w.toUnwrapped(), T = i.getTile(w);
                        if (m && (!T || !T.hasData())) continue;
                        h.activeTexture.set(d.TEXTURE0);
                        const E = En(T, u, o, _);
                        if (!E || !E.texture) continue;
                        const { texture: S, mix: I, offset: C, tileSize: R, buffer: A } = E;
                        let L, D;
                        m ? (L = $i.disabled, D = w.projMatrix) : l ? (L = new $i(d.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D), D = a ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(s, g)) : (L = t1.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get("raster-opacity") ? $i.ReadWrite : $i.ReadOnly, d.LESS), D = t1.transform.calculateProjMatrix(s, g));
                        const P = t1.terrain && m ? t1.terrain.stencilModeForRTTOverlap(w) : y[w.overscaledZ], O = n ? 0 : o.paint.get("raster-fade-duration");
                        T.registerFadeDuration(O);
                        const z = i.findLoadedParent(w, 0), M = ir(T, z, i, t1.transform, O);
                        let F, B;
                        !M.isFading && T.refreshedUponExpiration && (T.refreshedUponExpiration = !1), t1.terrain && t1.terrain.prepareDrawTile(), h.activeTexture.set(d.TEXTURE0), S.bind(v, d.CLAMP_TO_EDGE), h.activeTexture.set(d.TEXTURE1), z ? (z.texture && z.texture.bind(v, d.CLAMP_TO_EDGE), F = Math.pow(2, z.tileID.overscaledZ - T.tileID.overscaledZ), B = [
                            T.tileID.canonical.x * F % 1,
                            T.tileID.canonical.y * F % 1
                        ]) : S.bind(v, d.CLAMP_TO_EDGE), "useMipmap" in S && h.extTextureFilterAnisotropic && t1.transform.pitch > 20 && d.texParameterf(d.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);
                        const k = t1.transform;
                        let N;
                        const U = l ? Tn(k) : [
                            0,
                            0,
                            0,
                            0
                        ];
                        let j, V, G, H, q, Z = 0;
                        if (c && u instanceof e.aU && u.coordinates.length > 3) j = Float32Array.from(e.bk(e.dJ(new e.cD(0, 0, 0)))), V = Float32Array.from(k.globeMatrix), G = Float32Array.from(e.dF(k)), H = [
                            e.aF(k.center.lng),
                            e.aJ(k.center.lat)
                        ], N = u.elevatedGlobePerspectiveTransform, q = u.elevatedGlobeGridMatrix || new Float32Array(9);
                        else if (c) {
                            const t1 = e.dG(w.canonical);
                            Z = e.dH(t1.getCenter().lat), j = Float32Array.from(e.bk(e.dJ(w.canonical))), V = Float32Array.from(k.globeMatrix), G = Float32Array.from(e.dF(k)), H = [
                                e.aF(k.center.lng),
                                e.aJ(k.center.lat)
                            ], N = [
                                0,
                                0
                            ], q = Float32Array.from(e.dI(w.canonical, t1, Z, k.worldSize / k._pixelsPerMercatorPixel));
                        } else N = u instanceof e.aU ? u.perspectiveTransform : [
                            0,
                            0
                        ], j = new Float32Array(16), V = new Float32Array(9), G = new Float32Array(16), H = [
                            0,
                            0
                        ], q = new Float32Array(9);
                        const W = zr(D, j, V, G, q, B || [
                            0,
                            0
                        ], e.aj(t1.transform.zoom), H, U, F || 1, M, o, N, l ? o.paint.get("raster-elevation") : 0, 2, I, C, _.range, R, A, p), $ = t1.isTileAffectedByFog(w), X = t1.getOrCreateProgram("raster", {
                            defines: _.defines,
                            overrideFog: $
                        });
                        if (t1.uploadCommonUniforms(h, X, s), u instanceof e.aU) {
                            const i = u.elevatedGlobeVertexBuffer, s = u.elevatedGlobeIndexBuffer;
                            if (m || !a) u.boundsBuffer && u.boundsSegments && X.draw(t1, d.TRIANGLES, L, Yi.disabled, f, Qi.disabled, W, o.id, u.boundsBuffer, t1.quadTriangleIndexBuffer, u.boundsSegments);
                            else if (i && s) {
                                const n = k.zoom <= e.c_ ? u.elevatedGlobeSegments : u.getSegmentsForLongitude(k.center.lng);
                                n && X.draw(t1, d.TRIANGLES, L, Yi.disabled, f, r, W, o.id, i, s, n);
                            }
                        } else if (c) {
                            L = new $i(d.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D);
                            const e = t1.globeSharedBuffers;
                            if (e) {
                                const [i, s, n] = e.getGridBuffers(Z, !1);
                                X.draw(t1, d.TRIANGLES, L, x || P, t1.colorModeForRenderPass(), r, W, o.id, i, s, n);
                            }
                        } else {
                            const { tileBoundsBuffer: e, tileBoundsIndexBuffer: i, tileBoundsSegments: s } = t1.getTileBoundsBuffers(T);
                            X.draw(t1, d.TRIANGLES, L, P, f, Qi.disabled, W, o.id, e, i, s);
                        }
                    }
                    if (!(u instanceof e.aU) && c) for (const e of s){
                        const s = e.canonical.y === (1 << e.canonical.z) - 1;
                        0 === e.canonical.y && wn(!0, e, t1, i, o, p, _, r, x || Yi.disabled), s && wn(!1, e, t1, i, o, p, _, r === Qi.frontCW ? Qi.backCW : Qi.frontCW, x || Yi.disabled);
                    }
                };
                c ? w(x, t1.renderElevatedRasterBackface ? Qi.backCW : Qi.frontCW, t1.stencilModeFor3D()) : w(x, Qi.disabled, void 0), t1.resetStencilClippingMasks();
            },
            "raster-particle": function(t1, i, o, s, r, n) {
                "offscreen" === t1.renderPass && function(t1, i, o, s) {
                    if (!s.length) return;
                    const r = t1.context, n = r.gl, a = i.getSource();
                    if (!(a instanceof pt)) return;
                    const l = Math.ceil(Math.sqrt(o.paint.get("raster-particle-count")));
                    let c = o.particlePositionRGBAImage;
                    if (!c || c.width !== l) {
                        const t1 = function(e) {
                            const t1 = e * e, i = new Uint8Array(4 * t1), o = function(e) {
                                return e |= 0, e = Math.imul(2747636419 ^ e, 2654435769), e = Math.imul(e ^ e >>> 16, 2654435769), ((e = Math.imul(e ^ e >>> 16, 2654435769)) >>> 0) / 4294967296;
                            }, s = .9090909090909091;
                            for(let e = 0; e < t1; e++){
                                const t1 = s * (o(2 * e + 0) + Fr), r = s * (o(2 * e + 1) + Fr), n = 255 * t1 % 1, a = 255 * r % 1, l = n, c = r - a / 255, h = a;
                                i[4 * e + 0] = 255 * (t1 - n / 255), i[4 * e + 1] = 255 * l, i[4 * e + 2] = 255 * c, i[4 * e + 3] = 255 * h;
                            }
                            return i;
                        }(l);
                        c = o.particlePositionRGBAImage = new e.q({
                            width: l,
                            height: l
                        }, t1);
                    }
                    let h = o.particleFramebuffer;
                    h ? h.width !== l && (h.destroy(), h = o.particleFramebuffer = r.createFramebuffer(l, l, 1, null)) : h = o.particleFramebuffer = r.createFramebuffer(l, l, 1, null);
                    const d = [];
                    for (const e of s){
                        const t1 = i.getTile(e);
                        if (!(t1 instanceof Ot)) continue;
                        const s = Cn(t1, a, o);
                        if (!s) continue;
                        const n = [
                            t1.tileSize,
                            t1.tileSize
                        ];
                        let h = o.tileFramebuffer;
                        h || (h = o.tileFramebuffer = r.createFramebuffer(n[0], n[1], 1, null));
                        let u = t1.rasterParticleState;
                        u || (u = t1.rasterParticleState = new In(r, e, n, c));
                        const _ = u.update(o.lastInvalidatedAt);
                        u.particleTextureDimension !== l && u.updateParticleTexture(e, c);
                        const p = u.targetColorTexture;
                        u.targetColorTexture = u.backgroundColorTexture, u.backgroundColorTexture = p;
                        const f = u.particleTexture0;
                        u.particleTexture0 = u.particleTexture1, u.particleTexture1 = f, d.push([
                            e,
                            s,
                            u,
                            _
                        ]);
                    }
                    if (0 === d.length) return;
                    const u = e.o.now(), _ = o.previousDrawTimestamp ? .001 * (u - o.previousDrawTimestamp) : .0167;
                    if (o.previousDrawTimestamp = u, o.hasColorMap()) {
                        r.activeTexture.set(n.TEXTURE0 + 2);
                        let t1 = o.colorRampTexture;
                        t1 || (t1 = o.colorRampTexture = new e.T(r, o.colorRamp, n.RGBA8)), t1.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                    }
                    r.bindFramebuffer.set(o.tileFramebuffer.framebuffer), function(t1, i, o) {
                        const s = t1.context, r = s.gl, n = i.tileFramebuffer;
                        s.activeTexture.set(r.TEXTURE0);
                        const a = {
                            u_texture: 0,
                            u_opacity: 1.05 * (c = i.paint.get("raster-particle-fade-opacity-factor")) / (c + .05)
                        }, l = t1.getOrCreateProgram("rasterParticleTexture", {
                            defines: [],
                            overrideFog: !1
                        });
                        var c;
                        for (const c of o){
                            const [, , o, h] = c;
                            n.colorAttachment0.set(o.targetColorTexture.texture), s.viewport.set([
                                0,
                                0,
                                n.width,
                                n.height
                            ]), s.clear({
                                color: e.ao.transparent
                            }), h && (o.backgroundColorTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE), l.draw(t1, r.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, a, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments));
                        }
                    }(t1, o, d), function(t1, i, o, s) {
                        const r = t1.context, n = r.gl, a = o.tileFramebuffer, l = "globe" === t1.transform.projection.name, c = o.paint.get("raster-particle-max-speed");
                        for (const h of s){
                            const [s, d, u] = h;
                            r.activeTexture.set(n.TEXTURE0 + 0), d.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a.colorAttachment0.set(u.targetColorTexture.texture);
                            const _ = t1.getOrCreateProgram("rasterParticleDraw", {
                                defines: d.defines,
                                overrideFog: !1
                            });
                            r.activeTexture.set(n.TEXTURE0 + 1);
                            const p = d.scalarData ? [] : [
                                0,
                                1,
                                2,
                                3
                            ].map((t1)=>e.e9[t1](s));
                            p.push(s);
                            const f = s.canonical.x, m = s.canonical.y;
                            for (const e of p){
                                const r = i.getTile(l ? e.wrapped() : e);
                                if (!r) continue;
                                const a = r.rasterParticleState;
                                if (!a) continue;
                                const h = e.canonical.x + (1 << e.canonical.z) * (e.wrap - s.wrap), u = e.canonical.y;
                                a.particleTexture0.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                                const p = kr(1, a.particleTexture0.size[0], [
                                    h - f,
                                    u - m
                                ], 0, d.texture.size, 2, c, d.textureOffset, d.scale, d.offset);
                                _.draw(t1, n.POINTS, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, p, o.id, a.particleIndexBuffer, void 0, a.particleSegment);
                            }
                        }
                    }(t1, i, o, d), r.bindFramebuffer.set(o.particleFramebuffer.framebuffer), function(t1, i, o, s) {
                        const r = t1.context, n = r.gl, a = i.paint.get("raster-particle-max-speed"), l = s * i.paint.get("raster-particle-speed-factor") * .15, c = function(e) {
                            return Math.pow(e, 6);
                        }(.01 + 1 * i.paint.get("raster-particle-reset-rate-factor")), h = i.particleFramebuffer;
                        r.viewport.set([
                            0,
                            0,
                            h.width,
                            h.height
                        ]);
                        for (const s of o){
                            const [, o, d] = s;
                            r.activeTexture.set(n.TEXTURE0 + 0), o.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.activeTexture.set(n.TEXTURE0 + 1);
                            const u = d.particleTexture0;
                            u.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                            const _ = Nr(1, u.size[0], 0, o.texture.size, a, l, c, o.textureOffset, o.scale, o.offset);
                            h.colorAttachment0.set(d.particleTexture1.texture), r.clear({
                                color: e.ao.transparent
                            }), t1.getOrCreateProgram("rasterParticleUpdate", {
                                defines: o.defines
                            }).draw(t1, n.TRIANGLES, $i.disabled, Yi.disabled, Wi.unblended, Qi.disabled, _, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                        }
                    }(t1, o, d, _);
                }(t1, i, o, s), "translucent" === t1.renderPass && (function(t1, i, o, s) {
                    const r = t1.context, n = r.gl, a = i.getSource().tileSize, l = 5 * (1 - e.ah(e.cL, e.cL + 1, t1.transform.zoom)) * a + o.paint.get("raster-particle-elevation"), c = !t1.options.moving, h = "globe" === t1.transform.projection.name;
                    if (!s.length) return;
                    const [d, u] = t1.stencilConfigForOverlap(s), _ = [];
                    h && _.push("PROJECTION_GLOBE_VIEW");
                    const p = t1.stencilModeFor3D();
                    for (const s of u){
                        const a = s.toUnwrapped(), u = i.getTile(s);
                        if (!u.rasterParticleState) continue;
                        const f = u.rasterParticleState, m = 100;
                        u.registerFadeDuration(m);
                        const g = i.findLoadedParent(s, 0), v = ir(u, g, i, t1.transform, m);
                        let y, x;
                        t1.terrain && t1.terrain.prepareDrawTile(), r.activeTexture.set(n.TEXTURE0), f.targetColorTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.activeTexture.set(n.TEXTURE1), g && g.rasterParticleState ? (g.rasterParticleState.targetColorTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), y = Math.pow(2, g.tileID.overscaledZ - u.tileID.overscaledZ), x = [
                            u.tileID.canonical.x * y % 1,
                            u.tileID.canonical.y * y % 1
                        ]) : f.targetColorTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                        const b = h ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(a, c), w = t1.transform, T = Rn(w), E = e.dG(s.canonical), S = e.dH(E.getCenter().lat);
                        let I, C, R, A, L;
                        h ? (I = Float32Array.from(e.bk(e.dJ(s.canonical))), C = Float32Array.from(w.globeMatrix), R = Float32Array.from(e.dF(w)), A = [
                            e.aF(w.center.lng),
                            e.aJ(w.center.lat)
                        ], L = Float32Array.from(e.dI(s.canonical, E, S, w.worldSize / w._pixelsPerMercatorPixel))) : (I = new Float32Array(16), C = new Float32Array(9), R = new Float32Array(16), A = [
                            0,
                            0
                        ], L = new Float32Array(9));
                        const D = Br(b, I, C, R, L, x || [
                            0,
                            0
                        ], e.aj(t1.transform.zoom), A, T, y || 1, v, l), P = t1.isTileAffectedByFog(s), O = t1.getOrCreateProgram("rasterParticle", {
                            defines: _,
                            overrideFog: P
                        });
                        if (t1.uploadCommonUniforms(r, O, a), h) {
                            const e = new $i(n.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D), i = 0, s = t1.globeSharedBuffers;
                            if (s) {
                                const [r, a, l] = s.getGridBuffers(S, 0 !== i);
                                O.draw(t1, n.TRIANGLES, e, p, Wi.alphaBlended, t1.renderElevatedRasterBackface ? Qi.frontCCW : Qi.backCCW, D, o.id, r, a, l);
                            }
                        } else {
                            const e = t1.depthModeForSublayer(0, $i.ReadOnly), i = d[s.overscaledZ], { tileBoundsBuffer: r, tileBoundsIndexBuffer: a, tileBoundsSegments: l } = t1.getTileBoundsBuffers(u);
                            O.draw(t1, n.TRIANGLES, e, i, Wi.alphaBlended, Qi.disabled, D, o.id, r, a, l);
                        }
                    }
                    t1.resetStencilClippingMasks();
                }(t1, i, o, s), t1.style.map.triggerRepaint());
            },
            background: function(t1, i, o, s) {
                const r = o.paint.get("background-color"), n = "none" === o.paint.get("background-color-use-theme").constantOr("default"), a = o.paint.get("background-opacity"), l = o.paint.get("background-emissive-strength"), c = "viewport" === o.paint.get("background-pitch-alignment");
                if (0 === a) return;
                const h = t1.context, d = h.gl, u = t1.transform, _ = u.tileSize, p = o.paint.get("background-pattern");
                let f;
                if (void 0 !== p) {
                    if (null === p) return;
                    if (f = t1.imageManager.getPattern(e.I.from(p.toString()), o.scope, t1.style.getLut(o.scope)), !f) return;
                }
                const m = !p && 1 === r.a && 1 === a && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== m) return;
                const g = Yi.disabled, v = t1.depthModeForSublayer(0, "opaque" === m ? $i.ReadWrite : $i.ReadOnly), y = t1.colorModeForDrapableLayerRenderPass(l), x = p ? "backgroundPattern" : "background";
                let b, w = s;
                w || (b = t1.getBackgroundTiles(), w = Object.values(b).map((e)=>e.tileID)), p && (h.activeTexture.set(d.TEXTURE0), t1.imageManager.bind(t1.context, o.scope));
                const T = [];
                if (t1.terrain && t1.terrain.renderingToTexture && "mrt-fallback" === t1.emissiveMode && T.push("USE_MRT1"), c) {
                    const i = t1.getOrCreateProgram(x, {
                        overrideFog: !1,
                        overrideRtt: !0,
                        defines: T
                    }), s = new Float32Array(e.bA([])), h = new e.aQ(0, 0, 0, 0, 0), u = p ? Gr(s, l, a, t1, 0, o.scope, f, c, {
                        tileID: h,
                        tileSize: _
                    }) : Vr(s, l, a, r.toPremultipliedRenderColor(n ? null : o.lut));
                    return void i.draw(t1, d.TRIANGLES, v, g, y, Qi.disabled, u, o.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                }
                for (const e of w){
                    const m = t1.isTileAffectedByFog(e), w = t1.getOrCreateProgram(x, {
                        overrideFog: m,
                        defines: T
                    }), E = e.toUnwrapped(), S = s ? e.projMatrix : t1.transform.calculateProjMatrix(E);
                    t1.prepareDrawTile();
                    const I = i ? i.getTile(e) : b ? b[e.key] : new Pt(e, _, u.zoom, t1), C = p ? Gr(S, l, a, t1, 0, o.scope, f, c, {
                        tileID: e,
                        tileSize: _
                    }) : Vr(S, l, a, r.toPremultipliedRenderColor(n ? null : o.lut));
                    t1.uploadCommonUniforms(h, w, E);
                    const { tileBoundsBuffer: R, tileBoundsIndexBuffer: A, tileBoundsSegments: L } = t1.getTileBoundsBuffers(I);
                    w.draw(t1, d.TRIANGLES, v, g, y, Qi.disabled, C, o.id, R, A, L);
                }
            },
            sky: function(t1, i, o) {
                const s = t1._atmosphere ? e.aj(t1.transform.zoom) : 1, r = o.paint.get("sky-opacity") * s;
                if (0 === r) return;
                const n = t1.context, a = o.paint.get("sky-type"), l = new $i(n.gl.LEQUAL, $i.ReadOnly, [
                    0,
                    1
                ]), c = t1.frameCounter / 1e3 % 1;
                "atmosphere" === a ? "offscreen" === t1.renderPass ? o.needsSkyboxCapture(t1) && (function(t1, i) {
                    const o = t1.context, s = o.gl;
                    let r = i.skyboxFbo;
                    if (!r) {
                        r = i.skyboxFbo = o.createFramebuffer(32, 32, 1, null), i.skyboxGeometry = new Vn(o), i.skyboxTexture = o.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
                        for(let e = 0; e < 6; ++e)s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);
                    }
                    o.bindFramebuffer.set(r.framebuffer), o.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const n = i.getCenter(t1, !0), a = t1.getOrCreateProgram("skyboxCapture"), l = new Float64Array(16);
                    e.bA(l), e.en(l, l, .5 * -Math.PI), Gn(t1, i, a, l, n, 0), e.bA(l), e.en(l, l, .5 * Math.PI), Gn(t1, i, a, l, n, 1), e.bA(l), e.cU(l, l, .5 * -Math.PI), Gn(t1, i, a, l, n, 2), e.bA(l), e.cU(l, l, .5 * Math.PI), Gn(t1, i, a, l, n, 3), e.bA(l), Gn(t1, i, a, l, n, 4), e.bA(l), e.en(l, l, Math.PI), Gn(t1, i, a, l, n, 5), o.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                }(t1, o), o.markSkyboxValid(t1)) : "sky" === t1.renderPass && function(e, t1, i, o, s) {
                    const r = e.context, n = r.gl, a = e.transform, l = e.getOrCreateProgram("skybox");
                    r.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_CUBE_MAP, t1.skyboxTexture);
                    const c = ((e, t1, i, o, s)=>({
                            u_matrix: e,
                            u_sun_direction: t1,
                            u_cubemap: 0,
                            u_opacity: o,
                            u_temporal_offset: s
                        }))(a.skyboxMatrix, t1.getCenter(e, !1), 0, o, s);
                    e.uploadCommonUniforms(r, l), l.draw(e, n.TRIANGLES, i, Yi.disabled, e.colorModeForRenderPass(), Qi.backCW, c, "skybox", t1.skyboxGeometry.vertexBuffer, t1.skyboxGeometry.indexBuffer, t1.skyboxGeometry.segment);
                }(t1, o, l, r, c) : "gradient" === a && "sky" === t1.renderPass && function(t1, i, o, s, r) {
                    const n = t1.context, a = n.gl, l = t1.transform, c = t1.getOrCreateProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new Vn(n)), n.activeTexture.set(a.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new e.T(n, i.colorRamp, a.RGBA8)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    const d = ((t1, i, o, s, r)=>({
                            u_matrix: t1,
                            u_color_ramp: 0,
                            u_center_direction: i,
                            u_radius: e.an(o),
                            u_opacity: s,
                            u_temporal_offset: r
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), i.paint.get("sky-gradient-radius"), s, r);
                    t1.uploadCommonUniforms(n, c), c.draw(t1, a.TRIANGLES, o, Yi.disabled, t1.colorModeForRenderPass(), Qi.backCW, d, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, l, r, c);
            },
            custom: function(t1, i, o, s) {
                const r = t1.context, n = o.implementation;
                if (!t1.transform.projection.unsupportedLayers || !t1.transform.projection.unsupportedLayers.includes("custom") || t1.terrain && (t1.terrain.renderingToTexture || "offscreen" === t1.renderPass) && o.isDraped(i)) {
                    if ("offscreen" === t1.renderPass) {
                        const i = n.prerender;
                        if (i) {
                            if (t1.setCustomLayerDefaults(), r.setColorMode(t1.colorModeForRenderPass()), "globe" === t1.transform.projection.name) {
                                const o = t1.transform.pointMerc;
                                i.call(n, r.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.aj(t1.transform.zoom), [
                                    o.x,
                                    o.y
                                ], t1.transform.pixelsPerMeterRatio);
                            } else i.call(n, r.gl, t1.transform.customLayerMatrix());
                            r.setDirty(), t1.setBaseState();
                        }
                    } else if ("translucent" === t1.renderPass) {
                        if (t1.terrain && t1.terrain.renderingToTexture) {
                            const e = n.renderToTile;
                            if (e) {
                                const i = s[0].canonical, o = {
                                    x: i.x + s[0].wrap * (n.wrapTileId ? 0 : 1 << i.z),
                                    y: i.y,
                                    z: i.z
                                };
                                r.setDepthMode($i.disabled), r.setStencilMode(Yi.disabled), r.setColorMode(t1.colorModeForRenderPass()), t1.setCustomLayerDefaults(), e.call(n, r.gl, o), r.setDirty(), t1.setBaseState();
                            }
                            return;
                        }
                        t1.setCustomLayerDefaults(), r.setColorMode(t1.colorModeForRenderPass()), r.setStencilMode(Yi.disabled);
                        const i = "3d" === n.renderingMode ? new $i(t1.context.gl.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, $i.ReadOnly);
                        if (r.setDepthMode(i), "globe" === t1.transform.projection.name) {
                            const i = t1.transform.pointMerc;
                            n.render(r.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.aj(t1.transform.zoom), [
                                i.x,
                                i.y
                            ], t1.transform.pixelsPerMeterRatio);
                        } else n.render(r.gl, t1.transform.customLayerMatrix());
                        r.setDirty(), t1.setBaseState(), r.bindFramebuffer.set(null);
                    }
                } else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            },
            model: function(t1, i, o, s) {
                if ("opaque" === t1.renderPass) return;
                const r = o.paint.get("model-opacity").constantOr(1), n = o.paint.get("model-elevation-reference"), a = "ground" === n, l = "ground" === n;
                if (0 === r) return;
                const c = o.paint.get("model-cast-shadows");
                if ("shadow" === t1.renderPass) {
                    if (!c) return;
                    if (t1.terrain && r < .65 && o._transitionablePaint._values["model-opacity"].value.expression instanceof e.ad) return;
                }
                const h = t1.shadowRenderer, d = o.paint.get("model-receive-shadows");
                h && (h.useNormalOffset = !0, d || (h.enabled = !1));
                const u = ()=>{
                    h && (h.useNormalOffset = !0, d || (h.enabled = !0));
                }, _ = i.getSource();
                if ("light-beam" === t1.renderPass && "batched-model" !== _.type) return;
                if ("vector" === _.type || "geojson" === _.type) return function(t1, i, o, s, r) {
                    const n = t1.transform, a = "globe" === n.projection.name, l = n.getFreeCameraOptions().position;
                    if (!t1.modelManager) return;
                    const c = t1.modelManager;
                    o.modelManager = c;
                    const h = t1.shadowRenderer;
                    if (!o._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
                    const d = o._unevaluatedLayout._values["model-id"], u = Object.assign({}, o.layout.get("model-id").parameters), _ = t1.style.order.indexOf(o.fqid), p = o.paint.get("model-opacity").constantOr(1);
                    for (const f of s){
                        const s = i.getTile(f).getBucket(o);
                        if (!s || s.projection.name !== n.projection.name) continue;
                        const m = s.getModelUris();
                        if (m && !s.modelsRequested && (c.addModelsFromBucket(m, r), s.modelsRequested = !0), a) u.zoom = f.overscaledZ;
                        else {
                            const e = aa(f, n);
                            u.zoom = e;
                        }
                        const g = d.possiblyEvaluate(u);
                        if (ra(t1, s, f), na.shadowUniformsInitialized = !1, na.useSingleShadowCascade = !!h && 0 === h.getMaxCascadeForTile(f.toUnwrapped()), "shadow" === t1.renderPass && h) {
                            if (1 === t1.currentShadowCascade && s.isInsideFirstShadowMapFrustum) continue;
                            const i = n.calculatePosMatrix(f.toUnwrapped(), n.worldSize);
                            if (na.tileMatrix.set(i), na.shadowTileMatrix = Float32Array.from(h.calculateShadowPassMatrixFromMatrix(i)), na.aabb.min = [
                                0,
                                0,
                                0
                            ], na.aabb.max[0] = na.aabb.max[1] = e.al, na.aabb.max[2] = 0, ha(s, na, t1, o.scope)) continue;
                        }
                        const v = 1 << f.canonical.z, y = [
                            ((l.x - f.wrap) * v - f.canonical.x) * e.al,
                            (l.y * v - f.canonical.y) * e.al,
                            l.z * v * e.al
                        ];
                        t1.conflationActive && Object.keys(s.instancesPerModel).length > 0 && t1.style.isLayerClipped(o, i.getSource()) && s.updateReplacement(f, t1.replacementSource, _, o.scope) && (s.uploaded = !1, s.upload(t1.context));
                        let x = 0;
                        const b = new Array, w = new Array, T = new Array;
                        for(let i in s.instancesPerModel){
                            const n = s.instancesPerModel[i];
                            n.features.length > 0 && !a && (i = g.evaluate(n.features[0].feature, {}));
                            const h = c.getModel(i, r);
                            if (h || c.hasURLBeenRequested(i) || s.modelUris.includes(i) || (s.modelUris.push(i), s.modelsRequested = !1), h && h.uploaded) if (a) {
                                const i = e.c5([], [
                                    l.x,
                                    l.y,
                                    l.z
                                ], t1.transform.worldSize);
                                e.ew(i, i);
                                for(let o = 0; o < n.instancedDataArray.length; ++o){
                                    const r = [
                                        0,
                                        0,
                                        0
                                    ], a = [
                                        1,
                                        1,
                                        1
                                    ], l = e.ex(), c = n.tileCoordinatesForInstance(o), d = n.transformForInstance(o);
                                    e.ey(a, d), e.ez(l, d), e.eA(r, l);
                                    const u = n.translationForInstance(o), _ = new e.aT(0, 0);
                                    e.eB(s.canonical, _, c.x, c.y);
                                    const f = e.bC();
                                    e.eC(f, h, t1.transform, _, r, a, u, !0, !1, !1);
                                    const m = n.colorForInstance(o), g = e.bA([]), v = e.ef(_.lat, t1.transform.zoom), y = e.bq([], [
                                        1,
                                        1,
                                        1 / v
                                    ]);
                                    e.br(g, g, i), T.push({
                                        zScaleMatrix: y,
                                        negCameraPosMatrix: g
                                    });
                                    for (const e of h.nodes)ea(t1, e, f, t1.transform.expandedFarZProjMatrix, x, b, w, h.materialOverrides, p, m);
                                    ++x;
                                }
                            } else for (const e of h.nodes)la(t1, o, e, n, y, f, na);
                        }
                        if (a) if ("shadow" === t1.renderPass) {
                            for (const e of w)ta(e.mesh, e.nodeModelMatrix, t1, o);
                            for (const e of b)ta(e.mesh, e.nodeModelMatrix, t1, o);
                        } else sa(t1, o, b, w, T);
                    }
                }(t1, i, o, s, Qn(t1, o)), void u();
                if (!_.loaded()) return;
                if ("batched-model" === _.type) return function(t1, i, o, s) {
                    o.resetLayerRenderingStats(t1);
                    const r = t1.context, n = t1.transform, a = t1.style.fog, l = t1.shadowRenderer;
                    if ("mercator" !== n.projection.name) return void e.w(`Drawing 3D landmark models for ${n.projection.name} projection is not yet implemented`);
                    const c = t1.transform.getFreeCameraOptions().position, h = e.c5([], [
                        c.x,
                        c.y,
                        c.z
                    ], t1.transform.worldSize), d = e.ew([], h), u = e.bA([]), _ = e.ef(n.center.lat, n.zoom), p = e.bq([], [
                        1,
                        1,
                        1 / _
                    ]);
                    e.br(u, u, d);
                    const f = o.paint.get("model-opacity").constantOr(1), m = new $i(r.gl.LEQUAL, $i.ReadWrite, t1.depthRangeFor3D), g = new $i(r.gl.LEQUAL, $i.ReadOnly, t1.depthRangeFor3D), v = new e.d9([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]), y = "shadow" === t1.renderPass, x = y && l ? l.getCurrentCascadeFrustum() : n.getFrustum(n.scaleZoom(n.worldSize)), b = o.paint.get("model-front-cutoff"), w = b[2] < 1, T = co(t1, o.paint.get("model-cutoff-fade-range")), E = o.getLayerRenderingStats();
                    (function(e, t1, i, o) {
                        const s = e.terrain ? e.terrain.exaggeration() : 0, r = e.transform.zoom;
                        for (const n of o){
                            const o = t1.getTile(n).getBucket(i);
                            o && (o.setFilter(i.filter), e.conflationActive && o.updateReplacement(n, e.replacementSource), o.evaluateTransform(e, i), e.terrain && s > 0 && o.elevationUpdate(e.terrain, s, n, i.source), o.needsReEvaluation(e, r, i) && o.evaluate(i));
                        }
                    })(t1, i, o, s), function() {
                        let c, d, S;
                        w ? (c = s.length - 1, d = -1, S = -1) : (c = 0, d = s.length, S = 1);
                        const I = new Float64Array(16), C = e.cA(), R = new e.P(0, 0);
                        for(let A = c; A !== d; A += S){
                            const c = s[A], d = i.getTile(c).getBucket(o);
                            if (!d || !d.uploaded) continue;
                            let S = !1;
                            l && (S = 0 === l.getMaxCascadeForTile(c.toUnwrapped()));
                            const L = n.calculatePosMatrix(c.toUnwrapped(), n.worldSize), D = d.modelTraits;
                            !y && w && (e.bl(I, L), e.af(C, h, I), R.x = C[0], R.y = C[1]);
                            const P = [];
                            d.setFilter(o.filter);
                            for (const i of d.getNodesInfo()){
                                if (i.hiddenByReplacement) continue;
                                if (!i.node.meshes) continue;
                                const o = i.node;
                                let s = 0;
                                t1.terrain && o.elevation && (s = o.elevation * t1.terrain.exaggeration());
                                const r = (()=>{
                                    const t1 = i.aabb;
                                    return v.min = [
                                        ...t1.min
                                    ], v.max = [
                                        ...t1.max
                                    ], v.min[2] += s, v.max[2] += s, e.af(v.min, v.min, L), e.af(v.max, v.max, L), v;
                                })(), a = i.evaluatedScale;
                                if (a[0] <= 1 && a[1] <= 1 && a[2] <= 1 && 0 === r.intersects(x)) continue;
                                if (!y && w) {
                                    const t1 = 1 / 6;
                                    i.cameraCollisionOpacity = h[0] > r.min[0] && h[0] < r.max[0] && h[1] > r.min[1] && h[1] < r.max[1] && h[2] * _ < r.max[2] && o.footprint && e.c0(R, o.footprint) ? Math.max(i.cameraCollisionOpacity - t1, 0) : Math.min(1, i.cameraCollisionOpacity + t1);
                                }
                                const l = [
                                    ...L
                                ], d = 1 / e.d7(c.canonical), u = o.anchor ? o.anchor[0] : 0, p = o.anchor ? o.anchor[1] : 0;
                                e.br(l, l, [
                                    u * (a[0] - 1) + i.evaluatedTranslation[0] * d,
                                    p * (a[1] - 1) + i.evaluatedTranslation[1] * d,
                                    s + i.evaluatedTranslation[2]
                                ]), e.cq(a, e.eE) || e.cS(l, l, a);
                                const m = e.aB([], l, o.globalMatrix), g = e.aB([], n.expandedFarZProjMatrix, m), E = e.aB([], n.expandedFarZProjMatrix, l), S = e.aC([], [
                                    u,
                                    p,
                                    s,
                                    1
                                ], g)[2];
                                o.hidden = !1;
                                let I = f;
                                y || (w && (I *= i.cameraCollisionOpacity, I *= ua(l, n, i.aabb, b)), I *= da(T, S)), 0 !== I ? P.push({
                                    nodeInfo: i,
                                    depth: S,
                                    opacity: I,
                                    wvpForNode: g,
                                    wvpForTile: E,
                                    nodeModelMatrix: m,
                                    tileModelMatrix: l
                                }) : o.hidden = !0;
                            }
                            y || P.sort((e, t1)=>!w || 1 === e.opacity && 1 === t1.opacity ? e.depth < t1.depth ? -1 : 1 : 1 === e.opacity ? -1 : 1 === t1.opacity ? 1 : e.depth > t1.depth ? -1 : 1);
                            for (const i of P){
                                const s = i.nodeInfo, c = s.node;
                                let h = e.aB([], p, i.tileModelMatrix);
                                e.aB(h, u, h);
                                const d = e.bl([], h);
                                e.eg(d, d), e.cS(d, d, ca), h = e.aB(h, h, c.globalMatrix);
                                const _ = "light-beam" === t1.renderPass, f = "none" === o.paint.get("model-color-use-theme").constantOr("default"), v = D & e.eI.HasMapboxMeshFeatures, x = v ? 0 : s.evaluatedRMEA[0][2];
                                for(let e = 0; e < c.meshes.length; ++e){
                                    const u = c.meshes[e], p = e === c.lightMeshIndex;
                                    let b = i.wvpForNode;
                                    if (p) {
                                        if (!_ && !t1.terrain && t1.shadowRenderer) {
                                            t1.currentLayer < t1.firstLightBeamLayer && (t1.firstLightBeamLayer = t1.currentLayer);
                                            continue;
                                        }
                                        b = i.wvpForTile;
                                    } else if (_) continue;
                                    const w = {
                                        defines: []
                                    }, T = [];
                                    if (!y && l && (l.useNormalOffset = !!u.normalBuffer), Kn(w.defines, T, u, t1, f ? null : o.lut), v || w.defines.push("DIFFUSE_SHADED"), S && w.defines.push("SHADOWS_SINGLE_CASCADE"), E && (y ? E.numRenderedVerticesInShadowPass += u.vertexArray.length : E.numRenderedVerticesInTransparentPass += u.vertexArray.length), y) {
                                        ta(u, i.nodeModelMatrix, t1, o);
                                        continue;
                                    }
                                    let I = null;
                                    if (a) {
                                        const e = Yn(i.nodeModelMatrix, t1.transform);
                                        if (I = new Float32Array(e), "globe" !== n.projection.name) {
                                            const t1 = u.aabb.min, i = u.aabb.max, [o, s] = a.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                                            w.overrideFog = o >= Ve || s >= Ve;
                                        }
                                    }
                                    const C = u.material;
                                    let R;
                                    C.occlusionTexture && C.occlusionTexture.offsetScale && (R = C.occlusionTexture.offsetScale, w.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                                    const A = t1.getOrCreateProgram("model", w);
                                    !y && l && l.setupShadowsFromMatrix(i.tileModelMatrix, A, l.useNormalOffset), t1.uploadCommonUniforms(r, A, null, I);
                                    const L = C.pbrMetallicRoughness;
                                    L.metallicFactor = .9, L.roughnessFactor = .5;
                                    const D = qr(new Float32Array(b), new Float32Array(h), new Float32Array(d), new Float32Array(c.globalMatrix), t1, i.opacity, L.baseColorFactor, C.emissiveFactor, L.metallicFactor, L.roughnessFactor, C, x, o, [
                                        0,
                                        0,
                                        0
                                    ], R);
                                    !p && (s.hasTranslucentParts || i.opacity < 1) && A.draw(t1, r.gl.TRIANGLES, m, Yi.disabled, Wi.disabled, Qi.backCCW, D, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t1.transform.zoom, void 0, T), A.draw(t1, r.gl.TRIANGLES, p ? g : m, Yi.disabled, p || i.opacity < 1 || s.hasTranslucentParts ? Wi.alphaBlended : Wi.unblended, Qi.backCCW, D, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t1.transform.zoom, void 0, T);
                                }
                            }
                        }
                    }();
                }(t1, i, o, s), void u();
                if ("model" !== _.type) return;
                const p = _.getModels(), f = [], m = t1.transform.getFreeCameraOptions().position, g = e.c5([], [
                    m.x,
                    m.y,
                    m.z
                ], t1.transform.worldSize);
                e.ew(g, g);
                const v = [], y = [];
                let x = 0;
                for (const s of p){
                    const r = i.getFeatureState("", s.id), n = {
                        type: "Unknown",
                        id: s.id,
                        properties: s.featureProperties
                    }, c = o.paint.get("model-rotation").evaluate(n, r), h = o.paint.get("model-scale").evaluate(n, r), d = o.paint.get("model-translation").evaluate(n, r), u = o.paint.get("model-opacity").evaluate(n, r);
                    ia(o, s.id, r, s.featureProperties, s.nodeOverrideNames, s.nodeOverrides), oa(o, s.id, r, s.featureProperties, s.materialOverrideNames, s.materialOverrides), s.nodeOverrides.size > 0 && s.computeBoundsAndApplyParent(), s.computeModelMatrix(t1, c, h, d, l, a, !1);
                    const _ = e.bA([]), p = e.ef(s.position.lat, t1.transform.zoom), m = e.bq([], [
                        1,
                        1,
                        1 / p
                    ]);
                    e.br(_, _, g), f.push({
                        zScaleMatrix: m,
                        negCameraPosMatrix: _
                    });
                    for (const e of s.nodes)ea(t1, e, s.matrix, t1.transform.expandedFarZProjMatrix, x, v, y, s.materialOverrides, u);
                    x++;
                }
                if (v.sort((e, t1)=>t1.depth - e.depth), "shadow" !== t1.renderPass) sa(t1, o, v, y, f), u();
                else {
                    for (const e of y)ta(e.mesh, e.nodeModelMatrix, t1, o);
                    for (const e of v)ta(e.mesh, e.nodeModelMatrix, t1, o);
                    u();
                }
            }
        }, Aa = {
            line: function(e, t1, i) {
                if (e.hasElevatedBuckets = !1, e.hasNonElevatedBuckets = !1, void 0 !== e._unevaluatedLayout.getValue("line-elevation-reference") || void 0 !== e._unevaluatedLayout.getValue("line-z-offset")) {
                    if (t1) {
                        const i = t1.getVisibleCoordinates();
                        for (const o of i){
                            const i = t1.getTile(o).getBucket(e);
                            if (i && ("none" !== i.elevationType ? e.hasElevatedBuckets = !0 : e.hasNonElevatedBuckets = !0, e.hasElevatedBuckets && e.hasNonElevatedBuckets)) break;
                        }
                    }
                } else e.hasNonElevatedBuckets = !0;
            },
            model: function(e, t1, i) {
                const o = t1.getSource();
                if (!o.loaded()) return;
                if ("vector" === o.type || "geojson" === o.type) return void (i.modelManager && i.modelManager.upload(i, Qn(i, e)));
                if ("batched-model" === o.type) return;
                if ("model" !== o.type) return;
                const s = o.getModels();
                for (const e of s)e.upload(i.context);
            },
            raster: function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof pt && o.loaded())) return;
                const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!s) return;
                const r = e.paint.get("raster-array-band") || o.getInitialBand(s);
                if (null == r) return;
                const n = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const t1 of n)t1.updateNeeded(e.id, r) && o.prepareTile(t1, s, e.id, r);
            },
            "raster-particle": function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof pt && o.loaded())) return;
                const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!s) return;
                const r = e.paint.get("raster-particle-array-band") || o.getInitialBand(s);
                if (null == r) return;
                const n = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const t1 of n)t1.updateNeeded(e.id, r) && o.prepareTile(t1, s, e.id, r);
            }
        }, La = {
            fill: cn
        }, Da = {
            fill: function(e, t1, i, o) {
                if (!i.layout || "none" === i.layout.get("fill-elevation-reference") || 0 === i.paint.get("fill-opacity").constantOr(1)) return;
                const s = e.context.gl, r = new $i(s.LEQUAL, $i.ReadOnly, e.depthRangeFor3D), n = new Yi({
                    func: s.ALWAYS,
                    mask: 255
                }, 255, 255, s.KEEP, s.KEEP, s.REPLACE), a = e.transform.getFreeCameraOptions().position, l = e.getOrCreateProgram("elevatedStructuresDepthReconstruct");
                for (const c of o){
                    const o = t1.getTile(c), h = o.getBucket(i);
                    if (!h) continue;
                    const d = h.elevatedStructures;
                    if (!d || 0 === d.depthSegments.segments[0].primitiveLength) continue;
                    const u = ln(c.toUnwrapped(), a), _ = e.translatePosMatrix(c.projMatrix, o, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor")), p = Tr(_, u, 0, 1, 0);
                    l.draw(e, s.TRIANGLES, r, n, Wi.disabled, Qi.disabled, p, i.id, d.vertexBuffer, d.indexBuffer, d.depthSegments, i.paint, e.transform.zoom);
                }
            }
        };
        class Pa {
            constructor(t1, i, o, s, r){
                this.context = new Jr(t1, i), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this._timeStamp = e.o.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {
                    forceEnablePrecipitation: !1,
                    showTerrainProxyTiles: !1,
                    fpsWindow: 30,
                    continousRedraw: !1,
                    enabledLayers: {}
                };
                const n = [
                    "fill",
                    "line",
                    "symbol",
                    "circle",
                    "heatmap",
                    "fill-extrusion",
                    "building",
                    "raster",
                    "raster-particle",
                    "hillshade",
                    "model",
                    "background",
                    "sky"
                ];
                for (const e of n)this._debugParams.enabledLayers[e] = !0;
                for (const e of n);
                this.occlusionParams = new fa, this.setup(), this.numSublayers = Ft.maxUnderzooming + Ft.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.eP, this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new po(this), this._wireframeDebugCache = new pa, this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
                const a = new e.q({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0));
                this.emptyDepthTexture = new e.T(this.context, a, t1.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = s, this.worldview = r, this._forceEmissiveMode = !1, this.emissiveMode = "constant";
            }
            updateTerrain(e, t1) {
                const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new nr(this, e));
                const o = this._terrain;
                this.transform.elevation = i ? o : null, o.update(e, this.transform, t1), this.transform.elevation && !o.enabled && (this.transform.elevation = null);
            }
            _updateFog(e) {
                const t1 = e.fog;
                if (!t1 || "globe" === this.transform.projection.name || t1.getOpacity(this.transform.pitch) < 1 || t1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                const [i, o] = t1.getFovAdjustedRange(this.transform._fov);
                if (i > o) return void (this.transform.fogCullDistSq = null);
                const s = i + .78 * (o - i);
                this.transform.fogCullDistSq = s * s;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
            }
            get forceTerrainMode() {
                return this._forceTerrainMode;
            }
            set forceTerrainMode(e) {
                e && !this._terrain && (this._terrain = new nr(this, this.style)), this._forceTerrainMode = e;
            }
            get shadowRenderer() {
                return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
            }
            get wireframeDebugCache() {
                return this._wireframeDebugCache;
            }
            resize(t1, i) {
                if (this.width = t1 * e.o.devicePixelRatio, this.height = i * e.o.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e of this.style.order)this.style._mergedLayers[e].resize();
            }
            setup() {
                const t1 = this.context, i = new e.bd;
                i.emplaceBack(0, 0), i.emplaceBack(e.al, 0), i.emplaceBack(0, e.al), i.emplaceBack(e.al, e.al), this.tileExtentBuffer = t1.createVertexBuffer(i, e.bf.members), this.tileExtentSegments = e.bg.simpleSegment(0, 0, 4, 2);
                const o = new e.bd;
                o.emplaceBack(0, 0), o.emplaceBack(e.al, 0), o.emplaceBack(0, e.al), o.emplaceBack(e.al, e.al), this.debugBuffer = t1.createVertexBuffer(o, e.bf.members), this.debugSegments = e.bg.simpleSegment(0, 0, 4, 5);
                const s = new e.bd;
                s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(-1, 1), s.emplaceBack(1, 1), this.viewportBuffer = t1.createVertexBuffer(s, e.bf.members), this.viewportSegments = e.bg.simpleSegment(0, 0, 4, 2);
                const r = new e.b1;
                r.emplaceBack(0, 0, 0, 0), r.emplaceBack(e.al, 0, e.al, 0), r.emplaceBack(0, e.al, 0, e.al), r.emplaceBack(e.al, e.al, e.al, e.al), this.mercatorBoundsBuffer = t1.createVertexBuffer(r, e.bi.members), this.mercatorBoundsSegments = e.bg.simpleSegment(0, 0, 4, 2);
                const n = new e.b0;
                n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t1.createIndexBuffer(n);
                const a = new e.be;
                for (const e of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])a.emplaceBack(e);
                this.debugIndexBuffer = t1.createIndexBuffer(a), this.emptyTexture = new e.T(t1, new e.q({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t1.gl.RGBA8), this.identityMat = e.bC();
                const l = this.context.gl;
                this.stencilClearMode = new Yi({
                    func: l.ALWAYS,
                    mask: 0
                }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e) {
                return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
                    tileBoundsBuffer: e._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
                    tileBoundsSegments: e._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const e = this.context.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e.TRIANGLES, $i.disabled, this.stencilClearMode, Wi.disabled, Qi.disabled, tr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(e, t1, i) {
                if (!t1 || this.currentStencilSource === t1.id || !e.isTileClipped() || !i || 0 === i.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e = !1;
                    for (const t1 of i)if (void 0 === this._tileClippingMaskIDs[t1.key]) {
                        e = !0;
                        break;
                    }
                    if (!e) return;
                }
                this.currentStencilSource = t1.id;
                const o = this.context, s = o.gl;
                this.nextStencilID + i.length > 256 && this.clearStencil(), o.setColorMode(Wi.disabled), o.setDepthMode($i.disabled);
                const r = this.getOrCreateProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const e of i){
                    const i = t1.getTile(e), o = this._tileClippingMaskIDs[e.key] = this.nextStencilID++, { tileBoundsBuffer: n, tileBoundsIndexBuffer: a, tileBoundsSegments: l } = this.getTileBoundsBuffers(i);
                    r.draw(this, s.TRIANGLES, $i.disabled, new Yi({
                        func: s.ALWAYS,
                        mask: 0
                    }, o, 255, s.KEEP, s.KEEP, s.REPLACE), Wi.disabled, Qi.disabled, tr(e.projMatrix), "$clipping", n, a, l);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const e = this.nextStencilID++, t1 = this.context.gl;
                return new Yi({
                    func: t1.NOTEQUAL,
                    mask: 255
                }, e, 255, t1.KEEP, t1.KEEP, t1.REPLACE);
            }
            stencilModeForClipping(e) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e);
                const t1 = this.context.gl;
                return new Yi({
                    func: t1.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[e.key], 0, t1.KEEP, t1.KEEP, t1.REPLACE);
            }
            stencilConfigForOverlap(e) {
                const t1 = this.context.gl, i = e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ), o = i[i.length - 1].overscaledZ, s = i[0].overscaledZ - o + 1;
                if (s > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + s > 256 && this.clearStencil();
                    const e = {};
                    for(let i = 0; i < s; i++)e[i + o] = new Yi({
                        func: t1.GEQUAL,
                        mask: 255
                    }, i + this.nextStencilID, 255, t1.KEEP, t1.KEEP, t1.REPLACE);
                    return this.nextStencilID += s, [
                        e,
                        i
                    ];
                }
                return [
                    {
                        [o]: Yi.disabled
                    },
                    i
                ];
            }
            colorModeForRenderPass() {
                const t1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new Wi([
                        t1.CONSTANT_COLOR,
                        t1.ONE,
                        t1.CONSTANT_COLOR,
                        t1.ONE
                    ], new e.ao(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? Wi.unblended : Wi.alphaBlended;
            }
            colorModeForDrapableLayerRenderPass(t1) {
                const i = this.context.gl;
                return (()=>this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? null != t1 && "mrt-fallback" !== this.emissiveMode || "constant" === this.emissiveMode ? new Wi([
                    i.ONE,
                    i.ONE_MINUS_SRC_ALPHA,
                    i.CONSTANT_ALPHA,
                    i.ONE_MINUS_SRC_ALPHA
                ], new e.ao(0, 0, 0, null != t1 ? t1 : 0), [
                    !0,
                    !0,
                    !0,
                    !0
                ]) : "dual-source-blending" === this.emissiveMode ? new Wi([
                    i.ONE,
                    i.ONE_MINUS_SRC_ALPHA,
                    this.context.extBlendFuncExtended.SRC1_ALPHA_WEBGL,
                    i.ONE_MINUS_SRC_ALPHA
                ], e.ao.transparent, [
                    !0,
                    !0,
                    !0,
                    !0
                ]) : this.colorModeForRenderPass() : this.colorModeForRenderPass();
            }
            depthModeForSublayer(e, t1, i, o = !1) {
                if (this.depthOcclusion) return new $i(this.context.gl.GREATER, $i.ReadOnly, this.depthRangeFor3D);
                if (!this.opaquePassEnabledForLayer() && !o) return $i.disabled;
                const s = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                return new $i(i || this.context.gl.LEQUAL, t1, [
                    s,
                    s
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            blitDepth() {
                const t1 = this.context.gl, i = Math.ceil(this.width), o = Math.ceil(this.height), s = this.context.bindFramebuffer.get(), r = t1.getParameter(t1.TEXTURE_BINDING_2D);
                this.depthFBO && this.depthFBO.width === i && this.depthFBO.height === o || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i && 0 !== o && (this.depthFBO = new Kr(this.context, i, o, 0, "texture"), this.depthTexture = new e.T(this.context, {
                    width: i,
                    height: o,
                    data: null
                }, t1.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s), t1.bindTexture(t1.TEXTURE_2D, r), this.depthFBO && (t1.bindFramebuffer(t1.READ_FRAMEBUFFER, null), t1.bindFramebuffer(t1.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t1.blitFramebuffer(0, 0, i, o, 0, 0, i, o, t1.DEPTH_BUFFER_BIT, t1.NEAREST), t1.bindFramebuffer(t1.FRAMEBUFFER, this.context.bindFramebuffer.current));
            }
            updateAverageFPS() {
                this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e, t1)=>e + t1 / this._fpsHistory.length, 0));
            }
            render(t1, i) {
                const o = e.o.now();
                this._dt = o - this._timeStamp, this._timeStamp = o, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t1.map.repaint, this.style = t1, this.options = i;
                const s = this.style._mergedLayers, r = !(!this.terrain || !this.terrain.enabled), n = ()=>this.style._getOrder(r).filter((e)=>{
                        const t1 = s[e];
                        return !(t1.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t1.type];
                    });
                let a = n(), l = !1, c = !1, h = null, d = 0, u = !1;
                for (const e of a){
                    const t1 = s[e];
                    "none" !== t1.visibility && ("circle" === t1.type ? l = !0 : "building" === t1.type ? (h = t1, ++d) : "symbol" === t1.type && (t1.hasOcclusionOpacityProperties ? c = !0 : l = !0));
                }
                this.updateEmissiveMode();
                let _ = a.map((e)=>s[e]);
                const p = this.style._mergedSourceCaches;
                this.imageManager = t1.imageManager, this.modelManager = t1.modelManager, this.symbolFadeChange = t1.placement.symbolFadeChange(e.o.now()), this.imageManager.beginFrame();
                for(const e in p){
                    const t1 = p[e];
                    t1.used && (t1.prepare(this.context), t1.getSource().usedInConflation && ++d);
                }
                let f = !1;
                for (const e of _)e.isHidden(this.transform.zoom) || ("clip" === e.type && (f = !0), this.prepareLayer(e));
                const m = {}, g = {}, v = {}, y = {}, x = {};
                for(const e in p){
                    const t1 = p[e];
                    m[e] = t1.getVisibleCoordinates(), g[e] = m[e].slice().reverse(), v[e] = t1.getVisibleCoordinates(!0).reverse(), y[e] = t1.getShadowCasterCoordinates(), x[e] = t1.sortCoordinatesByDistance(m[e]);
                }
                const b = (e)=>{
                    const t1 = this.style.getLayerSourceCache(e);
                    return t1 && t1.used ? t1.getSource() : null;
                };
                if (d || f || this._clippingActiveLastFrame) {
                    const t1 = [], i = [];
                    let o = 0;
                    for (const e of _)this.isSourceForClippingOrConflation(e, b(e)) && (t1.push(e), i.push(o)), o++;
                    if (t1 && (f || t1.length > 1) || this._clippingActiveLastFrame) {
                        f = !1;
                        const o = [];
                        for(let s = 0; s < t1.length; s++){
                            const r = t1[s], n = i[s], a = this.style.getLayerSourceCache(r);
                            if (!a || !a.used || !a.getSource().usedInConflation && "clip" !== r.type && "building" !== r.type) continue;
                            let l = e.eQ, c = e.b_.None;
                            const h = [];
                            let d = !0;
                            if ("building" === r.type) l = e.eS;
                            else if ("clip" === r.type) {
                                l = n;
                                for (const t1 of r.layout.get("clip-layer-types"))c |= "model" === t1 ? e.b_.Model : "symbol" === t1 ? e.b_.Symbol : e.b_.FillExtrusion;
                                for (const e of r.layout.get("clip-layer-scope"))h.push(e);
                                r.isHidden(this.transform.zoom) ? d = !1 : f = !0;
                            }
                            d && o.push({
                                layer: r.fqid,
                                cache: a,
                                order: l,
                                clipMask: c,
                                clipScope: h
                            });
                        }
                        this.replacementSource.setSources(o), u = !0;
                    }
                }
                this._clippingActiveLastFrame = f, u || this.replacementSource.clear(), this.conflationActive = u, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
                for(let e = 0; e < _.length; e++){
                    const t1 = _[e];
                    if ("none" === t1.visibility) continue;
                    const i = t1.cutoffRange();
                    if (this.longestCutoffRange = Math.max(i, this.longestCutoffRange), i > 0) {
                        const e = b(t1);
                        e && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom)), t1.minzoom && (this.minCutoffZoom = Math.max(t1.minzoom, this.minCutoffZoom));
                    }
                    t1.is3D(r) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e), this._lastOcclusionLayer = e);
                }
                const w = this.style && this.style.fog;
                w ? (this._fogVisible = 0 !== w.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = w.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(v), this.opaquePassCutoff = 0, a = n(), _ = a.map((e)=>s[e]));
                const T = this._shadowRenderer;
                if (T) {
                    T.updateShadowParameters(this.transform, this.style.directionalLight);
                    for(const e in p)for (const t1 of m[e]){
                        let e = {
                            min: 0,
                            max: 0
                        };
                        this.terrain && (e = this.terrain.getMinMaxForTile(t1) || e), T.addShadowReceiver(t1.toUnwrapped(), e.min, e.max);
                    }
                }
                "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.eR(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new $n(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
                const E = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), S = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
                if (E && !this._snow && (this._snow = new Ca(this)), !E && this._snow && (this._snow.destroy(), delete this._snow), S && !this._rain && (this._rain = new Sa(this)), !S && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), h) {
                    this.buildingTileBorderManager || (this.buildingTileBorderManager = new Xn);
                    const e = this.style.getLayerSourceCache(h);
                    this.buildingTileBorderManager.updateBorders(e, h);
                }
                if (!q.has(this.context.gl)) return;
                this.renderPass = "offscreen";
                for (const e of _){
                    const i = t1.getLayerSourceCache(e);
                    if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;
                    const o = i ? g[i.id] : void 0;
                    ("custom" === e.type || "raster" === e.type || "raster-particle" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);
                }
                this.depthRangeFor3D = [
                    0,
                    1 - (_.length + 2) * this.numSublayers * this.depthEpsilon
                ], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, y)), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]);
                const I = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), C = (()=>{
                    if (i.showOverdrawInspector) return e.ao.black;
                    const t1 = this.style.fog;
                    if (t1 && this.transform.projection.supportsFog) {
                        const i = this.style.getLut(t1.scope);
                        if (!I) {
                            const o = "none" === t1.properties.get("color-use-theme"), s = t1.properties.get("color").toNonPremultipliedRenderColor(o ? null : i).toArray01();
                            return new e.ao(...s);
                        }
                        if (I) {
                            const o = "none" === t1.properties.get("space-color-use-theme"), s = t1.properties.get("space-color").toNonPremultipliedRenderColor(o ? null : i).toArray01();
                            return new e.ao(...s);
                        }
                    }
                    return e.ao.transparent;
                })();
                if (this.context.clear({
                    color: C,
                    depth: 1
                }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for(this.currentLayer = a.length - 1; this.currentLayer >= 0; this.currentLayer--){
                    const e = _[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) continue;
                    const o = i ? (e.is3D(r) ? x : g)[i.id] : void 0;
                    this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);
                }
                if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.aj(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for(this.currentLayer = 0; this.currentLayer < a.length; this.currentLayer++){
                    const e = _[this.currentLayer], i = t1.getLayerSourceCache(e);
                    e.isSky() && this.renderLayer(this, i, e, i ? g[i.id] : void 0);
                }
                function R(e, t1) {
                    let i;
                    return t1 && (i = ("symbol" === e.type ? v : e.is3D(r) ? x : g)[t1.id]), i;
                }
                if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
                    for(this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < a.length;){
                        const e = _[this.currentLayer];
                        if ("raster" === e.type || "raster-particle" === e.type) {
                            const i = t1.getLayerSourceCache(e);
                            this.renderLayer(this, i, e, R(e, i));
                        }
                        ++this.currentLayer;
                    }
                    this.renderElevatedRasterBackface = !1;
                }
                this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
                const A = T ? T.getGroundShadowLayerIndex() : -1;
                let L = !1, D = -1;
                for(let e = 0; e < a.length; ++e){
                    const t1 = _[e];
                    t1.isHidden(this.transform.zoom) || t1.is3D(r) && (D = e);
                }
                c && -1 === D && (l = !0);
                let P = !1;
                for(; this.currentLayer < a.length;){
                    const e = _[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) ++this.currentLayer;
                    else if (this.terrain && this.style.isLayerDraped(e)) {
                        if (e.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue;
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                    } else {
                        if (!P && e.is3D(r) && !r) {
                            const e = this.currentLayer, t1 = (e)=>{
                                for(this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++){
                                    const t1 = _[this.currentLayer];
                                    if (La[t1.type]) {
                                        const i = this.style.getLayerSourceCache(t1);
                                        La[t1.type](this, i, t1, R(t1, i), e);
                                    }
                                }
                            };
                            t1("initialize"), t1("reset"), this.currentLayer = e, P = !0;
                        }
                        if (l && !L && this.terrain && !this.transform.isOrthographic && (L = !0, this.blitDepth()), c && -1 !== D && this.currentLayer === D + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e, i, i ? m[i.id] : void 0), this.renderLayer(this, i, e, R(e, i)), !this.terrain && T && this.currentLayer === A) {
                            {
                                this.clearStencil(), this.resetStencilClippingMasks();
                                const e = this.currentLayer;
                                for(this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++){
                                    const e = _[this.currentLayer];
                                    if (Da[e.type]) {
                                        const t1 = this.style.getLayerSourceCache(e);
                                        Da[e.type](this, t1, e, R(e, t1));
                                    }
                                }
                                this.currentLayer = e;
                            }
                            if (T.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer) {
                                const e = this.currentLayer;
                                for(this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++){
                                    const e = _[this.currentLayer];
                                    if (!e.hasLightBeamPass()) continue;
                                    const i = t1.getLayerSourceCache(e);
                                    this.renderLayer(this, i, e, i ? g[i.id] : void 0);
                                }
                                this.currentLayer = e, this.renderPass = "translucent";
                            }
                        }
                        if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                            const e = this.currentLayer;
                            this.depthOcclusion = !0;
                            for (const e of this.layersWithOcclusionOpacity){
                                this.currentLayer = e;
                                const i = _[this.currentLayer], o = t1.getLayerSourceCache(i), s = o ? g[o.id] : void 0;
                                this.terrain || this._renderTileClippingMasks(i, o, o ? m[o.id] : void 0), this.renderLayer(this, o, i, s);
                            }
                            this.depthOcclusion = !1, this.currentLayer = e, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                        }
                        ++this.currentLayer;
                    }
                }
                if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                    let i = null;
                    _.forEach((e)=>{
                        const o = t1.getLayerSourceCache(e);
                        o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                    }), i && this.options.showTileBoundaries && zn(this, i, i.getVisibleCoordinates(), e.ao.red, !1, this.options.showParseStatus);
                }
                this.terrain && this._debugParams.showTerrainProxyTiles && zn(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.ao(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(e) {
                    const t1 = e.transform.padding;
                    Fn(e, e.transform.height - (t1.top || 0), 3, An), Fn(e, t1.bottom || 0, 3, Ln), Bn(e, t1.left || 0, 3, Dn), Bn(e, e.transform.width - (t1.right || 0), 3, Pn);
                    const i = e.transform.centerPoint;
                    !function(e, t1, i, o) {
                        kn(e, t1 - 1, i - 10, 2, 20, o), kn(e, t1 - 10, i - 1, 20, 2, o);
                    }(e, i.x, e.transform.height - i.y, On);
                }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), u || (this.conflationActive = !1);
            }
            prepareLayer(e) {
                this.gpuTimingStart(e);
                const { unsupportedLayers: t1 } = this.transform.projection, i = !t1 || !t1.includes(e.type);
                if (Aa[e.type] && (i || this.terrain && "custom" === e.type)) {
                    const t1 = this.style.getLayerSourceCache(e);
                    Aa[e.type](e, t1, this);
                }
                this.gpuTimingEnd();
            }
            renderLayer(e, t1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || "model" === i.type || "raster" === i.type || "raster-particle" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) && (!e.terrain || "custom" !== i.type) || "clip" === i.type || Ra[i.type](e, t1, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e) {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery, i = this.context.gl;
                let o = this.gpuTimers[e.id];
                o || (o = this.gpuTimers[e.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: i.createQuery()
                }), o.calls++, i.beginQuery(t1.TIME_ELAPSED_EXT, o.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e = this.context.extTimerQuery, t1 = this.context.gl, i = t1.createQuery();
                    this.deferredRenderGpuTimeQueries.push(i), t1.beginQuery(e.TIME_ELAPSED_EXT, i);
                }
            }
            gpuTimingDeferredRenderEnd() {
                this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e = this.gpuTimers;
                return this.gpuTimers = {}, e;
            }
            collectDeferredRenderGpuQueries() {
                const e = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e;
            }
            queryGpuTimers(e) {
                const t1 = {};
                for(const i in e){
                    const o = e[i], s = this.context.extTimerQuery, r = s.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;
                    s.deleteQueryEXT(o.query), t1[i] = r;
                }
                return t1;
            }
            queryGpuTimeDeferredRender(e) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t1 = this.context.gl;
                let i = 0;
                for (const o of e)i += t1.getQueryParameter(o, t1.QUERY_RESULT) / 1e6, t1.deleteQuery(o);
                return i;
            }
            translatePosMatrix(t1, i, o, s, r) {
                if (!o[0] && !o[1]) return t1;
                const n = r ? "map" === s ? this.transform.angle : 0 : "viewport" === s ? -this.transform.angle : 0;
                if (n) {
                    const e = Math.sin(n), t1 = Math.cos(n);
                    o = [
                        o[0] * t1 - o[1] * e,
                        o[0] * e + o[1] * t1
                    ];
                }
                const a = [
                    r ? o[0] : e.ay(i, o[0], this.transform.zoom),
                    r ? o[1] : e.ay(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return e.br(l, t1, a), l;
            }
            saveTileTexture(e) {
                if (e.context !== this.context) return;
                const t1 = e.size[0], i = this._tileTextures[t1];
                i ? i.push(e) : this._tileTextures[t1] = [
                    e
                ];
            }
            getTileTexture(e) {
                const t1 = this._tileTextures[e];
                return t1 && t1.length > 0 ? t1.pop() : null;
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
            }
            linearFloatFilteringSupported() {
                return null != this.context.extTextureFloatLinear;
            }
            currentGlobalDefines(e, t1, i) {
                const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i, s = [];
                return this.style && this.style.enable3dLights() && ("globeRaster" === e || "terrainRaster" === e ? (s.push("LIGHTING_3D_MODE"), s.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o || s.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || s.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s.push("TERRAIN"), this.linearFloatFilteringSupported() && s.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && s.push("GLOBE"), !this._fogVisible || o || void 0 !== t1 && !t1 || s.push("FOG", "FOG_DITHERING"), o && s.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s.push("OVERDRAW_INSPECTOR"), s;
            }
            getOrCreateProgram(e, t1) {
                this.cache = this.cache || {};
                const i = t1 && t1.defines || [], o = t1 && t1.config, s = this.currentGlobalDefines(e, t1 && t1.overrideFog, t1 && t1.overrideRtt).concat(i), r = hr.cacheKey(is[e], e, s, o);
                return this.cache[r] || (this.cache[r] = new hr(this.context, e, is[e], o, Wr[e], s)), this.cache[r];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            uploadCommonLightUniforms(t1, i) {
                if (this.style.enable3dLights()) {
                    const o = this.style.directionalLight, s = this.style.ambientLight;
                    if (o && s) {
                        const r = ((t1, i, o)=>{
                            const s = t1.properties.get("direction"), r = "none" === t1.properties.get("color-use-theme"), n = t1.properties.get("color").toNonPremultipliedRenderColor(r ? null : o.getLut(t1.scope)).toArray01(), a = t1.properties.get("intensity"), l = "none" === i.properties.get("color-use-theme"), c = i.properties.get("color").toNonPremultipliedRenderColor(l ? null : o.getLut(i.scope)).toArray01(), h = i.properties.get("intensity"), d = [
                                s.x,
                                s.y,
                                s.z
                            ], u = e.dN(c, h), _ = e.dN(n, a);
                            return {
                                u_lighting_ambient_color: u,
                                u_lighting_directional_dir: d,
                                u_lighting_directional_color: _,
                                u_ground_radiance: ar(d, _, u)
                            };
                        })(o, s, this.style);
                        i.setLightsUniformValues(t1, r);
                    }
                }
            }
            uploadCommonUniforms(t1, i, o, s, r) {
                if (this.uploadCommonLightUniforms(t1, i), this.terrain && this.terrain.renderingToTexture) return;
                const n = this.style.fog;
                if (n) {
                    const r = n.getOpacity(this.transform.pitch), a = ((t1, i, o, s, r, n, a, l, c, h, d, u)=>{
                        const _ = t1.transform, p = "none" === i.properties.get("color-use-theme"), f = i.properties.get("color").toNonPremultipliedRenderColor(p ? null : t1.style.getLut(i.scope)).toArray01();
                        f[3] = s;
                        const m = t1.frameCounter / 1e3 % 1, [g, v] = i.properties.get("vertical-range");
                        return {
                            u_fog_matrix: o ? _.calculateFogTileMatrix(o) : u || t1.identityMat,
                            u_fog_range: i.getFovAdjustedRange(_._fov),
                            u_fog_color: f,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_vertical_limit: [
                                Math.min(g, v),
                                v
                            ],
                            u_fog_temporal_offset: m,
                            u_frustum_tl: r,
                            u_frustum_tr: n,
                            u_frustum_br: a,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: d,
                            u_globe_transition: e.aj(_.zoom),
                            u_is_globe: +("globe" === _.projection.name)
                        };
                    })(this, n, o, r, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e.o.devicePixelRatio,
                        this.transform.height * e.o.devicePixelRatio
                    ], s);
                    i.setFogUniformValues(t1, a);
                }
                r && i.setCutoffUniformValues(t1, r.uniformValues);
            }
            setTileLoadedFlag(e) {
                this.tileLoaded = e;
            }
            saveCanvasCopy() {
                const e = this.canvasCopy();
                e && (this.frameCopies.push(e), this.tileLoaded = !1);
            }
            canvasCopy() {
                const e = this.context.gl, t1 = e.createTexture();
                return e.bindTexture(e.TEXTURE_2D, t1), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t1;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e = this.style && this.style.fog;
                return !!e && 0 !== e.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const e = this._backgroundTiles, t1 = this._backgroundTiles = {}, i = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const o of i)t1[o.key] = e[o.key] || new Pt(o, 512, this.transform.tileZoom, this, void 0, this.worldview);
                return t1;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
            isSourceForClippingOrConflation(e, t1) {
                return !(!e.is3D(!(!this.terrain || !this.terrain.enabled)) || "clip" !== e.type && "building" !== e.type && (e.minzoom && e.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e.sourceLayer && "procedural_buildings" !== e.sourceLayer) && (!t1 || "batched-model" !== t1.type)));
            }
            isTileAffectedByFog(e) {
                if (!this.style || !this.style.fog) return !1;
                if ("globe" === this.transform.projection.name) return !0;
                let t1 = this._cachedTileFogOpacities[e.key];
                return t1 || (this._cachedTileFogOpacities[e.key] = t1 = this.style.fog.getOpacityForTile(e)), t1[0] >= Ve || t1[1] >= Ve;
            }
            setupDepthForOcclusion(e, t1, i) {
                const o = this.context, s = o.gl, r = !!i;
                var n;
                i || (i = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        0,
                        1
                    ],
                    u_occluder_half_size: 16,
                    u_occlusion_depth_offset: -1e-4,
                    u_exaggeration: 0
                }), o.activeTexture.set(s.TEXTURE3), e && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), i.u_depth_size_inv = [
                    1 / this.depthFBO.width,
                    1 / this.depthFBO.height
                ], i.u_depth_range_unpack = [
                    2 / ((n = this.depthRangeFor3D)[1] - n[0]),
                    -1 - 2 * n[0] / (n[1] - n[0])
                ], i.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, i.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), o.activeTexture.set(s.TEXTURE0), r || t1.setTerrainUniformValues(o, i);
            }
            updateEmissiveMode() {
                if (this._forceEmissiveMode) return;
                const e = this.style.hasDataDrivenEmissiveStrength();
                this.emissiveMode = e ? this.context.extBlendFuncExtended ? "dual-source-blending" : "mrt-fallback" : "constant";
            }
        }
        function Oa(e, t1) {
            let i = !1, o = null;
            const s = ()=>{
                o = null, i && (e(), o = setTimeout(s, t1), i = !1);
            };
            return ()=>(i = !0, o || s(), o);
        }
        class za {
            constructor(t1){
                this._hashName = t1 && encodeURIComponent(t1), e.aY([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = Oa(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e) {
                return this._map = e, window.addEventListener("hashchange", this._onHashChange, !1), e.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const e = this._map;
                if (!e) return "";
                const t1 = Ma(e);
                if (this._hashName) {
                    const e = this._hashName;
                    let i = !1;
                    const o = location.hash.slice(1).split("&").map((o)=>{
                        const s = o.split("=")[0];
                        return s === e ? (i = !0, `${s}=${t1}`) : o;
                    }).filter((e)=>e);
                    return i || o.push(`${e}=${t1}`), `#${o.join("&")}`;
                }
                return `#${t1}`;
            }
            _getCurrentHash() {
                const e = location.hash.replace("#", "");
                if (this._hashName) {
                    let t1;
                    return e.split("&").map((e)=>e.split("=")).forEach((e)=>{
                        e[0] === this._hashName && (t1 = e);
                    }), (t1 && t1[1] || "").split("/");
                }
                return e.split("/");
            }
            _onHashChange() {
                const e = this._map;
                if (!e) return !1;
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((e)=>isNaN(Number(e)))) {
                    const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : e.getBearing();
                    return e.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: i,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
            }
        }
        function Ma(e, t1) {
            const i = e.getCenter(), o = Math.round(100 * e.getZoom()) / 100, s = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r = Math.pow(10, s), n = Math.round(i.lng * r) / r, a = Math.round(i.lat * r) / r, l = e.getBearing(), c = e.getPitch();
            let h = t1 ? `/${n}/${a}/${o}` : `${o}/${a}/${n}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }
        const Fa = {
            linearity: .3,
            easing: e.eT(0, 0, .3, 1)
        }, Ba = Object.assign({
            deceleration: 2500,
            maxSpeed: 1400
        }, Fa), ka = Object.assign({
            deceleration: 20,
            maxSpeed: 1400
        }, Fa), Na = Object.assign({
            deceleration: 1e3,
            maxSpeed: 360
        }, Fa), Ua = Object.assign({
            deceleration: 1e3,
            maxSpeed: 90
        }, Fa);
        class ja {
            constructor(e){
                this._map = e, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e.o.now(),
                    settings: t1
                });
            }
            _drainInertiaBuffer() {
                const t1 = this._inertiaBuffer, i = e.o.now();
                for(; t1.length > 0 && i - t1[0].time > 160;)t1.shift();
            }
            _onMoveEnd(t1) {
                if (this._map._prefersReducedMotion()) return;
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e.P(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e } of this._inertiaBuffer)i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s = {};
                if (i.pan.mag()) {
                    const e = Ga(i.pan.mag(), o, Object.assign({}, Ba, t1 || {}));
                    s.offset = i.pan.mult(e.amount / i.pan.mag()), s.center = this._map.transform.center, Va(s, e);
                }
                if (i.zoom) {
                    const e = Ga(i.zoom, o, ka);
                    s.zoom = this._map.transform.zoom + e.amount, Va(s, e);
                }
                if (i.bearing) {
                    const t1 = Ga(i.bearing, o, Na);
                    s.bearing = this._map.transform.bearing + e.aA(t1.amount, -179, 179), Va(s, t1);
                }
                if (i.pitch) {
                    const e = Ga(i.pitch, o, Ua);
                    s.pitch = this._map.transform.pitch + e.amount, Va(s, e);
                }
                if (s.zoom || s.bearing) {
                    const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    s.around = e ? this._map.unproject(e) : this._map.getCenter();
                }
                return this.clear(), s.noMoveStart = !0, s;
            }
        }
        function Va(e, t1) {
            (!e.duration || e.duration < t1.duration) && (e.duration = t1.duration, e.easing = t1.easing);
        }
        function Ga(t1, i, o) {
            const { maxSpeed: s, linearity: r, deceleration: n } = o, a = e.aA(t1 * r / (i / 1e3), -s, s), l = Math.abs(a) / (n * r);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: a * (l / 2)
            };
        }
        class Ha extends e.z {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e, t1, i, o = {}){
                const s = g(t1.getCanvasContainer(), i), r = t1.unproject(s);
                super(e, Object.assign({
                    point: s,
                    lngLat: r,
                    originalEvent: i
                }, o)), this._defaultPrevented = !1, this.target = t1;
            }
        }
        class qa extends e.z {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o){
                const s = "touchend" === t1 ? o.changedTouches : o.touches, r = v(i.getCanvasContainer(), s), n = r.map((e)=>i.unproject(e)), a = r.reduce((e, t1, i, o)=>e.add(t1.div(o.length)), new e.P(0, 0));
                super(t1, {
                    points: r,
                    point: a,
                    lngLats: n,
                    lngLat: i.unproject(a),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
        }
        class Za extends e.z {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e, t1){
                super("wheel", {
                    originalEvent: t1
                }), this._defaultPrevented = !1;
            }
        }
        class Wa {
            constructor(e, t1){
                this._map = e, this._clickTolerance = t1.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e) {
                return this._firePreventable(new Za(this._map, e));
            }
            mousedown(e, t1) {
                return this._mousedownPos = t1, this._firePreventable(new Ha(e.type, this._map, e));
            }
            mouseup(e) {
                this._map.fire(new Ha(e.type, this._map, e));
            }
            preclick(e) {
                const t1 = new MouseEvent("preclick", e);
                this._map.fire(new Ha(t1.type, this._map, t1));
            }
            click(e, t1) {
                this._mousedownPos && this._mousedownPos.dist(t1) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Ha(e.type, this._map, e)));
            }
            dblclick(e) {
                return this._firePreventable(new Ha(e.type, this._map, e));
            }
            mouseover(e) {
                this._map.fire(new Ha(e.type, this._map, e));
            }
            mouseout(e) {
                this._map.fire(new Ha(e.type, this._map, e));
            }
            touchstart(e) {
                return this._firePreventable(new qa(e.type, this._map, e));
            }
            touchmove(e) {
                this._map.fire(new qa(e.type, this._map, e));
            }
            touchend(e) {
                this._map.fire(new qa(e.type, this._map, e));
            }
            touchcancel(e) {
                this._map.fire(new qa(e.type, this._map, e));
            }
            _firePreventable(e) {
                if (this._map.fire(e), e.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class $a {
            constructor(e){
                this._map = e;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e) {
                this._map.fire(new Ha(e.type, this._map, e));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ha("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e) {
                this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Ha(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class Xa {
            constructor(e, t1){
                this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e, t1) {
                this.isEnabled() && e.shiftKey && 0 === e.button && (_(), this._startPos = this._lastPos = t1, this._active = !0);
            }
            mousemoveWindow(e, t1) {
                if (!this._active) return;
                const i = t1, o = this._startPos, s = this._lastPos;
                if (!o || !s || s.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
                this._lastPos = i, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
                const r = Math.min(o.x, i.x), n = Math.max(o.x, i.x), a = Math.min(o.y, i.y), c = Math.max(o.y, i.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${r}px,${a}px)`, this._box.style.width = n - r + "px", this._box.style.height = c - a + "px");
                });
            }
            mouseupWindow(t1, i) {
                if (!this._active) return;
                const o = this._startPos, s = i;
                if (o && 0 === t1.button) {
                    if (this.reset(), m(), o.x !== s.x || o.y !== s.y) return this._map.fire(new e.z("boxzoomend", {
                        originalEvent: t1
                    })), {
                        cameraAnimation: (e)=>e.fitScreenCoordinates(o, s, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t1);
                }
            }
            keydown(e) {
                this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t1, i) {
                return this._map.fire(new e.z(t1, {
                    originalEvent: i
                }));
            }
        }
        function Ya(e, t1) {
            const i = {};
            for(let o = 0; o < e.length; o++)i[e[o].identifier] = t1[o];
            return i;
        }
        class Ka {
            constructor(e){
                this.reset(), this.numTouches = e.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }
            touchstart(t1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t1.timeStamp), o.length === this.numTouches && (this.centroid = function(t1) {
                    const i = new e.P(0, 0);
                    for (const e of t1)i._add(e);
                    return i.div(t1.length);
                }(i), this.touches = Ya(o, i)));
            }
            touchmove(e, t1, i) {
                if (this.aborted || !this.centroid) return;
                const o = Ya(i, t1);
                for(const e in this.touches){
                    const t1 = o[e];
                    (!t1 || t1.dist(this.touches[e]) > 30) && (this.aborted = !0);
                }
            }
            touchend(e, t1, i) {
                if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e = !this.aborted && this.centroid;
                    if (this.reset(), e) return e;
                }
            }
        }
        class Ja {
            constructor(e){
                this.singleTap = new Ka(e), this.numTaps = e.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e, t1, i) {
                this.singleTap.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this.singleTap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this.singleTap.touchend(e, t1, i);
                if (o) {
                    const t1 = e.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (t1 && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class Qa {
            constructor(){
                this._zoomIn = new Ja({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new Ja({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e, t1, i) {
                this._zoomIn.touchstart(e, t1, i), this._zoomOut.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this._zoomIn.touchmove(e, t1, i), this._zoomOut.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this._zoomIn.touchend(e, t1, i), s = this._zoomOut.touchend(e, t1, i);
                return o ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() + 1,
                            around: t1.unproject(o)
                        }, {
                            originalEvent: e
                        })
                }) : s ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() - 1,
                            around: t1.unproject(s)
                        }, {
                            originalEvent: e
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const el = 0, tl = 2, il = {
            [el]: 1,
            [tl]: 2
        }, ol = {
            Control: "ctrlKey",
            Alt: "altKey",
            Shift: "shiftKey",
            Meta: "metaKey"
        };
        class sl {
            constructor(e){
                this.reset(), this._clickTolerance = e.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e, t1) {
                return !1;
            }
            _move(e, t1) {
                return {};
            }
            mousedown(e, t1) {
                if (this._lastPoint) return;
                const i = y(e);
                this._correctButton(e, i) && (this._lastPoint = t1, this._eventButton = i);
            }
            mousemoveWindow(e, t1) {
                const i = this._lastPoint;
                if (i) {
                    if (e.preventDefault(), null != this._eventButton && function(e, t1) {
                        const i = il[t1];
                        return void 0 === e.buttons || (e.buttons & i) !== i;
                    }(e, this._eventButton)) this.reset();
                    else if (this._moved || !(t1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t1, this._move(i, t1);
                }
            }
            mouseupWindow(e) {
                this._lastPoint && y(e) === this._eventButton && (this._moved && m(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class rl extends sl {
            mousedown(e, t1) {
                super.mousedown(e, t1), this._lastPoint && (this._active = !0);
            }
            _correctButton(e, t1) {
                return 0 === t1 && !e.ctrlKey;
            }
            _move(e, t1) {
                return {
                    around: t1,
                    panDelta: t1.sub(e)
                };
            }
        }
        class nl extends sl {
            constructor(e){
                super(e), this._pitchRotateKey = e.pitchRotateKey ? ol[e.pitchRotateKey] : void 0;
            }
            _correctButton(e, t1) {
                return this._pitchRotateKey ? 0 === t1 && e[this._pitchRotateKey] : 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = .8 * (t1.x - e.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(e) {
                this._pitchRotateKey || e.preventDefault();
            }
        }
        class al extends sl {
            constructor(e){
                super(e), this._pitchRotateKey = e.pitchRotateKey ? ol[e.pitchRotateKey] : void 0;
            }
            _correctButton(e, t1) {
                return this._pitchRotateKey ? 0 === t1 && e[this._pitchRotateKey] : 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = -.5 * (t1.y - e.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(e) {
                this._pitchRotateKey || e.preventDefault();
            }
        }
        class ll {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.aY([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);
            }
            touchstart(e, t1, i) {
                return this._calculateTransform(e, t1, i);
            }
            touchmove(t1, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e.eU()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t1.cancelable && t1.preventDefault(), this._calculateTransform(t1, i, o);
                }
            }
            touchend(e, t1, i) {
                this._calculateTransform(e, t1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t1, i, o) {
                o.length > 0 && (this._active = !0);
                const s = Ya(o, i), r = new e.P(0, 0), n = new e.P(0, 0);
                let a = 0;
                for(const e in s){
                    const t1 = s[e], i = this._touches[e];
                    i && (r._add(t1), n._add(t1.sub(i)), a++, s[e] = t1);
                }
                if (this._touches = s, a < this._minTouches || !n.mag()) return;
                const l = n.div(a);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: r.div(a),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 500);
            }
        }
        class cl {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e) {}
            _move(e, t1, i) {
                return {};
            }
            touchstart(e, t1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t1[0],
                    t1[1]
                ]));
            }
            touchmove(e, t1, i) {
                const o = this._firstTwoTouches;
                if (!o) return;
                e.preventDefault();
                const [s, r] = o, n = hl(i, t1, s), a = hl(i, t1, r);
                if (!n || !a) return;
                const l = this._aroundCenter ? null : n.add(a).div(2);
                return this._move([
                    n,
                    a
                ], l, e);
            }
            touchend(e, t1, i) {
                if (!this._firstTwoTouches) return;
                const [o, s] = this._firstTwoTouches, r = hl(i, t1, o), n = hl(i, t1, s);
                r && n || (this._active && m(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e) {
                this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function hl(e, t1, i) {
            for(let o = 0; o < e.length; o++)if (e[o].identifier === i) return t1[o];
        }
        function dl(e, t1) {
            return Math.log2(e / t1);
        }
        class ul extends cl {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e) {
                this._startDistance = this._distance = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._distance;
                if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(dl(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: dl(this._distance, i),
                    pinchAround: t1
                };
            }
        }
        function _l(e, t1) {
            return 180 * e.angleWith(t1) / Math.PI;
        }
        class pl extends cl {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e) {
                this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._vector;
                if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: _l(this._vector, i),
                    pinchAround: t1
                };
            }
            _isBelowThreshold(e) {
                this._minDiameter = Math.min(this._minDiameter, e.mag());
                const t1 = 25 / (Math.PI * this._minDiameter) * 360, i = this._startVector;
                if (!i) return !1;
                const o = _l(e, i);
                return Math.abs(o) < t1;
            }
        }
        function fl(e) {
            return Math.abs(e.y) > Math.abs(e.x);
        }
        class ml extends cl {
            constructor(e){
                super(), this._map = e;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e) {
                this._lastPoints = e, fl(e[0].sub(e[1])) && (this._valid = !1);
            }
            _move(t1, i, o) {
                const s = this._lastPoints;
                if (!s) return;
                const r = t1[0].sub(s[0]), n = t1[1].sub(s[1]);
                return this._map._cooperativeGestures && !e.eU() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r, n, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (r.y + n.y) / 2 * -.5
                });
            }
            gestureBeginsVertically(e, t1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = e.mag() >= 2, s = t1.mag() >= 2;
                if (!o && !s) return;
                if (!o || !s) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const r = e.y > 0 == t1.y > 0;
                return fl(e) && fl(t1) && r;
            }
        }
        const gl = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class vl {
            constructor(){
                const e = gl;
                this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                let t1 = 0, i = 0, o = 0, s = 0, r = 0;
                switch(e.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t1 = -1;
                        break;
                    case 37:
                        e.shiftKey ? i = -1 : (e.preventDefault(), s = -1);
                        break;
                    case 39:
                        e.shiftKey ? i = 1 : (e.preventDefault(), s = 1);
                        break;
                    case 38:
                        e.shiftKey ? o = 1 : (e.preventDefault(), r = -1);
                        break;
                    case 40:
                        e.shiftKey ? o = -1 : (e.preventDefault(), r = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (n)=>{
                        const a = n.getZoom();
                        n.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: yl,
                            zoom: t1 ? Math.round(a) + t1 * (e.shiftKey ? 2 : 1) : a,
                            bearing: n.getBearing() + i * this._bearingStep,
                            pitch: n.getPitch() + o * this._pitchStep,
                            offset: [
                                -s * this._panStep,
                                -r * this._panStep
                            ],
                            center: n.getCenter()
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function yl(e) {
            return e * (2 - e);
        }
        const xl = 4.000244140625, bl = 1 / 450;
        class wl {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = bl, e.aY([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e) {
                this._defaultZoomRate = e;
            }
            setWheelZoomRate(e) {
                this._wheelZoomRate = e;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t1.ctrlKey || t1.metaKey || this.isZooming() || e.eU())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i = t1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t1.deltaY : t1.deltaY;
                const o = e.o.now(), s = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % xl === 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : s > 400 ? (this._type = null, this._lastValue = i, this._timeout = window.setTimeout(this._onTimeout, 40, t1)) : this._type || (this._type = Math.abs(s * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t1, this._delta -= i, this._active || this._start(t1)), t1.preventDefault();
            }
            _onTimeout(e) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }
            _start(e) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t1 = g(this._el, e);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t1 = this._map.transform;
                "wheel" === this._type && t1.projection.wrap && (t1._center.lng >= 180 || t1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i = ()=>t1._terrainEnabled() && this._aroundCoord ? t1.computeZoomRelativeTo(this._aroundCoord) : t1.zoom;
                if (0 !== this._delta) {
                    const e = "wheel" === this._type && Math.abs(this._delta) > xl ? this._wheelZoomRate : this._defaultZoomRate;
                    let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
                    this._delta < 0 && 0 !== o && (o = 1 / o);
                    const s = i(), r = Math.pow(2, s), n = "number" == typeof this._targetZoom ? t1.zoomScale(this._targetZoom) : r;
                    this._targetZoom = Math.min(t1.maxZoom, Math.max(t1.minZoom, t1.scaleZoom(n * o))), "wheel" === this._type && (this._startZoom = s, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
                }
                const o = "number" == typeof this._targetZoom ? this._targetZoom : i(), s = this._startZoom, r = this._easing;
                let n, a = !1;
                if ("wheel" === this._type && s && r) {
                    const t1 = Math.min((e.o.now() - this._lastWheelEventTime) / 200, 1), i = r(t1);
                    n = e.ak(s, o, i), t1 < 1 ? this._frameId || (this._frameId = !0) : a = !0;
                } else n = o, a = !0;
                this._active = !0, a && (this._active = !1, this._finishTimeout = window.setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200));
                let l = n - i();
                return l * this._lastDelta < 0 && (l = 0), {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: l,
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t1) {
                let i = e.eV;
                if (this._prevEase) {
                    const t1 = this._prevEase, o = (e.o.now() - t1.start) / t1.duration, s = t1.easing(o + .01) - t1.easing(o), r = .27 / Math.sqrt(s * s + 1e-4) * .01, n = Math.sqrt(.0729 - r * r);
                    i = e.eT(r, n, .25, 1);
                }
                return this._prevEase = {
                    start: e.o.now(),
                    duration: t1,
                    easing: i
                }, i;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 200);
            }
        }
        class Tl {
            constructor(e, t1){
                this._clickZoom = e, this._tapZoom = t1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class El {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e, t1) {
                return e.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (e.shiftKey ? -1 : 1),
                            around: i.unproject(t1)
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Sl {
            constructor(){
                this._tap = new Ja({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e, t1, i) {
                this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t1, i));
            }
            touchmove(e, t1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = t1[0], s = o.y - this._swipePoint.y;
                        return this._swipePoint = o, e.preventDefault(), this._active = !0, {
                            zoomDelta: s / 128
                        };
                    }
                } else this._tap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t1, i) && (this._tapTime = e.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Il {
            constructor(e, t1, i){
                this._el = e, this._mousePan = t1, this._touchPan = i;
            }
            enable(e) {
                this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class Cl {
            constructor(e, t1, i){
                this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class Rl {
            constructor(e, t1, i, o){
                this._el = e, this._touchZoom = t1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e) {
                this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const Al = (e)=>e.zoom || e.drag || e.pitch || e.rotate;
        class Ll extends e.z {
        }
        class Dl {
            constructor(){
                this.constants = [
                    1,
                    1,
                    .01
                ], this.radius = 0;
            }
            setup(t1, i) {
                const o = e.av([], i, t1);
                this.radius = e.ag(o[2] < 0 ? e.eX([], o, this.constants) : [
                    o[0],
                    o[1],
                    0
                ]);
            }
            projectRay(t1) {
                e.eX(t1, t1, this.constants), e.aw(t1, t1), e.eY(t1, t1, this.constants);
                const i = e.c5([], t1, this.radius);
                if (i[2] > 0) {
                    const t1 = e.c5([], [
                        0,
                        0,
                        1
                    ], e.bJ(i, [
                        0,
                        0,
                        1
                    ])), o = e.c5([], e.aw([], [
                        i[0],
                        i[1],
                        0
                    ]), this.radius), s = e.d8([], i, e.c5([], e.av([], e.d8([], o, t1), i), 2));
                    i[0] = s[0], i[1] = s[1];
                }
                return i;
            }
        }
        function Pl(e) {
            return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
        }
        class Ol {
            constructor(t1, i){
                this._map = t1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ja(t1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Dl, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.aY([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.addEventListener(t1, o, i);
                }
            }
            destroy() {
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.removeEventListener(t1, o, i);
                }
            }
            _addDefaultHandlers(e) {
                const t1 = this._map, i = t1.getCanvasContainer();
                this._add("mapEvent", new Wa(t1, e));
                const o = t1.boxZoom = new Xa(t1, e);
                this._add("boxZoom", o);
                const s = new Qa, r = new El;
                t1.doubleClickZoom = new Tl(r, s), this._add("tapZoom", s), this._add("clickZoom", r);
                const n = new Sl;
                this._add("tapDragZoom", n);
                const a = t1.touchPitch = new ml(t1);
                this._add("touchPitch", a);
                const l = new nl(e), c = new al(e);
                t1.dragRotate = new Cl(e, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new rl(e), d = new ll(t1, e);
                t1.dragPan = new Il(i, h, d), this._add("mousePan", h), this._add("touchPan", d, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const u = new pl, _ = new ul;
                t1.touchZoomRotate = new Rl(i, _, u, n), this._add("touchRotate", u, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", _, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new $a(t1));
                const p = t1.scrollZoom = new wl(t1, this);
                this._add("scrollZoom", p, [
                    "mousePan"
                ]);
                const f = t1.keyboard = new vl;
                this._add("keyboard", f);
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e.interactive && e[i] && t1[i].enable(e[i]);
            }
            _add(e, t1, i) {
                this._handlers.push({
                    handlerName: e,
                    handler: t1,
                    allowed: i
                }), this._handlersById[e] = t1;
            }
            stop(e) {
                if (!this._updatingCamera) {
                    for (const { handler: e } of this._handlers)e.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;
                }
            }
            isActive() {
                for (const { handler: e } of this._handlers)if (e.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!Al(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e, t1, i) {
                for(const o in e)if (o !== i && (!t1 || t1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e) {
                this.handleEvent(e, `${e.type}Window`);
            }
            _getMapTouches(e) {
                const t1 = [];
                for (const i of e)this._el.contains(i.target) && t1.push(i);
                return t1;
            }
            handleEvent(e, t1) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e.type, o = i ? void 0 : e, s = {
                    needsRenderFrame: !1
                }, r = {}, n = {}, a = e.touches ? this._getMapTouches(e.touches) : void 0, l = a ? v(this._el, a) : i ? void 0 : g(this._el, e);
                for (const { handlerName: i, handler: c, allowed: h } of this._handlers){
                    if (!c.isEnabled()) continue;
                    let d;
                    this._blockedByActive(n, h, i) ? c.reset() : c[t1 || e.type] && (d = c[t1 || e.type](e, l, a), this.mergeHandlerResult(s, r, d, i, o), d && d.needsRenderFrame && this._triggerRenderFrame()), (d || c.isActive()) && (n[i] = c);
                }
                const c = {};
                for(const e in this._previousActiveHandlers)n[e] || (c[e] = o);
                this._previousActiveHandlers = n, (Object.keys(c).length || Pl(s)) && (this._changes.push([
                    s,
                    r,
                    c
                ]), this._triggerRenderFrame()), (Object.keys(n).length || Pl(s)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h } = s;
                h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }
            mergeHandlerResult(e, t1, i, o, s) {
                if (!i) return;
                Object.assign(e, i);
                const r = {
                    handlerName: o,
                    originalEvent: i.originalEvent || s
                };
                void 0 !== i.zoomDelta && (t1.zoom = r), void 0 !== i.panDelta && (t1.drag = r), void 0 !== i.pitchDelta && (t1.pitch = r), void 0 !== i.bearingDelta && (t1.rotate = r);
            }
            _applyChanges() {
                const t1 = {}, i = {}, o = {};
                for (const [s, r, n] of this._changes)s.panDelta && (t1.panDelta = (t1.panDelta || new e.P(0, 0))._add(s.panDelta)), s.zoomDelta && (t1.zoomDelta = (t1.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (t1.bearingDelta = (t1.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (t1.pitchDelta = (t1.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (t1.around = s.around), void 0 !== s.aroundCoord && (t1.aroundCoord = s.aroundCoord), void 0 !== s.pinchAround && (t1.pinchAround = s.pinchAround), s.noInertia && (t1.noInertia = s.noInertia), Object.assign(i, r), Object.assign(o, n);
                this._updateMapTransform(t1, i, o), this._changes = [];
            }
            _updateMapTransform(t1, i, o) {
                const s = this._map, r = s.transform, n = (e)=>[
                        e.x,
                        e.y,
                        e.z
                    ];
                if ((()=>{
                    const e = this._eventsInProgress.drag;
                    return e && !this._handlersById[e.handlerName].isActive();
                })() && !Pl(t1)) {
                    const e = r.zoom;
                    r.cameraElevationReference = "sea", null != this._originalZoom && r._orthographicProjectionAtLowPitch && "globe" !== r.projection.name && 0 === r.pitch ? (r.cameraElevationReference = "ground", r.zoom = this._originalZoom) : (r.recenterOnTerrain(), r.cameraElevationReference = "ground"), e !== r.zoom && this._map._update(!0);
                }
                if (r._isCameraConstrained && s._stop(!0), !Pl(t1)) return void this._fireEvents(i, o, !0);
                let { panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: d, aroundCoord: u, pinchAround: _ } = t1;
                r._isCameraConstrained && (l > 0 && (l = 0), r._isCameraConstrained = !1), void 0 !== _ && (d = _), (l || ((e)=>i[e] && !this._eventsInProgress[e])("drag")) && d && (this._dragOrigin = n(r.pointCoordinate3D(d)), this._originalZoom = r.zoom, this._trackingEllipsoid.setup(r._camera.position, this._dragOrigin)), r.cameraElevationReference = "sea", s._stop(!0), d = d || s.transform.centerPoint, c && (r.bearing += c), h && (r.pitch += h), r._updateCameraState();
                const p = [
                    0,
                    0,
                    0
                ];
                if (a) if ("mercator" === r.projection.name) {
                    const e = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(d).dir), t1 = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(d.sub(a)).dir);
                    p[0] = t1[0] - e[0], p[1] = t1[1] - e[1];
                } else {
                    const t1 = r.pointCoordinate(d);
                    if ("globe" === r.projection.name) {
                        a = a.rotate(-r.angle);
                        const i = r._pixelsPerMercatorPixel / r.worldSize;
                        p[0] = -a.x * e.eW(e.a$(t1.y)) * i, p[1] = -a.y * e.eW(r.center.lat) * i;
                    } else {
                        const e = r.pointCoordinate(d.sub(a));
                        t1 && e && (p[0] = e.x - t1.x, p[1] = e.y - t1.y);
                    }
                }
                const f = r.zoom, m = [
                    0,
                    0,
                    0
                ];
                if (l) {
                    const t1 = n(u || r.pointCoordinate3D(d)), i = {
                        dir: e.aw([], e.av([], t1, r._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const o = r.zoomDeltaToMovement(t1, l);
                        e.c5(m, i.dir, o);
                    }
                }
                const g = e.d8(p, p, m);
                r._translateCameraConstrained(g), l && Math.abs(r.zoom - f) > 1e-4 && r.recenterOnTerrain(), r.cameraElevationReference = "ground", this._map._update(), t1.noInertia || this._inertia.record(t1), this._fireEvents(i, o, !0);
            }
            _fireEvents(t1, i, o) {
                const s = Al(this._eventsInProgress), r = Al(t1), n = {};
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._eventsInProgress[e] || (n[`${e}start`] = i), this._eventsInProgress[e] = t1[e];
                }
                !s && r && this._fireEvent("movestart", r.originalEvent);
                for(const e in n)this._fireEvent(e, n[e]);
                r && this._fireEvent("move", r.originalEvent);
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._fireEvent(e, i);
                }
                const a = {};
                let l;
                for(const e in this._eventsInProgress){
                    const { handlerName: t1, originalEvent: o } = this._eventsInProgress[e];
                    this._handlersById[t1].isActive() || (delete this._eventsInProgress[e], l = i[t1] || o, a[`${e}end`] = l);
                }
                for(const e in a)this._fireEvent(e, a[e]);
                const c = Al(this._eventsInProgress);
                if (o && (s || r) && !c) {
                    this._updatingCamera = !0;
                    const t1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (e)=>0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
                    t1 ? (i(t1.bearing || this._map.getBearing()) && (t1.bearing = 0), this._map.easeTo(t1, {
                        originalEvent: l
                    })) : (this._map.fire(new e.z("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t1, i) {
                this._map.fire(new e.z(t1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e)=>{
                    this._frameId = void 0, this.handleEvent(new Ll("renderFrame", {
                        timeStamp: e
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const zl = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Ml extends e.E {
            constructor(t1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = t1, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.aY([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e.aT(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e, t1) {
                return this.jumpTo({
                    center: e
                }, t1);
            }
            panBy(t1, i, o) {
                return t1 = e.P.convert(t1).mult(-1), this.panTo(this.transform.center, Object.assign({
                    offset: t1
                }, i), o);
            }
            panTo(e, t1, i) {
                return this.easeTo(Object.assign({
                    center: e
                }, t1), i);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e, t1) {
                return this.jumpTo({
                    zoom: e
                }, t1), this;
            }
            zoomTo(e, t1, i) {
                return this.easeTo(Object.assign({
                    zoom: e
                }, t1), i);
            }
            zoomIn(e, t1) {
                return this.zoomTo(this.getZoom() + 1, e, t1), this;
            }
            zoomOut(e, t1) {
                return this.zoomTo(this.getZoom() - 1, e, t1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e, t1) {
                return this.jumpTo({
                    bearing: e
                }, t1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e, t1) {
                return this.jumpTo({
                    padding: e
                }, t1), this;
            }
            rotateTo(e, t1, i) {
                return this.easeTo(Object.assign({
                    bearing: e
                }, t1), i);
            }
            resetNorth(e, t1) {
                return this.rotateTo(0, Object.assign({
                    duration: 1e3
                }, e), t1), this;
            }
            resetNorthPitch(e, t1) {
                return this.easeTo(Object.assign({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, e), t1), this;
            }
            snapToNorth(e, t1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e, t1) {
                return this.jumpTo({
                    pitch: e
                }, t1), this;
            }
            cameraForBounds(t1, i) {
                t1 = e.aI.convert(t1);
                const o = i && i.bearing || 0, s = i && i.pitch || 0, r = t1.getNorthWest(), n = t1.getSouthEast();
                return this._cameraForBounds(this.transform, r, n, o, s, i);
            }
            _extendPadding(e) {
                const t1 = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                return null == e ? Object.assign({}, t1, this.transform.padding) : "number" == typeof e ? {
                    top: e,
                    bottom: e,
                    right: e,
                    left: e
                } : Object.assign({}, t1, e);
            }
            _extendCameraOptions(e) {
                return (e = Object.assign({
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, e)).padding = this._extendPadding(e.padding), e;
            }
            _minimumAABBFrustumDistance(e, t1) {
                const i = t1.max[0] - t1.min[0], o = t1.max[1] - t1.min[1];
                return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);
            }
            _cameraForBoundsOnGlobe(t1, i, o, s, r, n) {
                const a = t1.clone(), l = this._extendCameraOptions(n);
                a.bearing = s, a.pitch = r;
                const c = e.aT.convert(i), h = e.aT.convert(o), d = .5 * (c.lat + h.lat), u = .5 * (c.lng + h.lng), _ = e.eZ(d, u), p = e.aw([], _), f = e.aw([], e.bI([], p, [
                    0,
                    1,
                    0
                ])), m = e.bI([], f, p), g = [
                    f[0],
                    f[1],
                    f[2],
                    0,
                    m[0],
                    m[1],
                    m[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v = [
                    _,
                    e.eZ(c.lat, c.lng),
                    e.eZ(h.lat, c.lng),
                    e.eZ(h.lat, h.lng),
                    e.eZ(c.lat, h.lng),
                    e.eZ(d, c.lng),
                    e.eZ(d, h.lng),
                    e.eZ(c.lat, u),
                    e.eZ(h.lat, u)
                ];
                let y = e.d9.fromPoints(v.map((t1)=>[
                        e.bJ(f, t1),
                        e.bJ(m, t1),
                        e.bJ(p, t1)
                    ]));
                const x = e.af([], y.center, g);
                0 === e.e_(x) && e.e$(x, 0, 0, 1), e.aw(x, x), e.c5(x, x, e.aD), a.center = e.f0(x);
                const b = a.getWorldToCameraMatrix(), w = e.bl(new Float64Array(16), b);
                y = e.d9.applyTransform(y, e.aB([], b, g));
                const T = this._extendAABB(y, a, l, s);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                y = T, e.af(x, x, b);
                const E = .5 * (y.max[2] - y.min[2]), S = this._minimumAABBFrustumDistance(a, y), I = e.c5([], [
                    0,
                    0,
                    1
                ], E), C = e.d8(I, x, I), R = S + (0 === a.pitch ? 0 : e.bG(x, C)), A = a.globeCenterInViewSpace, L = e.av([], x, [
                    A[0],
                    A[1],
                    A[2]
                ]);
                e.aw(L, L), e.c5(L, L, R);
                const D = e.d8([], x, L);
                e.af(D, D, w);
                const P = e.eM / e.aD, O = e.ag(D), z = e.cf(Math.max(O * P - e.eM, Number.EPSILON), 0), M = Math.min(a.zoomFromMercatorZAdjusted(z), l.maxZoom);
                return M > .5 * (e.c_ + e.cL) ? (a.setProjection({
                    name: "mercator"
                }), a.zoom = M, this._cameraForBounds(a, i, o, s, r, n)) : {
                    center: a.center,
                    zoom: M,
                    bearing: s,
                    pitch: r
                };
            }
            _extendAABB(t1, i, o, s) {
                const r = .5 * ((o.padding.left || 0) + (o.padding.right || 0)), n = .5 * ((o.padding.top || 0) + (o.padding.bottom || 0)), a = n, l = r, c = r, h = n, d = i.width - (l + c), u = i.height - (a + h), _ = e.av([], t1.max, t1.min), p = Math.min(d / _[0], u / _[1]), f = Math.min(i.scaleZoom(i.scale * p), o.maxZoom);
                if (isNaN(f)) return null;
                const m = i.scale / i.zoomScale(f), g = new e.d9([
                    t1.min[0] - l * m,
                    t1.min[1] - h * m,
                    t1.min[2]
                ], [
                    t1.max[0] + c * m,
                    t1.max[1] + a * m,
                    t1.max[2]
                ]), v = ("number" == typeof o.offset.x && "number" == typeof o.offset.y ? new e.P(o.offset.x, o.offset.y) : e.P.convert(o.offset)).rotate(-e.an(s));
                return g.center[0] -= v.x * m, g.center[1] += v.y * m, g;
            }
            queryTerrainElevation(t1, i) {
                const o = this.transform.elevation;
                return o ? (i = Object.assign({}, {
                    exaggerated: !0
                }, i), o.getAtPoint(e.ae.fromLngLat(t1), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t1, i, o, s, r, n) {
                if ("globe" === t1.projection.name) return this._cameraForBoundsOnGlobe(t1, i, o, s, r, n);
                const a = t1.clone(), l = this._extendCameraOptions(n);
                a.bearing = s, a.pitch = r;
                const c = e.aT.convert(i), h = e.aT.convert(o), d = new e.aT(c.lng, h.lat), u = new e.aT(h.lng, c.lat), _ = a.project(c), p = a.project(h), f = this.queryTerrainElevation(c), m = this.queryTerrainElevation(h), g = this.queryTerrainElevation(d), v = this.queryTerrainElevation(u), y = [
                    [
                        _.x,
                        _.y,
                        Math.min(f || 0, m || 0, g || 0, v || 0)
                    ],
                    [
                        p.x,
                        p.y,
                        Math.max(f || 0, m || 0, g || 0, v || 0)
                    ]
                ];
                let x = e.d9.fromPoints(y);
                const b = a.getWorldToCameraMatrix(), w = e.bl(new Float64Array(16), b);
                x = e.d9.applyTransform(x, b);
                const T = this._extendAABB(x, a, l, s);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                x = T;
                const E = .5 * e.av([], x.max, x.min)[2], S = this._minimumAABBFrustumDistance(a, x), I = [
                    0,
                    0,
                    1,
                    0
                ];
                e.aC(I, I, b), e.f1(I, I);
                const C = e.c5([], I, S + E), R = e.d8([], x.center, C);
                e.af(x.center, x.center, w), e.af(R, R, w);
                const A = a.unproject(new e.P(x.center[0], x.center[1])), L = e.f2(a.projection, A), D = Math.pow(2, L), P = Math.min(a._zoomFromMercatorZ(R[2] * a.pixelsPerMeter * D / a.worldSize), l.maxZoom);
                return a.mercatorFromTransition && P < .5 * (e.c_ + e.cL) ? (a.setProjection({
                    name: "globe"
                }), a.zoom = P, this._cameraForBounds(a, i, o, s, r, n)) : {
                    center: A,
                    zoom: P,
                    bearing: s,
                    pitch: r
                };
            }
            fitBounds(e, t1, i) {
                const o = this.cameraForBounds(e, t1);
                return this._fitInternal(o, t1, i);
            }
            fitScreenCoordinates(t1, i, o, s, r) {
                const n = e.P.convert(t1), a = e.P.convert(i), l = new e.P(Math.min(n.x, a.x), Math.min(n.y, a.y)), c = new e.P(Math.max(n.x, a.x), Math.max(n.y, a.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n, a)) return this;
                const h = this.transform.pointLocation3D(l), d = this.transform.pointLocation3D(c), u = this.transform.pointLocation3D(new e.P(l.x, c.y)), _ = this.transform.pointLocation3D(new e.P(c.x, l.y)), p = [
                    Math.min(h.lng, d.lng, u.lng, _.lng),
                    Math.min(h.lat, d.lat, u.lat, _.lat)
                ], f = [
                    Math.max(h.lng, d.lng, u.lng, _.lng),
                    Math.max(h.lat, d.lat, u.lat, _.lat)
                ], m = s && s.pitch ? s.pitch : this.getPitch(), g = this._cameraForBounds(this.transform, p, f, o, m, s);
                return this._fitInternal(g, s, r);
            }
            _fitInternal(e, t1, i) {
                return e ? (t1 = Object.assign(e, t1)).linear ? this.easeTo(t1, i) : this.flyTo(t1, i) : this;
            }
            jumpTo(t1, i) {
                this.stop();
                const o = t1.preloadOnly ? this.transform.clone() : this.transform;
                let s = !1, r = !1, n = !1;
                "zoom" in t1 && o.zoom !== +t1.zoom && (s = !0, o.zoom = +t1.zoom), void 0 !== t1.center && (o.center = e.aT.convert(t1.center)), "bearing" in t1 && o.bearing !== +t1.bearing && (r = !0, o.bearing = +t1.bearing), "pitch" in t1 && o.pitch !== +t1.pitch && (n = !0, o.pitch = +t1.pitch);
                const a = "number" == typeof t1.padding ? this._extendPadding(t1.padding) : t1.padding;
                if (null != t1.padding && !o.isPaddingEqual(a)) if (!1 === t1.retainPadding) {
                    const e = o.clone();
                    e.padding = a, o.setLocationAtPoint(o.center, e.centerPoint);
                } else o.padding = a;
                return t1.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.z("movestart", i)).fire(new e.z("move", i)), s && this.fire(new e.z("zoomstart", i)).fire(new e.z("zoom", i)).fire(new e.z("zoomend", i)), r && this.fire(new e.z("rotatestart", i)).fire(new e.z("rotate", i)).fire(new e.z("rotateend", i)), n && this.fire(new e.z("pitchstart", i)).fire(new e.z("pitch", i)).fire(new e.z("pitchend", i)), this.fire(new e.z("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e.w(zl), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t1, i) {
                const o = this.transform;
                if (!o.projection.supportsFreeCamera) return e.w(zl), this;
                this.stop();
                const s = o.zoom, r = o.pitch, n = o.bearing;
                o.setFreeCameraOptions(t1);
                const a = s !== o.zoom, l = r !== o.pitch, c = n !== o.bearing;
                return this.fire(new e.z("movestart", i)).fire(new e.z("move", i)), a && this.fire(new e.z("zoomstart", i)).fire(new e.z("zoom", i)).fire(new e.z("zoomend", i)), c && this.fire(new e.z("rotatestart", i)).fire(new e.z("rotate", i)).fire(new e.z("rotateend", i)), l && this.fire(new e.z("pitchstart", i)).fire(new e.z("pitch", i)).fire(new e.z("pitchend", i)), this.fire(new e.z("moveend", i)), this;
            }
            easeTo(t1, i) {
                this._stop(!1, t1.easeId), (!1 === (t1 = Object.assign({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e.eV
                }, t1)).animate || this._prefersReducedMotion(t1)) && (t1.duration = 0);
                const o = this.transform, s = this.getZoom(), r = this.getBearing(), n = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? +t1.zoom : s, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, r) : r, h = "pitch" in t1 ? +t1.pitch : n, d = this._extendPadding(t1.padding), u = e.P.convert(t1.offset);
                let _, p, f;
                if ("globe" === o.projection.name) {
                    const i = e.ae.fromLngLat(o.center), s = u.rotate(-o.angle);
                    i.x += s.x / o.worldSize, i.y += s.y / o.worldSize;
                    const r = i.toLngLat(), n = e.aT.convert(t1.center || r);
                    this._normalizeCenter(n), _ = o.centerPoint.add(s), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.aF(n.lng), e.aJ(n.lat)).mult(o.worldSize).sub(p);
                } else {
                    _ = o.centerPoint.add(u);
                    const i = o.pointLocation(_), s = e.aT.convert(t1.center || i);
                    this._normalizeCenter(s), p = o.project(i), f = o.project(s).sub(p);
                }
                const m = o.zoomScale(l - s);
                let g, v;
                t1.around && (g = e.aT.convert(t1.around), v = o.locationPoint(g));
                const y = this._zooming || l !== s, x = this._rotating || r !== c, b = this._pitching || h !== n, w = !o.isPaddingEqual(d), T = !1 === t1.retainPadding ? o.clone() : o, E = (o)=>(E)=>{
                        if (y && (o.zoom = e.ak(s, l, E)), x && (o.bearing = e.ak(r, c, E)), b && (o.pitch = e.ak(n, h, E)), w && (T.interpolatePadding(a, d, E), _ = T.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);
                        else {
                            const e = o.zoomScale(o.zoom - s), t1 = l > s ? Math.min(2, m) : Math.max(.5, m), i = Math.pow(t1, 1 - E), r = o.unproject(p.add(f.mult(E * i)).mult(e));
                            o.setLocationAtPoint(o.renderWorldCopies ? r.wrap() : r, _);
                        }
                        return t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(E, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                const S = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = y, this._rotating = x, this._pitching = b, this._padding = w, this._easeId = t1.easeId, this._prepareEase(i, t1.noMoveStart, S), this._ease(E(o), (e)=>{
                    "sea" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);
                }, t1), this;
            }
            _prepareEase(t1, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i || o.moving || this.fire(new e.z("movestart", t1)), this._zooming && !o.zooming && this.fire(new e.z("zoomstart", t1)), this._rotating && !o.rotating && this.fire(new e.z("rotatestart", t1)), this._pitching && !o.pitching && this.fire(new e.z("pitchstart", t1));
            }
            _fireMoveEvents(t1) {
                this.fire(new e.z("move", t1)), this._zooming && this.fire(new e.z("zoom", t1)), this._rotating && this.fire(new e.z("rotate", t1)), this._pitching && this.fire(new e.z("pitch", t1));
            }
            _afterEase(t1, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o = this._zooming, s = this._rotating, r = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.z("zoomend", t1)), s && this.fire(new e.z("rotateend", t1)), r && this.fire(new e.z("pitchend", t1)), this.fire(new e.z("moveend", t1));
            }
            flyTo(t1, i) {
                if (this._prefersReducedMotion(t1)) {
                    const o = e.aH(t1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around",
                        "padding",
                        "retainPadding"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), t1 = Object.assign({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e.eV
                }, t1);
                const o = this.transform, s = this.getZoom(), r = this.getBearing(), n = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? e.aA(+t1.zoom, o.minZoom, o.maxZoom) : s, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, r) : r, h = "pitch" in t1 ? +t1.pitch : n, d = this._extendPadding(t1.padding), u = o.zoomScale(l - s), _ = e.P.convert(t1.offset);
                let p = o.centerPoint.add(_);
                const f = o.pointLocation(p), m = e.aT.convert(t1.center || f);
                this._normalizeCenter(m);
                const g = o.project(f), v = o.project(m).sub(g);
                let y = t1.curve;
                const x = Math.max(o.width, o.height), b = x / u, w = v.mag();
                if ("minZoom" in t1) {
                    const i = e.aA(Math.min(t1.minZoom, s, l), o.minZoom, o.maxZoom), r = x / o.zoomScale(i - s);
                    y = Math.sqrt(r / w * 2);
                }
                const T = y * y;
                function E(e) {
                    const t1 = (b * b - x * x + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : x) * T * w);
                    return Math.log(Math.sqrt(t1 * t1 + 1) - t1);
                }
                function S(e) {
                    return (Math.exp(e) - Math.exp(-e)) / 2;
                }
                function I(e) {
                    return (Math.exp(e) + Math.exp(-e)) / 2;
                }
                const C = E(0);
                let R = function(e) {
                    return I(C) / I(C + y * e);
                }, A = function(e) {
                    return x * ((I(C) * (S(t1 = C + y * e) / I(t1)) - S(C)) / T) / w;
                    //TURBOPACK unreachable
                    ;
                    var t1;
                }, L = (E(1) - C) / y;
                if (Math.abs(w) < 1e-6 || !isFinite(L)) {
                    if (Math.abs(x - b) < 1e-6) return this.easeTo(t1, i);
                    const e = b < x ? -1 : 1;
                    L = Math.abs(Math.log(b / x)) / y, A = function() {
                        return 0;
                    }, R = function(t1) {
                        return Math.exp(e * y * t1);
                    };
                }
                t1.duration = "duration" in t1 ? +t1.duration : 1e3 * L / ("screenSpeed" in t1 ? +t1.screenSpeed / y : +t1.speed), t1.maxDuration && t1.duration > t1.maxDuration && (t1.duration = 0);
                const D = r !== c, P = h !== n, O = !o.isPaddingEqual(d), z = !1 === t1.retainPadding ? o.clone() : o, M = (o)=>(u)=>{
                        const f = u * L, y = 1 / R(f);
                        o.zoom = 1 === u ? l : s + o.scaleZoom(y), D && (o.bearing = e.ak(r, c, u)), P && (o.pitch = e.ak(n, h, u)), O && (z.interpolatePadding(a, d, u), p = z.centerPoint.add(_));
                        const x = 1 === u ? m : o.unproject(g.add(v.mult(A(f))).mult(y));
                        return o.setLocationAtPoint(o.renderWorldCopies ? x.wrap() : x, p), o._updateCameraOnTerrain(), t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(M, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                return this._zooming = !0, this._rotating = D, this._pitching = P, this._padding = O, this._prepareEase(i, !1), this._ease(M(o), ()=>this._afterEase(i), t1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _requestRenderFrame(e) {}
            _cancelRenderFrame(e) {}
            _stop(e, t1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e = this._onEaseEnd;
                    this._onEaseEnd = void 0, e.call(this, t1);
                }
                if (!e) {
                    const e = this.handlers;
                    e && e.stop(!1);
                }
                return this;
            }
            _ease(t1, i, o) {
                !1 === o.animate || 0 === o.duration ? (t1(1), i()) : (this._easeStart = e.o.now(), this._easeOptions = o, this._onEaseFrame = t1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t1 = Math.min((e.o.now() - this._easeStart) / this._easeOptions.duration, 1), i = this._onEaseFrame;
                i && i(this._easeOptions.easing(t1)), t1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t1, i) {
                t1 = e.bT(t1, -180, 180);
                const o = Math.abs(t1 - i);
                return Math.abs(t1 - 360 - i) < o && (t1 -= 360), Math.abs(t1 + 360 - i) < o && (t1 += 360), t1;
            }
            _normalizeCenter(e) {
                const t1 = this.transform;
                if (t1.maxBounds) return;
                if ("globe" !== t1.projection.name && !t1.renderWorldCopies) return;
                const i = e.lng - t1.center.lng;
                e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t1) {
                return this._respectPrefersReducedMotion && e.o.prefersReducedMotion && !(t1 && t1.essential);
            }
            _emulate(e, t1, i) {
                const o = Math.ceil(15 * t1 / 1e3), s = [], r = e(i.clone());
                for(let e = 0; e <= o; e++){
                    const t1 = r(e / o);
                    s.push(t1.clone());
                }
                return s;
            }
            _preloadTiles(e, t1) {}
        }
        class Fl {
            constructor(t1 = {}){
                this.options = t1, e.aY([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e) {
                const t1 = this.options && this.options.compact, i = e._getUIString("AttributionControl.ToggleAttribution");
                this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i);
                const o = l("span", "mapboxgl-ctrl-icon", this._compactButton);
                return o.setAttribute("aria-hidden", "true"), o.setAttribute("title", i), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t1 = this._editLink;
                t1 || (t1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN
                    }
                ];
                if (t1) {
                    const o = i.reduce((e, t1, o)=>(t1.value && (e += `${t1.key}=${t1.value}${o < i.length - 1 ? "&" : ""}`), e), "?");
                    t1.href = `${e.e.FEEDBACK_URL}/${o}#${Ma(this._map, !0)}`, t1.rel = "noopener nofollow";
                }
            }
            _updateData(e) {
                !e || ("source" !== e.dataType || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType) && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e = [];
                if (this._map.style.stylesheet) {
                    const e = this._map.style.stylesheet;
                    this.styleOwner = e.owner, this.styleId = e.id;
                }
                const t1 = this._map.style._mergedSourceCaches;
                for(const i in t1){
                    const o = t1[i];
                    if (o.used) {
                        const t1 = o.getSource();
                        t1.attribution && e.indexOf(t1.attribution) < 0 && e.push(t1.attribution);
                    }
                }
                e.sort((e, t1)=>e.length - t1.length), e = e.filter((t1, i)=>{
                    for(let o = i + 1; o < e.length; o++)if (e[o].indexOf(t1) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [
                    ...this.options.customAttribution,
                    ...e
                ] : e.unshift(this.options.customAttribution));
                const i = e.map((e)=>(function(e) {
                        const t1 = (new DOMParser).parseFromString(e, "text/html");
                        return Array.from(t1.body.querySelectorAll("*")).reverse().forEach((e)=>{
                            const i = e.textContent || "";
                            if ("A" !== e.tagName) return void e.replaceWith(...e.childNodes);
                            const o = e.getAttribute("href");
                            if (!o || !/^(https?:|mailto:)/i.test(o)) return void e.replaceWith(t1.createTextNode(i));
                            const s = t1.createElement("a");
                            s.href = o, s.textContent = i, s.rel = "noopener nofollow";
                            const r = e.getAttribute("class");
                            r && (s.className = r), e.replaceWith(s);
                        }), t1.body.innerHTML;
                    })(e)).join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class Bl {
            constructor(){
                e.aY([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e) {
                this._map = e, this._container = l("div", "mapboxgl-ctrl");
                const t1 = l("a", "mapboxgl-ctrl-logo");
                return t1.target = "_blank", t1.rel = "noopener nofollow", t1.href = "https://www.mapbox.com/", t1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e) {
                e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e = this._map.style._sourceCaches;
                if (0 === Object.entries(e).length) return !0;
                for(const t1 in e){
                    const i = e[t1].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e = this._container.children;
                if (e.length) {
                    const t1 = e[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t1.classList.add("mapboxgl-compact") : t1.classList.remove("mapboxgl-compact");
                }
            }
        }
        class kl {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e) {
                const t1 = ++this._id;
                return this._queue.push({
                    callback: e,
                    id: t1,
                    cancelled: !1
                }), t1;
            }
            remove(e) {
                const t1 = this._currentlyRunning, i = t1 ? this._queue.concat(t1) : this._queue;
                for (const t1 of i)if (t1.id === e) return void (t1.cancelled = !0);
            }
            run(e = 0) {
                const t1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of t1)if (!i.cancelled && (i.callback(e), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        class Nl {
            constructor(e){
                this.jumpTo(e);
            }
            getValue(t1) {
                if (t1 <= this._startTime) return this._start;
                if (t1 >= this._endTime) return this._end;
                const i = e.dD((t1 - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i;
            }
            isEasing(e) {
                return e >= this._startTime && e <= this._endTime;
            }
            jumpTo(e) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
            }
            easeTo(e, t1, i) {
                this._start = this.getValue(t1), this._end = e, this._startTime = t1, this._endTime = t1 + i;
            }
        }
        const Ul = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox homepage",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use â + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        };
        class jl extends e.z {
            constructor(e, t1, i, o){
                const { point: s, lngLat: r, originalEvent: n, target: a } = e;
                super(e.type, {
                    point: s,
                    lngLat: r,
                    originalEvent: n,
                    target: a
                }), this.preventDefault = ()=>{
                    e.preventDefault();
                }, this.id = t1, this.interaction = i, this.feature = o;
            }
        }
        class Vl {
            constructor(e){
                this.map = e, this.interactionsByType = new Map, this.delegatedInteractions = new Map, this.typeById = new Map, this.filters = new Map, this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = new Map, this.prevHoveredFeatures = new Map;
            }
            add(t1, i) {
                if (this.typeById.has(t1)) throw new Error(`Interaction id "${t1}" already exists.`);
                const o = i.filter;
                let s = i.type;
                o && this.filters.set(t1, e.b6(o)), "mouseover" === s && (s = "mouseenter"), "mouseout" === s && (s = "mouseleave");
                const r = this.interactionsByType.get(s) || new Map;
                "mouseenter" === s || "mouseleave" === s ? (0 === this.delegatedInteractions.size && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t1, i)) : 0 === r.size && this.map.on(s, this.handleType), 0 === r.size && this.interactionsByType.set(s, r), r.set(t1, i), this.typeById.set(t1, s);
            }
            get(e) {
                const t1 = this.typeById.get(e);
                if (!t1) return;
                const i = this.interactionsByType.get(t1);
                return i ? i.get(e) : void 0;
            }
            remove(e) {
                const t1 = this.typeById.get(e);
                if (!t1) return;
                this.typeById.delete(e), this.filters.delete(e);
                const i = this.interactionsByType.get(t1);
                i && (i.delete(e), "mouseenter" === t1 || "mouseleave" === t1 ? (this.delegatedInteractions.delete(e), 0 === this.delegatedInteractions.size && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : 0 === i.size && this.map.off(t1, this.handleType));
            }
            queryTargets(e, t1) {
                const i = [];
                for (const [e, o] of t1)o.target && i.push({
                    targetId: e,
                    target: o.target,
                    filter: this.filters.get(e)
                });
                return this.map.style.queryRenderedTargets(e, i, this.map.transform);
            }
            handleMove(e) {
                this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = new Map;
                const t1 = this.queryTargets(e.point, Array.from(this.delegatedInteractions).reverse());
                t1.length && (e.type = "mouseenter", this.handleType(e, t1));
                const i = new Map;
                for (const [e, { feature: t1 }] of this.prevHoveredFeatures)this.hoveredFeatures.has(e) || i.set(t1.id, t1);
                i.size && (e.type = "mouseleave", this.handleType(e, Array.from(i.values())));
            }
            handleOut(e) {
                const t1 = Array.from(this.hoveredFeatures.values()).map(({ feature: e })=>e);
                t1.length && (e.type = "mouseleave", this.handleType(e, t1)), this.hoveredFeatures.clear();
            }
            handleType(t1, i) {
                const o = "mouseenter" === t1.type;
                if (o && !this.interactionsByType.has(t1.type)) return void e.w("mouseenter interaction required for mouseleave to work.");
                const s = Array.from(this.interactionsByType.get(t1.type)).reverse(), r = !!i;
                i = i || this.queryTargets(t1.point, s);
                let n = !1;
                const a = new Set;
                for (const l of i){
                    for (const [i, c] of s){
                        if (!c.target) continue;
                        const s = l.variants ? l.variants[i] : null;
                        if (s) {
                            for (const h of s){
                                if (vt(h, l, a, i)) continue;
                                const s = new e.dx(l, h), d = gt(h, l, i);
                                r && void 0 !== s.id && (s.state = this.map.getFeatureState(s));
                                const u = o ? this.prevHoveredFeatures.get(d) : null, _ = new jl(t1, i, c, s), p = u ? u.stop : c.handler(_);
                                if (o && this.hoveredFeatures.set(d, {
                                    feature: l,
                                    stop: p
                                }), !1 !== p) {
                                    n = !0;
                                    break;
                                }
                            }
                            if (n) break;
                        }
                    }
                    if (n) break;
                }
                if (!n) for (const [e, i] of s){
                    const { handler: o, target: s } = i;
                    if (!s && !1 !== o(new jl(t1, e, i, null))) break;
                }
            }
        }
        function Gl(t1, i) {
            if (Array.isArray(t1) && Array.isArray(i)) {
                const e = new Set(t1), o = new Set(i);
                return e.size === o.size && t1.every((e)=>o.has(e));
            }
            return e.by(t1, i);
        }
        const Hl = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            antialias: !1,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            respectPrefersReducedMotion: !0,
            crossSourceCollisions: !0,
            collectResourceTiming: !1,
            testMode: !1,
            precompilePrograms: !0,
            scaleFactor: 1,
            spriteFormat: "auto"
        }, ql = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class Zl {
            constructor(t1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new nl({
                    clickTolerance: t1.dragRotate._mouseRotate._clickTolerance
                }), this.map = t1, o && (this.mousePitch = new al({
                    clickTolerance: t1.dragRotate._mousePitch._clickTolerance
                })), e.aY([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }
            down(e, t1) {
                this.mouseRotate.mousedown(e, t1), this.mousePitch && this.mousePitch.mousedown(e, t1), _();
            }
            move(e, t1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(e, t1), s = o && o.bearingDelta;
                if (s && i.setBearing(i.getBearing() + s), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e, t1), s = o && o.pitchDelta;
                    s && i.setPitch(i.getPitch() + s);
                }
            }
            off() {
                const e = this.element;
                e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(e) {
                this.down(Object.assign({}, e, {
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }), g(this.element, e)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e) {
                this.move(e, g(this.element, e));
            }
            mouseup(e) {
                this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
            }
            touchstart(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }, this._startPos));
            }
            touchmove(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e.targetTouches)[0], this.move({
                    preventDefault: ()=>e.preventDefault()
                }, this._lastPos));
            }
            touchend(e) {
                0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        function Wl(t1, i, o) {
            if (t1 = new e.aT(t1.lng, t1.lat), i) {
                const s = new e.aT(t1.lng - 360, t1.lat), r = new e.aT(t1.lng + 360, t1.lat), n = 360 * Math.ceil(Math.abs(t1.lng - o.center.lng) / 360), a = o.locationPoint3D(t1).distSqr(i), l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
                o.locationPoint3D(s).distSqr(i) < a && (l || Math.abs(s.lng - o.center.lng) < n) ? t1 = s : o.locationPoint3D(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < n) && (t1 = r);
            }
            for(; Math.abs(t1.lng - o.center.lng) > 180;){
                const e = o.locationPoint3D(t1);
                if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;
                t1.lng > o.center.lng ? t1.lng -= 360 : t1.lng += 360;
            }
            return t1;
        }
        const $l = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        }, Xl = {
            rotation: 0,
            rotationAlignment: "auto",
            pitchAlignment: "auto",
            occludedOpacity: .2,
            altitude: 0
        };
        class Yl extends e.E {
            constructor(t1, i){
                super(), (t1 instanceof HTMLElement || i) && (t1 = Object.assign({
                    element: t1
                }, i)), e.aY([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this);
                const { anchor: o = "center", color: s = "#3FB1CE", scale: r = 1, draggable: n = !1, clickTolerance: a = 0, rotation: l = Xl.rotation, rotationAlignment: c = Xl.rotationAlignment, pitchAlignment: h = Xl.pitchAlignment, occludedOpacity: d = Xl.occludedOpacity, altitude: u = Xl.altitude } = t1 || {};
                this._anchor = o, this._color = s, this._scale = r, this._draggable = n, this._clickTolerance = a, this._rotation = l, this._rotationAlignment = c, this._pitchAlignment = h, this._occludedOpacity = d, this._altitude = u, this._state = "inactive", this._isDragging = !1, this._updateMoving = ()=>this._update(!0), t1 && t1.element ? (this._element = t1.element, this._offset = e.P.convert(t1 && t1.offset || [
                    0,
                    0
                ])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t1 && t1.offset || [
                    0,
                    -14
                ])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e)=>{
                    e.preventDefault();
                }), this._element.addEventListener("mousedown", (e)=>{
                    e.preventDefault();
                });
                const _ = this._element.classList;
                for(const e in $l)_.remove(`mapboxgl-marker-anchor-${e}`);
                _.add(`mapboxgl-marker-anchor-${this._anchor}`);
                const p = t1 && t1.className ? t1.className.trim().split(/\s+/) : [];
                _.add(...p), this._popup = null;
            }
            _createDefaultMarker() {
                const e = l("div"), t1 = c("svg", {
                    display: "block",
                    height: 41 * this._scale + "px",
                    width: 27 * this._scale + "px",
                    viewBox: "0 0 27 41"
                }, e);
                if (0 === this._altitude) {
                    const e = c("radialGradient", {
                        id: "shadowGradient"
                    }, c("defs", {}, t1));
                    c("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, e), c("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, e), c("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, t1);
                }
                return c("path", {
                    fill: this._color,
                    d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                }, t1), c("path", {
                    opacity: .25,
                    d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                }, t1), c("circle", {
                    fill: "white",
                    cx: 13.5,
                    cy: 13.5,
                    r: 5.5
                }, t1), e;
            }
            addTo(e) {
                return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
            }
            remove() {
                const e = this._map;
                return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t1) {
                return this._lngLat = e.aT.convert(t1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            setAltitude(e) {
                return e === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e || 0 !== this._altitude && 0 === e) && (this._element = this._createDefaultMarker()), this._altitude = e || Xl.altitude, this._update()), this;
            }
            getAltitude() {
                return this._altitude;
            }
            getElement() {
                return this._element;
            }
            setPopup(e) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                    if (!("offset" in e.options)) {
                        const t1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        e.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (t1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (t1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (t1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (t1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = e, e._marker = this, e._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e) {
                const t1 = e.code, i = e.charCode || e.keyCode;
                "Space" !== t1 && "Enter" !== t1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(e) {
                const t1 = e.originalEvent.target, i = this._element;
                this._popup && (t1 === i || i.contains(t1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e = this._popup;
                return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e = this._map, t1 = this._pos;
                if (!e || !t1) return !1;
                const i = e.unproject(t1, this._altitude), o = e.getFreeCameraOptions();
                if (!o.position) return !1;
                const s = o.position.toLngLat();
                return s.distanceTo(i) < .9 * s.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t1 = this._map;
                if (!t1) return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > t1.transform.width || i.y < 0 || i.y > t1.transform.height) return void this._clearFadeTimer();
                const o = t1.unproject(i, this._altitude);
                let s;
                t1._showingGlobe() && e.f5(t1.transform, this._lngLat) ? s = 0 : (s = 1 - t1._queryFogOpacity(o), t1.transform._terrainEnabled() && t1.getTerrain() && this._behindTerrain() && (s *= this._occludedOpacity)), this._element.style.opacity = `${s}`, this._element.style.pointerEvents = s > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(s), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e = this._pos;
                if (!e || !this._map) return;
                const t1 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${$l[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t1.x}px,${t1.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t1 = this._pos, i = this._map, o = this.getPitchAlignment();
                if (!i || !t1 || "map" !== o) return "";
                if (!i._showingGlobe()) {
                    const e = i.getPitch();
                    return e ? `rotateX(${e}deg)` : "";
                }
                const s = e.cX(e.f6(i.transform, this._lngLat)), r = t1.sub(e.f7(i.transform)), n = Math.abs(r.x) + Math.abs(r.y);
                if (0 === n) return "";
                const a = s / n;
                return `rotateX(${-r.y * a}deg) rotateY(${r.x * a}deg)`;
            }
            _calculateZTransform() {
                const t1 = this._pos, i = this._map;
                if (!i || !t1) return "";
                let o = 0;
                const s = this.getRotationAlignment();
                if ("map" === s) if (i._showingGlobe()) {
                    const t1 = i.project(new e.aT(this._lngLat.lng, this._lngLat.lat + .001), this._altitude), s = i.project(new e.aT(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(t1);
                    o = e.cX(Math.atan2(s.y, s.x)) - 90;
                } else o = -i.getBearing();
                else if ("horizon" === s) {
                    const s = e.ah(4, 6, i.getZoom()), r = e.f7(i.transform);
                    r.y += s * i.transform.height;
                    const n = t1.sub(r), a = e.cX(Math.atan2(n.y, n.x));
                    o = (a > 90 ? a - 270 : a + 90) * (1 - s);
                }
                return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }
            _update(e) {
                cancelAnimationFrame(this._updateFrameId);
                const t1 = this._map;
                t1 && (t1.transform.renderWorldCopies && (this._lngLat = Wl(this._lngLat, this._pos, t1.transform)), this._pos = t1.project(this._lngLat, this._altitude), !0 === e ? this._updateFrameId = requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), t1._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t1._showingGlobe() || t1.getTerrain() || t1.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t1) {
                return this._offset = e.P.convert(t1), this._update(), this;
            }
            addClassName(e) {
                return this._element.classList.add(e), this;
            }
            removeClassName(e) {
                return this._element.classList.remove(e), this;
            }
            toggleClassName(e) {
                return this._element.classList.toggle(e);
            }
            _onMove(t1) {
                const i = this._map;
                if (!i) return;
                const o = this._pointerdownPos, s = this._positionDelta;
                if (o && s) {
                    if (!this._isDragging) {
                        const e = this._clickTolerance || i._clickTolerance;
                        if (t1.point.dist(o) < e) return;
                        this._isDragging = !0;
                    }
                    this._pos = t1.point.sub(s), this._lngLat = i.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.z("dragstart"))), this.fire(new e.z("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t1 = this._map;
                t1 && (t1.off("mousemove", this._onMove), t1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.z("dragend")), this._state = "inactive";
            }
            _addDragHandler(e) {
                const t1 = this._map, i = this._pos;
                t1 && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = "pending", t1.on("mousemove", this._onMove), t1.on("touchmove", this._onMove), t1.once("mouseup", this._onUp), t1.once("touchend", this._onUp));
            }
            setDraggable(e) {
                this._draggable = !!e;
                const t1 = this._map;
                return t1 && (e ? (t1.on("mousedown", this._addDragHandler), t1.on("touchstart", this._addDragHandler)) : (t1.off("mousedown", this._addDragHandler), t1.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e) {
                return this._rotation = e || Xl.rotation, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e) {
                return this._rotationAlignment = e || Xl.rotationAlignment, this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e) {
                return this._pitchAlignment = e || Xl.pitchAlignment, this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e) {
                return this._occludedOpacity = e || Xl.occludedOpacity, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const Kl = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1,
            showButton: !0,
            followUserLocation: !0
        }, Jl = {
            maxWidth: 100,
            unit: "metric"
        }, Ql = {
            kilometer: "km",
            meter: "m",
            mile: "mi",
            foot: "ft",
            "nautical-mile": "nm"
        }, ec = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            altitude: 0
        }, tc = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function ic(t1 = new e.P(0, 0), i = "bottom") {
            if ("number" == typeof t1) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t1, 2)));
                switch(i){
                    case "top":
                        return new e.P(0, t1);
                    case "top-left":
                        return new e.P(o, o);
                    case "top-right":
                        return new e.P(-o, o);
                    case "bottom":
                        return new e.P(0, -t1);
                    case "bottom-left":
                        return new e.P(o, -o);
                    case "bottom-right":
                        return new e.P(-o, -o);
                    case "left":
                        return new e.P(t1, 0);
                    case "right":
                        return new e.P(-t1, 0);
                }
                return new e.P(0, 0);
            }
            return t1 instanceof e.P || Array.isArray(t1) ? e.P.convert(t1) : e.P.convert(t1[i] || [
                0,
                0
            ]);
        }
        const oc = {
            version: t1,
            supported: a.supported,
            setRTLTextPlugin: e.fb,
            getRTLTextPluginStatus: e.fa,
            Map: class extends Ml {
                constructor(t1){
                    o.mark(i.create);
                    const s = t1;
                    if (null != (t1 = Object.assign({}, Hl, t1)).minZoom && null != t1.maxZoom && t1.minZoom > t1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t1.minPitch && null != t1.maxPitch && t1.minPitch > t1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t1.minPitch && t1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t1.maxPitch && t1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1.antialias && e.f3(window) && (t1.antialias = !1, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new lo(t1.minZoom, t1.maxZoom, t1.minPitch, t1.maxPitch, t1.renderWorldCopies, null, null), t1), this._repaint = !!t1.repaint, this._interactive = t1.interactive, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t1.preserveDrawingBuffer, this._antialias = t1.antialias, this._trackResize = t1.trackResize, this._bearingSnap = t1.bearingSnap, this._refreshExpiredTiles = t1.refreshExpiredTiles, this._fadeDuration = t1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t1.crossSourceCollisions, this._collectResourceTiming = t1.collectResourceTiming, this._language = this._parseLanguage(t1.language), this._worldview = t1.worldview, this._renderTaskQueue = new kl, this._domRenderTaskQueue = new kl, this._controls = [], this._markers = [], this._popups = [], this._mapId = e.b2(), this._locale = Object.assign({}, Ul, t1.locale), this._clickTolerance = t1.clickTolerance, this._cooperativeGestures = t1.cooperativeGestures, this._performanceMetricsCollection = t1.performanceMetricsCollection, this._tessellationStep = t1.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = t1.precompilePrograms, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Nl(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = t1.scaleFactor, this._requestManager = new T(t1.transformRequest, t1.accessToken, t1.testMode), this._silenceAuthErrors = !!t1.testMode, this._contextCreateOptions = t1.contextCreateOptions ? Object.assign({}, t1.contextCreateOptions) : {}, "string" == typeof t1.container) {
                        const e = document.getElementById(t1.container);
                        if (!e) throw new Error(`Container '${t1.container.toString()}' not found.`);
                        this._container = e;
                    } else {
                        if (!(t1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t1.container;
                    }
                    if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t1.maxBounds && this.setMaxBounds(t1.maxBounds), this._spriteFormat = t1.spriteFormat, e.aY([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    if (this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new Ol(this, t1), this._localFontFamily = t1.localFontFamily, this._localIdeographFontFamily = t1.localIdeographFontFamily, (t1.style || !t1.testMode) && this.setStyle(t1.style || e.e.DEFAULT_STYLE, {
                        config: t1.config,
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t1.projection && this.setProjection(t1.projection), t1.hash && (this._hash = new za("string" == typeof t1.hash && t1.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                        null == s.center && null == s.zoom || (this.transform._unmodified = !1), this.jumpTo({
                            center: t1.center,
                            zoom: t1.zoom,
                            bearing: t1.bearing,
                            pitch: t1.pitch
                        });
                        const e = t1.bounds;
                        e && (this.resize(), this.fitBounds(e, Object.assign({}, t1.fitBoundsOptions, {
                            duration: 0
                        })));
                    }
                    this.resize(), t1.attributionControl && this.addControl(new Fl({
                        customAttribution: t1.customAttribution
                    })), this._logoControl = new Bl, this.addControl(this._logoControl, t1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent(), this._postStyleWithAppearanceEvent();
                    }), this.on("data", (t1)=>{
                        this._update("style" === t1.dataType), this.fire(new e.z(`${t1.dataType}data`, t1));
                    }), this.on("dataloading", (t1)=>{
                        this.fire(new e.z(`${t1.dataType}dataloading`, t1));
                    }), this._interactions = new Vl(this);
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t1, i) {
                    if (void 0 === i && (i = t1.getDefaultPosition ? t1.getDefaultPosition() : "top-right"), !t1 || !t1.onAdd) return this.fire(new e.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = t1.onAdd(this);
                    this._controls.push(t1);
                    const s = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? s.insertBefore(o, s.firstChild) : s.appendChild(o), this;
                }
                removeControl(t1) {
                    if (!t1 || !t1.onRemove) return this.fire(new e.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(t1);
                    return i > -1 && this._controls.splice(i, 1), t1.onRemove(this), this;
                }
                hasControl(e) {
                    return this._controls.indexOf(e) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t1) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new e.z("movestart", t1)).fire(new e.z("move", t1)), this.fire(new e.z("resize", t1)), i && this.fire(new e.z("moveend", t1)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t1) {
                    return this.transform.setMaxBounds(e.aI.convert(t1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = t1 ?? -2) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 ? this.setZoom(t1) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = t1 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 ? this.setZoom(t1) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = t1 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 ? this.setPitch(t1) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = t1 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 ? this.setPitch(t1) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getScaleFactor() {
                    return this._scaleFactor;
                }
                setScaleFactor(e) {
                    return this._scaleFactor = e, this.painter.scaleFactor = e, this.style && this.style._setLabelPlacementStale(), this.style._updateFilteredLayers((e)=>"symbol" === e.type), this._update(!0), this;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e) {
                    return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(e) {
                    return "auto" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map((e)=>"auto" === e ? navigator.language : e) : e;
                }
                setLanguage(e) {
                    const t1 = this._parseLanguage(e);
                    if (!this.style || t1 === this._language) return this;
                    this._language = t1, this.style.reloadSources();
                    for (const e of this._controls)e._setLanguage && e._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e) {
                    return this.style && e !== this._worldview ? (this._worldview = e, this._styleDirty = !0, this.style.reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e) {
                    return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
                        name: e
                    }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t1 = this.transform, i = t1.projection.name;
                    let o;
                    "globe" === i && t1.zoom >= e.cL ? (t1.setMercatorFromTransition(), o = !0) : "mercator" === i && t1.zoom < e.cL && (t1.setProjection({
                        name: "globe"
                    }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate(), this._update(!0));
                }
                _prioritizeAndUpdateProjection(e, t1) {
                    return this._updateProjection(e || t1 || {
                        name: "mercator"
                    });
                }
                _updateProjection(t1) {
                    let i;
                    const o = this.transform.mercatorFromTransition;
                    i = "globe" === t1.name && this.transform.zoom >= e.cL ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t1), this.style.applyProjectionUpdate();
                    const s = "mercator" === this.transform.getProjection().name && o !== this.transform.mercatorFromTransition;
                    return (i || s) && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
                }
                project(t1, i) {
                    return this.transform.locationPoint3D(e.aT.convert(t1), i);
                }
                unproject(t1, i) {
                    return this.transform.pointLocation3D(e.P.convert(t1), i);
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e, t1, i) {
                    const o = (e)=>{
                        let i = [];
                        if (Array.isArray(t1)) {
                            const o = t1.filter((e)=>this.getLayer(e));
                            i = o.length ? this.queryRenderedFeatures(e, {
                                layers: o
                            }) : [];
                        } else i = this.queryRenderedFeatures(e, {
                            target: t1
                        });
                        return i;
                    };
                    if ("mouseenter" === e || "mouseover" === e) {
                        let s = !1;
                        const r = (t1)=>{
                            const r = o(t1.point);
                            r.length ? s || (s = !0, i.call(this, new Ha(e, this, t1.originalEvent, {
                                features: r
                            }))) : s = !1;
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                mousemove: r,
                                mouseout: ()=>{
                                    s = !1;
                                }
                            }
                        };
                    }
                    if ("mouseleave" === e || "mouseout" === e) {
                        let s = !1;
                        const r = (t1)=>{
                            o(t1.point).length ? s = !0 : s && (s = !1, i.call(this, new Ha(e, this, t1.originalEvent)));
                        }, n = (t1)=>{
                            s && (s = !1, i.call(this, new Ha(e, this, t1.originalEvent)));
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                mousemove: r,
                                mouseout: n
                            }
                        };
                    }
                    {
                        const s = (e)=>{
                            const t1 = o(e.point);
                            t1.length && (e.features = t1, i.call(this, e), delete e.features);
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                [e]: s
                            }
                        };
                    }
                }
                on(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.on(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._createDelegatedListener(e, t1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);
                    for(const e in o.delegates)this.on(e, o.delegates[e]);
                    return this;
                }
                once(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.once(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._createDelegatedListener(e, t1, i);
                    for(const e in o.delegates)this.once(e, o.delegates[e]);
                    return this;
                }
                off(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.off(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
                    return o && ((e)=>{
                        for(let o = 0; o < e.length; o++){
                            const s = e[o];
                            if (s.listener === i && Gl(s.targets, t1)) {
                                for(const e in s.delegates)this.off(e, s.delegates[e]);
                                return e.splice(o, 1), this;
                            }
                        }
                    })(o), this;
                }
                queryRenderedFeatures(t1, i) {
                    if (!this.style) return [];
                    if (void 0 === t1 || t1 instanceof e.P || Array.isArray(t1) || void 0 !== i || (i = t1, t1 = void 0), t1 = t1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], !i) {
                        const e = this.style.queryRenderedFeatures(t1, void 0, this.transform), i = this.style.queryRenderedFeatureset(t1, void 0, this.transform);
                        return e.concat(i);
                    }
                    let o = !0;
                    if (i.target && (o = this._isTargetValid(i.target), o && !i.layers)) return this.style.queryRenderedFeatureset(t1, i, this.transform);
                    let s = !0;
                    if (i.layers && Array.isArray(i.layers)) {
                        for (const e of i.layers)if (!this._isValidId(e)) {
                            s = !1;
                            break;
                        }
                        if (s && !i.target) return this.style.queryRenderedFeatures(t1, i, this.transform);
                    }
                    let r = [];
                    return s && (r = r.concat(this.style.queryRenderedFeatures(t1, i, this.transform))), o && (r = r.concat(this.style.queryRenderedFeatureset(t1, i, this.transform))), r;
                }
                querySourceFeatures(e, t1) {
                    return !e || "string" == typeof e && !this._isValidId(e) ? [] : this.style.querySourceFeatures(e, t1);
                }
                queryRasterValue(e, t1, i) {
                    return this._isValidId(e) ? this.style.queryRasterValue(e, t1, i) : Promise.resolve(null);
                }
                isPointOnSurface(t1) {
                    const { name: i } = this.transform.projection;
                    return "globe" !== i && "mercator" !== i && e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t1));
                }
                addInteraction(e, t1) {
                    return this._interactions.add(e, t1), this;
                }
                removeInteraction(e) {
                    return this._interactions.remove(e), this;
                }
                getCooperativeGestures() {
                    return this._cooperativeGestures;
                }
                setCooperativeGestures(e) {
                    return this._cooperativeGestures = e, this;
                }
                setStyle(t1, i) {
                    return i = Object.assign({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i), this.style && t1 && !1 !== i.diff && i.localFontFamily === this._localFontFamily && i.localIdeographFontFamily === this._localIdeographFontFamily && !i.config ? (this.style._diffStyle(t1, (o, s)=>{
                        if (o) {
                            const s = "string" == typeof o ? o : o instanceof Error ? o.message : o.error;
                            e.w(`Unable to perform style diff: ${s}. Rebuilding the style from scratch.`), this._updateStyle(t1, i);
                        } else s && this._update(!0);
                    }, ()=>this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t1, i));
                }
                _getUIString(e) {
                    const t1 = this._locale[e];
                    if (null == t1) throw new Error(`Missing UI string '${e}'`);
                    return t1;
                }
                _updateStyle(e, t1) {
                    if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e) {
                        const i = Object.assign({}, t1);
                        t1 && t1.config && (i.initialConfig = t1.config, delete i.config), this.style = new Oo(this, i).load(e), this.style.setEventedParent(this, {
                            style: this.style
                        });
                    }
                    return this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Oo(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), !1);
                }
                _isValidId(t1) {
                    return null == t1 ? (this.fire(new e.y(new Error("IDs can't be empty."))), !1) : !e.dr(t1) || (this.fire(new e.y(new Error(`IDs can't contain special symbols: "${t1}".`))), !1);
                }
                _isTargetValid(e) {
                    return "featuresetId" in e ? this._isValidId("importId" in e ? e.importId : e.featuresetId) : "layerId" in e && this._isValidId(e.layerId);
                }
                _areTargetsValid(e) {
                    if (Array.isArray(e)) {
                        for (const t1 of e)if (!this._isValidId(t1)) return !1;
                        return !0;
                    }
                    return this._isTargetValid(e);
                }
                addSource(e, t1) {
                    return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t1), this._update(!0)) : this;
                }
                isSourceLoaded(e) {
                    return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);
                }
                areTilesLoaded() {
                    return this.style.areTilesLoaded();
                }
                addSourceType(e, t1, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e, t1, i);
                }
                removeSource(e) {
                    return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;
                }
                getSource(e) {
                    return this._isValidId(e) ? this.style.getOwnSource(e) : null;
                }
                addImage(t1, i, { pixelRatio: o = 1, sdf: s = !1, stretchX: r, stretchY: n, content: a } = {}) {
                    this._lazyInitEmptyStyle();
                    const l = e.I.from(t1);
                    if (i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {
                        const { width: t1, height: c, data: h } = e.o.getImageData(i);
                        this.style.addImage(l, {
                            data: new e.q({
                                width: t1,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: r,
                            stretchY: n,
                            content: a,
                            sdf: s,
                            version: 0,
                            usvg: !1
                        });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: c, height: h } = i, d = i;
                        this.style.addImage(l, {
                            data: new e.q({
                                width: c,
                                height: h
                            }, new Uint8Array(d.data)),
                            pixelRatio: o,
                            stretchX: r,
                            stretchY: n,
                            content: a,
                            sdf: s,
                            usvg: !1,
                            version: 0,
                            userImage: d
                        }), d.onAdd && d.onAdd(this, t1);
                    }
                }
                updateImage(t1, i) {
                    this._lazyInitEmptyStyle();
                    const o = e.I.from(t1), s = this.style.getImage(o);
                    if (!s) return void this.fire(new e.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const r = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.o.getImageData(i) : i, { width: n, height: a, data: l } = r;
                    if (void 0 === n || void 0 === a) return void this.fire(new e.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    if (n !== (s.usvg ? s.icon.usvg_tree.width : s.data.width) || a !== (s.usvg ? s.icon.usvg_tree.height : s.data.height)) return void this.fire(new e.y(new Error(`The width and height of the updated image (${n}, ${a})\n                must be that same as the previous version of the image\n                (${s.data.width}, ${s.data.height})`)));
                    const c = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);
                    let h = !1;
                    s.usvg ? (s.data = new e.q({
                        width: n,
                        height: a
                    }, new Uint8Array(l)), s.usvg = !1, s.icon = void 0, h = !0) : s.data.replace(l, c), this.style.updateImage(o, s, h);
                }
                hasImage(t1) {
                    return t1 ? !!this.style && !!this.style.getImage(e.I.from(t1)) : (this.fire(new e.y(new Error("Missing required image id"))), !1);
                }
                removeImage(t1) {
                    this.style.removeImage(e.I.from(t1));
                }
                loadImage(t1, i) {
                    e.n(this._requestManager.transformRequest(t1, e.R.Image), (t1, o)=>{
                        i(t1, o instanceof HTMLImageElement ? e.o.getImageData(o) : o);
                    });
                }
                listImages() {
                    return this.style.listImages().map((e)=>e.name);
                }
                addModel(e, t1) {
                    this._lazyInitEmptyStyle(), this.style.addModel(e, t1);
                }
                hasModel(t1) {
                    return t1 ? this.style.hasModel(t1) : (this.fire(new e.y(new Error("Missing required model id"))), !1);
                }
                removeModel(e) {
                    this.style.removeModel(e);
                }
                listModels() {
                    return this.style.listModels();
                }
                addLayer(e, t1) {
                    return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t1), this._update(!0)) : this;
                }
                getSlot(e) {
                    const t1 = this.getLayer(e);
                    return t1 && t1.slot || null;
                }
                setSlot(e, t1) {
                    return this.style.setSlot(e, t1), this.style.mergeLayers(), this._update(!0);
                }
                addImport(t1, i) {
                    return this.style.addImport(t1, i).catch((t1)=>this.fire(new e.y(new Error("Failed to add import", t1)))), this;
                }
                updateImport(e, t1) {
                    return "string" != typeof t1 && t1.id !== e ? (this.removeImport(e), this.addImport(t1)) : (this.style.updateImport(e, t1), this._update(!0));
                }
                removeImport(e) {
                    return this.style.removeImport(e), this;
                }
                moveImport(e, t1) {
                    return this.style.moveImport(e, t1), this._update(!0);
                }
                moveLayer(e, t1) {
                    return this._isValidId(e) ? (this.style.moveLayer(e, t1), this._update(!0)) : this;
                }
                removeLayer(e) {
                    return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;
                }
                getLayer(e) {
                    if (!this._isValidId(e)) return null;
                    const t1 = this.style.getOwnLayer(e);
                    return t1 ? "custom" === t1.type ? t1.implementation : t1.serialize() : void 0;
                }
                getSlots() {
                    return this.style.getSlots();
                }
                setLayerZoomRange(e, t1, i) {
                    return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t1, i), this._update(!0)) : this;
                }
                setFilter(e, t1, i = {}) {
                    return this._isValidId(e) ? (this.style.setFilter(e, t1, i), this._update(!0)) : this;
                }
                getFilter(e) {
                    return this._isValidId(e) ? this.style.getFilter(e) : null;
                }
                setPaintProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setPaintProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getPaintProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getPaintProperty(e, t1) : null;
                }
                setLayoutProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setLayoutProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getLayoutProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getLayoutProperty(e, t1) : null;
                }
                setLayerProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? ("appearances" === t1 && this._postAddingAppearancesToStyleEvent(), this.style.setLayerProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getGlyphsUrl() {
                    return this.style.getGlyphsUrl();
                }
                setGlyphsUrl(e) {
                    return this.style.setGlyphsUrl(e), this._update(!0);
                }
                getSchema(e) {
                    return this.style.getSchema(e);
                }
                setSchema(e, t1) {
                    return this.style.setSchema(e, t1), this._update(!0);
                }
                getConfig(e) {
                    return this.style.getConfig(e);
                }
                setConfig(e, t1) {
                    return this.style.setConfig(e, t1), this._update(!0);
                }
                getConfigProperty(e, t1) {
                    return this.style.getConfigProperty(e, t1);
                }
                setConfigProperty(e, t1, i) {
                    return this.style.setConfigProperty(e, t1, i), this._update(!0);
                }
                getFeaturesetDescriptors(e) {
                    return this.style.getFeaturesetDescriptors(e);
                }
                setLights(e) {
                    if (this._lazyInitEmptyStyle(), e && 1 === e.length && "flat" === e[0].type) {
                        const t1 = e[0];
                        t1.properties ? this.style.setFlatLight(t1.properties, t1.id, {}) : this.style.setFlatLight({}, "flat");
                    } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
                    return this._update(!0);
                }
                getLights() {
                    const e = this.style.getLights() || [];
                    return 0 === e.length && e.push({
                        id: this.style.light.id,
                        type: "flat",
                        properties: this.style.getFlatLight()
                    }), e;
                }
                setLight(e, t1 = {}) {
                    return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([
                        {
                            id: "flat",
                            type: "flat",
                            properties: e
                        }
                    ]);
                }
                getLight() {
                    return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
                }
                setTerrain(e) {
                    return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                setSnow(e) {
                    return this._lazyInitEmptyStyle(), this.style.setSnow(e), this._update(!0);
                }
                getSnow() {
                    return this.style ? this.style.getSnow() : null;
                }
                setRain(e) {
                    return this._lazyInitEmptyStyle(), this.style.setRain(e), this._update(!0);
                }
                getRain() {
                    return this.style ? this.style.getRain() : null;
                }
                setColorTheme(e) {
                    return this._lazyInitEmptyStyle(), this.style.setColorTheme(e), this._update(!0);
                }
                setImportColorTheme(e, t1) {
                    return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e, t1), this._update(!0);
                }
                setCamera(e) {
                    return this.style.setCamera(e), this._triggerCameraUpdate(e);
                }
                _triggerCameraUpdate(e) {
                    return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e["camera-projection"]));
                }
                getCamera() {
                    return this.style.camera;
                }
                _queryFogOpacity(t1) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.aT.convert(t1), this.transform) : 0;
                }
                setFeatureState(e, t1) {
                    return e.source && !this._isValidId(e.source) ? this : (this.style.setFeatureState(e, t1), this._update());
                }
                removeFeatureState(e, t1) {
                    return e.source && !this._isValidId(e.source) ? this : (this.style.removeFeatureState(e, t1), this._update());
                }
                getFeatureState(e) {
                    return e.source && !this._isValidId(e.source) ? null : this.style.getFeatureState(e);
                }
                _selectIndoorFloor(e) {
                    this.style.indoorManager.selectFloor(e);
                }
                _setIndoorActiveFloorsVisibility(e) {
                    this.style.indoorManager.setActiveFloorsVisibility(e);
                }
                getIndoorTileOptions(e, t1) {
                    return this.style.isIndoorEnabled() ? this.style.indoorManager.getIndoorTileOptions(e, t1) : null;
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const e = this._container.getBoundingClientRect().width || 400, t1 = this._container.getBoundingClientRect().height || 300;
                    let i, o, s, r = this._container;
                    for(; r && (!o || !s);){
                        const e = window.getComputedStyle(r).transform;
                        e && "none" !== e && (i = e.match(/matrix.*\((.+)\)/)[1].split(", "), i[0] && "0" !== i[0] && "1" !== i[0] && (o = i[0]), i[3] && "0" !== i[3] && "1" !== i[3] && (s = i[3])), r = r.parentElement;
                    }
                    this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = s ? Math.abs(t1 / s) : t1;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e = this._container;
                    e.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
                    const t1 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e);
                    this._canvas = l("canvas", "mapboxgl-canvas", t1), this._interactive && (t1.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = l("div", "mapboxgl-control-container", e), o = this._controlPositions = {};
                    [
                        "top-left",
                        "top",
                        "top-right",
                        "right",
                        "bottom-right",
                        "bottom",
                        "bottom-left",
                        "left"
                    ].forEach((e)=>{
                        o[e] = l("div", `mapboxgl-ctrl-${e}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t1, i) {
                    const o = e.o.devicePixelRatio || 1;
                    this._canvas.width = o * Math.ceil(t1), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e) {
                    this._markers.push(e);
                }
                _removeMarker(e) {
                    const t1 = this._markers.indexOf(e);
                    -1 !== t1 && this._markers.splice(t1, 1);
                }
                _addPopup(e) {
                    this._popups.push(e);
                }
                _removePopup(e) {
                    const t1 = this._popups.indexOf(e);
                    -1 !== t1 && this._popups.splice(t1, 1);
                }
                _setupPainter() {
                    const t1 = Object.assign({}, a.supported.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), i = this._canvas.getContext("webgl2", t1);
                    i ? (Z(i, !0), this.painter = new Pa(i, this._contextCreateOptions, this.transform, this._scaleFactor, this._worldview), this.on("data", (e)=>{
                        if ("source" === e.dataType) {
                            const t1 = this.transform.elevation ? this.transform.elevation._source() : null;
                            t1 && e.sourceCacheId === t1.id && this.style && this.style._setLabelPlacementStale(), this.painter.setTileLoadedFlag(!0);
                        }
                    }), e.k.testSupport(i)) : this.fire(new e.y(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t1) {
                    t1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.z("webglcontextlost", {
                        originalEvent: t1
                    }));
                }
                _contextRestored(t1) {
                    this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.clearLayers(), this.style.imageManager.destroyAtlasTextures(), this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e.z("webglcontextrestored", {
                        originalEvent: t1
                    }));
                }
                _onMapScroll(e) {
                    if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                idle() {
                    return !this.isMoving() && this.loaded();
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                frameReady() {
                    return this.loaded() && !this._placementDirty;
                }
                _update(e) {
                    return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e) {
                    return this._update(), this._renderTaskQueue.add(e);
                }
                _cancelRenderFrame(e) {
                    this._renderTaskQueue.remove(e);
                }
                _requestDomTask(e) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
                }
                _render(t1) {
                    let s;
                    this.fire(new e.z("renderstart")), ++this._frameId;
                    const r = this.painter.context.extTimerQuery, n = e.o.now(), a = this.painter.context.gl;
                    if (this.listens("gpu-timing-frame") && (s = a.createQuery(), a.beginQuery(r.TIME_ELAPSED_EXT, s)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t1), this._domRenderTaskQueue.run(t1), this._removed) return;
                    this._updateProjectionTransition();
                    const l = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t1 = this.transform.zoom, i = this.transform.pitch, o = e.o.now(), s = new e.ac(t1, {
                            now: o,
                            fadeDuration: l,
                            pitch: i,
                            transition: this.style.transition,
                            worldview: this._worldview
                        });
                        this.style.update(s);
                    }
                    this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let c = !1;
                    if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), c = this._updateAverageElevation(n), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c = this._updateAverageElevation(n), this.style && (this._placementDirty = this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, l, this._crossSourceCollisions, this.painter.replacementSource)), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showParseStatus: this.showParseStatus,
                        wireframe: {
                            terrain: this.showTerrainWireframe,
                            layers2D: this.showLayers2DWireframe,
                            layers3D: this.showLayers3DWireframe
                        },
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: l,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.mark(i.load), this.fire(new e.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s) {
                        const t1 = e.o.now() - n;
                        a.endQuery(r.TIME_ELAPSED_EXT), setTimeout(()=>{
                            const i = a.getQueryParameter(s, a.QUERY_RESULT) / 1e6;
                            a.deleteQuery(s), this.fire(new e.z("gpu-timing-frame", {
                                cpuTime: t1,
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(t1);
                            this.fire(new e.z("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t1 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(t1);
                            this.fire(new e.z("gpu-timing-deferred-render", {
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    const h = this._sourcesDirty || this._styleDirty || this._placementDirty || c;
                    if (h || this._repaint) this.triggerRepaint();
                    else {
                        const t1 = this.idle();
                        if (t1 && (c = this._updateAverageElevation(n, !0)), c) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t1 && (this.fire(new e.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t1 = this._calculateSpeedIndex();
                            this.fire(new e.z("speedindexcompleted", {
                                speedIndex: t1
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    !this._loaded || this._fullyLoaded || h || (this._fullyLoaded = !0, o.mark(i.fullLoad), this._performanceMetricsCollection && V(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e) {
                    for (const t1 of this._markers)e && !this.getRenderWorldCopies() && (t1._lngLat = t1._lngLat.wrap()), t1._update();
                    for (const t1 of this._popups)!e || this.getRenderWorldCopies() || t1._trackPointer || (t1._lngLat = t1._lngLat.wrap()), t1._update();
                }
                _updateAverageElevation(e, t1 = !1) {
                    const i = (e)=>(this.transform.averageElevation = e, this._update(!1), !0);
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
                    const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
                    if (o || (t1 || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                        const t1 = this.transform.averageElevation;
                        let s = this.transform.sampleAverageElevation();
                        null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s) ? s = 0 : this._averageElevationLastSampledAt = e;
                        const r = Math.abs(t1 - s);
                        if (r > 1) {
                            if (this._isInitialLoad || o) return this._averageElevation.jumpTo(s), i(s);
                            this._averageElevation.easeTo(s, e, 300);
                        } else if (r > 1e-4) return this._averageElevation.jumpTo(s), i(s);
                    }
                    return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
                }
                _authenticate() {
                    H(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t1)=>{
                        if (t1 && (t1.message === w || 401 === t1.status)) {
                            const t1 = this.painter.context.gl;
                            Z(t1, !1), this._logoControl instanceof Bl && this._logoControl._updateLogo(), t1 && t1.clear(t1.DEPTH_BUFFER_BIT | t1.COLOR_BUFFER_BIT | t1.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), z(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{});
                }
                _postStyleLoadEvent() {
                    this.style.globalId && F(this._requestManager._customAccessToken, {
                        map: this,
                        style: this.style.globalId,
                        importedStyles: this.style.getImportGlobalIds()
                    });
                }
                _postStyleWithAppearanceEvent() {
                    this.style.globalId && this.style.hasAppearances() && k(this._requestManager._customAccessToken);
                }
                _postAddingAppearancesToStyleEvent() {
                    U(this._requestManager._customAccessToken);
                }
                _updateTerrain() {
                    const e = this._isDragging();
                    this.painter.updateTerrain(this.style, e);
                }
                _calculateSpeedIndex() {
                    const e = this.painter.canvasCopy(), t1 = this.painter.getCanvasCopiesAndTimestamps();
                    t1.timeStamps.push(performance.now());
                    const i = this.painter.context.gl, o = i.createFramebuffer();
                    function s(e) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
                        const t1 = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t1), t1;
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(s(e), t1.canvasCopies.map(s), t1.timeStamps);
                }
                _canvasPixelComparison(e, t1, i) {
                    let o = i[1] - i[0];
                    const s = e.length / 4;
                    for(let r = 0; r < t1.length; r++){
                        const n = t1[r];
                        let a = 0;
                        for(let t1 = 0; t1 < n.length; t1 += 4)n[t1] === e[t1] && n[t1 + 1] === e[t1 + 1] && n[t1 + 2] === e[t1 + 2] && n[t1 + 3] === e[t1 + 3] && (a += 1);
                        o += (i[r + 2] - i[r + 1]) * (1 - a / s);
                    }
                    return o;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e of this._controls)e.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
                    const t1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t1 && t1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), q.delete(this.painter.context.gl), G.remove(), O.remove(), this._removed = !0, this.fire(new e.z("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t1) {
                    this._renderNextFrame = this._renderNextFrame || t1, this.style && !this._frame && (this._frame = e.o.frame((e)=>{
                        const t1 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t1 && this._render(e);
                    }));
                }
                _preloadTiles(t1) {
                    const i = this.style ? this.style.getSourceCaches() : [];
                    return e.bw(i, (e, i)=>e._preloadTiles(t1, i), ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e) {
                    this._trackResize && this.resize({
                        originalEvent: e
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e) {
                    this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
                }
                get showParseStatus() {
                    return !!this._showParseStatus;
                }
                set showParseStatus(e) {
                    this._showParseStatus !== e && (this._showParseStatus = e, this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e) {
                    this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());
                }
                get showLayers2DWireframe() {
                    return !!this._showLayers2DWireframe;
                }
                set showLayers2DWireframe(e) {
                    this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._update());
                }
                get showLayers3DWireframe() {
                    return !!this._showLayers3DWireframe;
                }
                set showLayers3DWireframe(e) {
                    this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e) {
                    this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e) {
                    this._showPadding !== e && (this._showPadding = e, this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e) {
                    this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, this.style && e ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e) {
                    this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e) {
                    this._repaint !== e && (this._repaint = e, this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e) {
                    this._vertices = e, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e) {
                    this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update());
                }
                _setCacheLimits(t1, i) {
                    e.f4(t1, i);
                }
                get version() {
                    return t1;
                }
            },
            NavigationControl: class {
                constructor(t1 = {}){
                    this.options = Object.assign({}, ql, t1), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this.options.showZoom && (e.aY([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e)=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: e
                        });
                    }), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e)=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: e
                        });
                    }), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aY([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e)=>{
                        const t1 = this._map;
                        t1 && (this.options.visualizePitch ? t1.resetNorthPitch({}, {
                            originalEvent: e
                        }) : t1.resetNorth({}, {
                            originalEvent: e
                        }));
                    }), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = e.getZoom(), i = t1 === e.getMaxZoom(), o = t1 === e.getMinZoom();
                    this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }
                _rotateCompassArrow() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;
                    e._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t1);
                    });
                }
                onAdd(e) {
                    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Zl(e, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e = this._map;
                    e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e, t1) {
                    const i = l("button", e, this._container);
                    return i.type = "button", i.addEventListener("click", t1), i;
                }
                _setButtonTitle(e, t1) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t1}`);
                    e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
                }
            },
            GeolocateControl: class extends e.E {
                constructor(t1 = {}){
                    super();
                    const i = navigator.geolocation;
                    this.options = Object.assign({
                        geolocation: i
                    }, Kl, t1), e.aY([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = Oa(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e) {
                    return this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    this._clearRequestTimeout(), void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(e) {
                    const t1 = (t1 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = t1, e(t1);
                    };
                    void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({
                        name: "geolocation"
                    }).then((e)=>t1("denied" !== e.state)).catch(()=>t1()) : t1();
                }
                _isOutOfMapMaxBounds(e) {
                    const t1 = this._map.getMaxBounds(), i = e.coords;
                    return !!t1 && (i.longitude < t1.getWest() || i.longitude > t1.getEast() || i.latitude < t1.getSouth() || i.latitude > t1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t1) {
                    if (this._map) {
                        if (this._clearRequestTimeout(), this._isOutOfMapMaxBounds(t1)) return this._setErrorState(), this.fire(new e.z("outofmaxbounds", t1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this.options.followUserLocation ? (this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active")) : (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"));
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t1), this.options.followUserLocation && (!this.options.trackUserLocation || "ACTIVE_LOCK" === this._watchState) && this._updateCamera(t1), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("geolocate", Object.assign({
                            coords: t1.coords,
                            timestamp: t1.timestamp
                        }, t1.toJSON ? {
                            toJSON: t1.toJSON.bind(t1)
                        } : {}))), this._finish();
                    }
                }
                _updateCamera(t1) {
                    const i = new e.aT(t1.coords.longitude, t1.coords.latitude), o = t1.coords.accuracy, s = this._map.getBearing(), r = Object.assign({
                        bearing: s
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), r, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t1) {
                    if (t1) {
                        const i = new e.aT(t1.coords.longitude, t1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map.transform, i = e.cf(1, t1._center.lat) * t1.worldSize, o = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t1) {
                    if (this._map) {
                        if (this._clearRequestTimeout(), this.options.trackUserLocation) if (1 === t1.code) {
                            this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                            const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
                        } else {
                            if (3 === t1.code && this._noTimeout) return;
                            this._setErrorState();
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("error", {
                            code: t1.code,
                            message: t1.message,
                            PERMISSION_DENIED: t1.PERMISSION_DENIED,
                            POSITION_UNAVAILABLE: t1.POSITION_UNAVAILABLE,
                            TIMEOUT: t1.TIMEOUT
                        })), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _startRequestTimeout() {
                    this._clearRequestTimeout();
                    const e = this.options.positionOptions.timeout;
                    e && (this._requestTimeoutId = window.setTimeout(()=>{
                        this._onError({
                            code: 3,
                            message: "Geolocation request timed out"
                        });
                    }, e));
                }
                _clearRequestTimeout() {
                    void 0 !== this._requestTimeoutId && (clearTimeout(this._requestTimeoutId), this._requestTimeoutId = void 0);
                }
                _setupUI(t1) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t1) {
                            e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t1);
                        } else {
                            const e = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Yl({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Yl({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.showButton || (this._container.style.display = "none"), this.options.trackUserLocation && this._map.on("movestart", (t1)=>{
                            t1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t1.originalEvent && "resize" === t1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.z("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e) {
                    this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e.w("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e.z("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.z("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let e;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this._startRequestTimeout(), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._startRequestTimeout(), this._timeoutId = window.setTimeout(this._finish, 1e4);
                    return !0;
                }
                setFollowUserLocation(t1) {
                    return this.options.followUserLocation = null != t1 ? t1 : Kl.followUserLocation, this.options.trackUserLocation && "OFF" !== this._watchState && (this.options.followUserLocation ? "BACKGROUND" !== this._watchState && "BACKGROUND_ERROR" !== this._watchState || (this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z("trackuserlocationstart"))) : "ACTIVE_LOCK" !== this._watchState && "ACTIVE_ERROR" !== this._watchState || (this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this.fire(new e.z("trackuserlocationend")))), this;
                }
                _addDeviceOrientationListener() {
                    const e = ()=>{
                        const e = "ondeviceorientationabsolute" in window ? "deviceorientationabsolute" : "deviceorientation";
                        window.addEventListener(e, this._onDeviceOrientation);
                    };
                    "function" == typeof DeviceOrientationEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t1)=>{
                        "granted" === t1 && e();
                    }).catch(console.error) : e();
                }
                _clearWatch() {
                    this._clearRequestTimeout(), this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: Fl,
            ScaleControl: class {
                constructor(t1 = {}){
                    this.options = Object.assign({}, Jl, t1), e.aY([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e = this.options.maxWidth || 100, t1 = this._map, i = t1._containerHeight / 2, o = t1._containerWidth / 2 - e / 2, s = t1.unproject([
                        o,
                        i
                    ]), r = t1.unproject([
                        o + e,
                        i
                    ]), n = s.distanceTo(r);
                    if ("imperial" === this.options.unit) {
                        const t1 = 3.2808 * n;
                        t1 > 5280 ? this._setScale(e, t1 / 5280, "mile") : this._setScale(e, t1, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e, n / 1852, "nautical-mile") : n >= 1e3 ? this._setScale(e, n / 1e3, "kilometer") : this._setScale(e, n, "meter");
                }
                _setScale(e, t1, i) {
                    this._map._requestDomTask(()=>{
                        const o = function(e) {
                            const t1 = Math.pow(10, `${Math.floor(e)}`.length - 1);
                            let i = e / t1;
                            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(e) {
                                const t1 = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
                                return Math.round(e * t1) / t1;
                            }(i), t1 * i;
                        }(t1), s = o / t1;
                        this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "short",
                            unit: i
                        }).format(o) : `${o}&nbsp;${Ql[i]}`, this._container.style.width = e * s + "px";
                    });
                }
                onAdd(e) {
                    return this._map = e, this._language = e.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e) {
                    this._language = e, this._update();
                }
                setUnit(e) {
                    this.options.unit = e, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t1 = {}){
                    this._fullscreen = !1, t1 && t1.container && (t1.container instanceof HTMLElement ? this._container = t1.container : e.w("Full screen control 'container' must be a DOM element.")), e.aY([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t1) {
                    return this._map = t1, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const e = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    l("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            IndoorControl: So,
            Popup: class extends e.E {
                constructor(t1){
                    super(), this.options = Object.assign(Object.create(ec), t1), this._altitude = this.options.altitude, e.aY([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t1 && t1.className ? t1.className.trim().split(/\s+/) : []);
                }
                addTo(t1) {
                    return this._map && this.remove(), this._map = t1, this.options.closeOnClick && t1.on("preclick", this._onClose), this.options.closeOnMove && t1.on("move", this._onClose), t1.on("remove", this.remove), this._update(), t1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t1.on("mousemove", this._onMouseEvent), t1.on("mouseup", this._onMouseEvent), t1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t1.on("move", this._update), this.fire(new e.z("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t1 = this._map;
                    return t1 && (t1.off("move", this._update), t1.off("move", this._onClose), t1.off("preclick", this._onClose), t1.off("click", this._onClose), t1.off("remove", this.remove), t1.off("mousemove", this._onMouseEvent), t1.off("mouseup", this._onMouseEvent), t1.off("drag", this._onMouseEvent), t1._canvasContainer && t1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t1._removePopup(this), this._map = void 0), this.fire(new e.z("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t1) {
                    this._lngLat = e.aT.convert(t1), this._pos = null, this._trackPointer = !1, this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                getAltitude() {
                    return this._altitude;
                }
                setAltitude(e) {
                    return this._altitude = e, this._update(), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e = this._map;
                    return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(e) {
                    return this.setDOMContent(document.createTextNode(e));
                }
                setHTML(e) {
                    const t1 = document.createDocumentFragment(), i = document.createElement("body");
                    let o;
                    for(i.innerHTML = e; o = i.firstChild, o;)t1.appendChild(o);
                    return this.setDOMContent(t1);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e) {
                    return this.options.maxWidth = e, this._update(), this;
                }
                setDOMContent(e) {
                    let t1 = this._content;
                    if (t1) for(; t1.hasChildNodes();)t1.firstChild && t1.removeChild(t1.firstChild);
                    else t1 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t1.appendChild(e), this.options.closeButton) {
                        const e = this._closeButton = l("button", "mapboxgl-popup-close-button", t1);
                        e.type = "button", e.setAttribute("aria-label", "Close popup"), e.innerHTML = '<span aria-hidden="true">&#215;</span>', e.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e) {
                    return this._classList.add(e), this._updateClassList(), this;
                }
                removeClassName(e) {
                    return this._classList.delete(e), this._updateClassList(), this;
                }
                setOffset(e) {
                    return this.options.offset = e, this._update(), this;
                }
                toggleClassName(e) {
                    let t1;
                    return this._classList.delete(e) ? t1 = !1 : (this._classList.add(e), t1 = !0), this._updateClassList(), t1;
                }
                _onMouseEvent(e) {
                    this._update(e.point);
                }
                _getAnchor(e) {
                    if (this.options.anchor) return this.options.anchor;
                    const t1 = this._map, i = this._container, o = this._pos;
                    if (!t1 || !i || !o) return "bottom";
                    const s = i.offsetWidth, r = i.offsetHeight, n = o.x < s / 2, a = o.x > t1.transform.width - s / 2;
                    if (o.y + e < r) return n ? "top-left" : a ? "top-right" : "top";
                    if (o.y > t1.transform.height - r) {
                        if (n) return "bottom-left";
                        if (a) return "bottom-right";
                    }
                    return n ? "left" : a ? "right" : "bottom";
                }
                _updateClassList() {
                    const e = this._container;
                    if (!e) return;
                    const t1 = [
                        ...this._classList
                    ];
                    t1.push("mapboxgl-popup"), this._anchor && t1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t1.push("mapboxgl-popup-track-pointer"), e.className = t1.join(" ");
                }
                _update(t1) {
                    const i = this._map, o = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !o) return;
                    let s = this._container;
                    if (s || (s = this._container = l("div", "mapboxgl-popup", i.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", s), s.appendChild(o)), this.options.maxWidth && s.style.maxWidth !== this.options.maxWidth && (s.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Wl(this._lngLat, this._pos, i.transform)), !this._trackPointer || t1) {
                        const o = this._pos = this._trackPointer && t1 instanceof e.P ? t1 : i.project(this._lngLat, this._altitude), s = ic(this.options.offset), r = this._anchor = this._getAnchor(s.y), n = ic(this.options.offset, r), a = o.add(n).round();
                        i._requestDomTask(()=>{
                            this._container && r && (this._container.style.transform = `${$l[r]} translate(${a.x}px,${a.y}px)`);
                        });
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const t1 = e.f5(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t1);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e = this._container.querySelector(tc);
                    e && e.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e) {
                    this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
                }
            },
            Marker: Yl,
            Style: Oo,
            LngLat: e.aT,
            LngLatBounds: e.aI,
            Point: e.P,
            MercatorCoordinate: e.ae,
            FreeCameraOptions: oo,
            Evented: e.E,
            config: e.e,
            prewarm: e.f9,
            clearPrewarmedResources: e.f8,
            get accessToken () {
                return e.e.ACCESS_TOKEN;
            },
            set accessToken (t){
                e.e.ACCESS_TOKEN = t;
            },
            get baseApiUrl () {
                return e.e.API_URL;
            },
            set baseApiUrl (t){
                e.e.API_URL = t;
            },
            get workerCount () {
                return e.fi.workerCount;
            },
            set workerCount (t){
                e.fi.workerCount = t;
            },
            get maxParallelImageRequests () {
                return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t){
                e.e.MAX_PARALLEL_IMAGE_REQUESTS = t;
            },
            clearStorage (t1) {
                e.fh(t1);
            },
            get workerUrl () {
                return e.fg.workerUrl;
            },
            set workerUrl (t){
                e.fg.workerUrl = t;
            },
            get workerClass () {
                return e.fg.workerClass;
            },
            set workerClass (t){
                e.fg.workerClass = t;
            },
            get workerParams () {
                return e.fg.workerParams;
            },
            set workerParams (t){
                e.fg.workerParams = t;
            },
            get dracoUrl () {
                return e.ff();
            },
            set dracoUrl (t){
                e.fe(t);
            },
            get meshoptUrl () {
                return e.fd();
            },
            set meshoptUrl (t){
                e.fc(t);
            },
            setNow: e.o.setNow,
            restoreNow: e.o.restoreNow
        };
        return oc;
    });
    //
    // Our custom intro provides a specialized "define()" function, called by the
    // AMD modules below, that sets up the worker blob URL and then executes the
    // main module, storing its exported value as 'mapboxgl'
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
}); //# sourceMappingURL=mapbox-gl.js.map
}),
];

//# sourceMappingURL=node_modules_mapbox-gl_dist_mapbox-gl_32a5203b.js.map